/*! For license information please see vendor.js.LICENSE.txt */ ! function(modules) {
    var installedModules = {};

    function __webpack_require__(moduleId) {
        if (installedModules[moduleId]) return installedModules[moduleId].exports;
        var module = installedModules[moduleId] = {
            i: moduleId,
            l: !1,
            exports: {}
        };
        return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__), module.l = !0, module.exports
    }
    __webpack_require__.m = modules, __webpack_require__.c = installedModules, __webpack_require__.d = function(exports, name, getter) {
        __webpack_require__.o(exports, name) || Object.defineProperty(exports, name, {
            enumerable: !0,
            get: getter
        })
    }, __webpack_require__.r = function(exports) {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(exports, Symbol.toStringTag, {
            value: "Module"
        }), Object.defineProperty(exports, "__esModule", {
            value: !0
        })
    }, __webpack_require__.t = function(value, mode) {
        if (1 & mode && (value = __webpack_require__(value)), 8 & mode) return value;
        if (4 & mode && "object" == typeof value && value && value.__esModule) return value;
        var ns = Object.create(null);
        if (__webpack_require__.r(ns), Object.defineProperty(ns, "default", {
                enumerable: !0,
                value: value
            }), 2 & mode && "string" != typeof value)
            for (var key in value) __webpack_require__.d(ns, key, function(key) {
                return value[key]
            }.bind(null, key));
        return ns
    }, __webpack_require__.n = function(module) {
        var getter = module && module.__esModule ? function() {
            return module.default
        } : function() {
            return module
        };
        return __webpack_require__.d(getter, "a", getter), getter
    }, __webpack_require__.o = function(object, property) {
        return Object.prototype.hasOwnProperty.call(object, property)
    }, __webpack_require__.p = "/static/", __webpack_require__(__webpack_require__.s = 259)
}([function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(global) {
        __webpack_require__.d(__webpack_exports__, "a", (function() {
            return ANALYZE_FOR_ENTRY_COMPONENTS
        })), __webpack_require__.d(__webpack_exports__, "b", (function() {
            return APP_ID
        })), __webpack_require__.d(__webpack_exports__, "c", (function() {
            return APP_INITIALIZER
        })), __webpack_require__.d(__webpack_exports__, "d", (function() {
            return ApplicationInitStatus
        })), __webpack_require__.d(__webpack_exports__, "e", (function() {
            return ApplicationModule
        })), __webpack_require__.d(__webpack_exports__, "f", (function() {
            return ApplicationRef
        })), __webpack_require__.d(__webpack_exports__, "g", (function() {
            return Attribute
        })), __webpack_require__.d(__webpack_exports__, "h", (function() {
            return ChangeDetectorRef
        })), __webpack_require__.d(__webpack_exports__, "i", (function() {
            return Compiler
        })), __webpack_require__.d(__webpack_exports__, "j", (function() {
            return Component
        })), __webpack_require__.d(__webpack_exports__, "k", (function() {
            return ComponentFactoryResolver
        })), __webpack_require__.d(__webpack_exports__, "l", (function() {
            return ContentChildren
        })), __webpack_require__.d(__webpack_exports__, "m", (function() {
            return DEFAULT_CURRENCY_CODE
        })), __webpack_require__.d(__webpack_exports__, "n", (function() {
            return Directive
        })), __webpack_require__.d(__webpack_exports__, "o", (function() {
            return ElementRef
        })), __webpack_require__.d(__webpack_exports__, "p", (function() {
            return ErrorHandler
        })), __webpack_require__.d(__webpack_exports__, "q", (function() {
            return EventEmitter
        })), __webpack_require__.d(__webpack_exports__, "r", (function() {
            return Host
        })), __webpack_require__.d(__webpack_exports__, "s", (function() {
            return HostListener
        })), __webpack_require__.d(__webpack_exports__, "t", (function() {
            return INJECTOR$1
        })), __webpack_require__.d(__webpack_exports__, "u", (function() {
            return Inject
        })), __webpack_require__.d(__webpack_exports__, "v", (function() {
            return Injectable
        })), __webpack_require__.d(__webpack_exports__, "w", (function() {
            return InjectionToken
        })), __webpack_require__.d(__webpack_exports__, "x", (function() {
            return Injector
        })), __webpack_require__.d(__webpack_exports__, "y", (function() {
            return Input
        })), __webpack_require__.d(__webpack_exports__, "z", (function() {
            return IterableDiffers
        })), __webpack_require__.d(__webpack_exports__, "A", (function() {
            return KeyValueDiffers
        })), __webpack_require__.d(__webpack_exports__, "B", (function() {
            return LOCALE_ID$1
        })), __webpack_require__.d(__webpack_exports__, "C", (function() {
            return NgModule
        })), __webpack_require__.d(__webpack_exports__, "D", (function() {
            return NgModuleFactory
        })), __webpack_require__.d(__webpack_exports__, "E", (function() {
            return NgModuleFactoryLoader
        })), __webpack_require__.d(__webpack_exports__, "F", (function() {
            return NgModuleRef
        })), __webpack_require__.d(__webpack_exports__, "G", (function() {
            return NgProbeToken
        })), __webpack_require__.d(__webpack_exports__, "H", (function() {
            return NgZone
        })), __webpack_require__.d(__webpack_exports__, "I", (function() {
            return Optional
        })), __webpack_require__.d(__webpack_exports__, "J", (function() {
            return Output
        })), __webpack_require__.d(__webpack_exports__, "K", (function() {
            return PLATFORM_ID
        })), __webpack_require__.d(__webpack_exports__, "L", (function() {
            return PLATFORM_INITIALIZER
        })), __webpack_require__.d(__webpack_exports__, "M", (function() {
            return Pipe
        })), __webpack_require__.d(__webpack_exports__, "N", (function() {
            return PlatformRef
        })), __webpack_require__.d(__webpack_exports__, "O", (function() {
            return ReflectiveInjector
        })), __webpack_require__.d(__webpack_exports__, "P", (function() {
            return Renderer2
        })), __webpack_require__.d(__webpack_exports__, "Q", (function() {
            return RendererFactory2
        })), __webpack_require__.d(__webpack_exports__, "R", (function() {
            return RendererStyleFlags2
        })), __webpack_require__.d(__webpack_exports__, "S", (function() {
            return Sanitizer
        })), __webpack_require__.d(__webpack_exports__, "T", (function() {
            return SecurityContext
        })), __webpack_require__.d(__webpack_exports__, "U", (function() {
            return Self
        })), __webpack_require__.d(__webpack_exports__, "V", (function() {
            return SimpleChange
        })), __webpack_require__.d(__webpack_exports__, "W", (function() {
            return SkipSelf
        })), __webpack_require__.d(__webpack_exports__, "X", (function() {
            return TemplateRef
        })), __webpack_require__.d(__webpack_exports__, "Y", (function() {
            return Testability
        })), __webpack_require__.d(__webpack_exports__, "Z", (function() {
            return TestabilityRegistry
        })), __webpack_require__.d(__webpack_exports__, "ab", (function() {
            return Version
        })), __webpack_require__.d(__webpack_exports__, "bb", (function() {
            return ViewChild
        })), __webpack_require__.d(__webpack_exports__, "cb", (function() {
            return ViewContainerRef
        })), __webpack_require__.d(__webpack_exports__, "db", (function() {
            return ViewEncapsulation
        })), __webpack_require__.d(__webpack_exports__, "eb", (function() {
            return createPlatformFactory
        })), __webpack_require__.d(__webpack_exports__, "fb", (function() {
            return forwardRef
        })), __webpack_require__.d(__webpack_exports__, "gb", (function() {
            return isDevMode
        })), __webpack_require__.d(__webpack_exports__, "hb", (function() {
            return platformCore
        })), __webpack_require__.d(__webpack_exports__, "ib", (function() {
            return setTestabilityGetter
        })), __webpack_require__.d(__webpack_exports__, "jb", (function() {
            return Console
        })), __webpack_require__.d(__webpack_exports__, "kb", (function() {
            return INJECTOR_SCOPE
        })), __webpack_require__.d(__webpack_exports__, "lb", (function() {
            return LocaleDataIndex
        })), __webpack_require__.d(__webpack_exports__, "mb", (function() {
            return NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR
        })), __webpack_require__.d(__webpack_exports__, "nb", (function() {
            return _sanitizeHtml
        })), __webpack_require__.d(__webpack_exports__, "ob", (function() {
            return _sanitizeUrl
        })), __webpack_require__.d(__webpack_exports__, "pb", (function() {
            return allowSanitizationBypassAndThrow
        })), __webpack_require__.d(__webpack_exports__, "qb", (function() {
            return bypassSanitizationTrustHtml
        })), __webpack_require__.d(__webpack_exports__, "rb", (function() {
            return bypassSanitizationTrustResourceUrl
        })), __webpack_require__.d(__webpack_exports__, "sb", (function() {
            return bypassSanitizationTrustScript
        })), __webpack_require__.d(__webpack_exports__, "tb", (function() {
            return bypassSanitizationTrustStyle
        })), __webpack_require__.d(__webpack_exports__, "ub", (function() {
            return bypassSanitizationTrustUrl
        })), __webpack_require__.d(__webpack_exports__, "vb", (function() {
            return findLocaleData
        })), __webpack_require__.d(__webpack_exports__, "wb", (function() {
            return getDebugNodeR2
        })), __webpack_require__.d(__webpack_exports__, "xb", (function() {
            return getLocaleCurrencyCode
        })), __webpack_require__.d(__webpack_exports__, "yb", (function() {
            return getLocalePluralCase
        })), __webpack_require__.d(__webpack_exports__, "zb", (function() {
            return getSanitizationBypassType
        })), __webpack_require__.d(__webpack_exports__, "Ab", (function() {
            return _global
        })), __webpack_require__.d(__webpack_exports__, "Bb", (function() {
            return isListLikeIterable
        })), __webpack_require__.d(__webpack_exports__, "Cb", (function() {
            return isObservable
        })), __webpack_require__.d(__webpack_exports__, "Db", (function() {
            return isPromise
        })), __webpack_require__.d(__webpack_exports__, "Eb", (function() {
            return registerLocaleData
        })), __webpack_require__.d(__webpack_exports__, "Fb", (function() {
            return setDocument
        })), __webpack_require__.d(__webpack_exports__, "Gb", (function() {
            return stringify
        })), __webpack_require__.d(__webpack_exports__, "Hb", (function() {
            return unwrapSafeValue
        })), __webpack_require__.d(__webpack_exports__, "Ib", (function() {
            return ɵɵdefineInjectable
        })), __webpack_require__.d(__webpack_exports__, "Jb", (function() {
            return ɵɵinject
        }));
        var rxjs__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(32),
            rxjs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15),
            rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12),
            rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(281),
            rxjs_operators__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(283);

        function getClosureSafeProperty(objWithPropertyToExtract) {
            for (let key in objWithPropertyToExtract)
                if (objWithPropertyToExtract[key] === getClosureSafeProperty) return key;
            throw Error("Could not find renamed property on target object.")
        }

        function stringify(token) {
            if ("string" == typeof token) return token;
            if (Array.isArray(token)) return "[" + token.map(stringify).join(", ") + "]";
            if (null == token) return "" + token;
            if (token.overriddenName) return `${token.overriddenName}`;
            if (token.name) return `${token.name}`;
            const res = token.toString();
            if (null == res) return "" + res;
            const newLineIndex = res.indexOf("\n");
            return -1 === newLineIndex ? res : res.substring(0, newLineIndex)
        }

        function concatStringsWithSpace(before, after) {
            return null == before || "" === before ? null === after ? "" : after : null == after || "" === after ? before : before + " " + after
        }
        const __forward_ref__ = getClosureSafeProperty({
            __forward_ref__: getClosureSafeProperty
        });

        function forwardRef(forwardRefFn) {
            return forwardRefFn.__forward_ref__ = forwardRef, forwardRefFn.toString = function() {
                return stringify(this())
            }, forwardRefFn
        }

        function resolveForwardRef(type) {
            return isForwardRef(type) ? type() : type
        }

        function isForwardRef(fn) {
            return "function" == typeof fn && fn.hasOwnProperty(__forward_ref__) && fn.__forward_ref__ === forwardRef
        }

        function assertNumber(actual, msg) {
            "number" != typeof actual && throwError(msg, typeof actual, "number", "===")
        }

        function assertString(actual, msg) {
            "string" != typeof actual && throwError(msg, null === actual ? "null" : typeof actual, "string", "===")
        }

        function assertFunction(actual, msg) {
            "function" != typeof actual && throwError(msg, null === actual ? "null" : typeof actual, "function", "===")
        }

        function assertEqual(actual, expected, msg) {
            actual != expected && throwError(msg, actual, expected, "==")
        }

        function assertNotEqual(actual, expected, msg) {
            actual == expected && throwError(msg, actual, expected, "!=")
        }

        function assertSame(actual, expected, msg) {
            actual !== expected && throwError(msg, actual, expected, "===")
        }

        function assertNotSame(actual, expected, msg) {
            actual === expected && throwError(msg, actual, expected, "!==")
        }

        function assertLessThan(actual, expected, msg) {
            actual < expected || throwError(msg, actual, expected, "<")
        }

        function assertGreaterThan(actual, expected, msg) {
            actual > expected || throwError(msg, actual, expected, ">")
        }

        function assertGreaterThanOrEqual(actual, expected, msg) {
            actual >= expected || throwError(msg, actual, expected, ">=")
        }

        function assertDefined(actual, msg) {
            null == actual && throwError(msg, actual, null, "!=")
        }

        function throwError(msg, actual, expected, comparison) {
            throw new Error(`ASSERTION ERROR: ${msg}` + (null == comparison ? "" : ` [Expected=> ${expected} ${comparison} ${actual} <=Actual]`))
        }

        function assertDomNode(node) {
            "undefined" != typeof Node && node instanceof Node || "object" == typeof node && null != node && "WebWorkerRenderNode" === node.constructor.name || throwError(`The provided value must be an instance of a DOM Node but got ${stringify(node)}`)
        }

        function assertIndexInRange(arr, index) {
            assertDefined(arr, "Array must be defined.");
            const maxLen = arr.length;
            (index < 0 || index >= maxLen) && throwError(`Index expected to be less than ${maxLen} but got ${index}`)
        }

        function ɵɵdefineInjectable(opts) {
            return {
                token: opts.token,
                providedIn: opts.providedIn || null,
                factory: opts.factory,
                value: void 0
            }
        }

        function ɵɵdefineInjector(options) {
            return {
                factory: options.factory,
                providers: options.providers || [],
                imports: options.imports || []
            }
        }

        function getInjectableDef(type) {
            return getOwnDefinition(type, NG_PROV_DEF) || getOwnDefinition(type, NG_INJECTABLE_DEF)
        }

        function getOwnDefinition(type, field) {
            return type.hasOwnProperty(field) ? type[field] : null
        }
        const NG_PROV_DEF = getClosureSafeProperty({
                "ɵprov": getClosureSafeProperty
            }),
            NG_INJECTABLE_DEF = (getClosureSafeProperty({
                "ɵinj": getClosureSafeProperty
            }), getClosureSafeProperty({
                ngInjectableDef: getClosureSafeProperty
            }));
        getClosureSafeProperty({
            ngInjectorDef: getClosureSafeProperty
        });
        var InjectFlags;
        let _injectImplementation;

        function setInjectImplementation(impl) {
            const previous = _injectImplementation;
            return _injectImplementation = impl, previous
        }

        function injectRootLimpMode(token, notFoundValue, flags) {
            const injectableDef = getInjectableDef(token);
            if (injectableDef && "root" == injectableDef.providedIn) return void 0 === injectableDef.value ? injectableDef.value = injectableDef.factory() : injectableDef.value;
            if (flags & InjectFlags.Optional) return null;
            if (void 0 !== notFoundValue) return notFoundValue;
            throw new Error(`Injector: NOT_FOUND [${stringify(token)}]`)
        }

        function noSideEffects(fn) {
            return {
                toString: fn
            }.toString()
        }
        var ChangeDetectionStrategy, ChangeDetectorStatus, ViewEncapsulation;
        ! function(InjectFlags) {
            InjectFlags[InjectFlags.Default = 0] = "Default", InjectFlags[InjectFlags.Host = 1] = "Host", InjectFlags[InjectFlags.Self = 2] = "Self", InjectFlags[InjectFlags.SkipSelf = 4] = "SkipSelf", InjectFlags[InjectFlags.Optional = 8] = "Optional"
        }(InjectFlags || (InjectFlags = {})),
        function(ChangeDetectionStrategy) {
            ChangeDetectionStrategy[ChangeDetectionStrategy.OnPush = 0] = "OnPush", ChangeDetectionStrategy[ChangeDetectionStrategy.Default = 1] = "Default"
        }(ChangeDetectionStrategy || (ChangeDetectionStrategy = {})),
        function(ChangeDetectorStatus) {
            ChangeDetectorStatus[ChangeDetectorStatus.CheckOnce = 0] = "CheckOnce", ChangeDetectorStatus[ChangeDetectorStatus.Checked = 1] = "Checked", ChangeDetectorStatus[ChangeDetectorStatus.CheckAlways = 2] = "CheckAlways", ChangeDetectorStatus[ChangeDetectorStatus.Detached = 3] = "Detached", ChangeDetectorStatus[ChangeDetectorStatus.Errored = 4] = "Errored", ChangeDetectorStatus[ChangeDetectorStatus.Destroyed = 5] = "Destroyed"
        }(ChangeDetectorStatus || (ChangeDetectorStatus = {})),
        function(ViewEncapsulation) {
            ViewEncapsulation[ViewEncapsulation.Emulated = 0] = "Emulated", ViewEncapsulation[ViewEncapsulation.None = 2] = "None", ViewEncapsulation[ViewEncapsulation.ShadowDom = 3] = "ShadowDom"
        }(ViewEncapsulation || (ViewEncapsulation = {}));
        const __globalThis = "undefined" != typeof globalThis && globalThis,
            __window = "undefined" != typeof window && window,
            __self = "undefined" != typeof self && "undefined" != typeof WorkerGlobalScope && self instanceof WorkerGlobalScope && self,
            _global = __globalThis || void 0 !== global && global || __window || __self;

        function initNgDevMode() {
            return !("undefined" != typeof ngDevMode && !ngDevMode) && ("object" != typeof ngDevMode && function() {
                const locationString = "undefined" != typeof location ? location.toString() : "",
                    newCounters = {
                        namedConstructors: -1 != locationString.indexOf("ngDevMode=namedConstructors"),
                        firstCreatePass: 0,
                        tNode: 0,
                        tView: 0,
                        rendererCreateTextNode: 0,
                        rendererSetText: 0,
                        rendererCreateElement: 0,
                        rendererAddEventListener: 0,
                        rendererSetAttribute: 0,
                        rendererRemoveAttribute: 0,
                        rendererSetProperty: 0,
                        rendererSetClassName: 0,
                        rendererAddClass: 0,
                        rendererRemoveClass: 0,
                        rendererSetStyle: 0,
                        rendererRemoveStyle: 0,
                        rendererDestroy: 0,
                        rendererDestroyNode: 0,
                        rendererMoveNode: 0,
                        rendererRemoveNode: 0,
                        rendererAppendChild: 0,
                        rendererInsertBefore: 0,
                        rendererCreateComment: 0
                    },
                    allowNgDevModeTrue = -1 === locationString.indexOf("ngDevMode=false");
                _global.ngDevMode = allowNgDevModeTrue && newCounters
            }(), "undefined" != typeof ngDevMode && !!ngDevMode)
        }
        const EMPTY_OBJ = {},
            EMPTY_ARRAY = [];
        ("undefined" == typeof ngDevMode || ngDevMode) && initNgDevMode() && (Object.freeze(EMPTY_OBJ), Object.freeze(EMPTY_ARRAY));
        const NG_COMP_DEF = getClosureSafeProperty({
                "ɵcmp": getClosureSafeProperty
            }),
            NG_FACTORY_DEF = (getClosureSafeProperty({
                "ɵdir": getClosureSafeProperty
            }), getClosureSafeProperty({
                "ɵpipe": getClosureSafeProperty
            }), getClosureSafeProperty({
                "ɵmod": getClosureSafeProperty
            }), getClosureSafeProperty({
                "ɵloc": getClosureSafeProperty
            }), getClosureSafeProperty({
                "ɵfac": getClosureSafeProperty
            })),
            NG_ELEMENT_ID = getClosureSafeProperty({
                __NG_ELEMENT_ID__: getClosureSafeProperty
            });

        function getComponentDef(type) {
            return type[NG_COMP_DEF] || null
        }
        const TViewTypeAsString = ["Root", "Component", "Embedded"];

        function isLView(value) {
            return Array.isArray(value) && "object" == typeof value[1]
        }

        function isLContainer(value) {
            return Array.isArray(value) && !0 === value[1]
        }

        function isComponentHost(tNode) {
            return 2 == (2 & tNode.flags)
        }

        function isComponentDef(def) {
            return null !== def.template
        }

        function assertTNodeForLView(tNode, lView) {
            assertTNodeForTView(tNode, lView[1])
        }

        function assertTNodeForTView(tNode, tView) {
            assertTNode(tNode), tNode.hasOwnProperty("tView_") && assertEqual(tNode.tView_, tView, "This TNode does not belong to this TView.")
        }

        function assertTNode(tNode) {
            assertDefined(tNode, "TNode must be defined"), tNode && "object" == typeof tNode && tNode.hasOwnProperty("directiveStylingLast") || throwError("Not of type TNode, got: " + tNode)
        }

        function assertComponentType(actual, msg = "Type passed in is not ComponentType, it does not have 'ɵcmp' property.") {
            getComponentDef(actual) || throwError(msg)
        }

        function assertLContainer(value) {
            assertDefined(value, "LContainer must be defined"), assertEqual(isLContainer(value), !0, "Expecting LContainer")
        }

        function assertLViewOrUndefined(value) {
            value && assertEqual(isLView(value), !0, "Expecting LView or undefined or null")
        }

        function assertLView(value) {
            assertDefined(value, "LView must be defined"), assertEqual(isLView(value), !0, "Expecting LView")
        }

        function assertFirstCreatePass(tView, errMessage) {
            assertEqual(tView.firstCreatePass, !0, errMessage || "Should only be called in first create pass.")
        }

        function assertFirstUpdatePass(tView, errMessage) {
            assertEqual(tView.firstUpdatePass, !0, errMessage || "Should only be called in first update pass.")
        }

        function assertIndexInExpandoRange(lView, index) {
            assertBetween(lView[1].expandoStartIndex, lView.length, index)
        }

        function assertBetween(lower, upper, index) {
            lower <= index && index < upper || throwError(`Index out of range (expecting ${lower} <= ${index} < ${upper})`)
        }

        function assertNodeInjector(lView, injectorIndex) {
            assertIndexInExpandoRange(lView, injectorIndex), assertIndexInExpandoRange(lView, injectorIndex + 8), assertNumber(lView[injectorIndex + 0], "injectorIndex should point to a bloom filter"), assertNumber(lView[injectorIndex + 1], "injectorIndex should point to a bloom filter"), assertNumber(lView[injectorIndex + 2], "injectorIndex should point to a bloom filter"), assertNumber(lView[injectorIndex + 3], "injectorIndex should point to a bloom filter"), assertNumber(lView[injectorIndex + 4], "injectorIndex should point to a bloom filter"), assertNumber(lView[injectorIndex + 5], "injectorIndex should point to a bloom filter"), assertNumber(lView[injectorIndex + 6], "injectorIndex should point to a bloom filter"), assertNumber(lView[injectorIndex + 7], "injectorIndex should point to a bloom filter"), assertNumber(lView[injectorIndex + 8], "injectorIndex should point to parent injector")
        }

        function getFactoryDef(type, throwNotFound) {
            const hasFactoryDef = type.hasOwnProperty(NG_FACTORY_DEF);
            if (!hasFactoryDef && !0 === throwNotFound && ngDevMode) throw new Error(`Type ${stringify(type)} does not have 'ɵfac' property.`);
            return hasFactoryDef ? type[NG_FACTORY_DEF] : null
        }
        class RuntimeError extends Error {
            constructor(code, message) {
                super(formatRuntimeError(code, message)), this.code = code
            }
        }

        function formatRuntimeError(code, message) {
            return `${code?`NG0${code}: `:""}${message}`
        }

        function renderStringify(value) {
            return "string" == typeof value ? value : null == value ? "" : String(value)
        }

        function stringifyForError(value) {
            return "function" == typeof value ? value.name || value.toString() : "object" == typeof value && null != value && "function" == typeof value.type ? value.type.name || value.type.toString() : renderStringify(value)
        }

        function throwCyclicDependencyError(token, path) {
            const depPath = path ? `. Dependency path: ${path.join(" > ")} > ${token}` : "";
            throw new RuntimeError("200", `Circular dependency in DI detected for ${token}${depPath}`)
        }

        function throwProviderNotFoundError(token, injectorName) {
            const injectorDetails = injectorName ? ` in ${injectorName}` : "";
            throw new RuntimeError("201", `No provider for ${stringifyForError(token)} found${injectorDetails}`)
        }
        class SimpleChange {
            constructor(previousValue, currentValue, firstChange) {
                this.previousValue = previousValue, this.currentValue = currentValue, this.firstChange = firstChange
            }
            isFirstChange() {
                return this.firstChange
            }
        }

        function ɵɵNgOnChangesFeature() {
            return NgOnChangesFeatureImpl
        }

        function NgOnChangesFeatureImpl(definition) {
            return definition.type.prototype.ngOnChanges && (definition.setInput = ngOnChangesSetInput), rememberChangeHistoryAndInvokeOnChangesHook
        }

        function rememberChangeHistoryAndInvokeOnChangesHook() {
            const simpleChangesStore = getSimpleChangesStore(this),
                current = null == simpleChangesStore ? void 0 : simpleChangesStore.current;
            if (current) {
                const previous = simpleChangesStore.previous;
                if (previous === EMPTY_OBJ) simpleChangesStore.previous = current;
                else
                    for (let key in current) previous[key] = current[key];
                simpleChangesStore.current = null, this.ngOnChanges(current)
            }
        }

        function ngOnChangesSetInput(instance, value, publicName, privateName) {
            const simpleChangesStore = getSimpleChangesStore(instance) || function(instance, store) {
                    return instance.__ngSimpleChanges__ = store
                }(instance, {
                    previous: EMPTY_OBJ,
                    current: null
                }),
                current = simpleChangesStore.current || (simpleChangesStore.current = {}),
                previous = simpleChangesStore.previous,
                declaredName = this.declaredInputs[publicName],
                previousChange = previous[declaredName];
            current[declaredName] = new SimpleChange(previousChange && previousChange.currentValue, value, previous === EMPTY_OBJ), instance[privateName] = value
        }
        ɵɵNgOnChangesFeature.ngInherit = !0;

        function getSimpleChangesStore(instance) {
            return instance.__ngSimpleChanges__ || null
        }
        let DOCUMENT;

        function setDocument(document) {
            DOCUMENT = document
        }

        function getDocument() {
            return void 0 !== DOCUMENT ? DOCUMENT : "undefined" != typeof document ? document : void 0
        }
        var RendererStyleFlags3;

        function isProceduralRenderer(renderer) {
            return !!renderer.listen
        }! function(RendererStyleFlags3) {
            RendererStyleFlags3[RendererStyleFlags3.Important = 1] = "Important", RendererStyleFlags3[RendererStyleFlags3.DashCase = 2] = "DashCase"
        }(RendererStyleFlags3 || (RendererStyleFlags3 = {}));
        const domRendererFactory3 = {
            createRenderer: (hostElement, rendererType) => getDocument()
        };

        function unwrapRNode(value) {
            for (; Array.isArray(value);) value = value[0];
            return value
        }

        function getNativeByTNode(tNode, lView) {
            ngDevMode && assertTNodeForLView(tNode, lView), ngDevMode && assertIndexInRange(lView, tNode.index);
            const node = unwrapRNode(lView[tNode.index]);
            return ngDevMode && !isProceduralRenderer(lView[11]) && assertDomNode(node), node
        }

        function getTNode(tView, index) {
            ngDevMode && assertGreaterThan(index, -1, "wrong index for TNode"), ngDevMode && assertLessThan(index, tView.data.length, "wrong index for TNode");
            const tNode = tView.data[index];
            return ngDevMode && null !== tNode && assertTNode(tNode), tNode
        }

        function getComponentLViewByIndex(nodeIndex, hostView) {
            ngDevMode && assertIndexInRange(hostView, nodeIndex);
            const slotValue = hostView[nodeIndex];
            return isLView(slotValue) ? slotValue : slotValue[0]
        }

        function readPatchedData(target) {
            return ngDevMode && assertDefined(target, "Target expected"), target.__ngContext__ || null
        }

        function readPatchedLView(target) {
            const value = readPatchedData(target);
            return value ? Array.isArray(value) ? value : value.lView : null
        }

        function isCreationMode(view) {
            return 4 == (4 & view[2])
        }

        function viewAttachedToChangeDetector(view) {
            return 128 == (128 & view[2])
        }

        function resetPreOrderHookFlags(lView) {
            lView[18] = 0
        }

        function updateTransplantedViewCount(lContainer, amount) {
            lContainer[5] += amount;
            let viewOrContainer = lContainer,
                parent = lContainer[3];
            for (; null !== parent && (1 === amount && 1 === viewOrContainer[5] || -1 === amount && 0 === viewOrContainer[5]);) parent[5] += amount, viewOrContainer = parent, parent = parent[3]
        }
        const instructionState = {
            lFrame: createLFrame(null),
            bindingsEnabled: !0,
            isInCheckNoChangesMode: !1
        };

        function getLView() {
            return instructionState.lFrame.lView
        }

        function getTView() {
            return instructionState.lFrame.tView
        }

        function getCurrentTNode() {
            let currentTNode = getCurrentTNodePlaceholderOk();
            for (; null !== currentTNode && 64 === currentTNode.type;) currentTNode = currentTNode.parent;
            return currentTNode
        }

        function getCurrentTNodePlaceholderOk() {
            return instructionState.lFrame.currentTNode
        }

        function getCurrentParentTNode() {
            const lFrame = instructionState.lFrame,
                currentTNode = lFrame.currentTNode;
            return lFrame.isParent ? currentTNode : currentTNode.parent
        }

        function setCurrentTNode(tNode, isParent) {
            ngDevMode && tNode && assertTNodeForTView(tNode, instructionState.lFrame.tView);
            const lFrame = instructionState.lFrame;
            lFrame.currentTNode = tNode, lFrame.isParent = isParent
        }

        function isCurrentTNodeParent() {
            return instructionState.lFrame.isParent
        }

        function isInCheckNoChangesMode() {
            return instructionState.isInCheckNoChangesMode
        }

        function setIsInCheckNoChangesMode(mode) {
            instructionState.isInCheckNoChangesMode = mode
        }

        function setBindingIndex(value) {
            return instructionState.lFrame.bindingIndex = value
        }

        function setBindingRootForHostBindings(bindingRootIndex, currentDirectiveIndex) {
            const lFrame = instructionState.lFrame;
            lFrame.bindingIndex = lFrame.bindingRootIndex = bindingRootIndex, setCurrentDirectiveIndex(currentDirectiveIndex)
        }

        function setCurrentDirectiveIndex(currentDirectiveIndex) {
            instructionState.lFrame.currentDirectiveIndex = currentDirectiveIndex
        }

        function setCurrentQueryIndex(value) {
            instructionState.lFrame.currentQueryIndex = value
        }

        function getDeclarationTNode(lView) {
            const tView = lView[1];
            return 2 === tView.type ? (ngDevMode && assertDefined(tView.declTNode, "Embedded TNodes should have declaration parents."), tView.declTNode) : 1 === tView.type ? lView[6] : null
        }

        function enterDI(lView, tNode, flags) {
            if (ngDevMode && assertLViewOrUndefined(lView), flags & InjectFlags.SkipSelf) {
                ngDevMode && assertTNodeForTView(tNode, lView[1]);
                let parentTNode = tNode,
                    parentLView = lView;
                for (; !(ngDevMode && assertDefined(parentTNode, "Parent TNode should be defined"), parentTNode = parentTNode.parent, null !== parentTNode || flags & InjectFlags.Host || (parentTNode = getDeclarationTNode(parentLView), null === parentTNode) || (ngDevMode && assertDefined(parentLView, "Parent LView should be defined"), parentLView = parentLView[15], 10 & parentTNode.type)););
                if (null === parentTNode) return !1;
                tNode = parentTNode, lView = parentLView
            }
            ngDevMode && assertTNodeForLView(tNode, lView);
            const lFrame = instructionState.lFrame = allocLFrame();
            return lFrame.currentTNode = tNode, lFrame.lView = lView, !0
        }

        function enterView(newView) {
            ngDevMode && assertNotEqual(newView[0], newView[1], "????"), ngDevMode && assertLViewOrUndefined(newView);
            const newLFrame = allocLFrame();
            ngDevMode && (assertEqual(newLFrame.isParent, !0, "Expected clean LFrame"), assertEqual(newLFrame.lView, null, "Expected clean LFrame"), assertEqual(newLFrame.tView, null, "Expected clean LFrame"), assertEqual(newLFrame.selectedIndex, -1, "Expected clean LFrame"), assertEqual(newLFrame.elementDepthCount, 0, "Expected clean LFrame"), assertEqual(newLFrame.currentDirectiveIndex, -1, "Expected clean LFrame"), assertEqual(newLFrame.currentNamespace, null, "Expected clean LFrame"), assertEqual(newLFrame.bindingRootIndex, -1, "Expected clean LFrame"), assertEqual(newLFrame.currentQueryIndex, 0, "Expected clean LFrame"));
            const tView = newView[1];
            instructionState.lFrame = newLFrame, ngDevMode && tView.firstChild && assertTNodeForTView(tView.firstChild, tView), newLFrame.currentTNode = tView.firstChild, newLFrame.lView = newView, newLFrame.tView = tView, newLFrame.contextLView = newView, newLFrame.bindingIndex = tView.bindingStartIndex, newLFrame.inI18n = !1
        }

        function allocLFrame() {
            const currentLFrame = instructionState.lFrame,
                childLFrame = null === currentLFrame ? null : currentLFrame.child;
            return null === childLFrame ? createLFrame(currentLFrame) : childLFrame
        }

        function createLFrame(parent) {
            const lFrame = {
                currentTNode: null,
                isParent: !0,
                lView: null,
                tView: null,
                selectedIndex: -1,
                contextLView: null,
                elementDepthCount: 0,
                currentNamespace: null,
                currentDirectiveIndex: -1,
                bindingRootIndex: -1,
                bindingIndex: -1,
                currentQueryIndex: 0,
                parent: parent,
                child: null,
                inI18n: !1
            };
            return null !== parent && (parent.child = lFrame), lFrame
        }

        function leaveViewLight() {
            const oldLFrame = instructionState.lFrame;
            return instructionState.lFrame = oldLFrame.parent, oldLFrame.currentTNode = null, oldLFrame.lView = null, oldLFrame
        }
        const leaveDI = leaveViewLight;

        function leaveView() {
            const oldLFrame = leaveViewLight();
            oldLFrame.isParent = !0, oldLFrame.tView = null, oldLFrame.selectedIndex = -1, oldLFrame.contextLView = null, oldLFrame.elementDepthCount = 0, oldLFrame.currentDirectiveIndex = -1, oldLFrame.currentNamespace = null, oldLFrame.bindingRootIndex = -1, oldLFrame.bindingIndex = -1, oldLFrame.currentQueryIndex = 0
        }

        function getSelectedIndex() {
            return instructionState.lFrame.selectedIndex
        }

        function setSelectedIndex(index) {
            ngDevMode && -1 !== index && assertGreaterThanOrEqual(index, 20, "Index must be past HEADER_OFFSET (or -1)."), ngDevMode && assertLessThan(index, instructionState.lFrame.lView.length, "Can't set index passed end of LView"), instructionState.lFrame.selectedIndex = index
        }

        function registerPostOrderHooks(tView, tNode) {
            ngDevMode && assertFirstCreatePass(tView);
            for (let i = tNode.directiveStart, end = tNode.directiveEnd; i < end; i++) {
                const directiveDef = tView.data[i];
                ngDevMode && assertDefined(directiveDef, "Expecting DirectiveDef");
                const lifecycleHooks = directiveDef.type.prototype,
                    {
                        ngAfterContentInit: ngAfterContentInit,
                        ngAfterContentChecked: ngAfterContentChecked,
                        ngAfterViewInit: ngAfterViewInit,
                        ngAfterViewChecked: ngAfterViewChecked,
                        ngOnDestroy: ngOnDestroy
                    } = lifecycleHooks;
                ngAfterContentInit && (tView.contentHooks || (tView.contentHooks = [])).push(-i, ngAfterContentInit), ngAfterContentChecked && ((tView.contentHooks || (tView.contentHooks = [])).push(i, ngAfterContentChecked), (tView.contentCheckHooks || (tView.contentCheckHooks = [])).push(i, ngAfterContentChecked)), ngAfterViewInit && (tView.viewHooks || (tView.viewHooks = [])).push(-i, ngAfterViewInit), ngAfterViewChecked && ((tView.viewHooks || (tView.viewHooks = [])).push(i, ngAfterViewChecked), (tView.viewCheckHooks || (tView.viewCheckHooks = [])).push(i, ngAfterViewChecked)), null != ngOnDestroy && (tView.destroyHooks || (tView.destroyHooks = [])).push(i, ngOnDestroy)
            }
        }

        function executeCheckHooks(lView, hooks, nodeIndex) {
            callHooks(lView, hooks, 3, nodeIndex)
        }

        function executeInitAndCheckHooks(lView, hooks, initPhase, nodeIndex) {
            ngDevMode && assertNotEqual(initPhase, 3, "Init pre-order hooks should not be called more than once"), (3 & lView[2]) === initPhase && callHooks(lView, hooks, initPhase, nodeIndex)
        }

        function incrementInitPhaseFlags(lView, initPhase) {
            ngDevMode && assertNotEqual(initPhase, 3, "Init hooks phase should not be incremented after all init hooks have been run.");
            let flags = lView[2];
            (3 & flags) === initPhase && (flags &= 2047, flags += 1, lView[2] = flags)
        }

        function callHooks(currentView, arr, initPhase, currentNodeIndex) {
            ngDevMode && assertEqual(isInCheckNoChangesMode(), !1, "Hooks should never be run when in check no changes mode.");
            const nodeIndexLimit = null != currentNodeIndex ? currentNodeIndex : -1;
            let lastNodeIndexFound = 0;
            for (let i = void 0 !== currentNodeIndex ? 65535 & currentView[18] : 0; i < arr.length; i++) {
                if ("number" == typeof arr[i + 1]) {
                    if (lastNodeIndexFound = arr[i], null != currentNodeIndex && lastNodeIndexFound >= currentNodeIndex) break
                } else {
                    arr[i] < 0 && (currentView[18] += 65536), (lastNodeIndexFound < nodeIndexLimit || -1 == nodeIndexLimit) && (callHook(currentView, initPhase, arr, i), currentView[18] = (4294901760 & currentView[18]) + i + 2), i++
                }
            }
        }

        function callHook(currentView, initPhase, arr, i) {
            const isInitHook = arr[i] < 0,
                hook = arr[i + 1],
                directive = currentView[isInitHook ? -arr[i] : arr[i]];
            if (isInitHook) {
                currentView[2] >> 11 < currentView[18] >> 16 && (3 & currentView[2]) === initPhase && (currentView[2] += 2048, hook.call(directive))
            } else hook.call(directive)
        }
        class NodeInjectorFactory {
            constructor(factory, isViewProvider, injectImplementation) {
                this.factory = factory, this.resolving = !1, ngDevMode && assertDefined(factory, "Factory not specified"), ngDevMode && assertEqual(typeof factory, "function", "Expected factory function."), this.canSeeViewProviders = isViewProvider, this.injectImpl = injectImplementation
            }
        }

        function toTNodeTypeAsString(tNodeType) {
            let text = "";
            return 1 & tNodeType && (text += "|Text"), 2 & tNodeType && (text += "|Element"), 4 & tNodeType && (text += "|Container"), 8 & tNodeType && (text += "|ElementContainer"), 16 & tNodeType && (text += "|Projection"), 32 & tNodeType && (text += "|IcuContainer"), 64 & tNodeType && (text += "|Placeholder"), text.length > 0 ? text.substring(1) : text
        }

        function assertTNodeType(tNode, expectedTypes, message) {
            assertDefined(tNode, "should be called with a TNode"), 0 == (tNode.type & expectedTypes) && throwError(message || `Expected [${toTNodeTypeAsString(expectedTypes)}] but got ${toTNodeTypeAsString(tNode.type)}.`)
        }

        function setUpAttributes(renderer, native, attrs) {
            const isProc = isProceduralRenderer(renderer);
            let i = 0;
            for (; i < attrs.length;) {
                const value = attrs[i];
                if ("number" == typeof value) {
                    if (0 !== value) break;
                    i++;
                    const namespaceURI = attrs[i++],
                        attrName = attrs[i++],
                        attrVal = attrs[i++];
                    ngDevMode && ngDevMode.rendererSetAttribute++, isProc ? renderer.setAttribute(native, attrName, attrVal, namespaceURI) : native.setAttributeNS(namespaceURI, attrName, attrVal)
                } else {
                    const attrName = value,
                        attrVal = attrs[++i];
                    ngDevMode && ngDevMode.rendererSetAttribute++, isAnimationProp(attrName) ? isProc && renderer.setProperty(native, attrName, attrVal) : isProc ? renderer.setAttribute(native, attrName, attrVal) : native.setAttribute(attrName, attrVal), i++
                }
            }
            return i
        }

        function isAnimationProp(name) {
            return 64 === name.charCodeAt(0)
        }

        function hasParentInjector(parentLocation) {
            return -1 !== parentLocation
        }

        function getParentInjectorIndex(parentLocation) {
            ngDevMode && assertNumber(parentLocation, "Number expected"), ngDevMode && assertNotEqual(parentLocation, -1, "Not a valid state.");
            return ngDevMode && assertGreaterThan(32767 & parentLocation, 20, "Parent injector must be pointing past HEADER_OFFSET."), 32767 & parentLocation
        }

        function getParentInjectorView(location, startView) {
            let viewOffset = location >> 16;
            let parentView = startView;
            for (; viewOffset > 0;) parentView = parentView[15], viewOffset--;
            return parentView
        }
        let includeViewProviders = !0;

        function setIncludeViewProviders(v) {
            const oldValue = includeViewProviders;
            return includeViewProviders = v, oldValue
        }
        let nextNgElementId = 0;

        function getOrCreateNodeInjectorForNode(tNode, lView) {
            const existingInjectorIndex = getInjectorIndex(tNode, lView);
            if (-1 !== existingInjectorIndex) return existingInjectorIndex;
            const tView = lView[1];
            tView.firstCreatePass && (tNode.injectorIndex = lView.length, insertBloom(tView.data, tNode), insertBloom(lView, null), insertBloom(tView.blueprint, null));
            const parentLoc = getParentInjectorLocation(tNode, lView),
                injectorIndex = tNode.injectorIndex;
            if (hasParentInjector(parentLoc)) {
                const parentIndex = getParentInjectorIndex(parentLoc),
                    parentLView = getParentInjectorView(parentLoc, lView),
                    parentData = parentLView[1].data;
                for (let i = 0; i < 8; i++) lView[injectorIndex + i] = parentLView[parentIndex + i] | parentData[parentIndex + i]
            }
            return lView[injectorIndex + 8] = parentLoc, injectorIndex
        }

        function insertBloom(arr, footer) {
            arr.push(0, 0, 0, 0, 0, 0, 0, 0, footer)
        }

        function getInjectorIndex(tNode, lView) {
            return -1 === tNode.injectorIndex || tNode.parent && tNode.parent.injectorIndex === tNode.injectorIndex || null === lView[tNode.injectorIndex + 8] ? -1 : (ngDevMode && assertIndexInRange(lView, tNode.injectorIndex), tNode.injectorIndex)
        }

        function getParentInjectorLocation(tNode, lView) {
            if (tNode.parent && -1 !== tNode.parent.injectorIndex) return tNode.parent.injectorIndex;
            let declarationViewOffset = 0,
                parentTNode = null,
                lViewCursor = lView;
            for (; null !== lViewCursor;) {
                const tView = lViewCursor[1],
                    tViewType = tView.type;
                if (2 === tViewType ? (ngDevMode && assertDefined(tView.declTNode, "Embedded TNodes should have declaration parents."), parentTNode = tView.declTNode) : 1 === tViewType ? parentTNode = lViewCursor[6] : (ngDevMode && assertEqual(tView.type, 0, "Root type expected"), parentTNode = null), null === parentTNode) return -1;
                if (ngDevMode && parentTNode && assertTNodeForLView(parentTNode, lViewCursor[15]), declarationViewOffset++, lViewCursor = lViewCursor[15], -1 !== parentTNode.injectorIndex) return parentTNode.injectorIndex | declarationViewOffset << 16
            }
            return -1
        }

        function diPublicInInjector(injectorIndex, tView, token) {
            ! function(injectorIndex, tView, type) {
                let id;
                ngDevMode && assertEqual(tView.firstCreatePass, !0, "expected firstCreatePass to be true"), "string" == typeof type ? id = type.charCodeAt(0) || 0 : type.hasOwnProperty(NG_ELEMENT_ID) && (id = type[NG_ELEMENT_ID]), null == id && (id = type[NG_ELEMENT_ID] = nextNgElementId++);
                const bloomBit = 255 & id,
                    mask = 1 << bloomBit,
                    b7 = 128 & bloomBit,
                    b6 = 64 & bloomBit,
                    b5 = 32 & bloomBit,
                    tData = tView.data;
                b7 ? b6 ? b5 ? tData[injectorIndex + 7] |= mask : tData[injectorIndex + 6] |= mask : b5 ? tData[injectorIndex + 5] |= mask : tData[injectorIndex + 4] |= mask : b6 ? b5 ? tData[injectorIndex + 3] |= mask : tData[injectorIndex + 2] |= mask : b5 ? tData[injectorIndex + 1] |= mask : tData[injectorIndex] |= mask
            }(injectorIndex, tView, token)
        }

        function notFoundValueOrThrow(notFoundValue, token, flags) {
            if (flags & InjectFlags.Optional) return notFoundValue;
            throwProviderNotFoundError(token, "NodeInjector")
        }

        function lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue) {
            if (flags & InjectFlags.Optional && void 0 === notFoundValue && (notFoundValue = null), 0 == (flags & (InjectFlags.Self | InjectFlags.Host))) {
                const moduleInjector = lView[9],
                    previousInjectImplementation = setInjectImplementation(void 0);
                try {
                    return moduleInjector ? moduleInjector.get(token, notFoundValue, flags & InjectFlags.Optional) : injectRootLimpMode(token, notFoundValue, flags & InjectFlags.Optional)
                } finally {
                    setInjectImplementation(previousInjectImplementation)
                }
            }
            return notFoundValueOrThrow(notFoundValue, token, flags)
        }

        function getOrCreateInjectable(tNode, lView, token, flags = InjectFlags.Default, notFoundValue) {
            if (null !== tNode) {
                const bloomHash = function(token) {
                    if (ngDevMode && assertDefined(token, "token must be defined"), "string" == typeof token) return token.charCodeAt(0) || 0;
                    const tokenId = token.hasOwnProperty(NG_ELEMENT_ID) ? token[NG_ELEMENT_ID] : void 0;
                    return "number" == typeof tokenId ? tokenId >= 0 ? 255 & tokenId : (ngDevMode && assertEqual(tokenId, -1, "Expecting to get Special Injector Id"), createNodeInjector) : tokenId
                }(token);
                if ("function" == typeof bloomHash) {
                    if (!enterDI(lView, tNode, flags)) return flags & InjectFlags.Host ? notFoundValueOrThrow(notFoundValue, token, flags) : lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue);
                    try {
                        const value = bloomHash();
                        if (null != value || flags & InjectFlags.Optional) return value;
                        throwProviderNotFoundError(token)
                    } finally {
                        leaveDI()
                    }
                } else if ("number" == typeof bloomHash) {
                    let previousTView = null,
                        injectorIndex = getInjectorIndex(tNode, lView),
                        parentLocation = -1,
                        hostTElementNode = flags & InjectFlags.Host ? lView[16][6] : null;
                    for ((-1 === injectorIndex || flags & InjectFlags.SkipSelf) && (parentLocation = -1 === injectorIndex ? getParentInjectorLocation(tNode, lView) : lView[injectorIndex + 8], -1 !== parentLocation && shouldSearchParent(flags, !1) ? (previousTView = lView[1], injectorIndex = getParentInjectorIndex(parentLocation), lView = getParentInjectorView(parentLocation, lView)) : injectorIndex = -1); - 1 !== injectorIndex;) {
                        ngDevMode && assertNodeInjector(lView, injectorIndex);
                        const tView = lView[1];
                        if (ngDevMode && assertTNodeForLView(tView.data[injectorIndex + 8], lView), bloomHasToken(bloomHash, injectorIndex, tView.data)) {
                            const instance = searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode);
                            if (instance !== NOT_FOUND) return instance
                        }
                        parentLocation = lView[injectorIndex + 8], -1 !== parentLocation && shouldSearchParent(flags, lView[1].data[injectorIndex + 8] === hostTElementNode) && bloomHasToken(bloomHash, injectorIndex, lView) ? (previousTView = tView, injectorIndex = getParentInjectorIndex(parentLocation), lView = getParentInjectorView(parentLocation, lView)) : injectorIndex = -1
                    }
                }
            }
            return lookupTokenUsingModuleInjector(lView, token, flags, notFoundValue)
        }
        const NOT_FOUND = {};

        function createNodeInjector() {
            return new NodeInjector(getCurrentTNode(), getLView())
        }

        function searchTokensOnInjector(injectorIndex, lView, token, previousTView, flags, hostTElementNode) {
            const currentTView = lView[1],
                tNode = currentTView.data[injectorIndex + 8],
                injectableIdx = locateDirectiveOrProvider(tNode, currentTView, token, null == previousTView ? isComponentHost(tNode) && includeViewProviders : previousTView != currentTView && 0 != (3 & tNode.type), flags & InjectFlags.Host && hostTElementNode === tNode);
            return null !== injectableIdx ? getNodeInjectable(lView, currentTView, injectableIdx, tNode) : NOT_FOUND
        }

        function locateDirectiveOrProvider(tNode, tView, token, canAccessViewProviders, isHostSpecialCase) {
            const nodeProviderIndexes = tNode.providerIndexes,
                tInjectables = tView.data,
                injectablesStart = 1048575 & nodeProviderIndexes,
                directivesStart = tNode.directiveStart,
                directiveEnd = tNode.directiveEnd,
                cptViewProvidersCount = nodeProviderIndexes >> 20,
                endIndex = isHostSpecialCase ? injectablesStart + cptViewProvidersCount : directiveEnd;
            for (let i = canAccessViewProviders ? injectablesStart : injectablesStart + cptViewProvidersCount; i < endIndex; i++) {
                const providerTokenOrDef = tInjectables[i];
                if (i < directivesStart && token === providerTokenOrDef || i >= directivesStart && providerTokenOrDef.type === token) return i
            }
            if (isHostSpecialCase) {
                const dirDef = tInjectables[directivesStart];
                if (dirDef && isComponentDef(dirDef) && dirDef.type === token) return directivesStart
            }
            return null
        }

        function getNodeInjectable(lView, tView, index, tNode) {
            let value = lView[index];
            const tData = tView.data;
            if (value instanceof NodeInjectorFactory) {
                const factory = value;
                factory.resolving && throwCyclicDependencyError(stringifyForError(tData[index]));
                const previousIncludeViewProviders = setIncludeViewProviders(factory.canSeeViewProviders);
                factory.resolving = !0;
                const previousInjectImplementation = factory.injectImpl ? setInjectImplementation(factory.injectImpl) : null,
                    success = enterDI(lView, tNode, InjectFlags.Default);
                ngDevMode && assertEqual(success, !0, "Because flags do not contain `SkipSelf' we expect this to always succeed.");
                try {
                    value = lView[index] = factory.factory(void 0, tData, lView, tNode), tView.firstCreatePass && index >= tNode.directiveStart && (ngDevMode && function(obj) {
                        void 0 !== obj.type && null != obj.selectors && void 0 !== obj.inputs || throwError("Expected a DirectiveDef/ComponentDef and this object does not seem to have the expected shape.")
                    }(tData[index]), function(directiveIndex, directiveDef, tView) {
                        ngDevMode && assertFirstCreatePass(tView);
                        const {
                            ngOnChanges: ngOnChanges,
                            ngOnInit: ngOnInit,
                            ngDoCheck: ngDoCheck
                        } = directiveDef.type.prototype;
                        if (ngOnChanges) {
                            const wrappedOnChanges = NgOnChangesFeatureImpl(directiveDef);
                            (tView.preOrderHooks || (tView.preOrderHooks = [])).push(directiveIndex, wrappedOnChanges), (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = [])).push(directiveIndex, wrappedOnChanges)
                        }
                        ngOnInit && (tView.preOrderHooks || (tView.preOrderHooks = [])).push(0 - directiveIndex, ngOnInit), ngDoCheck && ((tView.preOrderHooks || (tView.preOrderHooks = [])).push(directiveIndex, ngDoCheck), (tView.preOrderCheckHooks || (tView.preOrderCheckHooks = [])).push(directiveIndex, ngDoCheck))
                    }(index, tData[index], tView))
                } finally {
                    null !== previousInjectImplementation && setInjectImplementation(previousInjectImplementation), setIncludeViewProviders(previousIncludeViewProviders), factory.resolving = !1, leaveDI()
                }
            }
            return value
        }

        function bloomHasToken(bloomHash, injectorIndex, injectorView) {
            const mask = 1 << bloomHash,
                b6 = 64 & bloomHash,
                b5 = 32 & bloomHash;
            let value;
            return value = 128 & bloomHash ? b6 ? b5 ? injectorView[injectorIndex + 7] : injectorView[injectorIndex + 6] : b5 ? injectorView[injectorIndex + 5] : injectorView[injectorIndex + 4] : b6 ? b5 ? injectorView[injectorIndex + 3] : injectorView[injectorIndex + 2] : b5 ? injectorView[injectorIndex + 1] : injectorView[injectorIndex], !!(value & mask)
        }

        function shouldSearchParent(flags, isFirstHostTNode) {
            return !(flags & InjectFlags.Self || flags & InjectFlags.Host && isFirstHostTNode)
        }
        class NodeInjector {
            constructor(_tNode, _lView) {
                this._tNode = _tNode, this._lView = _lView
            }
            get(token, notFoundValue) {
                return getOrCreateInjectable(this._tNode, this._lView, token, void 0, notFoundValue)
            }
        }
        const ANNOTATIONS = "__annotations__",
            PARAMETERS = "__parameters__",
            PROP_METADATA = "__prop__metadata__";

        function makeDecorator(name, props, parentClass, additionalProcessing, typeFn) {
            return noSideEffects((() => {
                const metaCtor = makeMetadataCtor(props);

                function DecoratorFactory(...args) {
                    if (this instanceof DecoratorFactory) return metaCtor.call(this, ...args), this;
                    const annotationInstance = new DecoratorFactory(...args);
                    return function(cls) {
                        typeFn && typeFn(cls, ...args);
                        return (cls.hasOwnProperty(ANNOTATIONS) ? cls[ANNOTATIONS] : Object.defineProperty(cls, ANNOTATIONS, {
                            value: []
                        })[ANNOTATIONS]).push(annotationInstance), additionalProcessing && additionalProcessing(cls), cls
                    }
                }
                return parentClass && (DecoratorFactory.prototype = Object.create(parentClass.prototype)), DecoratorFactory.prototype.ngMetadataName = name, DecoratorFactory.annotationCls = DecoratorFactory, DecoratorFactory
            }))
        }

        function makeMetadataCtor(props) {
            return function(...args) {
                if (props) {
                    const values = props(...args);
                    for (const propName in values) this[propName] = values[propName]
                }
            }
        }

        function makeParamDecorator(name, props, parentClass) {
            return noSideEffects((() => {
                const metaCtor = makeMetadataCtor(props);

                function ParamDecoratorFactory(...args) {
                    if (this instanceof ParamDecoratorFactory) return metaCtor.apply(this, args), this;
                    const annotationInstance = new ParamDecoratorFactory(...args);
                    return ParamDecorator.annotation = annotationInstance, ParamDecorator;

                    function ParamDecorator(cls, unusedKey, index) {
                        const parameters = cls.hasOwnProperty(PARAMETERS) ? cls[PARAMETERS] : Object.defineProperty(cls, PARAMETERS, {
                            value: []
                        })[PARAMETERS];
                        for (; parameters.length <= index;) parameters.push(null);
                        return (parameters[index] = parameters[index] || []).push(annotationInstance), cls
                    }
                }
                return parentClass && (ParamDecoratorFactory.prototype = Object.create(parentClass.prototype)), ParamDecoratorFactory.prototype.ngMetadataName = name, ParamDecoratorFactory.annotationCls = ParamDecoratorFactory, ParamDecoratorFactory
            }))
        }

        function makePropDecorator(name, props, parentClass, additionalProcessing) {
            return noSideEffects((() => {
                const metaCtor = makeMetadataCtor(props);

                function PropDecoratorFactory(...args) {
                    if (this instanceof PropDecoratorFactory) return metaCtor.apply(this, args), this;
                    const decoratorInstance = new PropDecoratorFactory(...args);
                    return function(target, name) {
                        const constructor = target.constructor,
                            meta = constructor.hasOwnProperty(PROP_METADATA) ? constructor[PROP_METADATA] : Object.defineProperty(constructor, PROP_METADATA, {
                                value: {}
                            })[PROP_METADATA];
                        meta[name] = meta.hasOwnProperty(name) && meta[name] || [], meta[name].unshift(decoratorInstance), additionalProcessing && additionalProcessing(target, name, ...args)
                    }
                }
                return parentClass && (PropDecoratorFactory.prototype = Object.create(parentClass.prototype)), PropDecoratorFactory.prototype.ngMetadataName = name, PropDecoratorFactory.annotationCls = PropDecoratorFactory, PropDecoratorFactory
            }))
        }
        const Attribute = function() {
            return makeParamDecorator("Attribute", (attributeName => ({
                attributeName: attributeName
            })))
        }();
        class InjectionToken {
            constructor(_desc, options) {
                this._desc = _desc, this.ngMetadataName = "InjectionToken", this.ɵprov = void 0, "number" == typeof options ? (("undefined" == typeof ngDevMode || ngDevMode) && assertLessThan(options, 0, "Only negative numbers are supported here"), this.__NG_ELEMENT_ID__ = options) : void 0 !== options && (this.ɵprov = ɵɵdefineInjectable({
                    token: this,
                    providedIn: options.providedIn || "root",
                    factory: options.factory
                }))
            }
            toString() {
                return `InjectionToken ${this._desc}`
            }
        }
        const ANALYZE_FOR_ENTRY_COMPONENTS = new InjectionToken("AnalyzeForEntryComponents");
        class Query {}
        const ContentChildren = makePropDecorator("ContentChildren", ((selector, data = {}) => Object.assign({
                selector: selector,
                first: !1,
                isViewQuery: !1,
                descendants: !1
            }, data)), Query),
            ViewChild = (makePropDecorator("ContentChild", ((selector, data = {}) => Object.assign({
                selector: selector,
                first: !0,
                isViewQuery: !1,
                descendants: !0
            }, data)), Query), makePropDecorator("ViewChildren", ((selector, data = {}) => Object.assign({
                selector: selector,
                first: !1,
                isViewQuery: !0,
                descendants: !0
            }, data)), Query), makePropDecorator("ViewChild", ((selector, data) => Object.assign({
                selector: selector,
                first: !0,
                isViewQuery: !0,
                descendants: !0
            }, data)), Query));
        var R3ResolvedDependencyType, R3FactoryTarget, ViewEncapsulation$1;
        ! function(R3ResolvedDependencyType) {
            R3ResolvedDependencyType[R3ResolvedDependencyType.Token = 0] = "Token", R3ResolvedDependencyType[R3ResolvedDependencyType.Attribute = 1] = "Attribute", R3ResolvedDependencyType[R3ResolvedDependencyType.ChangeDetectorRef = 2] = "ChangeDetectorRef", R3ResolvedDependencyType[R3ResolvedDependencyType.Invalid = 3] = "Invalid"
        }(R3ResolvedDependencyType || (R3ResolvedDependencyType = {})),
        function(R3FactoryTarget) {
            R3FactoryTarget[R3FactoryTarget.Directive = 0] = "Directive", R3FactoryTarget[R3FactoryTarget.Component = 1] = "Component", R3FactoryTarget[R3FactoryTarget.Injectable = 2] = "Injectable", R3FactoryTarget[R3FactoryTarget.Pipe = 3] = "Pipe", R3FactoryTarget[R3FactoryTarget.NgModule = 4] = "NgModule"
        }(R3FactoryTarget || (R3FactoryTarget = {})),
        function(ViewEncapsulation) {
            ViewEncapsulation[ViewEncapsulation.Emulated = 0] = "Emulated", ViewEncapsulation[ViewEncapsulation.None = 2] = "None", ViewEncapsulation[ViewEncapsulation.ShadowDom = 3] = "ShadowDom"
        }(ViewEncapsulation$1 || (ViewEncapsulation$1 = {}));
        const Type = Function;

        function isType(v) {
            return "function" == typeof v
        }

        function newArray(size, value) {
            const list = [];
            for (let i = 0; i < size; i++) list.push(value);
            return list
        }
        const ES5_DELEGATE_CTOR = /^function\s+\S+\(\)\s*{[\s\S]+\.apply\(this,\s*(arguments|[^()]+\(arguments\))\)/,
            ES2015_INHERITED_CLASS = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{/,
            ES2015_INHERITED_CLASS_WITH_CTOR = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(/,
            ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR = /^class\s+[A-Za-z\d$_]*\s*extends\s+[^{]+{[\s\S]*constructor\s*\(\)\s*{\s*super\(\.\.\.arguments\)/;
        class ReflectionCapabilities {
            constructor(reflect) {
                this._reflect = reflect || _global.Reflect
            }
            isReflectionEnabled() {
                return !0
            }
            factory(t) {
                return (...args) => new t(...args)
            }
            _zipTypesAndAnnotations(paramTypes, paramAnnotations) {
                let result;
                result = newArray(void 0 === paramTypes ? paramAnnotations.length : paramTypes.length);
                for (let i = 0; i < result.length; i++) void 0 === paramTypes ? result[i] = [] : paramTypes[i] && paramTypes[i] != Object ? result[i] = [paramTypes[i]] : result[i] = [], paramAnnotations && null != paramAnnotations[i] && (result[i] = result[i].concat(paramAnnotations[i]));
                return result
            }
            _ownParameters(type, parentCtor) {
                if (function(typeStr) {
                        return ES5_DELEGATE_CTOR.test(typeStr) || ES2015_INHERITED_CLASS_WITH_DELEGATE_CTOR.test(typeStr) || ES2015_INHERITED_CLASS.test(typeStr) && !ES2015_INHERITED_CLASS_WITH_CTOR.test(typeStr)
                    }(type.toString())) return null;
                if (type.parameters && type.parameters !== parentCtor.parameters) return type.parameters;
                const tsickleCtorParams = type.ctorParameters;
                if (tsickleCtorParams && tsickleCtorParams !== parentCtor.ctorParameters) {
                    const ctorParameters = "function" == typeof tsickleCtorParams ? tsickleCtorParams() : tsickleCtorParams,
                        paramTypes = ctorParameters.map((ctorParam => ctorParam && ctorParam.type)),
                        paramAnnotations = ctorParameters.map((ctorParam => ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators)));
                    return this._zipTypesAndAnnotations(paramTypes, paramAnnotations)
                }
                const paramAnnotations = type.hasOwnProperty(PARAMETERS) && type[PARAMETERS],
                    paramTypes = this._reflect && this._reflect.getOwnMetadata && this._reflect.getOwnMetadata("design:paramtypes", type);
                return paramTypes || paramAnnotations ? this._zipTypesAndAnnotations(paramTypes, paramAnnotations) : newArray(type.length)
            }
            parameters(type) {
                if (!isType(type)) return [];
                const parentCtor = getParentCtor(type);
                let parameters = this._ownParameters(type, parentCtor);
                return parameters || parentCtor === Object || (parameters = this.parameters(parentCtor)), parameters || []
            }
            _ownAnnotations(typeOrFunc, parentCtor) {
                if (typeOrFunc.annotations && typeOrFunc.annotations !== parentCtor.annotations) {
                    let annotations = typeOrFunc.annotations;
                    return "function" == typeof annotations && annotations.annotations && (annotations = annotations.annotations), annotations
                }
                return typeOrFunc.decorators && typeOrFunc.decorators !== parentCtor.decorators ? convertTsickleDecoratorIntoMetadata(typeOrFunc.decorators) : typeOrFunc.hasOwnProperty(ANNOTATIONS) ? typeOrFunc[ANNOTATIONS] : null
            }
            annotations(typeOrFunc) {
                if (!isType(typeOrFunc)) return [];
                const parentCtor = getParentCtor(typeOrFunc),
                    ownAnnotations = this._ownAnnotations(typeOrFunc, parentCtor) || [];
                return (parentCtor !== Object ? this.annotations(parentCtor) : []).concat(ownAnnotations)
            }
            _ownPropMetadata(typeOrFunc, parentCtor) {
                if (typeOrFunc.propMetadata && typeOrFunc.propMetadata !== parentCtor.propMetadata) {
                    let propMetadata = typeOrFunc.propMetadata;
                    return "function" == typeof propMetadata && propMetadata.propMetadata && (propMetadata = propMetadata.propMetadata), propMetadata
                }
                if (typeOrFunc.propDecorators && typeOrFunc.propDecorators !== parentCtor.propDecorators) {
                    const propDecorators = typeOrFunc.propDecorators,
                        propMetadata = {};
                    return Object.keys(propDecorators).forEach((prop => {
                        propMetadata[prop] = convertTsickleDecoratorIntoMetadata(propDecorators[prop])
                    })), propMetadata
                }
                return typeOrFunc.hasOwnProperty(PROP_METADATA) ? typeOrFunc[PROP_METADATA] : null
            }
            propMetadata(typeOrFunc) {
                if (!isType(typeOrFunc)) return {};
                const parentCtor = getParentCtor(typeOrFunc),
                    propMetadata = {};
                if (parentCtor !== Object) {
                    const parentPropMetadata = this.propMetadata(parentCtor);
                    Object.keys(parentPropMetadata).forEach((propName => {
                        propMetadata[propName] = parentPropMetadata[propName]
                    }))
                }
                const ownPropMetadata = this._ownPropMetadata(typeOrFunc, parentCtor);
                return ownPropMetadata && Object.keys(ownPropMetadata).forEach((propName => {
                    const decorators = [];
                    propMetadata.hasOwnProperty(propName) && decorators.push(...propMetadata[propName]), decorators.push(...ownPropMetadata[propName]), propMetadata[propName] = decorators
                })), propMetadata
            }
            ownPropMetadata(typeOrFunc) {
                return isType(typeOrFunc) && this._ownPropMetadata(typeOrFunc, getParentCtor(typeOrFunc)) || {}
            }
            hasLifecycleHook(type, lcProperty) {
                return type instanceof Type && lcProperty in type.prototype
            }
            guards(type) {
                return {}
            }
            getter(name) {
                return new Function("o", "return o." + name + ";")
            }
            setter(name) {
                return new Function("o", "v", "return o." + name + " = v;")
            }
            method(name) {
                return new Function("o", "args", `if (!o.${name}) throw new Error('"${name}" is undefined');\n        return o.${name}.apply(o, args);`)
            }
            importUri(type) {
                return "object" == typeof type && type.filePath ? type.filePath : `./${stringify(type)}`
            }
            resourceUri(type) {
                return `./${stringify(type)}`
            }
            resolveIdentifier(name, moduleUrl, members, runtime) {
                return runtime
            }
            resolveEnum(enumIdentifier, name) {
                return enumIdentifier[name]
            }
        }

        function convertTsickleDecoratorIntoMetadata(decoratorInvocations) {
            return decoratorInvocations ? decoratorInvocations.map((decoratorInvocation => new(0, decoratorInvocation.type.annotationCls)(...decoratorInvocation.args ? decoratorInvocation.args : []))) : []
        }

        function getParentCtor(ctor) {
            const parentProto = ctor.prototype ? Object.getPrototypeOf(ctor.prototype) : null;
            return (parentProto ? parentProto.constructor : null) || Object
        }
        const Inject = makeParamDecorator("Inject", (token => ({
                token: token
            }))),
            Optional = makeParamDecorator("Optional"),
            Self = makeParamDecorator("Self"),
            SkipSelf = makeParamDecorator("SkipSelf"),
            Host = makeParamDecorator("Host");
        new Map;
        new Set;
        const THROW_IF_NOT_FOUND = {},
            NEW_LINE = /\n/gm,
            USE_VALUE = getClosureSafeProperty({
                provide: String,
                useValue: getClosureSafeProperty
            });
        let _currentInjector;

        function setCurrentInjector(injector) {
            const former = _currentInjector;
            return _currentInjector = injector, former
        }

        function injectInjectorOnly(token, flags = InjectFlags.Default) {
            if (void 0 === _currentInjector) throw new Error("inject() must be called from an injection context");
            return null === _currentInjector ? injectRootLimpMode(token, void 0, flags) : _currentInjector.get(token, flags & InjectFlags.Optional ? null : void 0, flags)
        }

        function ɵɵinject(token, flags = InjectFlags.Default) {
            return (_injectImplementation || injectInjectorOnly)(resolveForwardRef(token), flags)
        }

        function injectArgs(types) {
            const args = [];
            for (let i = 0; i < types.length; i++) {
                const arg = resolveForwardRef(types[i]);
                if (Array.isArray(arg)) {
                    if (0 === arg.length) throw new Error("Arguments array must have arguments.");
                    let type, flags = InjectFlags.Default;
                    for (let j = 0; j < arg.length; j++) {
                        const meta = arg[j];
                        meta instanceof Optional || "Optional" === meta.ngMetadataName || meta === Optional ? flags |= InjectFlags.Optional : meta instanceof SkipSelf || "SkipSelf" === meta.ngMetadataName || meta === SkipSelf ? flags |= InjectFlags.SkipSelf : meta instanceof Self || "Self" === meta.ngMetadataName || meta === Self ? flags |= InjectFlags.Self : type = meta instanceof Inject || meta === Inject ? meta.token : meta
                    }
                    args.push(ɵɵinject(type, flags))
                } else args.push(ɵɵinject(arg))
            }
            return args
        }

        function catchInjectorError(e, token, injectorErrorName, source) {
            const tokenPath = e.ngTempTokenPath;
            throw token.__source && tokenPath.unshift(token.__source), e.message = formatError("\n" + e.message, tokenPath, injectorErrorName, source), e.ngTokenPath = tokenPath, e.ngTempTokenPath = null, e
        }

        function formatError(text, obj, injectorErrorName, source = null) {
            text = text && "\n" === text.charAt(0) && "ɵ" == text.charAt(1) ? text.substr(2) : text;
            let context = stringify(obj);
            if (Array.isArray(obj)) context = obj.map(stringify).join(" -> ");
            else if ("object" == typeof obj) {
                let parts = [];
                for (let key in obj)
                    if (obj.hasOwnProperty(key)) {
                        let value = obj[key];
                        parts.push(key + ":" + ("string" == typeof value ? JSON.stringify(value) : stringify(value)))
                    }
                context = `{${parts.join(", ")}}`
            }
            return `${injectorErrorName}${source?"("+source+")":""}[${context}]: ${text.replace(NEW_LINE,"\n  ")}`
        }
        let policy;

        function getPolicy() {
            if (void 0 === policy && (policy = null, _global.trustedTypes)) try {
                policy = _global.trustedTypes.createPolicy("angular", {
                    createHTML: s => s,
                    createScript: s => s,
                    createScriptURL: s => s
                })
            } catch (_a) {}
            return policy
        }

        function trustedHTMLFromString(html) {
            var _a;
            return (null === (_a = getPolicy()) || void 0 === _a ? void 0 : _a.createHTML(html)) || html
        }

        function trustedScriptFromString(script) {
            var _a;
            return (null === (_a = getPolicy()) || void 0 === _a ? void 0 : _a.createScript(script)) || script
        }
        class SafeValueImpl {
            constructor(changingThisBreaksApplicationSecurity) {
                this.changingThisBreaksApplicationSecurity = changingThisBreaksApplicationSecurity
            }
            toString() {
                return `SafeValue must use [property]=binding: ${this.changingThisBreaksApplicationSecurity} (see https://g.co/ng/security#xss)`
            }
        }
        class SafeHtmlImpl extends SafeValueImpl {
            getTypeName() {
                return "HTML"
            }
        }
        class SafeStyleImpl extends SafeValueImpl {
            getTypeName() {
                return "Style"
            }
        }
        class SafeScriptImpl extends SafeValueImpl {
            getTypeName() {
                return "Script"
            }
        }
        class SafeUrlImpl extends SafeValueImpl {
            getTypeName() {
                return "URL"
            }
        }
        class SafeResourceUrlImpl extends SafeValueImpl {
            getTypeName() {
                return "ResourceURL"
            }
        }

        function unwrapSafeValue(value) {
            return value instanceof SafeValueImpl ? value.changingThisBreaksApplicationSecurity : value
        }

        function allowSanitizationBypassAndThrow(value, type) {
            const actualType = getSanitizationBypassType(value);
            if (null != actualType && actualType !== type) {
                if ("ResourceURL" === actualType && "URL" === type) return !0;
                throw new Error(`Required a safe ${type}, got a ${actualType} (see https://g.co/ng/security#xss)`)
            }
            return actualType === type
        }

        function getSanitizationBypassType(value) {
            return value instanceof SafeValueImpl && value.getTypeName() || null
        }

        function bypassSanitizationTrustHtml(trustedHtml) {
            return new SafeHtmlImpl(trustedHtml)
        }

        function bypassSanitizationTrustStyle(trustedStyle) {
            return new SafeStyleImpl(trustedStyle)
        }

        function bypassSanitizationTrustScript(trustedScript) {
            return new SafeScriptImpl(trustedScript)
        }

        function bypassSanitizationTrustUrl(trustedUrl) {
            return new SafeUrlImpl(trustedUrl)
        }

        function bypassSanitizationTrustResourceUrl(trustedResourceUrl) {
            return new SafeResourceUrlImpl(trustedResourceUrl)
        }

        function getInertBodyHelper(defaultDoc) {
            return function() {
                try {
                    return !!(new window.DOMParser).parseFromString(trustedHTMLFromString(""), "text/html")
                } catch (_a) {
                    return !1
                }
            }() ? new DOMParserHelper : new InertDocumentHelper(defaultDoc)
        }
        class DOMParserHelper {
            getInertBodyElement(html) {
                html = "<body><remove></remove>" + html;
                try {
                    const body = (new window.DOMParser).parseFromString(trustedHTMLFromString(html), "text/html").body;
                    return body.removeChild(body.firstChild), body
                } catch (_a) {
                    return null
                }
            }
        }
        class InertDocumentHelper {
            constructor(defaultDoc) {
                if (this.defaultDoc = defaultDoc, this.inertDocument = this.defaultDoc.implementation.createHTMLDocument("sanitization-inert"), null == this.inertDocument.body) {
                    const inertHtml = this.inertDocument.createElement("html");
                    this.inertDocument.appendChild(inertHtml);
                    const inertBodyElement = this.inertDocument.createElement("body");
                    inertHtml.appendChild(inertBodyElement)
                }
            }
            getInertBodyElement(html) {
                const templateEl = this.inertDocument.createElement("template");
                if ("content" in templateEl) return templateEl.innerHTML = trustedHTMLFromString(html), templateEl;
                const inertBody = this.inertDocument.createElement("body");
                return inertBody.innerHTML = trustedHTMLFromString(html), this.defaultDoc.documentMode && this.stripCustomNsAttrs(inertBody), inertBody
            }
            stripCustomNsAttrs(el) {
                const elAttrs = el.attributes;
                for (let i = elAttrs.length - 1; 0 < i; i--) {
                    const attrName = elAttrs.item(i).name;
                    "xmlns:ns1" !== attrName && 0 !== attrName.indexOf("ns1:") || el.removeAttribute(attrName)
                }
                let childNode = el.firstChild;
                for (; childNode;) childNode.nodeType === Node.ELEMENT_NODE && this.stripCustomNsAttrs(childNode), childNode = childNode.nextSibling
            }
        }
        const SAFE_URL_PATTERN = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^&:/?#]*(?:[/?#]|$))/gi,
            DATA_URL_PATTERN = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[a-z0-9+\/]+=*$/i;

        function _sanitizeUrl(url) {
            return (url = String(url)).match(SAFE_URL_PATTERN) || url.match(DATA_URL_PATTERN) ? url : (("undefined" == typeof ngDevMode || ngDevMode) && console.warn(`WARNING: sanitizing unsafe URL value ${url} (see https://g.co/ng/security#xss)`), "unsafe:" + url)
        }

        function sanitizeSrcset(srcset) {
            return (srcset = String(srcset)).split(",").map((srcset => _sanitizeUrl(srcset.trim()))).join(", ")
        }

        function tagSet(tags) {
            const res = {};
            for (const t of tags.split(",")) res[t] = !0;
            return res
        }

        function merge(...sets) {
            const res = {};
            for (const s of sets)
                for (const v in s) s.hasOwnProperty(v) && (res[v] = !0);
            return res
        }
        const VOID_ELEMENTS = tagSet("area,br,col,hr,img,wbr"),
            OPTIONAL_END_TAG_BLOCK_ELEMENTS = tagSet("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),
            OPTIONAL_END_TAG_INLINE_ELEMENTS = tagSet("rp,rt"),
            OPTIONAL_END_TAG_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, OPTIONAL_END_TAG_BLOCK_ELEMENTS),
            BLOCK_ELEMENTS = merge(OPTIONAL_END_TAG_BLOCK_ELEMENTS, tagSet("address,article,aside,blockquote,caption,center,del,details,dialog,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,main,map,menu,nav,ol,pre,section,summary,table,ul")),
            INLINE_ELEMENTS = merge(OPTIONAL_END_TAG_INLINE_ELEMENTS, tagSet("a,abbr,acronym,audio,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,picture,q,ruby,rp,rt,s,samp,small,source,span,strike,strong,sub,sup,time,track,tt,u,var,video")),
            VALID_ELEMENTS = merge(VOID_ELEMENTS, BLOCK_ELEMENTS, INLINE_ELEMENTS, OPTIONAL_END_TAG_ELEMENTS),
            URI_ATTRS = tagSet("background,cite,href,itemtype,longdesc,poster,src,xlink:href"),
            SRCSET_ATTRS = tagSet("srcset"),
            HTML_ATTRS = tagSet("abbr,accesskey,align,alt,autoplay,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,controls,coords,datetime,default,dir,download,face,headers,height,hidden,hreflang,hspace,ismap,itemscope,itemprop,kind,label,lang,language,loop,media,muted,nohref,nowrap,open,preload,rel,rev,role,rows,rowspan,rules,scope,scrolling,shape,size,sizes,span,srclang,start,summary,tabindex,target,title,translate,type,usemap,valign,value,vspace,width"),
            ARIA_ATTRS = tagSet("aria-activedescendant,aria-atomic,aria-autocomplete,aria-busy,aria-checked,aria-colcount,aria-colindex,aria-colspan,aria-controls,aria-current,aria-describedby,aria-details,aria-disabled,aria-dropeffect,aria-errormessage,aria-expanded,aria-flowto,aria-grabbed,aria-haspopup,aria-hidden,aria-invalid,aria-keyshortcuts,aria-label,aria-labelledby,aria-level,aria-live,aria-modal,aria-multiline,aria-multiselectable,aria-orientation,aria-owns,aria-placeholder,aria-posinset,aria-pressed,aria-readonly,aria-relevant,aria-required,aria-roledescription,aria-rowcount,aria-rowindex,aria-rowspan,aria-selected,aria-setsize,aria-sort,aria-valuemax,aria-valuemin,aria-valuenow,aria-valuetext"),
            VALID_ATTRS = merge(URI_ATTRS, SRCSET_ATTRS, HTML_ATTRS, ARIA_ATTRS),
            SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS = tagSet("script,style,template");
        class SanitizingHtmlSerializer {
            constructor() {
                this.sanitizedSomething = !1, this.buf = []
            }
            sanitizeChildren(el) {
                let current = el.firstChild,
                    traverseContent = !0;
                for (; current;)
                    if (current.nodeType === Node.ELEMENT_NODE ? traverseContent = this.startElement(current) : current.nodeType === Node.TEXT_NODE ? this.chars(current.nodeValue) : this.sanitizedSomething = !0, traverseContent && current.firstChild) current = current.firstChild;
                    else
                        for (; current;) {
                            current.nodeType === Node.ELEMENT_NODE && this.endElement(current);
                            let next = this.checkClobberedElement(current, current.nextSibling);
                            if (next) {
                                current = next;
                                break
                            }
                            current = this.checkClobberedElement(current, current.parentNode)
                        }
                return this.buf.join("")
            }
            startElement(element) {
                const tagName = element.nodeName.toLowerCase();
                if (!VALID_ELEMENTS.hasOwnProperty(tagName)) return this.sanitizedSomething = !0, !SKIP_TRAVERSING_CONTENT_IF_INVALID_ELEMENTS.hasOwnProperty(tagName);
                this.buf.push("<"), this.buf.push(tagName);
                const elAttrs = element.attributes;
                for (let i = 0; i < elAttrs.length; i++) {
                    const elAttr = elAttrs.item(i),
                        attrName = elAttr.name,
                        lower = attrName.toLowerCase();
                    if (!VALID_ATTRS.hasOwnProperty(lower)) {
                        this.sanitizedSomething = !0;
                        continue
                    }
                    let value = elAttr.value;
                    URI_ATTRS[lower] && (value = _sanitizeUrl(value)), SRCSET_ATTRS[lower] && (value = sanitizeSrcset(value)), this.buf.push(" ", attrName, '="', encodeEntities(value), '"')
                }
                return this.buf.push(">"), !0
            }
            endElement(current) {
                const tagName = current.nodeName.toLowerCase();
                VALID_ELEMENTS.hasOwnProperty(tagName) && !VOID_ELEMENTS.hasOwnProperty(tagName) && (this.buf.push("</"), this.buf.push(tagName), this.buf.push(">"))
            }
            chars(chars) {
                this.buf.push(encodeEntities(chars))
            }
            checkClobberedElement(node, nextNode) {
                if (nextNode && (node.compareDocumentPosition(nextNode) & Node.DOCUMENT_POSITION_CONTAINED_BY) === Node.DOCUMENT_POSITION_CONTAINED_BY) throw new Error(`Failed to sanitize html because the element is clobbered: ${node.outerHTML}`);
                return nextNode
            }
        }
        const SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
            NON_ALPHANUMERIC_REGEXP = /([^\#-~ |!])/g;

        function encodeEntities(value) {
            return value.replace(/&/g, "&amp;").replace(SURROGATE_PAIR_REGEXP, (function(match) {
                return "&#" + (1024 * (match.charCodeAt(0) - 55296) + (match.charCodeAt(1) - 56320) + 65536) + ";"
            })).replace(NON_ALPHANUMERIC_REGEXP, (function(match) {
                return "&#" + match.charCodeAt(0) + ";"
            })).replace(/</g, "&lt;").replace(/>/g, "&gt;")
        }
        let inertBodyHelper;

        function _sanitizeHtml(defaultDoc, unsafeHtmlInput) {
            let inertBodyElement = null;
            try {
                inertBodyHelper = inertBodyHelper || getInertBodyHelper(defaultDoc);
                let unsafeHtml = unsafeHtmlInput ? String(unsafeHtmlInput) : "";
                inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml);
                let mXSSAttempts = 5,
                    parsedHtml = unsafeHtml;
                do {
                    if (0 === mXSSAttempts) throw new Error("Failed to sanitize html because the input is unstable");
                    mXSSAttempts--, unsafeHtml = parsedHtml, parsedHtml = inertBodyElement.innerHTML, inertBodyElement = inertBodyHelper.getInertBodyElement(unsafeHtml)
                } while (unsafeHtml !== parsedHtml);
                const sanitizer = new SanitizingHtmlSerializer,
                    safeHtml = sanitizer.sanitizeChildren(getTemplateContent(inertBodyElement) || inertBodyElement);
                return ("undefined" == typeof ngDevMode || ngDevMode) && sanitizer.sanitizedSomething && console.warn("WARNING: sanitizing HTML stripped some content, see https://g.co/ng/security#xss"), safeHtml
            } finally {
                if (inertBodyElement) {
                    const parent = getTemplateContent(inertBodyElement) || inertBodyElement;
                    for (; parent.firstChild;) parent.removeChild(parent.firstChild)
                }
            }
        }

        function getTemplateContent(el) {
            return "content" in el && function(el) {
                return el.nodeType === Node.ELEMENT_NODE && "TEMPLATE" === el.nodeName
            }(el) ? el.content : null
        }
        var SecurityContext;
        ! function(SecurityContext) {
            SecurityContext[SecurityContext.NONE = 0] = "NONE", SecurityContext[SecurityContext.HTML = 1] = "HTML", SecurityContext[SecurityContext.STYLE = 2] = "STYLE", SecurityContext[SecurityContext.SCRIPT = 3] = "SCRIPT", SecurityContext[SecurityContext.URL = 4] = "URL", SecurityContext[SecurityContext.RESOURCE_URL = 5] = "RESOURCE_URL"
        }(SecurityContext || (SecurityContext = {}));

        function getDebugContext(error) {
            return error.ngDebugContext
        }

        function getOriginalError(error) {
            return error.ngOriginalError
        }

        function defaultErrorLogger(console, ...values) {
            console.error(...values)
        }
        class ErrorHandler {
            constructor() {
                this._console = console
            }
            handleError(error) {
                const originalError = this._findOriginalError(error),
                    context = this._findContext(error),
                    errorLogger = function(error) {
                        return error.ngErrorLogger || defaultErrorLogger
                    }(error);
                errorLogger(this._console, "ERROR", error), originalError && errorLogger(this._console, "ORIGINAL ERROR", originalError), context && errorLogger(this._console, "ERROR CONTEXT", context)
            }
            _findContext(error) {
                return error ? getDebugContext(error) ? getDebugContext(error) : this._findContext(getOriginalError(error)) : null
            }
            _findOriginalError(error) {
                let e = getOriginalError(error);
                for (; e && getOriginalError(e);) e = getOriginalError(e);
                return e
            }
        }

        function createNamedArrayType(name) {
            if (!ngDevMode) throw new Error("Looks like we are in 'prod mode', but we are creating a named Array type, which is wrong! Check your code");
            try {
                return function(...args) {
                    if ("undefined" == typeof ngDevMode) throw new Error("newTrustedFunctionForDev should never be called in production");
                    if (!_global.trustedTypes) return new Function(...args);
                    const body = `(function anonymous(${args.slice(0,-1).join(",")}\n) { ${args.pop().toString()}\n})`,
                        fn = _global.eval(trustedScriptFromString(body));
                    return fn.toString = () => body, fn.bind(_global)
                }("Array", `return class ${name} extends Array{}`)(Array)
            } catch (e) {
                return Array
            }
        }

        function attachPatchData(target, data) {
            target.__ngContext__ = data
        }
        const defaultScheduler = ("undefined" != typeof requestAnimationFrame && requestAnimationFrame || setTimeout).bind(_global);
        var RendererStyleFlags2;
        let _icuContainerIterate;

        function icuContainerIterate(tIcuContainerNode, lView) {
            return _icuContainerIterate(tIcuContainerNode, lView)
        }! function(RendererStyleFlags2) {
            RendererStyleFlags2[RendererStyleFlags2.Important = 1] = "Important", RendererStyleFlags2[RendererStyleFlags2.DashCase = 2] = "DashCase"
        }(RendererStyleFlags2 || (RendererStyleFlags2 = {}));

        function getLViewParent(lView) {
            ngDevMode && assertLView(lView);
            const parent = lView[3];
            return isLContainer(parent) ? parent[3] : parent
        }

        function getFirstLContainer(lView) {
            return getNearestLContainer(lView[13])
        }

        function getNextLContainer(container) {
            return getNearestLContainer(container[4])
        }

        function getNearestLContainer(viewOrContainer) {
            for (; null !== viewOrContainer && !isLContainer(viewOrContainer);) viewOrContainer = viewOrContainer[4];
            return viewOrContainer
        }

        function applyToElementOrContainer(action, renderer, parent, lNodeToHandle, beforeNode) {
            if (null != lNodeToHandle) {
                let lContainer, isComponent = !1;
                isLContainer(lNodeToHandle) ? lContainer = lNodeToHandle : isLView(lNodeToHandle) && (isComponent = !0, ngDevMode && assertDefined(lNodeToHandle[0], "HOST must be defined for a component LView"), lNodeToHandle = lNodeToHandle[0]);
                const rNode = unwrapRNode(lNodeToHandle);
                ngDevMode && !isProceduralRenderer(renderer) && assertDomNode(rNode), 0 === action && null !== parent ? null == beforeNode ? nativeAppendChild(renderer, parent, rNode) : nativeInsertBefore(renderer, parent, rNode, beforeNode || null, !0) : 1 === action && null !== parent ? nativeInsertBefore(renderer, parent, rNode, beforeNode || null, !0) : 2 === action ? nativeRemoveNode(renderer, rNode, isComponent) : 3 === action && (ngDevMode && ngDevMode.rendererDestroyNode++, renderer.destroyNode(rNode)), null != lContainer && function(renderer, action, lContainer, parentRElement, beforeNode) {
                    ngDevMode && assertLContainer(lContainer);
                    const anchor = lContainer[7],
                        native = unwrapRNode(lContainer);
                    anchor !== native && applyToElementOrContainer(action, renderer, parentRElement, anchor, beforeNode);
                    for (let i = 10; i < lContainer.length; i++) {
                        const lView = lContainer[i];
                        applyView(lView[1], lView, renderer, action, parentRElement, anchor)
                    }
                }(renderer, action, lContainer, parent, beforeNode)
            }
        }

        function createElementNode(renderer, name, namespace) {
            return ngDevMode && ngDevMode.rendererCreateElement++, isProceduralRenderer(renderer) ? renderer.createElement(name, namespace) : null === namespace ? renderer.createElement(name) : renderer.createElementNS(namespace, name)
        }

        function detachMovedView(declarationContainer, lView) {
            ngDevMode && assertLContainer(declarationContainer), ngDevMode && assertDefined(declarationContainer[9], "A projected view should belong to a non-empty projected views collection");
            const movedViews = declarationContainer[9],
                declarationViewIndex = movedViews.indexOf(lView),
                insertionLContainer = lView[3];
            ngDevMode && assertLContainer(insertionLContainer), 1024 & lView[2] && (lView[2] &= -1025, updateTransplantedViewCount(insertionLContainer, -1)), movedViews.splice(declarationViewIndex, 1)
        }

        function destroyLView(tView, lView) {
            if (!(256 & lView[2])) {
                const renderer = lView[11];
                isProceduralRenderer(renderer) && renderer.destroyNode && applyView(tView, lView, renderer, 3, null, null),
                    function(rootView) {
                        let lViewOrLContainer = rootView[13];
                        if (!lViewOrLContainer) return cleanUpView(rootView[1], rootView);
                        for (; lViewOrLContainer;) {
                            let next = null;
                            if (isLView(lViewOrLContainer)) next = lViewOrLContainer[13];
                            else {
                                ngDevMode && assertLContainer(lViewOrLContainer);
                                const firstView = lViewOrLContainer[10];
                                firstView && (next = firstView)
                            }
                            if (!next) {
                                for (; lViewOrLContainer && !lViewOrLContainer[4] && lViewOrLContainer !== rootView;) isLView(lViewOrLContainer) && cleanUpView(lViewOrLContainer[1], lViewOrLContainer), lViewOrLContainer = lViewOrLContainer[3];
                                null === lViewOrLContainer && (lViewOrLContainer = rootView), isLView(lViewOrLContainer) && cleanUpView(lViewOrLContainer[1], lViewOrLContainer), next = lViewOrLContainer && lViewOrLContainer[4]
                            }
                            lViewOrLContainer = next
                        }
                    }(lView)
            }
        }

        function cleanUpView(tView, lView) {
            if (!(256 & lView[2])) {
                lView[2] &= -129, lView[2] |= 256,
                    function(tView, lView) {
                        let destroyHooks;
                        if (null != tView && null != (destroyHooks = tView.destroyHooks))
                            for (let i = 0; i < destroyHooks.length; i += 2) {
                                const context = lView[destroyHooks[i]];
                                if (!(context instanceof NodeInjectorFactory)) {
                                    const toCall = destroyHooks[i + 1];
                                    if (Array.isArray(toCall))
                                        for (let j = 0; j < toCall.length; j += 2) toCall[j + 1].call(context[toCall[j]]);
                                    else toCall.call(context)
                                }
                            }
                    }(tView, lView),
                    function(tView, lView) {
                        const tCleanup = tView.cleanup,
                            lCleanup = lView[7];
                        let lastLCleanupIndex = -1;
                        if (null !== tCleanup) {
                            for (let i = 0; i < tCleanup.length - 1; i += 2)
                                if ("string" == typeof tCleanup[i]) {
                                    const idxOrTargetGetter = tCleanup[i + 1],
                                        target = "function" == typeof idxOrTargetGetter ? idxOrTargetGetter(lView) : unwrapRNode(lView[idxOrTargetGetter]),
                                        listener = lCleanup[lastLCleanupIndex = tCleanup[i + 2]],
                                        useCaptureOrSubIdx = tCleanup[i + 3];
                                    "boolean" == typeof useCaptureOrSubIdx ? target.removeEventListener(tCleanup[i], listener, useCaptureOrSubIdx) : useCaptureOrSubIdx >= 0 ? lCleanup[lastLCleanupIndex = useCaptureOrSubIdx]() : lCleanup[lastLCleanupIndex = -useCaptureOrSubIdx].unsubscribe(), i += 2
                                } else {
                                    const context = lCleanup[lastLCleanupIndex = tCleanup[i + 1]];
                                    tCleanup[i].call(context)
                                }
                            if (null !== lCleanup)
                                for (let i = lastLCleanupIndex + 1; i < lCleanup.length; i++) {
                                    const instanceCleanupFn = lCleanup[i];
                                    ngDevMode && assertFunction(instanceCleanupFn, "Expecting instance cleanup function."), instanceCleanupFn()
                                }
                            lView[7] = null
                        }
                    }(tView, lView), 1 === lView[1].type && isProceduralRenderer(lView[11]) && (ngDevMode && ngDevMode.rendererDestroy++, lView[11].destroy());
                const declarationContainer = lView[17];
                if (null !== declarationContainer && isLContainer(lView[3])) {
                    declarationContainer !== lView[3] && detachMovedView(declarationContainer, lView);
                    const lQueries = lView[19];
                    null !== lQueries && lQueries.detachView(tView)
                }
            }
        }

        function nativeInsertBefore(renderer, parent, child, beforeNode, isMove) {
            ngDevMode && ngDevMode.rendererInsertBefore++, isProceduralRenderer(renderer) ? renderer.insertBefore(parent, child, beforeNode, isMove) : parent.insertBefore(child, beforeNode, isMove)
        }

        function nativeAppendChild(renderer, parent, child) {
            ngDevMode && ngDevMode.rendererAppendChild++, ngDevMode && assertDefined(parent, "parent node must be defined"), isProceduralRenderer(renderer) ? renderer.appendChild(parent, child) : parent.appendChild(child)
        }

        function nativeParentNode(renderer, node) {
            return isProceduralRenderer(renderer) ? renderer.parentNode(node) : node.parentNode
        }

        function nativeRemoveNode(renderer, rNode, isHostElement) {
            ngDevMode && ngDevMode.rendererRemoveNode++;
            const nativeParent = nativeParentNode(renderer, rNode);
            nativeParent && function(renderer, parent, child, isHostElement) {
                isProceduralRenderer(renderer) ? renderer.removeChild(parent, child, isHostElement) : parent.removeChild(child)
            }(renderer, nativeParent, rNode, isHostElement)
        }

        function applyNodes(renderer, action, tNode, lView, parentRElement, beforeNode, isProjection) {
            for (; null != tNode;) {
                ngDevMode && assertTNodeForLView(tNode, lView), ngDevMode && assertTNodeType(tNode, 63);
                const rawSlotValue = lView[tNode.index],
                    tNodeType = tNode.type;
                if (isProjection && 0 === action && (rawSlotValue && attachPatchData(unwrapRNode(rawSlotValue), lView), tNode.flags |= 4), 64 != (64 & tNode.flags))
                    if (8 & tNodeType) applyNodes(renderer, action, tNode.child, lView, parentRElement, beforeNode, !1), applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode);
                    else if (32 & tNodeType) {
                    const nextRNode = icuContainerIterate(tNode, lView);
                    let rNode;
                    for (; rNode = nextRNode();) applyToElementOrContainer(action, renderer, parentRElement, rNode, beforeNode);
                    applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode)
                } else 16 & tNodeType ? applyProjectionRecursive(renderer, action, lView, tNode, parentRElement, beforeNode) : (ngDevMode && assertTNodeType(tNode, 7), applyToElementOrContainer(action, renderer, parentRElement, rawSlotValue, beforeNode));
                tNode = isProjection ? tNode.projectionNext : tNode.next
            }
        }

        function applyView(tView, lView, renderer, action, parentRElement, beforeNode) {
            applyNodes(renderer, action, tView.firstChild, lView, parentRElement, beforeNode, !1)
        }

        function applyProjectionRecursive(renderer, action, lView, tProjectionNode, parentRElement, beforeNode) {
            const componentLView = lView[16],
                componentNode = componentLView[6];
            ngDevMode && assertEqual(typeof tProjectionNode.projection, "number", "expecting projection index");
            const nodeToProjectOrRNodes = componentNode.projection[tProjectionNode.projection];
            if (Array.isArray(nodeToProjectOrRNodes))
                for (let i = 0; i < nodeToProjectOrRNodes.length; i++) {
                    applyToElementOrContainer(action, renderer, parentRElement, nodeToProjectOrRNodes[i], beforeNode)
                } else {
                    applyNodes(renderer, action, nodeToProjectOrRNodes, componentLView[3], parentRElement, beforeNode, !0)
                }
        }

        function writeDirectStyle(renderer, element, newValue) {
            ngDevMode && assertString(newValue, "'newValue' should be a string"), isProceduralRenderer(renderer) ? renderer.setAttribute(element, "style", newValue) : element.style.cssText = newValue, ngDevMode && ngDevMode.rendererSetStyle++
        }

        function writeDirectClass(renderer, element, newValue) {
            ngDevMode && assertString(newValue, "'newValue' should be a string"), isProceduralRenderer(renderer) ? "" === newValue ? renderer.removeAttribute(element, "class") : renderer.setAttribute(element, "class", newValue) : element.className = newValue, ngDevMode && ngDevMode.rendererSetClassName++
        }

        function isPositive(mode) {
            return 0 == (1 & mode)
        }

        function maybeWrapInNotSelector(isNegativeMode, chunk) {
            return isNegativeMode ? ":not(" + chunk.trim() + ")" : chunk
        }

        function stringifyCSSSelector(selector) {
            let result = selector[0],
                i = 1,
                mode = 2,
                currentChunk = "",
                isNegativeMode = !1;
            for (; i < selector.length;) {
                let valueOrMarker = selector[i];
                if ("string" == typeof valueOrMarker)
                    if (2 & mode) {
                        const attrValue = selector[++i];
                        currentChunk += "[" + valueOrMarker + (attrValue.length > 0 ? '="' + attrValue + '"' : "") + "]"
                    } else 8 & mode ? currentChunk += "." + valueOrMarker : 4 & mode && (currentChunk += " " + valueOrMarker);
                else "" === currentChunk || isPositive(valueOrMarker) || (result += maybeWrapInNotSelector(isNegativeMode, currentChunk), currentChunk = ""), mode = valueOrMarker, isNegativeMode = isNegativeMode || !isPositive(mode);
                i++
            }
            return "" !== currentChunk && (result += maybeWrapInNotSelector(isNegativeMode, currentChunk)), result
        }
        const NO_CHANGE = "undefined" == typeof ngDevMode || ngDevMode ? {
            __brand__: "NO_CHANGE"
        } : {};

        function selectIndexInternal(tView, lView, index, checkNoChangesMode) {
            if (ngDevMode && function(lView, index) {
                    assertBetween(20, lView[1].bindingStartIndex, index)
                }(lView, index), !checkNoChangesMode) {
                if (3 == (3 & lView[2])) {
                    const preOrderCheckHooks = tView.preOrderCheckHooks;
                    null !== preOrderCheckHooks && executeCheckHooks(lView, preOrderCheckHooks, index)
                } else {
                    const preOrderHooks = tView.preOrderHooks;
                    null !== preOrderHooks && executeInitAndCheckHooks(lView, preOrderHooks, 0, index)
                }
            }
            setSelectedIndex(index)
        }

        function getTStylingRangePrev(tStylingRange) {
            return ngDevMode && assertNumber(tStylingRange, "expected number"), tStylingRange >> 17 & 32767
        }

        function getTStylingRangePrevDuplicate(tStylingRange) {
            return ngDevMode && assertNumber(tStylingRange, "expected number"), 2 == (2 & tStylingRange)
        }

        function getTStylingRangeNext(tStylingRange) {
            return ngDevMode && assertNumber(tStylingRange, "expected number"), (131068 & tStylingRange) >> 2
        }

        function getTStylingRangeNextDuplicate(tStylingRange) {
            return ngDevMode && assertNumber(tStylingRange, "expected number"), 1 == (1 & tStylingRange)
        }

        function attachDebugObject(obj, debug) {
            if (!ngDevMode) throw new Error("This method should be guarded with `ngDevMode` so that it can be tree shaken in production!");
            Object.defineProperty(obj, "debug", {
                value: debug,
                enumerable: !1
            })
        }
        const NG_DEV_MODE = ("undefined" == typeof ngDevMode || !!ngDevMode) && initNgDevMode();
        let LVIEW_COMPONENT_CACHE, LVIEW_EMBEDDED_CACHE, LVIEW_ROOT;

        function cloneToLViewFromTViewBlueprint(tView) {
            return function(type, name) {
                switch (type) {
                    case 0:
                        return void 0 === LVIEW_ROOT && (LVIEW_ROOT = new(createNamedArrayType("LRootView"))), LVIEW_ROOT;
                    case 1:
                        void 0 === LVIEW_COMPONENT_CACHE && (LVIEW_COMPONENT_CACHE = new Map);
                        let componentArray = LVIEW_COMPONENT_CACHE.get(name);
                        return void 0 === componentArray && (componentArray = new(createNamedArrayType("LComponentView" + nameSuffix(name))), LVIEW_COMPONENT_CACHE.set(name, componentArray)), componentArray;
                    case 2:
                        void 0 === LVIEW_EMBEDDED_CACHE && (LVIEW_EMBEDDED_CACHE = new Map);
                        let embeddedArray = LVIEW_EMBEDDED_CACHE.get(name);
                        return void 0 === embeddedArray && (embeddedArray = new(createNamedArrayType("LEmbeddedView" + nameSuffix(name))), LVIEW_EMBEDDED_CACHE.set(name, embeddedArray)), embeddedArray
                }
                throw new Error("unreachable code")
            }(tView.type, tView.template && tView.template.name).concat(tView.blueprint)
        }

        function nameSuffix(text) {
            if (null == text) return "";
            const index = text.lastIndexOf("_Template");
            return "_" + (-1 === index ? text : text.substr(0, index))
        }
        const TNodeDebug = class {
            constructor(tView_, type, index, insertBeforeIndex, injectorIndex, directiveStart, directiveEnd, directiveStylingLast, propertyBindings, flags, providerIndexes, value, attrs, mergedAttrs, localNames, initialInputs, inputs, outputs, tViews, next, projectionNext, child, parent, projection, styles, stylesWithoutHost, residualStyles, classes, classesWithoutHost, residualClasses, classBindings, styleBindings) {
                this.tView_ = tView_, this.type = type, this.index = index, this.insertBeforeIndex = insertBeforeIndex, this.injectorIndex = injectorIndex, this.directiveStart = directiveStart, this.directiveEnd = directiveEnd, this.directiveStylingLast = directiveStylingLast, this.propertyBindings = propertyBindings, this.flags = flags, this.providerIndexes = providerIndexes, this.value = value, this.attrs = attrs, this.mergedAttrs = mergedAttrs, this.localNames = localNames, this.initialInputs = initialInputs, this.inputs = inputs, this.outputs = outputs, this.tViews = tViews, this.next = next, this.projectionNext = projectionNext, this.child = child, this.parent = parent, this.projection = projection, this.styles = styles, this.stylesWithoutHost = stylesWithoutHost, this.residualStyles = residualStyles, this.classes = classes, this.classesWithoutHost = classesWithoutHost, this.residualClasses = residualClasses, this.classBindings = classBindings, this.styleBindings = styleBindings
            }
            debugNodeInjectorPath(lView) {
                const path = [];
                let injectorIndex = getInjectorIndex(this, lView);
                for (ngDevMode && assertNodeInjector(lView, injectorIndex); - 1 !== injectorIndex;) {
                    const tNode = lView[1].data[injectorIndex + 8];
                    path.push(buildDebugNode(tNode, lView));
                    const parentLocation = lView[injectorIndex + 8]; - 1 === parentLocation ? injectorIndex = -1 : (injectorIndex = getParentInjectorIndex(parentLocation), lView = getParentInjectorView(parentLocation, lView))
                }
                return path
            }
            get type_() {
                return toTNodeTypeAsString(this.type) || `TNodeType.?${this.type}?`
            }
            get flags_() {
                const flags = [];
                return 16 & this.flags && flags.push("TNodeFlags.hasClassInput"), 8 & this.flags && flags.push("TNodeFlags.hasContentQuery"), 32 & this.flags && flags.push("TNodeFlags.hasStyleInput"), 128 & this.flags && flags.push("TNodeFlags.hasHostBindings"), 2 & this.flags && flags.push("TNodeFlags.isComponentHost"), 1 & this.flags && flags.push("TNodeFlags.isDirectiveHost"), 64 & this.flags && flags.push("TNodeFlags.isDetached"), 4 & this.flags && flags.push("TNodeFlags.isProjected"), flags.join("|")
            }
            get template_() {
                if (1 & this.type) return this.value;
                const buf = [],
                    tagName = "string" == typeof this.value && this.value || this.type_;
                if (buf.push("<", tagName), this.flags && buf.push(" ", this.flags_), this.attrs)
                    for (let i = 0; i < this.attrs.length;) {
                        const attrName = this.attrs[i++];
                        if ("number" == typeof attrName) break;
                        const attrValue = this.attrs[i++];
                        buf.push(" ", attrName, '="', attrValue, '"')
                    }
                return buf.push(">"), processTNodeChildren(this.child, buf), buf.push("</", tagName, ">"), buf.join("")
            }
            get styleBindings_() {
                return toDebugStyleBinding(this, !1)
            }
            get classBindings_() {
                return toDebugStyleBinding(this, !0)
            }
            get providerIndexStart_() {
                return 1048575 & this.providerIndexes
            }
            get providerIndexEnd_() {
                return this.providerIndexStart_ + (this.providerIndexes >>> 20)
            }
        };

        function toDebugStyleBinding(tNode, isClassBased) {
            const tData = tNode.tView_.data,
                bindings = [],
                range = isClassBased ? tNode.classBindings : tNode.styleBindings,
                prev = getTStylingRangePrev(range),
                next = getTStylingRangeNext(range);
            let isTemplate = 0 !== next,
                cursor = isTemplate ? next : prev;
            for (; 0 !== cursor;) {
                const itemKey = tData[cursor],
                    itemRange = tData[cursor + 1];
                bindings.unshift({
                    key: itemKey,
                    index: cursor,
                    isTemplate: isTemplate,
                    prevDuplicate: getTStylingRangePrevDuplicate(itemRange),
                    nextDuplicate: getTStylingRangeNextDuplicate(itemRange),
                    nextIndex: getTStylingRangeNext(itemRange),
                    prevIndex: getTStylingRangePrev(itemRange)
                }), cursor === prev && (isTemplate = !1), cursor = getTStylingRangePrev(itemRange)
            }
            return bindings.push((isClassBased ? tNode.residualClasses : tNode.residualStyles) || null), bindings
        }

        function processTNodeChildren(tNode, buf) {
            for (; tNode;) buf.push(tNode.template_), tNode = tNode.next
        }
        const TViewData = NG_DEV_MODE && createNamedArrayType("TViewData") || null;
        let TVIEWDATA_EMPTY;
        const LViewBlueprint = NG_DEV_MODE && createNamedArrayType("LViewBlueprint") || null,
            TViewComponents = (NG_DEV_MODE && createNamedArrayType("MatchesArray"), NG_DEV_MODE && createNamedArrayType("TViewComponents") || null),
            LCleanup = (NG_DEV_MODE && createNamedArrayType("TNodeLocalNames"), NG_DEV_MODE && createNamedArrayType("TNodeInitialInputs"), NG_DEV_MODE && createNamedArrayType("TNodeInitialData"), NG_DEV_MODE && createNamedArrayType("LCleanup") || null),
            TCleanup = NG_DEV_MODE && createNamedArrayType("TCleanup") || null;

        function toDebug(obj) {
            if (obj) {
                const debug = obj.debug;
                return assertDefined(debug, "Object does not have a debug representation."), debug
            }
            return obj
        }

        function toHtml(value, includeChildren = !1) {
            const node = unwrapRNode(value);
            if (node) switch (node.nodeType) {
                case Node.TEXT_NODE:
                    return node.textContent;
                case Node.COMMENT_NODE:
                    return `\x3c!--${node.textContent}--\x3e`;
                case Node.ELEMENT_NODE:
                    const outerHTML = node.outerHTML;
                    if (includeChildren) return outerHTML; {
                        const innerHTML = ">" + node.innerHTML + "<";
                        return outerHTML.split(innerHTML)[0] + ">"
                    }
            }
            return null
        }
        class LViewDebug {
            constructor(_raw_lView) {
                this._raw_lView = _raw_lView
            }
            get flags() {
                const flags = this._raw_lView[2];
                return {
                    __raw__flags__: flags,
                    initPhaseState: 3 & flags,
                    creationMode: !!(4 & flags),
                    firstViewPass: !!(8 & flags),
                    checkAlways: !!(16 & flags),
                    dirty: !!(64 & flags),
                    attached: !!(128 & flags),
                    destroyed: !!(256 & flags),
                    isRoot: !!(512 & flags),
                    indexWithinInitPhase: flags >> 11
                }
            }
            get parent() {
                return toDebug(this._raw_lView[3])
            }
            get hostHTML() {
                return toHtml(this._raw_lView[0], !0)
            }
            get html() {
                return (this.nodes || []).map(mapToHTML).join("")
            }
            get context() {
                return this._raw_lView[8]
            }
            get nodes() {
                const lView = this._raw_lView;
                return toDebugNodes(lView[1].firstChild, lView)
            }
            get template() {
                return this.tView.template_
            }
            get tView() {
                return this._raw_lView[1]
            }
            get cleanup() {
                return this._raw_lView[7]
            }
            get injector() {
                return this._raw_lView[9]
            }
            get rendererFactory() {
                return this._raw_lView[10]
            }
            get renderer() {
                return this._raw_lView[11]
            }
            get sanitizer() {
                return this._raw_lView[12]
            }
            get childHead() {
                return toDebug(this._raw_lView[13])
            }
            get next() {
                return toDebug(this._raw_lView[4])
            }
            get childTail() {
                return toDebug(this._raw_lView[14])
            }
            get declarationView() {
                return toDebug(this._raw_lView[15])
            }
            get queries() {
                return this._raw_lView[19]
            }
            get tHost() {
                return this._raw_lView[6]
            }
            get decls() {
                return toLViewRange(this.tView, this._raw_lView, 20, this.tView.bindingStartIndex)
            }
            get vars() {
                return toLViewRange(this.tView, this._raw_lView, this.tView.bindingStartIndex, this.tView.expandoStartIndex)
            }
            get expando() {
                return toLViewRange(this.tView, this._raw_lView, this.tView.expandoStartIndex, this._raw_lView.length)
            }
            get childViews() {
                const childViews = [];
                let child = this.childHead;
                for (; child;) childViews.push(child), child = child.next;
                return childViews
            }
        }

        function mapToHTML(node) {
            if ("ElementContainer" === node.type) return (node.children || []).map(mapToHTML).join("");
            if ("IcuContainer" === node.type) throw new Error("Not implemented");
            return toHtml(node.native, !0) || ""
        }

        function toLViewRange(tView, lView, start, end) {
            let content = [];
            for (let index = start; index < end; index++) content.push({
                index: index,
                t: tView.data[index],
                l: lView[index]
            });
            return {
                start: start,
                end: end,
                length: end - start,
                content: content
            }
        }

        function toDebugNodes(tNode, lView) {
            if (tNode) {
                const debugNodes = [];
                let tNodeCursor = tNode;
                for (; tNodeCursor;) debugNodes.push(buildDebugNode(tNodeCursor, lView)), tNodeCursor = tNodeCursor.next;
                return debugNodes
            }
            return []
        }

        function buildDebugNode(tNode, lView) {
            const native = unwrapRNode(lView[tNode.index]),
                factories = [],
                instances = [],
                tView = lView[1];
            for (let i = tNode.directiveStart; i < tNode.directiveEnd; i++) {
                const def = tView.data[i];
                factories.push(def.type), instances.push(lView[i])
            }
            return {
                html: toHtml(native),
                type: toTNodeTypeAsString(tNode.type),
                native: native,
                children: toDebugNodes(tNode.child, lView),
                factories: factories,
                instances: instances,
                injector: buildNodeInjectorDebug(tNode, tView, lView)
            }
        }

        function buildNodeInjectorDebug(tNode, tView, lView) {
            const viewProviders = [];
            for (let i = tNode.providerIndexStart_; i < tNode.providerIndexEnd_; i++) viewProviders.push(tView.data[i]);
            const providers = [];
            for (let i = tNode.providerIndexEnd_; i < tNode.directiveEnd; i++) providers.push(tView.data[i]);
            return {
                bloom: toBloom(lView, tNode.injectorIndex),
                cumulativeBloom: toBloom(tView.data, tNode.injectorIndex),
                providers: providers,
                viewProviders: viewProviders,
                parentInjectorIndex: lView[tNode.providerIndexStart_ - 1]
            }
        }

        function binary(array, idx) {
            const value = array[idx];
            if ("number" != typeof value) return "????????";
            const text = "00000000" + value.toString(2);
            return text.substring(text.length - 8)
        }

        function toBloom(array, idx) {
            return `${binary(array,idx+7)}_${binary(array,idx+6)}_${binary(array,idx+5)}_${binary(array,idx+4)}_${binary(array,idx+3)}_${binary(array,idx+2)}_${binary(array,idx+1)}_${binary(array,idx+0)}`
        }
        const _CLEAN_PROMISE = Promise.resolve(null);

        function refreshContentQueries(tView, lView) {
            const contentQueries = tView.contentQueries;
            if (null !== contentQueries)
                for (let i = 0; i < contentQueries.length; i += 2) {
                    const queryStartIdx = contentQueries[i],
                        directiveDefIdx = contentQueries[i + 1];
                    if (-1 !== directiveDefIdx) {
                        const directiveDef = tView.data[directiveDefIdx];
                        ngDevMode && assertDefined(directiveDef, "DirectiveDef not found."), ngDevMode && assertDefined(directiveDef.contentQueries, "contentQueries function should be defined"), setCurrentQueryIndex(queryStartIdx), directiveDef.contentQueries(2, lView[directiveDefIdx], directiveDefIdx)
                    }
                }
        }

        function createLView(parentLView, tView, context, flags, host, tHostNode, rendererFactory, renderer, sanitizer, injector) {
            const lView = ngDevMode ? cloneToLViewFromTViewBlueprint(tView) : tView.blueprint.slice();
            return lView[0] = host, lView[2] = 140 | flags, resetPreOrderHookFlags(lView), ngDevMode && tView.declTNode && parentLView && assertTNodeForLView(tView.declTNode, parentLView), lView[3] = lView[15] = parentLView, lView[8] = context, lView[10] = rendererFactory || parentLView && parentLView[10], ngDevMode && assertDefined(lView[10], "RendererFactory is required"), lView[11] = renderer || parentLView && parentLView[11], ngDevMode && assertDefined(lView[11], "Renderer is required"), lView[12] = sanitizer || parentLView && parentLView[12] || null, lView[9] = injector || parentLView && parentLView[9] || null, lView[6] = tHostNode, ngDevMode && assertEqual(2 != tView.type || null !== parentLView, !0, "Embedded views must have parentLView"), lView[16] = 2 == tView.type ? parentLView[16] : lView, ngDevMode && function(lView) {
                attachDebugObject(lView, new LViewDebug(lView))
            }(lView), lView
        }

        function getOrCreateTNode(tView, index, type, name, attrs) {
            ngDevMode && 0 !== index && assertGreaterThanOrEqual(index, 20, "TNodes can't be in the LView header."), ngDevMode && function(type) {
                2 !== type && 1 !== type && 4 !== type && 8 !== type && 32 !== type && 16 !== type && 64 !== type && throwError(`Expected TNodeType to have only a single type selected, but got ${toTNodeTypeAsString(type)}.`)
            }(type);
            let tNode = tView.data[index];
            if (null === tNode) tNode = createTNodeAtIndex(tView, index, type, name, attrs), instructionState.lFrame.inI18n && (tNode.flags |= 64);
            else if (64 & tNode.type) {
                tNode.type = type, tNode.value = name, tNode.attrs = attrs;
                const parent = getCurrentParentTNode();
                tNode.injectorIndex = null === parent ? -1 : parent.injectorIndex, ngDevMode && assertTNodeForTView(tNode, tView), ngDevMode && assertEqual(index, tNode.index, "Expecting same index")
            }
            return setCurrentTNode(tNode, !0), tNode
        }

        function createTNodeAtIndex(tView, index, type, name, attrs) {
            const currentTNode = getCurrentTNodePlaceholderOk(),
                isParent = isCurrentTNodeParent(),
                parent = isParent ? currentTNode : currentTNode && currentTNode.parent,
                tNode = tView.data[index] = function(tView, tParent, type, index, value, attrs) {
                    ngDevMode && 0 !== index && assertGreaterThanOrEqual(index, 20, "TNodes can't be in the LView header."), ngDevMode && assertNotSame(attrs, void 0, "'undefined' is not valid value for 'attrs'"), ngDevMode && ngDevMode.tNode++, ngDevMode && tParent && assertTNodeForTView(tParent, tView);
                    let injectorIndex = tParent ? tParent.injectorIndex : -1;
                    const tNode = ngDevMode ? new TNodeDebug(tView, type, index, null, injectorIndex, -1, -1, -1, null, 0, 0, value, attrs, null, null, void 0, null, null, null, null, null, null, tParent, null, null, null, void 0, null, null, void 0, 0, 0) : {
                        type: type,
                        index: index,
                        insertBeforeIndex: null,
                        injectorIndex: injectorIndex,
                        directiveStart: -1,
                        directiveEnd: -1,
                        directiveStylingLast: -1,
                        propertyBindings: null,
                        flags: 0,
                        providerIndexes: 0,
                        value: value,
                        attrs: attrs,
                        mergedAttrs: null,
                        localNames: null,
                        initialInputs: void 0,
                        inputs: null,
                        outputs: null,
                        tViews: null,
                        next: null,
                        projectionNext: null,
                        child: null,
                        parent: tParent,
                        projection: null,
                        styles: null,
                        stylesWithoutHost: null,
                        residualStyles: void 0,
                        classes: null,
                        classesWithoutHost: null,
                        residualClasses: void 0,
                        classBindings: 0,
                        styleBindings: 0
                    };
                    ngDevMode && Object.seal(tNode);
                    return tNode
                }(tView, parent, type, index, name, attrs);
            return null === tView.firstChild && (tView.firstChild = tNode), null !== currentTNode && (isParent ? null == currentTNode.child && null !== tNode.parent && (currentTNode.child = tNode) : null === currentTNode.next && (currentTNode.next = tNode)), tNode
        }

        function allocExpando(tView, lView, numSlotsToAlloc, initialValue) {
            if (0 === numSlotsToAlloc) return -1;
            ngDevMode && (assertFirstCreatePass(tView), assertSame(tView, lView[1], "`LView` must be associated with `TView`!"), assertEqual(tView.data.length, lView.length, "Expecting LView to be same size as TView"), assertEqual(tView.data.length, tView.blueprint.length, "Expecting Blueprint to be same size as TView"), assertFirstUpdatePass(tView));
            const allocIdx = lView.length;
            for (let i = 0; i < numSlotsToAlloc; i++) lView.push(initialValue), tView.blueprint.push(initialValue), tView.data.push(null);
            return allocIdx
        }

        function renderView(tView, lView, context) {
            ngDevMode && assertEqual(isCreationMode(lView), !0, "Should be run in creation mode"), enterView(lView);
            try {
                const viewQuery = tView.viewQuery;
                null !== viewQuery && executeViewQueryFn(1, viewQuery, context);
                const templateFn = tView.template;
                null !== templateFn && executeTemplate(tView, lView, templateFn, 1, context), tView.firstCreatePass && (tView.firstCreatePass = !1), tView.staticContentQueries && refreshContentQueries(tView, lView), tView.staticViewQueries && executeViewQueryFn(2, tView.viewQuery, context);
                const components = tView.components;
                null !== components && function(hostLView, components) {
                    for (let i = 0; i < components.length; i++) renderComponent(hostLView, components[i])
                }(lView, components)
            } catch (error) {
                throw tView.firstCreatePass && (tView.incompleteFirstPass = !0), error
            } finally {
                lView[2] &= -5, leaveView()
            }
        }

        function refreshView(tView, lView, templateFn, context) {
            ngDevMode && assertEqual(isCreationMode(lView), !1, "Should be run in update mode");
            const flags = lView[2];
            if (256 == (256 & flags)) return;
            enterView(lView);
            const isInCheckNoChangesPass = isInCheckNoChangesMode();
            try {
                resetPreOrderHookFlags(lView), setBindingIndex(tView.bindingStartIndex), null !== templateFn && executeTemplate(tView, lView, templateFn, 2, context);
                const hooksInitPhaseCompleted = 3 == (3 & flags);
                if (!isInCheckNoChangesPass)
                    if (hooksInitPhaseCompleted) {
                        const preOrderCheckHooks = tView.preOrderCheckHooks;
                        null !== preOrderCheckHooks && executeCheckHooks(lView, preOrderCheckHooks, null)
                    } else {
                        const preOrderHooks = tView.preOrderHooks;
                        null !== preOrderHooks && executeInitAndCheckHooks(lView, preOrderHooks, 0, null), incrementInitPhaseFlags(lView, 0)
                    }
                if (function(lView) {
                        for (let lContainer = getFirstLContainer(lView); null !== lContainer; lContainer = getNextLContainer(lContainer)) {
                            if (!lContainer[2]) continue;
                            const movedViews = lContainer[9];
                            ngDevMode && assertDefined(movedViews, "Transplanted View flags set but missing MOVED_VIEWS");
                            for (let i = 0; i < movedViews.length; i++) {
                                const movedLView = movedViews[i],
                                    insertionLContainer = movedLView[3];
                                ngDevMode && assertLContainer(insertionLContainer), 0 == (1024 & movedLView[2]) && updateTransplantedViewCount(insertionLContainer, 1), movedLView[2] |= 1024
                            }
                        }
                    }(lView), function(lView) {
                        for (let lContainer = getFirstLContainer(lView); null !== lContainer; lContainer = getNextLContainer(lContainer))
                            for (let i = 10; i < lContainer.length; i++) {
                                const embeddedLView = lContainer[i],
                                    embeddedTView = embeddedLView[1];
                                ngDevMode && assertDefined(embeddedTView, "TView must be allocated"), viewAttachedToChangeDetector(embeddedLView) && refreshView(embeddedTView, embeddedLView, embeddedTView.template, embeddedLView[8])
                            }
                    }(lView), null !== tView.contentQueries && refreshContentQueries(tView, lView), !isInCheckNoChangesPass)
                    if (hooksInitPhaseCompleted) {
                        const contentCheckHooks = tView.contentCheckHooks;
                        null !== contentCheckHooks && executeCheckHooks(lView, contentCheckHooks)
                    } else {
                        const contentHooks = tView.contentHooks;
                        null !== contentHooks && executeInitAndCheckHooks(lView, contentHooks, 1), incrementInitPhaseFlags(lView, 1)
                    }! function(tView, lView) {
                    const hostBindingOpCodes = tView.hostBindingOpCodes;
                    if (null !== hostBindingOpCodes) try {
                        for (let i = 0; i < hostBindingOpCodes.length; i++) {
                            const opCode = hostBindingOpCodes[i];
                            if (opCode < 0) setSelectedIndex(~opCode);
                            else {
                                const directiveIdx = opCode,
                                    bindingRootIndx = hostBindingOpCodes[++i],
                                    hostBindingFn = hostBindingOpCodes[++i];
                                setBindingRootForHostBindings(bindingRootIndx, directiveIdx), hostBindingFn(2, lView[directiveIdx])
                            }
                        }
                    } finally {
                        setSelectedIndex(-1)
                    }
                }(tView, lView);
                const components = tView.components;
                null !== components && function(hostLView, components) {
                    for (let i = 0; i < components.length; i++) refreshComponent(hostLView, components[i])
                }(lView, components);
                const viewQuery = tView.viewQuery;
                if (null !== viewQuery && executeViewQueryFn(2, viewQuery, context), !isInCheckNoChangesPass)
                    if (hooksInitPhaseCompleted) {
                        const viewCheckHooks = tView.viewCheckHooks;
                        null !== viewCheckHooks && executeCheckHooks(lView, viewCheckHooks)
                    } else {
                        const viewHooks = tView.viewHooks;
                        null !== viewHooks && executeInitAndCheckHooks(lView, viewHooks, 2), incrementInitPhaseFlags(lView, 2)
                    }!0 === tView.firstUpdatePass && (tView.firstUpdatePass = !1), isInCheckNoChangesPass || (lView[2] &= -73), 1024 & lView[2] && (lView[2] &= -1025, updateTransplantedViewCount(lView[3], -1))
            } finally {
                leaveView()
            }
        }

        function renderComponentOrTemplate(tView, lView, templateFn, context) {
            const rendererFactory = lView[10],
                normalExecutionPath = !isInCheckNoChangesMode(),
                creationModeIsActive = isCreationMode(lView);
            try {
                normalExecutionPath && !creationModeIsActive && rendererFactory.begin && rendererFactory.begin(), creationModeIsActive && renderView(tView, lView, context), refreshView(tView, lView, templateFn, context)
            } finally {
                normalExecutionPath && !creationModeIsActive && rendererFactory.end && rendererFactory.end()
            }
        }

        function executeTemplate(tView, lView, templateFn, rf, context) {
            const prevSelectedIndex = getSelectedIndex();
            try {
                setSelectedIndex(-1), 2 & rf && lView.length > 20 && selectIndexInternal(tView, lView, 20, isInCheckNoChangesMode()), templateFn(rf, context)
            } finally {
                setSelectedIndex(prevSelectedIndex)
            }
        }

        function getOrCreateTComponentView(def) {
            const tView = def.tView;
            if (null === tView || tView.incompleteFirstPass) {
                const declTNode = null;
                return def.tView = createTView(1, declTNode, def.template, def.decls, def.vars, def.directiveDefs, def.pipeDefs, def.viewQuery, def.schemas, def.consts)
            }
            return tView
        }

        function createTView(type, declTNode, templateFn, decls, vars, directives, pipes, viewQuery, schemas, constsOrFactory) {
            ngDevMode && ngDevMode.tView++;
            const bindingStartIndex = 20 + decls,
                initialViewLength = bindingStartIndex + vars,
                blueprint = function(bindingStartIndex, initialViewLength) {
                    const blueprint = ngDevMode ? new LViewBlueprint : [];
                    for (let i = 0; i < initialViewLength; i++) blueprint.push(i < bindingStartIndex ? null : NO_CHANGE);
                    return blueprint
                }(bindingStartIndex, initialViewLength),
                consts = "function" == typeof constsOrFactory ? constsOrFactory() : constsOrFactory,
                tView = blueprint[1] = ngDevMode ? new class {
                    constructor(type, blueprint, template, queries, viewQuery, declTNode, data, bindingStartIndex, expandoStartIndex, hostBindingOpCodes, firstCreatePass, firstUpdatePass, staticViewQueries, staticContentQueries, preOrderHooks, preOrderCheckHooks, contentHooks, contentCheckHooks, viewHooks, viewCheckHooks, destroyHooks, cleanup, contentQueries, components, directiveRegistry, pipeRegistry, firstChild, schemas, consts, incompleteFirstPass, _decls, _vars) {
                        this.type = type, this.blueprint = blueprint, this.template = template, this.queries = queries, this.viewQuery = viewQuery, this.declTNode = declTNode, this.data = data, this.bindingStartIndex = bindingStartIndex, this.expandoStartIndex = expandoStartIndex, this.hostBindingOpCodes = hostBindingOpCodes, this.firstCreatePass = firstCreatePass, this.firstUpdatePass = firstUpdatePass, this.staticViewQueries = staticViewQueries, this.staticContentQueries = staticContentQueries, this.preOrderHooks = preOrderHooks, this.preOrderCheckHooks = preOrderCheckHooks, this.contentHooks = contentHooks, this.contentCheckHooks = contentCheckHooks, this.viewHooks = viewHooks, this.viewCheckHooks = viewCheckHooks, this.destroyHooks = destroyHooks, this.cleanup = cleanup, this.contentQueries = contentQueries, this.components = components, this.directiveRegistry = directiveRegistry, this.pipeRegistry = pipeRegistry, this.firstChild = firstChild, this.schemas = schemas, this.consts = consts, this.incompleteFirstPass = incompleteFirstPass, this._decls = _decls, this._vars = _vars
                    }
                    get template_() {
                        const buf = [];
                        return processTNodeChildren(this.firstChild, buf), buf.join("")
                    }
                    get type_() {
                        return TViewTypeAsString[this.type] || `TViewType.?${this.type}?`
                    }
                }(type, blueprint, templateFn, null, viewQuery, declTNode, (list = blueprint, void 0 === TVIEWDATA_EMPTY && (TVIEWDATA_EMPTY = new TViewData), TVIEWDATA_EMPTY.concat(list)).fill(null, bindingStartIndex), bindingStartIndex, initialViewLength, null, !0, !0, !1, !1, null, null, null, null, null, null, null, null, null, null, "function" == typeof directives ? directives() : directives, "function" == typeof pipes ? pipes() : pipes, null, schemas, consts, !1, decls, vars) : {
                    type: type,
                    blueprint: blueprint,
                    template: templateFn,
                    queries: null,
                    viewQuery: viewQuery,
                    declTNode: declTNode,
                    data: blueprint.slice().fill(null, bindingStartIndex),
                    bindingStartIndex: bindingStartIndex,
                    expandoStartIndex: initialViewLength,
                    hostBindingOpCodes: null,
                    firstCreatePass: !0,
                    firstUpdatePass: !0,
                    staticViewQueries: !1,
                    staticContentQueries: !1,
                    preOrderHooks: null,
                    preOrderCheckHooks: null,
                    contentHooks: null,
                    contentCheckHooks: null,
                    viewHooks: null,
                    viewCheckHooks: null,
                    destroyHooks: null,
                    cleanup: null,
                    contentQueries: null,
                    components: null,
                    directiveRegistry: "function" == typeof directives ? directives() : directives,
                    pipeRegistry: "function" == typeof pipes ? pipes() : pipes,
                    firstChild: null,
                    schemas: schemas,
                    consts: consts,
                    incompleteFirstPass: !1
                };
            var list;
            return ngDevMode && Object.seal(tView), tView
        }

        function createError(text, token) {
            return new Error(`Renderer: ${text} [${stringifyForError(token)}]`)
        }

        function locateHostElement(renderer, elementOrSelector, encapsulation) {
            if (isProceduralRenderer(renderer)) {
                const preserveContent = encapsulation === ViewEncapsulation.ShadowDom;
                return renderer.selectRootElement(elementOrSelector, preserveContent)
            }
            let rElement = "string" == typeof elementOrSelector ? renderer.querySelector(elementOrSelector) : elementOrSelector;
            return ngDevMode && function(rElement, elementOrSelector) {
                if (!rElement) throw createError("string" == typeof elementOrSelector ? "Host node with selector not found:" : "Host node is required:", elementOrSelector)
            }(rElement, elementOrSelector), rElement.textContent = "", rElement
        }

        function storeCleanupWithContext(tView, lView, context, cleanupFn) {
            const lCleanup = getLCleanup(lView);
            null === context ? (ngDevMode && Object.freeze(getTViewCleanup(tView)), lCleanup.push(cleanupFn)) : (lCleanup.push(context), tView.firstCreatePass && getTViewCleanup(tView).push(cleanupFn, lCleanup.length - 1))
        }

        function registerHostBindingOpCodes(tView, tNode, lView, directiveIdx, directiveVarsIdx, def) {
            ngDevMode && assertFirstCreatePass(tView);
            const hostBindings = def.hostBindings;
            if (hostBindings) {
                let hostBindingOpCodes = tView.hostBindingOpCodes;
                null === hostBindingOpCodes && (hostBindingOpCodes = tView.hostBindingOpCodes = []);
                const elementIndx = ~tNode.index;
                (function(hostBindingOpCodes) {
                    let i = hostBindingOpCodes.length;
                    for (; i > 0;) {
                        const value = hostBindingOpCodes[--i];
                        if ("number" == typeof value && value < 0) return value
                    }
                    return 0
                })(hostBindingOpCodes) != elementIndx && hostBindingOpCodes.push(elementIndx), hostBindingOpCodes.push(directiveIdx, directiveVarsIdx, hostBindings)
            }
        }

        function invokeHostBindingsInCreationMode(def, directive) {
            null !== def.hostBindings && def.hostBindings(1, directive)
        }

        function markAsComponentHost(tView, hostTNode) {
            ngDevMode && assertFirstCreatePass(tView), hostTNode.flags |= 2, (tView.components || (tView.components = ngDevMode ? new TViewComponents : [])).push(hostTNode.index)
        }

        function initTNodeFlags(tNode, index, numberOfDirectives) {
            ngDevMode && assertNotEqual(numberOfDirectives, tNode.directiveEnd - tNode.directiveStart, "Reached the max number of directives"), tNode.flags |= 1, tNode.directiveStart = index, tNode.directiveEnd = index + numberOfDirectives, tNode.providerIndexes = index
        }

        function configureViewWithDirective(tView, tNode, lView, directiveIndex, def) {
            ngDevMode && assertGreaterThanOrEqual(directiveIndex, 20, "Must be in Expando section"), tView.data[directiveIndex] = def;
            const directiveFactory = def.factory || (def.factory = getFactoryDef(def.type, !0)),
                nodeInjectorFactory = new NodeInjectorFactory(directiveFactory, isComponentDef(def), null);
            tView.blueprint[directiveIndex] = nodeInjectorFactory, lView[directiveIndex] = nodeInjectorFactory, registerHostBindingOpCodes(tView, tNode, 0, directiveIndex, allocExpando(tView, lView, def.hostVars, NO_CHANGE), def)
        }("undefined" == typeof ngDevMode || ngDevMode) && initNgDevMode() && createNamedArrayType("LContainer");

        function refreshComponent(hostLView, componentHostIdx) {
            ngDevMode && assertEqual(isCreationMode(hostLView), !1, "Should be run in update mode");
            const componentView = getComponentLViewByIndex(componentHostIdx, hostLView);
            if (viewAttachedToChangeDetector(componentView)) {
                const tView = componentView[1];
                80 & componentView[2] ? refreshView(tView, componentView, tView.template, componentView[8]) : componentView[5] > 0 && refreshContainsDirtyView(componentView)
            }
        }

        function refreshContainsDirtyView(lView) {
            for (let lContainer = getFirstLContainer(lView); null !== lContainer; lContainer = getNextLContainer(lContainer))
                for (let i = 10; i < lContainer.length; i++) {
                    const embeddedLView = lContainer[i];
                    if (1024 & embeddedLView[2]) {
                        const embeddedTView = embeddedLView[1];
                        ngDevMode && assertDefined(embeddedTView, "TView must be allocated"), refreshView(embeddedTView, embeddedLView, embeddedTView.template, embeddedLView[8])
                    } else embeddedLView[5] > 0 && refreshContainsDirtyView(embeddedLView)
                }
            const components = lView[1].components;
            if (null !== components)
                for (let i = 0; i < components.length; i++) {
                    const componentView = getComponentLViewByIndex(components[i], lView);
                    viewAttachedToChangeDetector(componentView) && componentView[5] > 0 && refreshContainsDirtyView(componentView)
                }
        }

        function renderComponent(hostLView, componentHostIdx) {
            ngDevMode && assertEqual(isCreationMode(hostLView), !0, "Should be run in creation mode");
            const componentView = getComponentLViewByIndex(componentHostIdx, hostLView),
                componentTView = componentView[1];
            ! function(tView, lView) {
                for (let i = lView.length; i < tView.blueprint.length; i++) lView.push(tView.blueprint[i])
            }(componentTView, componentView), renderView(componentTView, componentView, componentView[8])
        }

        function addToViewTree(lView, lViewOrLContainer) {
            return lView[13] ? lView[14][4] = lViewOrLContainer : lView[13] = lViewOrLContainer, lView[14] = lViewOrLContainer, lViewOrLContainer
        }

        function markViewDirty(lView) {
            for (; lView;) {
                lView[2] |= 64;
                const parent = getLViewParent(lView);
                if (0 != (512 & lView[2]) && !parent) return lView;
                lView = parent
            }
            return null
        }

        function tickRootContext(rootContext) {
            for (let i = 0; i < rootContext.components.length; i++) {
                const rootComponent = rootContext.components[i],
                    lView = readPatchedLView(rootComponent),
                    tView = lView[1];
                renderComponentOrTemplate(tView, lView, tView.template, rootComponent)
            }
        }

        function detectChangesInternal(tView, lView, context) {
            const rendererFactory = lView[10];
            rendererFactory.begin && rendererFactory.begin();
            try {
                refreshView(tView, lView, tView.template, context)
            } catch (error) {
                throw handleError(lView, error), error
            } finally {
                rendererFactory.end && rendererFactory.end()
            }
        }

        function detectChangesInRootView(lView) {
            tickRootContext(lView[8])
        }

        function executeViewQueryFn(flags, viewQueryFn, component) {
            ngDevMode && assertDefined(viewQueryFn, "View queries function to execute must be defined."), setCurrentQueryIndex(0), viewQueryFn(flags, component)
        }
        const CLEAN_PROMISE = _CLEAN_PROMISE;

        function getLCleanup(view) {
            return view[7] || (view[7] = ngDevMode ? new LCleanup : [])
        }

        function getTViewCleanup(tView) {
            return tView.cleanup || (tView.cleanup = ngDevMode ? new TCleanup : [])
        }

        function handleError(lView, error) {
            const injector = lView[9],
                errorHandler = injector ? injector.get(ErrorHandler, null) : null;
            errorHandler && errorHandler.handleError(error)
        }

        function computeStaticStyling(tNode, attrs, writeToHost) {
            ngDevMode && assertFirstCreatePass(getTView(), "Expecting to be called in first template pass only");
            let styles = writeToHost ? tNode.styles : null,
                classes = writeToHost ? tNode.classes : null,
                mode = 0;
            if (null !== attrs)
                for (let i = 0; i < attrs.length; i++) {
                    const value = attrs[i];
                    if ("number" == typeof value) mode = value;
                    else if (1 == mode) classes = concatStringsWithSpace(classes, value);
                    else if (2 == mode) {
                        styles = concatStringsWithSpace(styles, value + ": " + attrs[++i] + ";")
                    }
                }
            writeToHost ? tNode.styles = styles : tNode.stylesWithoutHost = styles, writeToHost ? tNode.classes = classes : tNode.classesWithoutHost = classes
        }
        const INJECTOR$1 = new InjectionToken("INJECTOR", -1);
        class NullInjector {
            get(token, notFoundValue = THROW_IF_NOT_FOUND) {
                if (notFoundValue === THROW_IF_NOT_FOUND) {
                    const error = new Error(`NullInjectorError: No provider for ${stringify(token)}!`);
                    throw error.name = "NullInjectorError", error
                }
                return notFoundValue
            }
        }
        const INJECTOR_SCOPE = new InjectionToken("Set Injector scope.");
        const INJECTOR_IMPL = function(providers, parent, name) {
            return new StaticInjector(providers, parent, name)
        };
        class Injector {
            static create(options, parent) {
                return Array.isArray(options) ? INJECTOR_IMPL(options, parent, "") : INJECTOR_IMPL(options.providers, options.parent, options.name || "")
            }
        }
        Injector.THROW_IF_NOT_FOUND = THROW_IF_NOT_FOUND, Injector.NULL = new NullInjector, Injector.ɵprov = ɵɵdefineInjectable({
            token: Injector,
            providedIn: "any",
            factory: () => ɵɵinject(INJECTOR$1)
        }), Injector.__NG_ELEMENT_ID__ = -1;
        const IDENT = function(value) {
                return value
            },
            EMPTY = [],
            CIRCULAR$1 = IDENT,
            MULTI_PROVIDER_FN = function() {
                return Array.prototype.slice.call(arguments)
            };
        class StaticInjector {
            constructor(providers, parent = Injector.NULL, source = null) {
                this.parent = parent, this.source = source;
                const records = this._records = new Map;
                records.set(Injector, {
                    token: Injector,
                    fn: IDENT,
                    deps: EMPTY,
                    value: this,
                    useNew: !1
                }), records.set(INJECTOR$1, {
                    token: INJECTOR$1,
                    fn: IDENT,
                    deps: EMPTY,
                    value: this,
                    useNew: !1
                }), this.scope = recursivelyProcessProviders(records, providers)
            }
            get(token, notFoundValue, flags = InjectFlags.Default) {
                const records = this._records;
                let record = records.get(token);
                if (void 0 === record) {
                    const injectableDef = getInjectableDef(token);
                    if (injectableDef) {
                        const providedIn = injectableDef && injectableDef.providedIn;
                        ("any" === providedIn || null != providedIn && providedIn === this.scope) && records.set(token, record = resolveProvider({
                            provide: token,
                            useFactory: injectableDef.factory,
                            deps: EMPTY
                        }))
                    }
                    void 0 === record && records.set(token, null)
                }
                let lastInjector = setCurrentInjector(this);
                try {
                    return tryResolveToken(token, record, records, this.parent, notFoundValue, flags)
                } catch (e) {
                    return catchInjectorError(e, token, "StaticInjectorError", this.source)
                } finally {
                    setCurrentInjector(lastInjector)
                }
            }
            toString() {
                const tokens = [];
                return this._records.forEach(((v, token) => tokens.push(stringify(token)))), `StaticInjector[${tokens.join(", ")}]`
            }
        }

        function resolveProvider(provider) {
            const deps = function(provider) {
                let deps = EMPTY;
                const providerDeps = provider.deps;
                if (providerDeps && providerDeps.length) {
                    deps = [];
                    for (let i = 0; i < providerDeps.length; i++) {
                        let options = 6,
                            token = resolveForwardRef(providerDeps[i]);
                        if (Array.isArray(token))
                            for (let j = 0, annotations = token; j < annotations.length; j++) {
                                const annotation = annotations[j];
                                annotation instanceof Optional || annotation == Optional ? options |= 1 : annotation instanceof SkipSelf || annotation == SkipSelf ? options &= -3 : annotation instanceof Self || annotation == Self ? options &= -5 : token = annotation instanceof Inject ? annotation.token : resolveForwardRef(annotation)
                            }
                        deps.push({
                            token: token,
                            options: options
                        })
                    }
                } else if (provider.useExisting) {
                    deps = [{
                        token: resolveForwardRef(provider.useExisting),
                        options: 6
                    }]
                } else if (!providerDeps && !(USE_VALUE in provider)) throw staticError("'deps' required", provider);
                return deps
            }(provider);
            let fn = IDENT,
                value = EMPTY,
                useNew = !1,
                provide = resolveForwardRef(provider.provide);
            if (USE_VALUE in provider) value = provider.useValue;
            else if (provider.useFactory) fn = provider.useFactory;
            else if (provider.useExisting);
            else if (provider.useClass) useNew = !0, fn = resolveForwardRef(provider.useClass);
            else {
                if ("function" != typeof provide) throw staticError("StaticProvider does not have [useValue|useFactory|useExisting|useClass] or [provide] is not newable", provider);
                useNew = !0, fn = provide
            }
            return {
                deps: deps,
                fn: fn,
                useNew: useNew,
                value: value
            }
        }

        function multiProviderMixError(token) {
            return staticError("Cannot mix multi providers and regular providers", token)
        }

        function recursivelyProcessProviders(records, provider) {
            let scope = null;
            if (provider)
                if (provider = resolveForwardRef(provider), Array.isArray(provider))
                    for (let i = 0; i < provider.length; i++) scope = recursivelyProcessProviders(records, provider[i]) || scope;
                else {
                    if ("function" == typeof provider) throw staticError("Function/Class not supported", provider);
                    if (!provider || "object" != typeof provider || !provider.provide) throw staticError("Unexpected provider", provider); {
                        let token = resolveForwardRef(provider.provide);
                        const resolvedProvider = resolveProvider(provider);
                        if (!0 === provider.multi) {
                            let multiProvider = records.get(token);
                            if (multiProvider) {
                                if (multiProvider.fn !== MULTI_PROVIDER_FN) throw multiProviderMixError(token)
                            } else records.set(token, multiProvider = {
                                token: provider.provide,
                                deps: [],
                                useNew: !1,
                                fn: MULTI_PROVIDER_FN,
                                value: EMPTY
                            });
                            token = provider, multiProvider.deps.push({
                                token: token,
                                options: 6
                            })
                        }
                        const record = records.get(token);
                        if (record && record.fn == MULTI_PROVIDER_FN) throw multiProviderMixError(token);
                        token === INJECTOR_SCOPE && (scope = resolvedProvider.value), records.set(token, resolvedProvider)
                    }
                }
            return scope
        }

        function tryResolveToken(token, record, records, parent, notFoundValue, flags) {
            try {
                return function(token, record, records, parent, notFoundValue, flags) {
                    let value;
                    if (!record || flags & InjectFlags.SkipSelf) value = flags & InjectFlags.Self ? flags & InjectFlags.Optional ? Injector.NULL.get(token, void 0 !== notFoundValue ? notFoundValue : null) : Injector.NULL.get(token, notFoundValue) : parent.get(token, notFoundValue, InjectFlags.Default);
                    else {
                        if (value = record.value, value == CIRCULAR$1) throw Error("ɵCircular dependency");
                        if (value === EMPTY) {
                            let obj;
                            record.value = CIRCULAR$1;
                            let useNew = record.useNew,
                                fn = record.fn,
                                depRecords = record.deps,
                                deps = EMPTY;
                            if (depRecords.length) {
                                deps = [];
                                for (let i = 0; i < depRecords.length; i++) {
                                    const depRecord = depRecords[i],
                                        options = depRecord.options,
                                        childRecord = 2 & options ? records.get(depRecord.token) : void 0;
                                    deps.push(tryResolveToken(depRecord.token, childRecord, records, childRecord || 4 & options ? parent : Injector.NULL, 1 & options ? null : Injector.THROW_IF_NOT_FOUND, InjectFlags.Default))
                                }
                            }
                            record.value = value = useNew ? new fn(...deps) : fn.apply(obj, deps)
                        }
                    }
                    return value
                }(token, record, records, parent, notFoundValue, flags)
            } catch (e) {
                e instanceof Error || (e = new Error(e));
                throw (e.ngTempTokenPath = e.ngTempTokenPath || []).unshift(token), record && record.value == CIRCULAR$1 && (record.value = EMPTY), e
            }
        }

        function staticError(text, obj) {
            return new Error(formatError(text, obj, "StaticInjectorError"))
        }

        function createRootComponentView(rNode, def, rootView, rendererFactory, hostRenderer, sanitizer) {
            const tView = rootView[1];
            ngDevMode && assertIndexInRange(rootView, 20), rootView[20] = rNode;
            const tNode = getOrCreateTNode(tView, 20, 2, "#host", null),
                mergedAttrs = tNode.mergedAttrs = def.hostAttrs;
            null !== mergedAttrs && (computeStaticStyling(tNode, mergedAttrs, !0), null !== rNode && (setUpAttributes(hostRenderer, rNode, mergedAttrs), null !== tNode.classes && writeDirectClass(hostRenderer, rNode, tNode.classes), null !== tNode.styles && writeDirectStyle(hostRenderer, rNode, tNode.styles)));
            const viewRenderer = rendererFactory.createRenderer(rNode, def),
                componentView = createLView(rootView, getOrCreateTComponentView(def), null, def.onPush ? 64 : 16, rootView[20], tNode, rendererFactory, viewRenderer, sanitizer || null, null);
            return tView.firstCreatePass && (diPublicInInjector(getOrCreateNodeInjectorForNode(tNode, rootView), tView, def.type), markAsComponentHost(tView, tNode), initTNodeFlags(tNode, rootView.length, 1)), addToViewTree(rootView, componentView), rootView[20] = componentView
        }

        function createRootComponent(componentView, componentDef, rootLView, rootContext, hostFeatures) {
            const tView = rootLView[1],
                component = function(tView, lView, def) {
                    const rootTNode = getCurrentTNode();
                    if (tView.firstCreatePass) {
                        def.providersResolver && def.providersResolver(def);
                        const directiveIndex = allocExpando(tView, lView, 1, null);
                        ngDevMode && assertEqual(directiveIndex, rootTNode.directiveStart, "Because this is a root component the allocated expando should match the TNode component."), configureViewWithDirective(tView, rootTNode, lView, directiveIndex, def)
                    }
                    const directive = getNodeInjectable(lView, tView, rootTNode.directiveStart, rootTNode);
                    attachPatchData(directive, lView);
                    const native = getNativeByTNode(rootTNode, lView);
                    return native && attachPatchData(native, lView), directive
                }(tView, rootLView, componentDef);
            if (rootContext.components.push(component), componentView[8] = component, hostFeatures && hostFeatures.forEach((feature => feature(component, componentDef))), componentDef.contentQueries) {
                const tNode = getCurrentTNode();
                ngDevMode && assertDefined(tNode, "TNode expected"), componentDef.contentQueries(1, component, tNode.directiveStart)
            }
            const rootTNode = getCurrentTNode();
            if (ngDevMode && assertDefined(rootTNode, "tNode should have been already created"), tView.firstCreatePass && (null !== componentDef.hostBindings || null !== componentDef.hostAttrs)) {
                setSelectedIndex(rootTNode.index);
                registerHostBindingOpCodes(rootLView[1], rootTNode, 0, rootTNode.directiveStart, rootTNode.directiveEnd, componentDef), invokeHostBindingsInCreationMode(componentDef, component)
            }
            return component
        }

        function createRootContext(scheduler, playerHandler) {
            return {
                components: [],
                scheduler: scheduler || defaultScheduler,
                clean: CLEAN_PROMISE,
                playerHandler: playerHandler || null,
                flags: 0
            }
        }

        function LifecycleHooksFeature(component, def) {
            const lView = readPatchedLView(component);
            ngDevMode && assertDefined(lView, "LView is required");
            const tView = lView[1],
                tNode = getCurrentTNode();
            ngDevMode && assertDefined(tNode, "TNode is required"), registerPostOrderHooks(tView, tNode)
        }
        let _symbolIterator = null;

        function getSymbolIterator() {
            if (!_symbolIterator) {
                const Symbol = _global.Symbol;
                if (Symbol && Symbol.iterator) _symbolIterator = Symbol.iterator;
                else {
                    const keys = Object.getOwnPropertyNames(Map.prototype);
                    for (let i = 0; i < keys.length; ++i) {
                        const key = keys[i];
                        "entries" !== key && "size" !== key && Map.prototype[key] === Map.prototype.entries && (_symbolIterator = key)
                    }
                }
            }
            return _symbolIterator
        }

        function isListLikeIterable(obj) {
            return !!isJsObject(obj) && (Array.isArray(obj) || !(obj instanceof Map) && getSymbolIterator() in obj)
        }

        function isJsObject(o) {
            return null !== o && ("function" == typeof o || "object" == typeof o)
        }
        getClosureSafeProperty({
            provide: String,
            useValue: getClosureSafeProperty
        });
        const USE_VALUE$2 = getClosureSafeProperty({
                provide: String,
                useValue: getClosureSafeProperty
            }),
            EMPTY_ARRAY$2 = [];

        function convertInjectableProviderToFactory(type, provider) {
            if (!provider) {
                const deps = (new ReflectionCapabilities).parameters(type);
                return () => new type(...injectArgs(deps))
            }
            if (USE_VALUE$2 in provider) {
                const valueProvider = provider;
                return () => valueProvider.useValue
            }
            if (provider.useExisting) {
                const existingProvider = provider;
                return () => ɵɵinject(resolveForwardRef(existingProvider.useExisting))
            }
            if (provider.useFactory) {
                const factoryProvider = provider;
                return () => factoryProvider.useFactory(...injectArgs(factoryProvider.deps || EMPTY_ARRAY$2))
            }
            if (provider.useClass) {
                const classProvider = provider;
                let deps = provider.deps;
                if (!deps) {
                    const reflectionCapabilities = new ReflectionCapabilities;
                    deps = reflectionCapabilities.parameters(type)
                }
                return () => new(resolveForwardRef(classProvider.useClass))(...injectArgs(deps))
            } {
                let deps = provider.deps;
                if (!deps) {
                    const reflectionCapabilities = new ReflectionCapabilities;
                    deps = reflectionCapabilities.parameters(type)
                }
                return () => new type(...injectArgs(deps))
            }
        }
        const Injectable = makeDecorator("Injectable", void 0, void 0, void 0, ((type, meta) => SWITCH_COMPILE_INJECTABLE(type, meta)));
        const SWITCH_COMPILE_INJECTABLE = function(injectableType, options) {
            options && void 0 !== options.providedIn && !getInjectableDef(injectableType) && (injectableType.ɵprov = ɵɵdefineInjectable({
                token: injectableType,
                providedIn: options.providedIn,
                factory: convertInjectableProviderToFactory(injectableType, options)
            }))
        };

        function constructResolvingPath(keys) {
            if (keys.length > 1) {
                return " (" + function(keys) {
                    const res = [];
                    for (let i = 0; i < keys.length; ++i) {
                        if (res.indexOf(keys[i]) > -1) return res.push(keys[i]), res;
                        res.push(keys[i])
                    }
                    return res
                }(keys.slice().reverse()).map((k => stringify(k.token))).join(" -> ") + ")"
            }
            return ""
        }

        function injectionError(injector, key, constructResolvingMessage, originalError) {
            const keys = [key],
                errMsg = constructResolvingMessage(keys),
                error = originalError ? function(message, originalError) {
                    const msg = `${message} caused by: ${originalError instanceof Error?originalError.message:originalError}`,
                        error = Error(msg);
                    return error.ngOriginalError = originalError, error
                }(errMsg, originalError) : Error(errMsg);
            return error.addKey = addKey, error.keys = keys, error.injectors = [injector], error.constructResolvingMessage = constructResolvingMessage, error.ngOriginalError = originalError, error
        }

        function addKey(injector, key) {
            this.injectors.push(injector), this.keys.push(key), this.message = this.constructResolvingMessage(this.keys)
        }

        function noAnnotationError(typeOrFunc, params) {
            const signature = [];
            for (let i = 0, ii = params.length; i < ii; i++) {
                const parameter = params[i];
                parameter && 0 != parameter.length ? signature.push(parameter.map(stringify).join(" ")) : signature.push("?")
            }
            return Error("Cannot resolve all parameters for '" + stringify(typeOrFunc) + "'(" + signature.join(", ") + "). Make sure that all the parameters are decorated with Inject or have valid type annotations and that '" + stringify(typeOrFunc) + "' is decorated with Injectable.")
        }

        function mixingMultiProvidersWithRegularProvidersError(provider1, provider2) {
            return Error(`Cannot mix multi providers and regular providers, got: ${provider1} ${provider2}`)
        }
        class ReflectiveKey {
            constructor(token, id) {
                if (this.token = token, this.id = id, !token) throw new Error("Token must be defined!");
                this.displayName = stringify(this.token)
            }
            static get(token) {
                return _globalKeyRegistry.get(resolveForwardRef(token))
            }
            static get numberOfKeys() {
                return _globalKeyRegistry.numberOfKeys
            }
        }
        const _globalKeyRegistry = new class {
            constructor() {
                this._allKeys = new Map
            }
            get(token) {
                if (token instanceof ReflectiveKey) return token;
                if (this._allKeys.has(token)) return this._allKeys.get(token);
                const newKey = new ReflectiveKey(token, ReflectiveKey.numberOfKeys);
                return this._allKeys.set(token, newKey), newKey
            }
            get numberOfKeys() {
                return this._allKeys.size
            }
        };
        const reflector = new class {
            constructor(reflectionCapabilities) {
                this.reflectionCapabilities = reflectionCapabilities
            }
            updateCapabilities(caps) {
                this.reflectionCapabilities = caps
            }
            factory(type) {
                return this.reflectionCapabilities.factory(type)
            }
            parameters(typeOrFunc) {
                return this.reflectionCapabilities.parameters(typeOrFunc)
            }
            annotations(typeOrFunc) {
                return this.reflectionCapabilities.annotations(typeOrFunc)
            }
            propMetadata(typeOrFunc) {
                return this.reflectionCapabilities.propMetadata(typeOrFunc)
            }
            hasLifecycleHook(type, lcProperty) {
                return this.reflectionCapabilities.hasLifecycleHook(type, lcProperty)
            }
            getter(name) {
                return this.reflectionCapabilities.getter(name)
            }
            setter(name) {
                return this.reflectionCapabilities.setter(name)
            }
            method(name) {
                return this.reflectionCapabilities.method(name)
            }
            importUri(type) {
                return this.reflectionCapabilities.importUri(type)
            }
            resourceUri(type) {
                return this.reflectionCapabilities.resourceUri(type)
            }
            resolveIdentifier(name, moduleUrl, members, runtime) {
                return this.reflectionCapabilities.resolveIdentifier(name, moduleUrl, members, runtime)
            }
            resolveEnum(identifier, name) {
                return this.reflectionCapabilities.resolveEnum(identifier, name)
            }
        }(new ReflectionCapabilities);
        class ReflectiveDependency {
            constructor(key, optional, visibility) {
                this.key = key, this.optional = optional, this.visibility = visibility
            }
            static fromKey(key) {
                return new ReflectiveDependency(key, !1, null)
            }
        }
        const _EMPTY_LIST = [];
        class ResolvedReflectiveProvider_ {
            constructor(key, resolvedFactories, multiProvider) {
                this.key = key, this.resolvedFactories = resolvedFactories, this.multiProvider = multiProvider, this.resolvedFactory = this.resolvedFactories[0]
            }
        }
        class ResolvedReflectiveFactory {
            constructor(factory, dependencies) {
                this.factory = factory, this.dependencies = dependencies
            }
        }

        function resolveReflectiveFactory(provider) {
            let factoryFn, resolvedDeps;
            if (provider.useClass) {
                const useClass = resolveForwardRef(provider.useClass);
                factoryFn = reflector.factory(useClass), resolvedDeps = _dependenciesFor(useClass)
            } else provider.useExisting ? (factoryFn = aliasInstance => aliasInstance, resolvedDeps = [ReflectiveDependency.fromKey(ReflectiveKey.get(provider.useExisting))]) : provider.useFactory ? (factoryFn = provider.useFactory, resolvedDeps = function(typeOrFunc, dependencies) {
                if (dependencies) {
                    const params = dependencies.map((t => [t]));
                    return dependencies.map((t => _extractToken(typeOrFunc, t, params)))
                }
                return _dependenciesFor(typeOrFunc)
            }(provider.useFactory, provider.deps)) : (factoryFn = () => provider.useValue, resolvedDeps = _EMPTY_LIST);
            return new ResolvedReflectiveFactory(factoryFn, resolvedDeps)
        }

        function resolveReflectiveProvider(provider) {
            return new ResolvedReflectiveProvider_(ReflectiveKey.get(provider.provide), [resolveReflectiveFactory(provider)], provider.multi || !1)
        }

        function resolveReflectiveProviders(providers) {
            const resolvedProviderMap = function(providers, normalizedProvidersMap) {
                for (let i = 0; i < providers.length; i++) {
                    const provider = providers[i],
                        existing = normalizedProvidersMap.get(provider.key.id);
                    if (existing) {
                        if (provider.multiProvider !== existing.multiProvider) throw mixingMultiProvidersWithRegularProvidersError(existing, provider);
                        if (provider.multiProvider)
                            for (let j = 0; j < provider.resolvedFactories.length; j++) existing.resolvedFactories.push(provider.resolvedFactories[j]);
                        else normalizedProvidersMap.set(provider.key.id, provider)
                    } else {
                        let resolvedProvider;
                        resolvedProvider = provider.multiProvider ? new ResolvedReflectiveProvider_(provider.key, provider.resolvedFactories.slice(), provider.multiProvider) : provider, normalizedProvidersMap.set(provider.key.id, resolvedProvider)
                    }
                }
                return normalizedProvidersMap
            }(_normalizeProviders(providers, []).map(resolveReflectiveProvider), new Map);
            return Array.from(resolvedProviderMap.values())
        }

        function _normalizeProviders(providers, res) {
            return providers.forEach((b => {
                if (b instanceof Type) res.push({
                    provide: b,
                    useClass: b
                });
                else if (b && "object" == typeof b && void 0 !== b.provide) res.push(b);
                else {
                    if (!Array.isArray(b)) throw Error(`Invalid provider - only instances of Provider and Type are allowed, got: ${b}`);
                    _normalizeProviders(b, res)
                }
            })), res
        }

        function _dependenciesFor(typeOrFunc) {
            const params = reflector.parameters(typeOrFunc);
            if (!params) return [];
            if (params.some((p => null == p))) throw noAnnotationError(typeOrFunc, params);
            return params.map((p => _extractToken(typeOrFunc, p, params)))
        }

        function _extractToken(typeOrFunc, metadata, params) {
            let token = null,
                optional = !1;
            if (!Array.isArray(metadata)) return _createDependency(metadata instanceof Inject ? metadata.token : metadata, optional, null);
            let visibility = null;
            for (let i = 0; i < metadata.length; ++i) {
                const paramMetadata = metadata[i];
                paramMetadata instanceof Type ? token = paramMetadata : paramMetadata instanceof Inject ? token = paramMetadata.token : paramMetadata instanceof Optional ? optional = !0 : paramMetadata instanceof Self || paramMetadata instanceof SkipSelf ? visibility = paramMetadata : paramMetadata instanceof InjectionToken && (token = paramMetadata)
            }
            if (token = resolveForwardRef(token), null != token) return _createDependency(token, optional, visibility);
            throw noAnnotationError(typeOrFunc, params)
        }

        function _createDependency(token, optional, visibility) {
            return new ReflectiveDependency(ReflectiveKey.get(token), optional, visibility)
        }
        const UNDEFINED = {};
        class ReflectiveInjector {
            static resolve(providers) {
                return resolveReflectiveProviders(providers)
            }
            static resolveAndCreate(providers, parent) {
                const ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);
                return ReflectiveInjector.fromResolvedProviders(ResolvedReflectiveProviders, parent)
            }
            static fromResolvedProviders(providers, parent) {
                return new ReflectiveInjector_(providers, parent)
            }
        }
        class ReflectiveInjector_ {
            constructor(_providers, _parent) {
                this._constructionCounter = 0, this._providers = _providers, this.parent = _parent || null;
                const len = _providers.length;
                this.keyIds = [], this.objs = [];
                for (let i = 0; i < len; i++) this.keyIds[i] = _providers[i].key.id, this.objs[i] = UNDEFINED
            }
            get(token, notFoundValue = THROW_IF_NOT_FOUND) {
                return this._getByKey(ReflectiveKey.get(token), null, notFoundValue)
            }
            resolveAndCreateChild(providers) {
                const ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);
                return this.createChildFromResolved(ResolvedReflectiveProviders)
            }
            createChildFromResolved(providers) {
                const inj = new ReflectiveInjector_(providers);
                return inj.parent = this, inj
            }
            resolveAndInstantiate(provider) {
                return this.instantiateResolved(ReflectiveInjector.resolve([provider])[0])
            }
            instantiateResolved(provider) {
                return this._instantiateProvider(provider)
            }
            getProviderAtIndex(index) {
                if (index < 0 || index >= this._providers.length) throw function(index) {
                    return Error(`Index ${index} is out-of-bounds.`)
                }(index);
                return this._providers[index]
            }
            _new(provider) {
                if (this._constructionCounter++ > this._getMaxNumberOfObjects()) throw injector = this, key = provider.key, injectionError(injector, key, (function(keys) {
                    return `Cannot instantiate cyclic dependency!${constructResolvingPath(keys)}`
                }));
                var injector, key;
                return this._instantiateProvider(provider)
            }
            _getMaxNumberOfObjects() {
                return this.objs.length
            }
            _instantiateProvider(provider) {
                if (provider.multiProvider) {
                    const res = [];
                    for (let i = 0; i < provider.resolvedFactories.length; ++i) res[i] = this._instantiate(provider, provider.resolvedFactories[i]);
                    return res
                }
                return this._instantiate(provider, provider.resolvedFactories[0])
            }
            _instantiate(provider, ResolvedReflectiveFactory) {
                const factory = ResolvedReflectiveFactory.factory;
                let deps, obj;
                try {
                    deps = ResolvedReflectiveFactory.dependencies.map((dep => this._getByReflectiveDependency(dep)))
                } catch (e) {
                    throw e.addKey && e.addKey(this, provider.key), e
                }
                try {
                    obj = factory(...deps)
                } catch (e) {
                    throw injector = this, originalException = e, e.stack, key = provider.key, injectionError(injector, key, (function(keys) {
                        const first = stringify(keys[0].token);
                        return `${originalException.message}: Error during instantiation of ${first}!${constructResolvingPath(keys)}.`
                    }), originalException)
                }
                var injector, originalException, key;
                return obj
            }
            _getByReflectiveDependency(dep) {
                return this._getByKey(dep.key, dep.visibility, dep.optional ? null : THROW_IF_NOT_FOUND)
            }
            _getByKey(key, visibility, notFoundValue) {
                return key === ReflectiveInjector_.INJECTOR_KEY ? this : visibility instanceof Self ? this._getByKeySelf(key, notFoundValue) : this._getByKeyDefault(key, notFoundValue, visibility)
            }
            _getObjByKeyId(keyId) {
                for (let i = 0; i < this.keyIds.length; i++)
                    if (this.keyIds[i] === keyId) return this.objs[i] === UNDEFINED && (this.objs[i] = this._new(this._providers[i])), this.objs[i];
                return UNDEFINED
            }
            _throwOrNull(key, notFoundValue) {
                if (notFoundValue !== THROW_IF_NOT_FOUND) return notFoundValue;
                throw function(injector, key) {
                    return injectionError(injector, key, (function(keys) {
                        return `No provider for ${stringify(keys[0].token)}!${constructResolvingPath(keys)}`
                    }))
                }(this, key)
            }
            _getByKeySelf(key, notFoundValue) {
                const obj = this._getObjByKeyId(key.id);
                return obj !== UNDEFINED ? obj : this._throwOrNull(key, notFoundValue)
            }
            _getByKeyDefault(key, notFoundValue, visibility) {
                let inj;
                for (inj = visibility instanceof SkipSelf ? this.parent : this; inj instanceof ReflectiveInjector_;) {
                    const inj_ = inj,
                        obj = inj_._getObjByKeyId(key.id);
                    if (obj !== UNDEFINED) return obj;
                    inj = inj_.parent
                }
                return null !== inj ? inj.get(key.token, notFoundValue) : this._throwOrNull(key, notFoundValue)
            }
            get displayName() {
                return `ReflectiveInjector(providers: [${function(injector,fn){const res=[];for(let i=0;i<injector._providers.length;++i)res[i]=fn(injector.getProviderAtIndex(i));return res}(this,(b=>' "'+b.key.displayName+'" ')).join(", ")}])`
            }
            toString() {
                return this.displayName
            }
        }

        function isPromise(obj) {
            return !!obj && "function" == typeof obj.then
        }

        function isObservable(obj) {
            return !!obj && "function" == typeof obj.subscribe
        }
        ReflectiveInjector_.INJECTOR_KEY = ReflectiveKey.get(Injector);
        const EMPTY_OBJ$1 = {},
            EMPTY_ARRAY$3 = [];
        ("undefined" == typeof ngDevMode || ngDevMode) && initNgDevMode() && (Object.freeze(EMPTY_OBJ$1), Object.freeze(EMPTY_ARRAY$3));
        "undefined" == typeof ngI18nClosureMode && (_global.ngI18nClosureMode = "undefined" != typeof goog && "function" == typeof goog.getMsg);
        const u = void 0;
        var localeEn = ["en", [
                ["a", "p"],
                ["AM", "PM"], u
            ],
            [
                ["AM", "PM"], u, u
            ],
            [
                ["S", "M", "T", "W", "T", "F", "S"],
                ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
                ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
                ["Su", "Mo", "Tu", "We", "Th", "Fr", "Sa"]
            ], u, [
                ["J", "F", "M", "A", "M", "J", "J", "A", "S", "O", "N", "D"],
                ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
                ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"]
            ], u, [
                ["B", "A"],
                ["BC", "AD"],
                ["Before Christ", "Anno Domini"]
            ], 0, [6, 0],
            ["M/d/yy", "MMM d, y", "MMMM d, y", "EEEE, MMMM d, y"],
            ["h:mm a", "h:mm:ss a", "h:mm:ss a z", "h:mm:ss a zzzz"],
            ["{1}, {0}", u, "{1} 'at' {0}", u],
            [".", ",", ";", "%", "+", "-", "E", "×", "‰", "∞", "NaN", ":"],
            ["#,##0.###", "#,##0%", "¤#,##0.00", "#E0"], "USD", "$", "US Dollar", {}, "ltr",
            function(n) {
                let i = Math.floor(Math.abs(n)),
                    v = n.toString().replace(/^[^.]*\.?/, "").length;
                return 1 === i && 0 === v ? 1 : 5
            }
        ];
        let LOCALE_DATA = {};

        function registerLocaleData(data, localeId, extraData) {
            "string" != typeof localeId && (extraData = localeId, localeId = data[LocaleDataIndex.LocaleId]), localeId = localeId.toLowerCase().replace(/_/g, "-"), LOCALE_DATA[localeId] = data, extraData && (LOCALE_DATA[localeId][LocaleDataIndex.ExtraData] = extraData)
        }

        function findLocaleData(locale) {
            const normalizedLocale = function(locale) {
                return locale.toLowerCase().replace(/_/g, "-")
            }(locale);
            let match = getLocaleData(normalizedLocale);
            if (match) return match;
            const parentLocale = normalizedLocale.split("-")[0];
            if (match = getLocaleData(parentLocale), match) return match;
            if ("en" === parentLocale) return localeEn;
            throw new Error(`Missing locale data for the locale "${locale}".`)
        }

        function getLocaleCurrencyCode(locale) {
            return findLocaleData(locale)[LocaleDataIndex.CurrencyCode] || null
        }

        function getLocalePluralCase(locale) {
            return findLocaleData(locale)[LocaleDataIndex.PluralCase]
        }

        function getLocaleData(normalizedLocale) {
            return normalizedLocale in LOCALE_DATA || (LOCALE_DATA[normalizedLocale] = _global.ng && _global.ng.common && _global.ng.common.locales && _global.ng.common.locales[normalizedLocale]), LOCALE_DATA[normalizedLocale]
        }
        var LocaleDataIndex;
        ! function(LocaleDataIndex) {
            LocaleDataIndex[LocaleDataIndex.LocaleId = 0] = "LocaleId", LocaleDataIndex[LocaleDataIndex.DayPeriodsFormat = 1] = "DayPeriodsFormat", LocaleDataIndex[LocaleDataIndex.DayPeriodsStandalone = 2] = "DayPeriodsStandalone", LocaleDataIndex[LocaleDataIndex.DaysFormat = 3] = "DaysFormat", LocaleDataIndex[LocaleDataIndex.DaysStandalone = 4] = "DaysStandalone", LocaleDataIndex[LocaleDataIndex.MonthsFormat = 5] = "MonthsFormat", LocaleDataIndex[LocaleDataIndex.MonthsStandalone = 6] = "MonthsStandalone", LocaleDataIndex[LocaleDataIndex.Eras = 7] = "Eras", LocaleDataIndex[LocaleDataIndex.FirstDayOfWeek = 8] = "FirstDayOfWeek", LocaleDataIndex[LocaleDataIndex.WeekendRange = 9] = "WeekendRange", LocaleDataIndex[LocaleDataIndex.DateFormat = 10] = "DateFormat", LocaleDataIndex[LocaleDataIndex.TimeFormat = 11] = "TimeFormat", LocaleDataIndex[LocaleDataIndex.DateTimeFormat = 12] = "DateTimeFormat", LocaleDataIndex[LocaleDataIndex.NumberSymbols = 13] = "NumberSymbols", LocaleDataIndex[LocaleDataIndex.NumberFormats = 14] = "NumberFormats", LocaleDataIndex[LocaleDataIndex.CurrencyCode = 15] = "CurrencyCode", LocaleDataIndex[LocaleDataIndex.CurrencySymbol = 16] = "CurrencySymbol", LocaleDataIndex[LocaleDataIndex.CurrencyName = 17] = "CurrencyName", LocaleDataIndex[LocaleDataIndex.Currencies = 18] = "Currencies", LocaleDataIndex[LocaleDataIndex.Directionality = 19] = "Directionality", LocaleDataIndex[LocaleDataIndex.PluralCase = 20] = "PluralCase", LocaleDataIndex[LocaleDataIndex.ExtraData = 21] = "ExtraData"
        }(LocaleDataIndex || (LocaleDataIndex = {}));
        var I18nCreateOpCode;
        ! function(I18nCreateOpCode) {
            I18nCreateOpCode[I18nCreateOpCode.SHIFT = 2] = "SHIFT", I18nCreateOpCode[I18nCreateOpCode.APPEND_EAGERLY = 1] = "APPEND_EAGERLY", I18nCreateOpCode[I18nCreateOpCode.COMMENT = 2] = "COMMENT"
        }(I18nCreateOpCode || (I18nCreateOpCode = {}));
        class ComponentRef {}
        class ComponentFactory {}

        function noComponentFactoryError(component) {
            const error = Error(`No component factory found for ${stringify(component)}. Did you add it to @NgModule.entryComponents?`);
            return error[ERROR_COMPONENT] = component, error
        }
        const ERROR_COMPONENT = "ngComponent";
        class ComponentFactoryResolver {}
        ComponentFactoryResolver.NULL = new class {
            resolveComponentFactory(component) {
                throw noComponentFactoryError(component)
            }
        };
        class ComponentFactoryBoundToModule extends ComponentFactory {
            constructor(factory, ngModule) {
                super(), this.factory = factory, this.ngModule = ngModule, this.selector = factory.selector, this.componentType = factory.componentType, this.ngContentSelectors = factory.ngContentSelectors, this.inputs = factory.inputs, this.outputs = factory.outputs
            }
            create(injector, projectableNodes, rootSelectorOrNode, ngModule) {
                return this.factory.create(injector, projectableNodes, rootSelectorOrNode, ngModule || this.ngModule)
            }
        }

        function noop(...args) {}

        function createElementRef(tNode, lView) {
            return new ElementRef(getNativeByTNode(tNode, lView))
        }
        const SWITCH_ELEMENT_REF_FACTORY = noop;
        class ElementRef {
            constructor(nativeElement) {
                this.nativeElement = nativeElement
            }
        }
        ElementRef.__NG_ELEMENT_ID__ = SWITCH_ELEMENT_REF_FACTORY;
        new InjectionToken("Renderer2Interceptor");
        class RendererFactory2 {}
        class Renderer2 {}
        Renderer2.__NG_ELEMENT_ID__ = () => SWITCH_RENDERER2_FACTORY();
        const SWITCH_RENDERER2_FACTORY = noop;
        class Sanitizer {}
        Sanitizer.ɵprov = ɵɵdefineInjectable({
            token: Sanitizer,
            providedIn: "root",
            factory: () => null
        });
        class Version {
            constructor(full) {
                this.full = full, this.major = full.split(".")[0], this.minor = full.split(".")[1], this.patch = full.split(".").slice(2).join(".")
            }
        }
        const VERSION = new Version("11.0.5");
        class DefaultIterableDifferFactory {
            constructor() {}
            supports(obj) {
                return isListLikeIterable(obj)
            }
            create(trackByFn) {
                return new DefaultIterableDiffer(trackByFn)
            }
        }
        const trackByIdentity = (index, item) => item;
        class DefaultIterableDiffer {
            constructor(trackByFn) {
                this.length = 0, this._linkedRecords = null, this._unlinkedRecords = null, this._previousItHead = null, this._itHead = null, this._itTail = null, this._additionsHead = null, this._additionsTail = null, this._movesHead = null, this._movesTail = null, this._removalsHead = null, this._removalsTail = null, this._identityChangesHead = null, this._identityChangesTail = null, this._trackByFn = trackByFn || trackByIdentity
            }
            forEachItem(fn) {
                let record;
                for (record = this._itHead; null !== record; record = record._next) fn(record)
            }
            forEachOperation(fn) {
                let nextIt = this._itHead,
                    nextRemove = this._removalsHead,
                    addRemoveOffset = 0,
                    moveOffsets = null;
                for (; nextIt || nextRemove;) {
                    const record = !nextRemove || nextIt && nextIt.currentIndex < getPreviousIndex(nextRemove, addRemoveOffset, moveOffsets) ? nextIt : nextRemove,
                        adjPreviousIndex = getPreviousIndex(record, addRemoveOffset, moveOffsets),
                        currentIndex = record.currentIndex;
                    if (record === nextRemove) addRemoveOffset--, nextRemove = nextRemove._nextRemoved;
                    else if (nextIt = nextIt._next, null == record.previousIndex) addRemoveOffset++;
                    else {
                        moveOffsets || (moveOffsets = []);
                        const localMovePreviousIndex = adjPreviousIndex - addRemoveOffset,
                            localCurrentIndex = currentIndex - addRemoveOffset;
                        if (localMovePreviousIndex != localCurrentIndex) {
                            for (let i = 0; i < localMovePreviousIndex; i++) {
                                const offset = i < moveOffsets.length ? moveOffsets[i] : moveOffsets[i] = 0,
                                    index = offset + i;
                                localCurrentIndex <= index && index < localMovePreviousIndex && (moveOffsets[i] = offset + 1)
                            }
                            moveOffsets[record.previousIndex] = localCurrentIndex - localMovePreviousIndex
                        }
                    }
                    adjPreviousIndex !== currentIndex && fn(record, adjPreviousIndex, currentIndex)
                }
            }
            forEachPreviousItem(fn) {
                let record;
                for (record = this._previousItHead; null !== record; record = record._nextPrevious) fn(record)
            }
            forEachAddedItem(fn) {
                let record;
                for (record = this._additionsHead; null !== record; record = record._nextAdded) fn(record)
            }
            forEachMovedItem(fn) {
                let record;
                for (record = this._movesHead; null !== record; record = record._nextMoved) fn(record)
            }
            forEachRemovedItem(fn) {
                let record;
                for (record = this._removalsHead; null !== record; record = record._nextRemoved) fn(record)
            }
            forEachIdentityChange(fn) {
                let record;
                for (record = this._identityChangesHead; null !== record; record = record._nextIdentityChange) fn(record)
            }
            diff(collection) {
                if (null == collection && (collection = []), !isListLikeIterable(collection)) throw new Error(`Error trying to diff '${stringify(collection)}'. Only arrays and iterables are allowed`);
                return this.check(collection) ? this : null
            }
            onDestroy() {}
            check(collection) {
                this._reset();
                let index, item, itemTrackBy, record = this._itHead,
                    mayBeDirty = !1;
                if (Array.isArray(collection)) {
                    this.length = collection.length;
                    for (let index = 0; index < this.length; index++) item = collection[index], itemTrackBy = this._trackByFn(index, item), null !== record && Object.is(record.trackById, itemTrackBy) ? (mayBeDirty && (record = this._verifyReinsertion(record, item, itemTrackBy, index)), Object.is(record.item, item) || this._addIdentityChange(record, item)) : (record = this._mismatch(record, item, itemTrackBy, index), mayBeDirty = !0), record = record._next
                } else index = 0,
                    function(obj, fn) {
                        if (Array.isArray(obj))
                            for (let i = 0; i < obj.length; i++) fn(obj[i]);
                        else {
                            const iterator = obj[getSymbolIterator()]();
                            let item;
                            for (; !(item = iterator.next()).done;) fn(item.value)
                        }
                    }(collection, (item => {
                        itemTrackBy = this._trackByFn(index, item), null !== record && Object.is(record.trackById, itemTrackBy) ? (mayBeDirty && (record = this._verifyReinsertion(record, item, itemTrackBy, index)), Object.is(record.item, item) || this._addIdentityChange(record, item)) : (record = this._mismatch(record, item, itemTrackBy, index), mayBeDirty = !0), record = record._next, index++
                    })), this.length = index;
                return this._truncate(record), this.collection = collection, this.isDirty
            }
            get isDirty() {
                return null !== this._additionsHead || null !== this._movesHead || null !== this._removalsHead || null !== this._identityChangesHead
            }
            _reset() {
                if (this.isDirty) {
                    let record;
                    for (record = this._previousItHead = this._itHead; null !== record; record = record._next) record._nextPrevious = record._next;
                    for (record = this._additionsHead; null !== record; record = record._nextAdded) record.previousIndex = record.currentIndex;
                    for (this._additionsHead = this._additionsTail = null, record = this._movesHead; null !== record; record = record._nextMoved) record.previousIndex = record.currentIndex;
                    this._movesHead = this._movesTail = null, this._removalsHead = this._removalsTail = null, this._identityChangesHead = this._identityChangesTail = null
                }
            }
            _mismatch(record, item, itemTrackBy, index) {
                let previousRecord;
                return null === record ? previousRecord = this._itTail : (previousRecord = record._prev, this._remove(record)), null !== (record = null === this._linkedRecords ? null : this._linkedRecords.get(itemTrackBy, index)) ? (Object.is(record.item, item) || this._addIdentityChange(record, item), this._moveAfter(record, previousRecord, index)) : null !== (record = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(itemTrackBy, null)) ? (Object.is(record.item, item) || this._addIdentityChange(record, item), this._reinsertAfter(record, previousRecord, index)) : record = this._addAfter(new IterableChangeRecord_(item, itemTrackBy), previousRecord, index), record
            }
            _verifyReinsertion(record, item, itemTrackBy, index) {
                let reinsertRecord = null === this._unlinkedRecords ? null : this._unlinkedRecords.get(itemTrackBy, null);
                return null !== reinsertRecord ? record = this._reinsertAfter(reinsertRecord, record._prev, index) : record.currentIndex != index && (record.currentIndex = index, this._addToMoves(record, index)), record
            }
            _truncate(record) {
                for (; null !== record;) {
                    const nextRecord = record._next;
                    this._addToRemovals(this._unlink(record)), record = nextRecord
                }
                null !== this._unlinkedRecords && this._unlinkedRecords.clear(), null !== this._additionsTail && (this._additionsTail._nextAdded = null), null !== this._movesTail && (this._movesTail._nextMoved = null), null !== this._itTail && (this._itTail._next = null), null !== this._removalsTail && (this._removalsTail._nextRemoved = null), null !== this._identityChangesTail && (this._identityChangesTail._nextIdentityChange = null)
            }
            _reinsertAfter(record, prevRecord, index) {
                null !== this._unlinkedRecords && this._unlinkedRecords.remove(record);
                const prev = record._prevRemoved,
                    next = record._nextRemoved;
                return null === prev ? this._removalsHead = next : prev._nextRemoved = next, null === next ? this._removalsTail = prev : next._prevRemoved = prev, this._insertAfter(record, prevRecord, index), this._addToMoves(record, index), record
            }
            _moveAfter(record, prevRecord, index) {
                return this._unlink(record), this._insertAfter(record, prevRecord, index), this._addToMoves(record, index), record
            }
            _addAfter(record, prevRecord, index) {
                return this._insertAfter(record, prevRecord, index), null === this._additionsTail ? this._additionsTail = this._additionsHead = record : this._additionsTail = this._additionsTail._nextAdded = record, record
            }
            _insertAfter(record, prevRecord, index) {
                const next = null === prevRecord ? this._itHead : prevRecord._next;
                return record._next = next, record._prev = prevRecord, null === next ? this._itTail = record : next._prev = record, null === prevRecord ? this._itHead = record : prevRecord._next = record, null === this._linkedRecords && (this._linkedRecords = new _DuplicateMap), this._linkedRecords.put(record), record.currentIndex = index, record
            }
            _remove(record) {
                return this._addToRemovals(this._unlink(record))
            }
            _unlink(record) {
                null !== this._linkedRecords && this._linkedRecords.remove(record);
                const prev = record._prev,
                    next = record._next;
                return null === prev ? this._itHead = next : prev._next = next, null === next ? this._itTail = prev : next._prev = prev, record
            }
            _addToMoves(record, toIndex) {
                return record.previousIndex === toIndex || (null === this._movesTail ? this._movesTail = this._movesHead = record : this._movesTail = this._movesTail._nextMoved = record), record
            }
            _addToRemovals(record) {
                return null === this._unlinkedRecords && (this._unlinkedRecords = new _DuplicateMap), this._unlinkedRecords.put(record), record.currentIndex = null, record._nextRemoved = null, null === this._removalsTail ? (this._removalsTail = this._removalsHead = record, record._prevRemoved = null) : (record._prevRemoved = this._removalsTail, this._removalsTail = this._removalsTail._nextRemoved = record), record
            }
            _addIdentityChange(record, item) {
                return record.item = item, null === this._identityChangesTail ? this._identityChangesTail = this._identityChangesHead = record : this._identityChangesTail = this._identityChangesTail._nextIdentityChange = record, record
            }
        }
        class IterableChangeRecord_ {
            constructor(item, trackById) {
                this.item = item, this.trackById = trackById, this.currentIndex = null, this.previousIndex = null, this._nextPrevious = null, this._prev = null, this._next = null, this._prevDup = null, this._nextDup = null, this._prevRemoved = null, this._nextRemoved = null, this._nextAdded = null, this._nextMoved = null, this._nextIdentityChange = null
            }
        }
        class _DuplicateItemRecordList {
            constructor() {
                this._head = null, this._tail = null
            }
            add(record) {
                null === this._head ? (this._head = this._tail = record, record._nextDup = null, record._prevDup = null) : (this._tail._nextDup = record, record._prevDup = this._tail, record._nextDup = null, this._tail = record)
            }
            get(trackById, atOrAfterIndex) {
                let record;
                for (record = this._head; null !== record; record = record._nextDup)
                    if ((null === atOrAfterIndex || atOrAfterIndex <= record.currentIndex) && Object.is(record.trackById, trackById)) return record;
                return null
            }
            remove(record) {
                const prev = record._prevDup,
                    next = record._nextDup;
                return null === prev ? this._head = next : prev._nextDup = next, null === next ? this._tail = prev : next._prevDup = prev, null === this._head
            }
        }
        class _DuplicateMap {
            constructor() {
                this.map = new Map
            }
            put(record) {
                const key = record.trackById;
                let duplicates = this.map.get(key);
                duplicates || (duplicates = new _DuplicateItemRecordList, this.map.set(key, duplicates)), duplicates.add(record)
            }
            get(trackById, atOrAfterIndex) {
                const key = trackById,
                    recordList = this.map.get(key);
                return recordList ? recordList.get(trackById, atOrAfterIndex) : null
            }
            remove(record) {
                const key = record.trackById;
                return this.map.get(key).remove(record) && this.map.delete(key), record
            }
            get isEmpty() {
                return 0 === this.map.size
            }
            clear() {
                this.map.clear()
            }
        }

        function getPreviousIndex(item, addRemoveOffset, moveOffsets) {
            const previousIndex = item.previousIndex;
            if (null === previousIndex) return previousIndex;
            let moveOffset = 0;
            return moveOffsets && previousIndex < moveOffsets.length && (moveOffset = moveOffsets[previousIndex]), previousIndex + addRemoveOffset + moveOffset
        }
        class DefaultKeyValueDifferFactory {
            constructor() {}
            supports(obj) {
                return obj instanceof Map || isJsObject(obj)
            }
            create() {
                return new DefaultKeyValueDiffer
            }
        }
        class DefaultKeyValueDiffer {
            constructor() {
                this._records = new Map, this._mapHead = null, this._appendAfter = null, this._previousMapHead = null, this._changesHead = null, this._changesTail = null, this._additionsHead = null, this._additionsTail = null, this._removalsHead = null, this._removalsTail = null
            }
            get isDirty() {
                return null !== this._additionsHead || null !== this._changesHead || null !== this._removalsHead
            }
            forEachItem(fn) {
                let record;
                for (record = this._mapHead; null !== record; record = record._next) fn(record)
            }
            forEachPreviousItem(fn) {
                let record;
                for (record = this._previousMapHead; null !== record; record = record._nextPrevious) fn(record)
            }
            forEachChangedItem(fn) {
                let record;
                for (record = this._changesHead; null !== record; record = record._nextChanged) fn(record)
            }
            forEachAddedItem(fn) {
                let record;
                for (record = this._additionsHead; null !== record; record = record._nextAdded) fn(record)
            }
            forEachRemovedItem(fn) {
                let record;
                for (record = this._removalsHead; null !== record; record = record._nextRemoved) fn(record)
            }
            diff(map) {
                if (map) {
                    if (!(map instanceof Map || isJsObject(map))) throw new Error(`Error trying to diff '${stringify(map)}'. Only maps and objects are allowed`)
                } else map = new Map;
                return this.check(map) ? this : null
            }
            onDestroy() {}
            check(map) {
                this._reset();
                let insertBefore = this._mapHead;
                if (this._appendAfter = null, this._forEach(map, ((value, key) => {
                        if (insertBefore && insertBefore.key === key) this._maybeAddToChanges(insertBefore, value), this._appendAfter = insertBefore, insertBefore = insertBefore._next;
                        else {
                            const record = this._getOrCreateRecordForKey(key, value);
                            insertBefore = this._insertBeforeOrAppend(insertBefore, record)
                        }
                    })), insertBefore) {
                    insertBefore._prev && (insertBefore._prev._next = null), this._removalsHead = insertBefore;
                    for (let record = insertBefore; null !== record; record = record._nextRemoved) record === this._mapHead && (this._mapHead = null), this._records.delete(record.key), record._nextRemoved = record._next, record.previousValue = record.currentValue, record.currentValue = null, record._prev = null, record._next = null
                }
                return this._changesTail && (this._changesTail._nextChanged = null), this._additionsTail && (this._additionsTail._nextAdded = null), this.isDirty
            }
            _insertBeforeOrAppend(before, record) {
                if (before) {
                    const prev = before._prev;
                    return record._next = before, record._prev = prev, before._prev = record, prev && (prev._next = record), before === this._mapHead && (this._mapHead = record), this._appendAfter = before, before
                }
                return this._appendAfter ? (this._appendAfter._next = record, record._prev = this._appendAfter) : this._mapHead = record, this._appendAfter = record, null
            }
            _getOrCreateRecordForKey(key, value) {
                if (this._records.has(key)) {
                    const record = this._records.get(key);
                    this._maybeAddToChanges(record, value);
                    const prev = record._prev,
                        next = record._next;
                    return prev && (prev._next = next), next && (next._prev = prev), record._next = null, record._prev = null, record
                }
                const record = new KeyValueChangeRecord_(key);
                return this._records.set(key, record), record.currentValue = value, this._addToAdditions(record), record
            }
            _reset() {
                if (this.isDirty) {
                    let record;
                    for (this._previousMapHead = this._mapHead, record = this._previousMapHead; null !== record; record = record._next) record._nextPrevious = record._next;
                    for (record = this._changesHead; null !== record; record = record._nextChanged) record.previousValue = record.currentValue;
                    for (record = this._additionsHead; null != record; record = record._nextAdded) record.previousValue = record.currentValue;
                    this._changesHead = this._changesTail = null, this._additionsHead = this._additionsTail = null, this._removalsHead = null
                }
            }
            _maybeAddToChanges(record, newValue) {
                Object.is(newValue, record.currentValue) || (record.previousValue = record.currentValue, record.currentValue = newValue, this._addToChanges(record))
            }
            _addToAdditions(record) {
                null === this._additionsHead ? this._additionsHead = this._additionsTail = record : (this._additionsTail._nextAdded = record, this._additionsTail = record)
            }
            _addToChanges(record) {
                null === this._changesHead ? this._changesHead = this._changesTail = record : (this._changesTail._nextChanged = record, this._changesTail = record)
            }
            _forEach(obj, fn) {
                obj instanceof Map ? obj.forEach(fn) : Object.keys(obj).forEach((k => fn(obj[k], k)))
            }
        }
        class KeyValueChangeRecord_ {
            constructor(key) {
                this.key = key, this.previousValue = null, this.currentValue = null, this._nextPrevious = null, this._next = null, this._prev = null, this._nextAdded = null, this._nextRemoved = null, this._nextChanged = null
            }
        }
        class IterableDiffers {
            constructor(factories) {
                this.factories = factories
            }
            static create(factories, parent) {
                if (null != parent) {
                    const copied = parent.factories.slice();
                    factories = factories.concat(copied)
                }
                return new IterableDiffers(factories)
            }
            static extend(factories) {
                return {
                    provide: IterableDiffers,
                    useFactory: parent => {
                        if (!parent) throw new Error("Cannot extend IterableDiffers without a parent injector");
                        return IterableDiffers.create(factories, parent)
                    },
                    deps: [
                        [IterableDiffers, new SkipSelf, new Optional]
                    ]
                }
            }
            find(iterable) {
                const factory = this.factories.find((f => f.supports(iterable)));
                if (null != factory) return factory;
                throw new Error(`Cannot find a differ supporting object '${iterable}' of type '${type=iterable,type.name||typeof type}'`);
                var type
            }
        }
        IterableDiffers.ɵprov = ɵɵdefineInjectable({
            token: IterableDiffers,
            providedIn: "root",
            factory: () => new IterableDiffers([new DefaultIterableDifferFactory])
        });
        class KeyValueDiffers {
            constructor(factories) {
                this.factories = factories
            }
            static create(factories, parent) {
                if (parent) {
                    const copied = parent.factories.slice();
                    factories = factories.concat(copied)
                }
                return new KeyValueDiffers(factories)
            }
            static extend(factories) {
                return {
                    provide: KeyValueDiffers,
                    useFactory: parent => {
                        if (!parent) throw new Error("Cannot extend KeyValueDiffers without a parent injector");
                        return KeyValueDiffers.create(factories, parent)
                    },
                    deps: [
                        [KeyValueDiffers, new SkipSelf, new Optional]
                    ]
                }
            }
            find(kv) {
                const factory = this.factories.find((f => f.supports(kv)));
                if (factory) return factory;
                throw new Error(`Cannot find a differ supporting object '${kv}'`)
            }
        }

        function collectNativeNodes(tView, lView, tNode, result, isProjection = !1) {
            for (; null !== tNode;) {
                ngDevMode && assertTNodeType(tNode, 63);
                const lNode = lView[tNode.index];
                if (null !== lNode && result.push(unwrapRNode(lNode)), isLContainer(lNode))
                    for (let i = 10; i < lNode.length; i++) {
                        const lViewInAContainer = lNode[i],
                            lViewFirstChildTNode = lViewInAContainer[1].firstChild;
                        null !== lViewFirstChildTNode && collectNativeNodes(lViewInAContainer[1], lViewInAContainer, lViewFirstChildTNode, result)
                    }
                const tNodeType = tNode.type;
                if (8 & tNodeType) collectNativeNodes(tView, lView, tNode.child, result);
                else if (32 & tNodeType) {
                    const nextRNode = icuContainerIterate(tNode, lView);
                    let rNode;
                    for (; rNode = nextRNode();) result.push(rNode)
                } else if (16 & tNodeType) {
                    const componentView = lView[16],
                        componentHost = componentView[6],
                        slotIdx = tNode.projection;
                    ngDevMode && assertDefined(componentHost.projection, "Components with projection nodes (<ng-content>) must have projection slots defined.");
                    const nodesInSlot = componentHost.projection[slotIdx];
                    if (Array.isArray(nodesInSlot)) result.push(...nodesInSlot);
                    else {
                        const parentView = getLViewParent(componentView);
                        ngDevMode && assertDefined(parentView, "Component views should always have a parent view (component's host view)"), collectNativeNodes(parentView[1], parentView, nodesInSlot, result, !0)
                    }
                }
                tNode = isProjection ? tNode.projectionNext : tNode.next
            }
            return result
        }
        KeyValueDiffers.ɵprov = ɵɵdefineInjectable({
            token: KeyValueDiffers,
            providedIn: "root",
            factory: () => new KeyValueDiffers([new DefaultKeyValueDifferFactory])
        });
        class ViewRef {
            constructor(_lView, _cdRefInjectingView) {
                this._lView = _lView, this._cdRefInjectingView = _cdRefInjectingView, this._appRef = null, this._viewContainerRef = null
            }
            get rootNodes() {
                const lView = this._lView,
                    tView = lView[1];
                return collectNativeNodes(tView, lView, tView.firstChild, [])
            }
            get context() {
                return this._lView[8]
            }
            get destroyed() {
                return 256 == (256 & this._lView[2])
            }
            destroy() {
                if (this._appRef) this._appRef.detachView(this);
                else if (this._viewContainerRef) {
                    const index = this._viewContainerRef.indexOf(this);
                    index > -1 && this._viewContainerRef.detach(index), this._viewContainerRef = null
                }
                destroyLView(this._lView[1], this._lView)
            }
            onDestroy(callback) {
                storeCleanupWithContext(this._lView[1], this._lView, null, callback)
            }
            markForCheck() {
                markViewDirty(this._cdRefInjectingView || this._lView)
            }
            detach() {
                this._lView[2] &= -129
            }
            reattach() {
                this._lView[2] |= 128
            }
            detectChanges() {
                detectChangesInternal(this._lView[1], this._lView, this.context)
            }
            checkNoChanges() {
                ! function(tView, view, context) {
                    setIsInCheckNoChangesMode(!0);
                    try {
                        detectChangesInternal(tView, view, context)
                    } finally {
                        setIsInCheckNoChangesMode(!1)
                    }
                }(this._lView[1], this._lView, this.context)
            }
            attachToViewContainerRef(vcRef) {
                if (this._appRef) throw new Error("This view is already attached directly to the ApplicationRef!");
                this._viewContainerRef = vcRef
            }
            detachFromAppRef() {
                var tView, lView;
                this._appRef = null, tView = this._lView[1], lView = this._lView, applyView(tView, lView, lView[11], 2, null, null)
            }
            attachToAppRef(appRef) {
                if (this._viewContainerRef) throw new Error("This view is already attached to a ViewContainer!");
                this._appRef = appRef
            }
        }
        class RootViewRef extends ViewRef {
            constructor(_view) {
                super(_view), this._view = _view
            }
            detectChanges() {
                detectChangesInRootView(this._view)
            }
            checkNoChanges() {
                ! function(lView) {
                    setIsInCheckNoChangesMode(!0);
                    try {
                        detectChangesInRootView(lView)
                    } finally {
                        setIsInCheckNoChangesMode(!1)
                    }
                }(this._view)
            }
            get context() {
                return null
            }
        }
        const SWITCH_CHANGE_DETECTOR_REF_FACTORY = noop;
        class ChangeDetectorRef {}
        ChangeDetectorRef.__NG_ELEMENT_ID__ = SWITCH_CHANGE_DETECTOR_REF_FACTORY, ChangeDetectorRef.__ChangeDetectorRef__ = !0;
        const keyValDiff = [new DefaultKeyValueDifferFactory],
            iterableDiff = [new DefaultIterableDifferFactory],
            defaultIterableDiffers = new IterableDiffers(iterableDiff),
            defaultKeyValueDiffers = new KeyValueDiffers(keyValDiff),
            SWITCH_TEMPLATE_REF_FACTORY = noop;
        class TemplateRef {}
        TemplateRef.__NG_ELEMENT_ID__ = SWITCH_TEMPLATE_REF_FACTORY;
        class NgModuleRef {}
        class NgModuleFactory {}
        const SWITCH_VIEW_CONTAINER_REF_FACTORY = noop;
        class ViewContainerRef {}
        ViewContainerRef.__NG_ELEMENT_ID__ = SWITCH_VIEW_CONTAINER_REF_FACTORY;
        const _tokenKeyCache = new Map;

        function tokenKey(token) {
            let key = _tokenKeyCache.get(token);
            return key || (key = stringify(token) + "_" + _tokenKeyCache.size, _tokenKeyCache.set(token, key)), key
        }
        new WeakMap;
        tokenKey(Injector), tokenKey(INJECTOR$1), tokenKey(NgModuleRef);
        tokenKey(Renderer2), tokenKey(ElementRef), tokenKey(ViewContainerRef), tokenKey(TemplateRef), tokenKey(ChangeDetectorRef), tokenKey(Injector), tokenKey(INJECTOR$1);
        const NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR = {};
        class ComponentFactoryResolver$1 extends ComponentFactoryResolver {
            constructor(ngModule) {
                super(), this.ngModule = ngModule
            }
            resolveComponentFactory(component) {
                ngDevMode && assertComponentType(component);
                const componentDef = getComponentDef(component);
                return new ComponentFactory$1(componentDef, this.ngModule)
            }
        }

        function toRefArray(map) {
            const array = [];
            for (let nonMinified in map)
                if (map.hasOwnProperty(nonMinified)) {
                    const minified = map[nonMinified];
                    array.push({
                        propName: minified,
                        templateName: nonMinified
                    })
                }
            return array
        }
        const SCHEDULER = new InjectionToken("SCHEDULER_TOKEN", {
            providedIn: "root",
            factory: () => defaultScheduler
        });
        class ComponentFactory$1 extends ComponentFactory {
            constructor(componentDef, ngModule) {
                super(), this.componentDef = componentDef, this.ngModule = ngModule, this.componentType = componentDef.type, this.selector = componentDef.selectors.map(stringifyCSSSelector).join(","), this.ngContentSelectors = componentDef.ngContentSelectors ? componentDef.ngContentSelectors : [], this.isBoundToModule = !!ngModule
            }
            get inputs() {
                return toRefArray(this.componentDef.inputs)
            }
            get outputs() {
                return toRefArray(this.componentDef.outputs)
            }
            create(injector, projectableNodes, rootSelectorOrNode, ngModule) {
                const rootViewInjector = (ngModule = ngModule || this.ngModule) ? function(rootViewInjector, moduleInjector) {
                        return {
                            get: (token, notFoundValue, flags) => {
                                const value = rootViewInjector.get(token, NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR, flags);
                                return value !== NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR || notFoundValue === NOT_FOUND_CHECK_ONLY_ELEMENT_INJECTOR ? value : moduleInjector.get(token, notFoundValue, flags)
                            }
                        }
                    }(injector, ngModule.injector) : injector,
                    rendererFactory = rootViewInjector.get(RendererFactory2, domRendererFactory3),
                    sanitizer = rootViewInjector.get(Sanitizer, null),
                    hostRenderer = rendererFactory.createRenderer(null, this.componentDef),
                    elementName = this.componentDef.selectors[0][0] || "div",
                    hostRNode = rootSelectorOrNode ? locateHostElement(hostRenderer, rootSelectorOrNode, this.componentDef.encapsulation) : createElementNode(rendererFactory.createRenderer(null, this.componentDef), elementName, function(elementName) {
                        const name = elementName.toLowerCase();
                        return "svg" === name ? "http://www.w3.org/2000/svg" : "math" === name ? "http://www.w3.org/1998/MathML/" : null
                    }(elementName)),
                    rootFlags = this.componentDef.onPush ? 576 : 528,
                    rootContext = createRootContext(),
                    rootTView = createTView(0, null, null, 1, 0, null, null, null, null, null),
                    rootLView = createLView(null, rootTView, rootContext, rootFlags, null, null, rendererFactory, hostRenderer, sanitizer, rootViewInjector);
                let component, tElementNode;
                enterView(rootLView);
                try {
                    const componentView = createRootComponentView(hostRNode, this.componentDef, rootLView, rendererFactory, hostRenderer);
                    if (hostRNode)
                        if (rootSelectorOrNode) setUpAttributes(hostRenderer, hostRNode, ["ng-version", VERSION.full]);
                        else {
                            const {
                                attrs: attrs,
                                classes: classes
                            } = function(selector) {
                                const attrs = [],
                                    classes = [];
                                let i = 1,
                                    mode = 2;
                                for (; i < selector.length;) {
                                    let valueOrMarker = selector[i];
                                    if ("string" == typeof valueOrMarker) 2 === mode ? "" !== valueOrMarker && attrs.push(valueOrMarker, selector[++i]) : 8 === mode && classes.push(valueOrMarker);
                                    else {
                                        if (!isPositive(mode)) break;
                                        mode = valueOrMarker
                                    }
                                    i++
                                }
                                return {
                                    attrs: attrs,
                                    classes: classes
                                }
                            }(this.componentDef.selectors[0]);
                            attrs && setUpAttributes(hostRenderer, hostRNode, attrs), classes && classes.length > 0 && writeDirectClass(hostRenderer, hostRNode, classes.join(" "))
                        }
                    if (tElementNode = getTNode(rootTView, 20), void 0 !== projectableNodes) {
                        const projection = tElementNode.projection = [];
                        for (let i = 0; i < this.ngContentSelectors.length; i++) {
                            const nodesforSlot = projectableNodes[i];
                            projection.push(null != nodesforSlot ? Array.from(nodesforSlot) : null)
                        }
                    }
                    component = createRootComponent(componentView, this.componentDef, rootLView, rootContext, [LifecycleHooksFeature]), renderView(rootTView, rootLView, null)
                } finally {
                    leaveView()
                }
                return new ComponentRef$1(this.componentType, component, createElementRef(tElementNode, rootLView), rootLView, tElementNode)
            }
        }
        new ComponentFactoryResolver$1;
        class ComponentRef$1 extends ComponentRef {
            constructor(componentType, instance, location, _rootLView, _tNode) {
                super(), this.location = location, this._rootLView = _rootLView, this._tNode = _tNode, this.instance = instance, this.hostView = this.changeDetectorRef = new RootViewRef(_rootLView), this.componentType = componentType
            }
            get injector() {
                return new NodeInjector(this._tNode, this._rootLView)
            }
            destroy() {
                this.hostView.destroy()
            }
            onDestroy(callback) {
                this.hostView.onDestroy(callback)
            }
        }
        new Map;
        class EventEmitter_ extends rxjs__WEBPACK_IMPORTED_MODULE_0__.a {
            constructor(isAsync = !1) {
                super(), this.__isAsync = isAsync
            }
            emit(value) {
                super.next(value)
            }
            subscribe(generatorOrNext, error, complete) {
                let schedulerFn, errorFn = err => null,
                    completeFn = () => null;
                generatorOrNext && "object" == typeof generatorOrNext ? (schedulerFn = this.__isAsync ? value => {
                    setTimeout((() => generatorOrNext.next(value)))
                } : value => {
                    generatorOrNext.next(value)
                }, generatorOrNext.error && (errorFn = this.__isAsync ? err => {
                    setTimeout((() => generatorOrNext.error(err)))
                } : err => {
                    generatorOrNext.error(err)
                }), generatorOrNext.complete && (completeFn = this.__isAsync ? () => {
                    setTimeout((() => generatorOrNext.complete()))
                } : () => {
                    generatorOrNext.complete()
                })) : (schedulerFn = this.__isAsync ? value => {
                    setTimeout((() => generatorOrNext(value)))
                } : value => {
                    generatorOrNext(value)
                }, error && (errorFn = this.__isAsync ? err => {
                    setTimeout((() => error(err)))
                } : err => {
                    error(err)
                }), complete && (completeFn = this.__isAsync ? () => {
                    setTimeout((() => complete()))
                } : () => {
                    complete()
                }));
                const sink = super.subscribe(schedulerFn, errorFn, completeFn);
                return generatorOrNext instanceof rxjs__WEBPACK_IMPORTED_MODULE_1__.a && generatorOrNext.add(sink), sink
            }
        }
        const EventEmitter = EventEmitter_;
        new Map, new Map;
        const Directive = makeDecorator("Directive", ((dir = {}) => dir), void 0, void 0, ((type, meta) => SWITCH_COMPILE_DIRECTIVE(type, meta))),
            Component = makeDecorator("Component", ((c = {}) => Object.assign({
                changeDetection: ChangeDetectionStrategy.Default
            }, c)), Directive, void 0, ((type, meta) => SWITCH_COMPILE_COMPONENT(type, meta))),
            Pipe = makeDecorator("Pipe", (p => Object.assign({
                pure: !0
            }, p)), void 0, void 0, ((type, meta) => SWITCH_COMPILE_PIPE(type, meta))),
            Input = makePropDecorator("Input", (bindingPropertyName => ({
                bindingPropertyName: bindingPropertyName
            }))),
            Output = makePropDecorator("Output", (bindingPropertyName => ({
                bindingPropertyName: bindingPropertyName
            }))),
            HostListener = (makePropDecorator("HostBinding", (hostPropertyName => ({
                hostPropertyName: hostPropertyName
            }))), makePropDecorator("HostListener", ((eventName, args) => ({
                eventName: eventName,
                args: args
            })))),
            SWITCH_COMPILE_COMPONENT = noop,
            SWITCH_COMPILE_DIRECTIVE = noop,
            SWITCH_COMPILE_PIPE = noop,
            NgModule = makeDecorator("NgModule", (ngModule => ngModule), void 0, void 0, ((type, meta) => SWITCH_COMPILE_NGMODULE(type, meta)));
        const SWITCH_COMPILE_NGMODULE = function(moduleType, metadata) {
                let imports = metadata && metadata.imports || [];
                metadata && metadata.exports && (imports = [...imports, metadata.exports]), moduleType.ɵinj = ɵɵdefineInjector({
                    factory: convertInjectableProviderToFactory(moduleType, {
                        useClass: moduleType
                    }),
                    providers: metadata && metadata.providers,
                    imports: imports
                })
            },
            APP_INITIALIZER = new InjectionToken("Application Initializer");
        class ApplicationInitStatus {
            constructor(appInits) {
                this.appInits = appInits, this.resolve = noop, this.reject = noop, this.initialized = !1, this.done = !1, this.donePromise = new Promise(((res, rej) => {
                    this.resolve = res, this.reject = rej
                }))
            }
            runInitializers() {
                if (this.initialized) return;
                const asyncInitPromises = [],
                    complete = () => {
                        this.done = !0, this.resolve()
                    };
                if (this.appInits)
                    for (let i = 0; i < this.appInits.length; i++) {
                        const initResult = this.appInits[i]();
                        isPromise(initResult) && asyncInitPromises.push(initResult)
                    }
                Promise.all(asyncInitPromises).then((() => {
                    complete()
                })).catch((e => {
                    this.reject(e)
                })), 0 === asyncInitPromises.length && complete(), this.initialized = !0
            }
        }
        ApplicationInitStatus.decorators = [{
            type: Injectable
        }], ApplicationInitStatus.ctorParameters = () => [{
            type: Array,
            decorators: [{
                type: Inject,
                args: [APP_INITIALIZER]
            }, {
                type: Optional
            }]
        }];
        const APP_ID = new InjectionToken("AppId");
        const APP_ID_RANDOM_PROVIDER = {
            provide: APP_ID,
            useFactory: function() {
                return `${_randomChar()}${_randomChar()}${_randomChar()}`
            },
            deps: []
        };

        function _randomChar() {
            return String.fromCharCode(97 + Math.floor(25 * Math.random()))
        }
        const PLATFORM_INITIALIZER = new InjectionToken("Platform Initializer"),
            PLATFORM_ID = new InjectionToken("Platform ID"),
            APP_BOOTSTRAP_LISTENER = new InjectionToken("appBootstrapListener");
        new InjectionToken("Application Packages Root URL");
        class Console {
            log(message) {
                console.log(message)
            }
            warn(message) {
                console.warn(message)
            }
        }
        Console.decorators = [{
            type: Injectable
        }];
        const LOCALE_ID$1 = new InjectionToken("LocaleId"),
            DEFAULT_CURRENCY_CODE = new InjectionToken("DefaultCurrencyCode");
        new InjectionToken("Translations"), new InjectionToken("TranslationsFormat");
        var MissingTranslationStrategy;
        ! function(MissingTranslationStrategy) {
            MissingTranslationStrategy[MissingTranslationStrategy.Error = 0] = "Error", MissingTranslationStrategy[MissingTranslationStrategy.Warning = 1] = "Warning", MissingTranslationStrategy[MissingTranslationStrategy.Ignore = 2] = "Ignore"
        }(MissingTranslationStrategy || (MissingTranslationStrategy = {}));

        function _throwError() {
            throw new Error("Runtime compiler is not loaded")
        }
        const Compiler_compileModuleSync = _throwError,
            Compiler_compileModuleAsync = _throwError,
            Compiler_compileModuleAndAllComponentsSync = _throwError,
            Compiler_compileModuleAndAllComponentsAsync = _throwError;
        class Compiler {
            constructor() {
                this.compileModuleSync = Compiler_compileModuleSync, this.compileModuleAsync = Compiler_compileModuleAsync, this.compileModuleAndAllComponentsSync = Compiler_compileModuleAndAllComponentsSync, this.compileModuleAndAllComponentsAsync = Compiler_compileModuleAndAllComponentsAsync
            }
            clearCache() {}
            clearCacheFor(type) {}
            getModuleId(moduleType) {}
        }
        Compiler.decorators = [{
            type: Injectable
        }];
        new InjectionToken("compilerOptions");
        class CompilerFactory {}
        const promise = Promise.resolve(0);

        function scheduleMicroTask(fn) {
            "undefined" == typeof Zone ? promise.then((() => {
                fn && fn.apply(null, null)
            })) : Zone.current.scheduleMicroTask("scheduleMicrotask", fn)
        }
        class NgZone {
            constructor({
                enableLongStackTrace: enableLongStackTrace = !1,
                shouldCoalesceEventChangeDetection: shouldCoalesceEventChangeDetection = !1
            }) {
                if (this.hasPendingMacrotasks = !1, this.hasPendingMicrotasks = !1, this.isStable = !0, this.onUnstable = new EventEmitter(!1), this.onMicrotaskEmpty = new EventEmitter(!1), this.onStable = new EventEmitter(!1), this.onError = new EventEmitter(!1), "undefined" == typeof Zone) throw new Error("In this configuration Angular requires Zone.js");
                Zone.assertZonePatched();
                const self = this;
                self._nesting = 0, self._outer = self._inner = Zone.current, Zone.TaskTrackingZoneSpec && (self._inner = self._inner.fork(new Zone.TaskTrackingZoneSpec)), enableLongStackTrace && Zone.longStackTraceZoneSpec && (self._inner = self._inner.fork(Zone.longStackTraceZoneSpec)), self.shouldCoalesceEventChangeDetection = shouldCoalesceEventChangeDetection, self.lastRequestAnimationFrameId = -1, self.nativeRequestAnimationFrame = function() {
                        let nativeRequestAnimationFrame = _global.requestAnimationFrame,
                            nativeCancelAnimationFrame = _global.cancelAnimationFrame;
                        if ("undefined" != typeof Zone && nativeRequestAnimationFrame && nativeCancelAnimationFrame) {
                            const unpatchedRequestAnimationFrame = nativeRequestAnimationFrame[Zone.__symbol__("OriginalDelegate")];
                            unpatchedRequestAnimationFrame && (nativeRequestAnimationFrame = unpatchedRequestAnimationFrame);
                            const unpatchedCancelAnimationFrame = nativeCancelAnimationFrame[Zone.__symbol__("OriginalDelegate")];
                            unpatchedCancelAnimationFrame && (nativeCancelAnimationFrame = unpatchedCancelAnimationFrame)
                        }
                        return {
                            nativeRequestAnimationFrame: nativeRequestAnimationFrame,
                            nativeCancelAnimationFrame: nativeCancelAnimationFrame
                        }
                    }().nativeRequestAnimationFrame,
                    function(zone) {
                        const delayChangeDetectionForEventsDelegate = () => {
                                ! function(zone) {
                                    if (-1 !== zone.lastRequestAnimationFrameId) return;
                                    zone.lastRequestAnimationFrameId = zone.nativeRequestAnimationFrame.call(_global, (() => {
                                        zone.fakeTopEventTask || (zone.fakeTopEventTask = Zone.root.scheduleEventTask("fakeTopEventTask", (() => {
                                            zone.lastRequestAnimationFrameId = -1, updateMicroTaskStatus(zone), checkStable(zone)
                                        }), void 0, (() => {}), (() => {}))), zone.fakeTopEventTask.invoke()
                                    })), updateMicroTaskStatus(zone)
                                }(zone)
                            },
                            maybeDelayChangeDetection = !!zone.shouldCoalesceEventChangeDetection && zone.nativeRequestAnimationFrame && delayChangeDetectionForEventsDelegate;
                        zone._inner = zone._inner.fork({
                            name: "angular",
                            properties: {
                                isAngularZone: !0,
                                maybeDelayChangeDetection: maybeDelayChangeDetection
                            },
                            onInvokeTask: (delegate, current, target, task, applyThis, applyArgs) => {
                                try {
                                    return onEnter(zone), delegate.invokeTask(target, task, applyThis, applyArgs)
                                } finally {
                                    maybeDelayChangeDetection && "eventTask" === task.type && maybeDelayChangeDetection(), onLeave(zone)
                                }
                            },
                            onInvoke: (delegate, current, target, callback, applyThis, applyArgs, source) => {
                                try {
                                    return onEnter(zone), delegate.invoke(target, callback, applyThis, applyArgs, source)
                                } finally {
                                    onLeave(zone)
                                }
                            },
                            onHasTask: (delegate, current, target, hasTaskState) => {
                                delegate.hasTask(target, hasTaskState), current === target && ("microTask" == hasTaskState.change ? (zone._hasPendingMicrotasks = hasTaskState.microTask, updateMicroTaskStatus(zone), checkStable(zone)) : "macroTask" == hasTaskState.change && (zone.hasPendingMacrotasks = hasTaskState.macroTask))
                            },
                            onHandleError: (delegate, current, target, error) => (delegate.handleError(target, error), zone.runOutsideAngular((() => zone.onError.emit(error))), !1)
                        })
                    }(self)
            }
            static isInAngularZone() {
                return !0 === Zone.current.get("isAngularZone")
            }
            static assertInAngularZone() {
                if (!NgZone.isInAngularZone()) throw new Error("Expected to be in Angular Zone, but it is not!")
            }
            static assertNotInAngularZone() {
                if (NgZone.isInAngularZone()) throw new Error("Expected to not be in Angular Zone, but it is!")
            }
            run(fn, applyThis, applyArgs) {
                return this._inner.run(fn, applyThis, applyArgs)
            }
            runTask(fn, applyThis, applyArgs, name) {
                const zone = this._inner,
                    task = zone.scheduleEventTask("NgZoneEvent: " + name, fn, EMPTY_PAYLOAD, noop, noop);
                try {
                    return zone.runTask(task, applyThis, applyArgs)
                } finally {
                    zone.cancelTask(task)
                }
            }
            runGuarded(fn, applyThis, applyArgs) {
                return this._inner.runGuarded(fn, applyThis, applyArgs)
            }
            runOutsideAngular(fn) {
                return this._outer.run(fn)
            }
        }
        const EMPTY_PAYLOAD = {};

        function checkStable(zone) {
            if (0 == zone._nesting && !zone.hasPendingMicrotasks && !zone.isStable) try {
                zone._nesting++, zone.onMicrotaskEmpty.emit(null)
            } finally {
                if (zone._nesting--, !zone.hasPendingMicrotasks) try {
                    zone.runOutsideAngular((() => zone.onStable.emit(null)))
                } finally {
                    zone.isStable = !0
                }
            }
        }

        function updateMicroTaskStatus(zone) {
            zone._hasPendingMicrotasks || zone.shouldCoalesceEventChangeDetection && -1 !== zone.lastRequestAnimationFrameId ? zone.hasPendingMicrotasks = !0 : zone.hasPendingMicrotasks = !1
        }

        function onEnter(zone) {
            zone._nesting++, zone.isStable && (zone.isStable = !1, zone.onUnstable.emit(null))
        }

        function onLeave(zone) {
            zone._nesting--, checkStable(zone)
        }
        class NoopNgZone {
            constructor() {
                this.hasPendingMicrotasks = !1, this.hasPendingMacrotasks = !1, this.isStable = !0, this.onUnstable = new EventEmitter, this.onMicrotaskEmpty = new EventEmitter, this.onStable = new EventEmitter, this.onError = new EventEmitter
            }
            run(fn, applyThis, applyArgs) {
                return fn.apply(applyThis, applyArgs)
            }
            runGuarded(fn, applyThis, applyArgs) {
                return fn.apply(applyThis, applyArgs)
            }
            runOutsideAngular(fn) {
                return fn()
            }
            runTask(fn, applyThis, applyArgs, name) {
                return fn.apply(applyThis, applyArgs)
            }
        }
        class Testability {
            constructor(_ngZone) {
                this._ngZone = _ngZone, this._pendingCount = 0, this._isZoneStable = !0, this._didWork = !1, this._callbacks = [], this.taskTrackingZone = null, this._watchAngularEvents(), _ngZone.run((() => {
                    this.taskTrackingZone = "undefined" == typeof Zone ? null : Zone.current.get("TaskTrackingZone")
                }))
            }
            _watchAngularEvents() {
                this._ngZone.onUnstable.subscribe({
                    next: () => {
                        this._didWork = !0, this._isZoneStable = !1
                    }
                }), this._ngZone.runOutsideAngular((() => {
                    this._ngZone.onStable.subscribe({
                        next: () => {
                            NgZone.assertNotInAngularZone(), scheduleMicroTask((() => {
                                this._isZoneStable = !0, this._runCallbacksIfReady()
                            }))
                        }
                    })
                }))
            }
            increasePendingRequestCount() {
                return this._pendingCount += 1, this._didWork = !0, this._pendingCount
            }
            decreasePendingRequestCount() {
                if (this._pendingCount -= 1, this._pendingCount < 0) throw new Error("pending async requests below zero");
                return this._runCallbacksIfReady(), this._pendingCount
            }
            isStable() {
                return this._isZoneStable && 0 === this._pendingCount && !this._ngZone.hasPendingMacrotasks
            }
            _runCallbacksIfReady() {
                if (this.isStable()) scheduleMicroTask((() => {
                    for (; 0 !== this._callbacks.length;) {
                        let cb = this._callbacks.pop();
                        clearTimeout(cb.timeoutId), cb.doneCb(this._didWork)
                    }
                    this._didWork = !1
                }));
                else {
                    let pending = this.getPendingTasks();
                    this._callbacks = this._callbacks.filter((cb => !cb.updateCb || !cb.updateCb(pending) || (clearTimeout(cb.timeoutId), !1))), this._didWork = !0
                }
            }
            getPendingTasks() {
                return this.taskTrackingZone ? this.taskTrackingZone.macroTasks.map((t => ({
                    source: t.source,
                    creationLocation: t.creationLocation,
                    data: t.data
                }))) : []
            }
            addCallback(cb, timeout, updateCb) {
                let timeoutId = -1;
                timeout && timeout > 0 && (timeoutId = setTimeout((() => {
                    this._callbacks = this._callbacks.filter((cb => cb.timeoutId !== timeoutId)), cb(this._didWork, this.getPendingTasks())
                }), timeout)), this._callbacks.push({
                    doneCb: cb,
                    timeoutId: timeoutId,
                    updateCb: updateCb
                })
            }
            whenStable(doneCb, timeout, updateCb) {
                if (updateCb && !this.taskTrackingZone) throw new Error('Task tracking zone is required when passing an update callback to whenStable(). Is "zone.js/dist/task-tracking.js" loaded?');
                this.addCallback(doneCb, timeout, updateCb), this._runCallbacksIfReady()
            }
            getPendingRequestCount() {
                return this._pendingCount
            }
            findProviders(using, provider, exactMatch) {
                return []
            }
        }
        Testability.decorators = [{
            type: Injectable
        }], Testability.ctorParameters = () => [{
            type: NgZone
        }];
        class TestabilityRegistry {
            constructor() {
                this._applications = new Map, _testabilityGetter.addToWindow(this)
            }
            registerApplication(token, testability) {
                this._applications.set(token, testability)
            }
            unregisterApplication(token) {
                this._applications.delete(token)
            }
            unregisterAllApplications() {
                this._applications.clear()
            }
            getTestability(elem) {
                return this._applications.get(elem) || null
            }
            getAllTestabilities() {
                return Array.from(this._applications.values())
            }
            getAllRootElements() {
                return Array.from(this._applications.keys())
            }
            findTestabilityInTree(elem, findInAncestors = !0) {
                return _testabilityGetter.findTestabilityInTree(this, elem, findInAncestors)
            }
        }
        TestabilityRegistry.decorators = [{
            type: Injectable
        }], TestabilityRegistry.ctorParameters = () => [];

        function setTestabilityGetter(getter) {
            _testabilityGetter = getter
        }
        let _platform, _testabilityGetter = new class {
                addToWindow(registry) {}
                findTestabilityInTree(registry, elem, findInAncestors) {
                    return null
                }
            },
            _devMode = !0,
            _runModeLocked = !1;

        function isDevMode() {
            return _runModeLocked = !0, _devMode
        }
        let compileNgModuleFactory = function(injector, options, moduleType) {
            const compilerFactory = injector.get(CompilerFactory);
            return compilerFactory.createCompiler([options]).compileModuleAsync(moduleType)
        };
        let publishDefaultGlobalUtils$1 = function() {},
            isBoundToModule = function(cf) {
                return cf instanceof ComponentFactoryBoundToModule
            };
        const ALLOW_MULTIPLE_PLATFORMS = new InjectionToken("AllowMultipleToken");
        class NgProbeToken {
            constructor(name, token) {
                this.name = name, this.token = token
            }
        }

        function createPlatformFactory(parentPlatformFactory, name, providers = []) {
            const desc = `Platform: ${name}`,
                marker = new InjectionToken(desc);
            return (extraProviders = []) => {
                let platform = getPlatform();
                if (!platform || platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, !1))
                    if (parentPlatformFactory) parentPlatformFactory(providers.concat(extraProviders).concat({
                        provide: marker,
                        useValue: !0
                    }));
                    else {
                        const injectedProviders = providers.concat(extraProviders).concat({
                            provide: marker,
                            useValue: !0
                        }, {
                            provide: INJECTOR_SCOPE,
                            useValue: "platform"
                        });
                        ! function(injector) {
                            if (_platform && !_platform.destroyed && !_platform.injector.get(ALLOW_MULTIPLE_PLATFORMS, !1)) throw new Error("There can be only one platform. Destroy the previous one to create a new one.");
                            publishDefaultGlobalUtils$1(), _platform = injector.get(PlatformRef);
                            const inits = injector.get(PLATFORM_INITIALIZER, null);
                            inits && inits.forEach((init => init()))
                        }(Injector.create({
                            providers: injectedProviders,
                            name: desc
                        }))
                    }
                return function(requiredToken) {
                    const platform = getPlatform();
                    if (!platform) throw new Error("No platform exists!");
                    if (!platform.injector.get(requiredToken, null)) throw new Error("A platform with a different configuration has been created. Please destroy it first.");
                    return platform
                }(marker)
            }
        }

        function getPlatform() {
            return _platform && !_platform.destroyed ? _platform : null
        }
        class PlatformRef {
            constructor(_injector) {
                this._injector = _injector, this._modules = [], this._destroyListeners = [], this._destroyed = !1
            }
            bootstrapModuleFactory(moduleFactory, options) {
                const ngZone = function(ngZoneOption, ngZoneEventCoalescing) {
                        let ngZone;
                        ngZone = "noop" === ngZoneOption ? new NoopNgZone : ("zone.js" === ngZoneOption ? void 0 : ngZoneOption) || new NgZone({
                            enableLongStackTrace: isDevMode(),
                            shouldCoalesceEventChangeDetection: ngZoneEventCoalescing
                        });
                        return ngZone
                    }(options ? options.ngZone : void 0, options && options.ngZoneEventCoalescing || !1),
                    providers = [{
                        provide: NgZone,
                        useValue: ngZone
                    }];
                return ngZone.run((() => {
                    const ngZoneInjector = Injector.create({
                            providers: providers,
                            parent: this.injector,
                            name: moduleFactory.moduleType.name
                        }),
                        moduleRef = moduleFactory.create(ngZoneInjector),
                        exceptionHandler = moduleRef.injector.get(ErrorHandler, null);
                    if (!exceptionHandler) throw new Error("No ErrorHandler. Is platform module (BrowserModule) included?");
                    return ngZone.runOutsideAngular((() => {
                            const subscription = ngZone.onError.subscribe({
                                next: error => {
                                    exceptionHandler.handleError(error)
                                }
                            });
                            moduleRef.onDestroy((() => {
                                remove(this._modules, moduleRef), subscription.unsubscribe()
                            }))
                        })),
                        function(errorHandler, ngZone, callback) {
                            try {
                                const result = callback();
                                return isPromise(result) ? result.catch((e => {
                                    throw ngZone.runOutsideAngular((() => errorHandler.handleError(e))), e
                                })) : result
                            } catch (e) {
                                throw ngZone.runOutsideAngular((() => errorHandler.handleError(e))), e
                            }
                        }(exceptionHandler, ngZone, (() => {
                            const initStatus = moduleRef.injector.get(ApplicationInitStatus);
                            return initStatus.runInitializers(), initStatus.donePromise.then((() => (this._moduleDoBootstrap(moduleRef), moduleRef)))
                        }))
                }))
            }
            bootstrapModule(moduleType, compilerOptions = []) {
                const options = optionsReducer({}, compilerOptions);
                return compileNgModuleFactory(this.injector, options, moduleType).then((moduleFactory => this.bootstrapModuleFactory(moduleFactory, options)))
            }
            _moduleDoBootstrap(moduleRef) {
                const appRef = moduleRef.injector.get(ApplicationRef);
                if (moduleRef._bootstrapComponents.length > 0) moduleRef._bootstrapComponents.forEach((f => appRef.bootstrap(f)));
                else {
                    if (!moduleRef.instance.ngDoBootstrap) throw new Error(`The module ${stringify(moduleRef.instance.constructor)} was bootstrapped, but it does not declare "@NgModule.bootstrap" components nor a "ngDoBootstrap" method. Please define one of these.`);
                    moduleRef.instance.ngDoBootstrap(appRef)
                }
                this._modules.push(moduleRef)
            }
            onDestroy(callback) {
                this._destroyListeners.push(callback)
            }
            get injector() {
                return this._injector
            }
            destroy() {
                if (this._destroyed) throw new Error("The platform has already been destroyed!");
                this._modules.slice().forEach((module => module.destroy())), this._destroyListeners.forEach((listener => listener())), this._destroyed = !0
            }
            get destroyed() {
                return this._destroyed
            }
        }

        function optionsReducer(dst, objs) {
            return dst = Array.isArray(objs) ? objs.reduce(optionsReducer, dst) : Object.assign(Object.assign({}, dst), objs)
        }
        PlatformRef.decorators = [{
            type: Injectable
        }], PlatformRef.ctorParameters = () => [{
            type: Injector
        }];
        class ApplicationRef {
            constructor(_zone, _console, _injector, _exceptionHandler, _componentFactoryResolver, _initStatus) {
                this._zone = _zone, this._console = _console, this._injector = _injector, this._exceptionHandler = _exceptionHandler, this._componentFactoryResolver = _componentFactoryResolver, this._initStatus = _initStatus, this._bootstrapListeners = [], this._views = [], this._runningTick = !1, this._stable = !0, this.componentTypes = [], this.components = [], this._onMicrotaskEmptySubscription = this._zone.onMicrotaskEmpty.subscribe({
                    next: () => {
                        this._zone.run((() => {
                            this.tick()
                        }))
                    }
                });
                const isCurrentlyStable = new rxjs__WEBPACK_IMPORTED_MODULE_2__.a((observer => {
                        this._stable = this._zone.isStable && !this._zone.hasPendingMacrotasks && !this._zone.hasPendingMicrotasks, this._zone.runOutsideAngular((() => {
                            observer.next(this._stable), observer.complete()
                        }))
                    })),
                    isStable = new rxjs__WEBPACK_IMPORTED_MODULE_2__.a((observer => {
                        let stableSub;
                        this._zone.runOutsideAngular((() => {
                            stableSub = this._zone.onStable.subscribe((() => {
                                NgZone.assertNotInAngularZone(), scheduleMicroTask((() => {
                                    this._stable || this._zone.hasPendingMacrotasks || this._zone.hasPendingMicrotasks || (this._stable = !0, observer.next(!0))
                                }))
                            }))
                        }));
                        const unstableSub = this._zone.onUnstable.subscribe((() => {
                            NgZone.assertInAngularZone(), this._stable && (this._stable = !1, this._zone.runOutsideAngular((() => {
                                observer.next(!1)
                            })))
                        }));
                        return () => {
                            stableSub.unsubscribe(), unstableSub.unsubscribe()
                        }
                    }));
                this.isStable = Object(rxjs__WEBPACK_IMPORTED_MODULE_3__.a)(isCurrentlyStable, isStable.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_4__.a)()))
            }
            bootstrap(componentOrFactory, rootSelectorOrNode) {
                if (!this._initStatus.done) throw new Error("Cannot bootstrap as there are still asynchronous initializers running. Bootstrap components in the `ngDoBootstrap` method of the root module.");
                let componentFactory;
                componentFactory = componentOrFactory instanceof ComponentFactory ? componentOrFactory : this._componentFactoryResolver.resolveComponentFactory(componentOrFactory), this.componentTypes.push(componentFactory.componentType);
                const ngModule = isBoundToModule(componentFactory) ? void 0 : this._injector.get(NgModuleRef),
                    selectorOrNode = rootSelectorOrNode || componentFactory.selector,
                    compRef = componentFactory.create(Injector.NULL, [], selectorOrNode, ngModule),
                    nativeElement = compRef.location.nativeElement,
                    testability = compRef.injector.get(Testability, null),
                    testabilityRegistry = testability && compRef.injector.get(TestabilityRegistry);
                return testability && testabilityRegistry && testabilityRegistry.registerApplication(nativeElement, testability), compRef.onDestroy((() => {
                    this.detachView(compRef.hostView), remove(this.components, compRef), testabilityRegistry && testabilityRegistry.unregisterApplication(nativeElement)
                })), this._loadComponent(compRef), isDevMode() && this._console.log("Angular is running in development mode. Call enableProdMode() to enable production mode."), compRef
            }
            tick() {
                if (this._runningTick) throw new Error("ApplicationRef.tick is called recursively");
                try {
                    this._runningTick = !0;
                    for (let view of this._views) view.detectChanges();
                    if (("undefined" == typeof ngDevMode || ngDevMode) && isDevMode())
                        for (let view of this._views) view.checkNoChanges()
                } catch (e) {
                    this._zone.runOutsideAngular((() => this._exceptionHandler.handleError(e)))
                } finally {
                    this._runningTick = !1
                }
            }
            attachView(viewRef) {
                const view = viewRef;
                this._views.push(view), view.attachToAppRef(this)
            }
            detachView(viewRef) {
                const view = viewRef;
                remove(this._views, view), view.detachFromAppRef()
            }
            _loadComponent(componentRef) {
                this.attachView(componentRef.hostView), this.tick(), this.components.push(componentRef);
                this._injector.get(APP_BOOTSTRAP_LISTENER, []).concat(this._bootstrapListeners).forEach((listener => listener(componentRef)))
            }
            ngOnDestroy() {
                this._views.slice().forEach((view => view.destroy())), this._onMicrotaskEmptySubscription.unsubscribe()
            }
            get viewCount() {
                return this._views.length
            }
        }

        function remove(list, el) {
            const index = list.indexOf(el);
            index > -1 && list.splice(index, 1)
        }
        ApplicationRef.decorators = [{
            type: Injectable
        }], ApplicationRef.ctorParameters = () => [{
            type: NgZone
        }, {
            type: Console
        }, {
            type: Injector
        }, {
            type: ErrorHandler
        }, {
            type: ComponentFactoryResolver
        }, {
            type: ApplicationInitStatus
        }];
        class NgModuleFactoryLoader {}
        class SystemJsNgModuleLoaderConfig {}
        const DEFAULT_CONFIG = {
            factoryPathPrefix: "",
            factoryPathSuffix: ".ngfactory"
        };
        class SystemJsNgModuleLoader {
            constructor(_compiler, config) {
                this._compiler = _compiler, this._config = config || DEFAULT_CONFIG
            }
            load(path) {
                return this._compiler instanceof Compiler ? this.loadFactory(path) : this.loadAndCompile(path)
            }
            loadAndCompile(path) {
                let [module, exportName] = path.split("#");
                return void 0 === exportName && (exportName = "default"), __webpack_require__(256)(module).then((module => module[exportName])).then((type => checkNotEmpty(type, module, exportName))).then((type => this._compiler.compileModuleAsync(type)))
            }
            loadFactory(path) {
                let [module, exportName] = path.split("#"), factoryClassSuffix = "NgFactory";
                return void 0 === exportName && (exportName = "default", factoryClassSuffix = ""), __webpack_require__(256)(this._config.factoryPathPrefix + module + this._config.factoryPathSuffix).then((module => module[exportName + factoryClassSuffix])).then((factory => checkNotEmpty(factory, module, exportName)))
            }
        }

        function checkNotEmpty(value, modulePath, exportName) {
            if (!value) throw new Error(`Cannot find '${exportName}' in '${modulePath}'`);
            return value
        }
        SystemJsNgModuleLoader.decorators = [{
            type: Injectable
        }], SystemJsNgModuleLoader.ctorParameters = () => [{
            type: Compiler
        }, {
            type: SystemJsNgModuleLoaderConfig,
            decorators: [{
                type: Optional
            }]
        }];
        const _nativeNodeToDebugNode = new Map;

        function getDebugNode__PRE_R3__(nativeNode) {
            return _nativeNodeToDebugNode.get(nativeNode) || null
        }
        const getDebugNodeR2 = function(nativeNode) {
            return getDebugNode__PRE_R3__(nativeNode)
        };
        const platformCore = createPlatformFactory(null, "core", [{
            provide: PLATFORM_ID,
            useValue: "unknown"
        }, {
            provide: PlatformRef,
            deps: [Injector]
        }, {
            provide: TestabilityRegistry,
            deps: []
        }, {
            provide: Console,
            deps: []
        }]);
        const APPLICATION_MODULE_PROVIDERS = [{
            provide: ApplicationRef,
            useClass: ApplicationRef,
            deps: [NgZone, Console, Injector, ErrorHandler, ComponentFactoryResolver, ApplicationInitStatus]
        }, {
            provide: SCHEDULER,
            deps: [NgZone],
            useFactory: function(ngZone) {
                let queue = [];
                return ngZone.onStable.subscribe((() => {
                        for (; queue.length;) queue.pop()()
                    })),
                    function(fn) {
                        queue.push(fn)
                    }
            }
        }, {
            provide: ApplicationInitStatus,
            useClass: ApplicationInitStatus,
            deps: [
                [new Optional, APP_INITIALIZER]
            ]
        }, {
            provide: Compiler,
            useClass: Compiler,
            deps: []
        }, APP_ID_RANDOM_PROVIDER, {
            provide: IterableDiffers,
            useFactory: function() {
                return defaultIterableDiffers
            },
            deps: []
        }, {
            provide: KeyValueDiffers,
            useFactory: function() {
                return defaultKeyValueDiffers
            },
            deps: []
        }, {
            provide: LOCALE_ID$1,
            useFactory: function(locale) {
                return locale = locale || ("undefined" != typeof ngI18nClosureMode && ngI18nClosureMode && "undefined" != typeof goog && "en" !== goog.LOCALE ? goog.LOCALE : "en-US")
            },
            deps: [
                [new Inject(LOCALE_ID$1), new Optional, new SkipSelf]
            ]
        }, {
            provide: DEFAULT_CURRENCY_CODE,
            useValue: "USD"
        }];
        class ApplicationModule {
            constructor(appRef) {}
        }
        var ViewAction;
        ApplicationModule.decorators = [{
                type: NgModule,
                args: [{
                    providers: APPLICATION_MODULE_PROVIDERS
                }]
            }], ApplicationModule.ctorParameters = () => [{
                type: ApplicationRef
            }],
            function(ViewAction) {
                ViewAction[ViewAction.CreateViewNodes = 0] = "CreateViewNodes", ViewAction[ViewAction.CheckNoChanges = 1] = "CheckNoChanges", ViewAction[ViewAction.CheckNoChangesProjectedViews = 2] = "CheckNoChangesProjectedViews", ViewAction[ViewAction.CheckAndUpdate = 3] = "CheckAndUpdate", ViewAction[ViewAction.CheckAndUpdateProjectedViews = 4] = "CheckAndUpdateProjectedViews", ViewAction[ViewAction.Destroy = 5] = "Destroy"
            }(ViewAction || (ViewAction = {}));
        new Map, new Map, new Map;
        var DebugAction;
        ! function(DebugAction) {
            DebugAction[DebugAction.create = 0] = "create", DebugAction[DebugAction.detectChanges = 1] = "detectChanges", DebugAction[DebugAction.checkNoChanges = 2] = "checkNoChanges", DebugAction[DebugAction.destroy = 3] = "destroy", DebugAction[DebugAction.handleEvent = 4] = "handleEvent"
        }(DebugAction || (DebugAction = {}));
        "undefined" != typeof ngDevMode && ngDevMode && (_global.$localize = _global.$localize || function() {
            throw new Error("It looks like your application or one of its dependencies is using i18n.\nAngular 9 introduced a global `$localize()` function that needs to be loaded.\nPlease run `ng add @angular/localize` from the Angular CLI.\n(For non-CLI projects, add `import '@angular/localize/init';` to your `polyfills.ts` file.\nFor server-side rendering applications add the import to your `main.server.ts` file.)")
        })
    }).call(this, __webpack_require__(65))
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var _common_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6);
    __webpack_require__.d(__webpack_exports__, "anyTrueR", (function() {
        return _common_index__WEBPACK_IMPORTED_MODULE_0__.b
    })), __webpack_require__.d(__webpack_exports__, "applyPairs", (function() {
        return _common_index__WEBPACK_IMPORTED_MODULE_0__.c
    })), __webpack_require__.d(__webpack_exports__, "createProxyFunctions", (function() {
        return _common_index__WEBPACK_IMPORTED_MODULE_0__.e
    })), __webpack_require__.d(__webpack_exports__, "extend", (function() {
        return _common_index__WEBPACK_IMPORTED_MODULE_0__.h
    })), __webpack_require__.d(__webpack_exports__, "filter", (function() {
        return _common_index__WEBPACK_IMPORTED_MODULE_0__.i
    })), __webpack_require__.d(__webpack_exports__, "forEach", (function() {
        return _common_index__WEBPACK_IMPORTED_MODULE_0__.k
    })), __webpack_require__.d(__webpack_exports__, "identity", (function() {
        return _common_index__WEBPACK_IMPORTED_MODULE_0__.l
    })), __webpack_require__.d(__webpack_exports__, "inArray", (function() {
        return _common_index__WEBPACK_IMPORTED_MODULE_0__.m
    })), __webpack_require__.d(__webpack_exports__, "is", (function() {
        return _common_index__WEBPACK_IMPORTED_MODULE_0__.n
    })), __webpack_require__.d(__webpack_exports__, "isArray", (function() {
        return _common_index__WEBPACK_IMPORTED_MODULE_0__.o
    })), __webpack_require__.d(__webpack_exports__, "isDefined", (function() {
        return _common_index__WEBPACK_IMPORTED_MODULE_0__.p
    })), __webpack_require__.d(__webpack_exports__, "isFunction", (function() {
        return _common_index__WEBPACK_IMPORTED_MODULE_0__.q
    })), __webpack_require__.d(__webpack_exports__, "isInjectable", (function() {
        return _common_index__WEBPACK_IMPORTED_MODULE_0__.r
    })), __webpack_require__.d(__webpack_exports__, "isNullOrUndefined", (function() {
        return _common_index__WEBPACK_IMPORTED_MODULE_0__.s
    })), __webpack_require__.d(__webpack_exports__, "isNumber", (function() {
        return _common_index__WEBPACK_IMPORTED_MODULE_0__.t
    })), __webpack_require__.d(__webpack_exports__, "isObject", (function() {
        return _common_index__WEBPACK_IMPORTED_MODULE_0__.u
    })), __webpack_require__.d(__webpack_exports__, "isString", (function() {
        return _common_index__WEBPACK_IMPORTED_MODULE_0__.v
    })), __webpack_require__.d(__webpack_exports__, "kebobString", (function() {
        return _common_index__WEBPACK_IMPORTED_MODULE_0__.x
    })), __webpack_require__.d(__webpack_exports__, "noop", (function() {
        return _common_index__WEBPACK_IMPORTED_MODULE_0__.A
    })), __webpack_require__.d(__webpack_exports__, "parse", (function() {
        return _common_index__WEBPACK_IMPORTED_MODULE_0__.B
    })), __webpack_require__.d(__webpack_exports__, "pick", (function() {
        return _common_index__WEBPACK_IMPORTED_MODULE_0__.D
    })), __webpack_require__.d(__webpack_exports__, "removeFrom", (function() {
        return _common_index__WEBPACK_IMPORTED_MODULE_0__.F
    })), __webpack_require__.d(__webpack_exports__, "services", (function() {
        return _common_index__WEBPACK_IMPORTED_MODULE_0__.H
    })), __webpack_require__.d(__webpack_exports__, "tail", (function() {
        return _common_index__WEBPACK_IMPORTED_MODULE_0__.M
    })), __webpack_require__.d(__webpack_exports__, "trace", (function() {
        return _common_index__WEBPACK_IMPORTED_MODULE_0__.N
    })), __webpack_require__.d(__webpack_exports__, "uniqR", (function() {
        return _common_index__WEBPACK_IMPORTED_MODULE_0__.P
    })), __webpack_require__.d(__webpack_exports__, "unnestR", (function() {
        return _common_index__WEBPACK_IMPORTED_MODULE_0__.Q
    })), __webpack_require__.d(__webpack_exports__, "val", (function() {
        return _common_index__WEBPACK_IMPORTED_MODULE_0__.R
    }));
    var _params_index__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(27);
    __webpack_require__.o(_params_index__WEBPACK_IMPORTED_MODULE_1__, "BaseLocationServices") && __webpack_require__.d(__webpack_exports__, "BaseLocationServices", (function() {
        return _params_index__WEBPACK_IMPORTED_MODULE_1__.BaseLocationServices
    })), __webpack_require__.o(_params_index__WEBPACK_IMPORTED_MODULE_1__, "BaseUrlRule") && __webpack_require__.d(__webpack_exports__, "BaseUrlRule", (function() {
        return _params_index__WEBPACK_IMPORTED_MODULE_1__.BaseUrlRule
    })), __webpack_require__.o(_params_index__WEBPACK_IMPORTED_MODULE_1__, "BrowserLocationConfig") && __webpack_require__.d(__webpack_exports__, "BrowserLocationConfig", (function() {
        return _params_index__WEBPACK_IMPORTED_MODULE_1__.BrowserLocationConfig
    })), __webpack_require__.o(_params_index__WEBPACK_IMPORTED_MODULE_1__, "NATIVE_INJECTOR_TOKEN") && __webpack_require__.d(__webpack_exports__, "NATIVE_INJECTOR_TOKEN", (function() {
        return _params_index__WEBPACK_IMPORTED_MODULE_1__.NATIVE_INJECTOR_TOKEN
    })), __webpack_require__.o(_params_index__WEBPACK_IMPORTED_MODULE_1__, "Param") && __webpack_require__.d(__webpack_exports__, "Param", (function() {
        return _params_index__WEBPACK_IMPORTED_MODULE_1__.Param
    })), __webpack_require__.o(_params_index__WEBPACK_IMPORTED_MODULE_1__, "PathUtils") && __webpack_require__.d(__webpack_exports__, "PathUtils", (function() {
        return _params_index__WEBPACK_IMPORTED_MODULE_1__.PathUtils
    })), __webpack_require__.o(_params_index__WEBPACK_IMPORTED_MODULE_1__, "Resolvable") && __webpack_require__.d(__webpack_exports__, "Resolvable", (function() {
        return _params_index__WEBPACK_IMPORTED_MODULE_1__.Resolvable
    })), __webpack_require__.o(_params_index__WEBPACK_IMPORTED_MODULE_1__, "ResolveContext") && __webpack_require__.d(__webpack_exports__, "ResolveContext", (function() {
        return _params_index__WEBPACK_IMPORTED_MODULE_1__.ResolveContext
    })), __webpack_require__.o(_params_index__WEBPACK_IMPORTED_MODULE_1__, "StateRegistry") && __webpack_require__.d(__webpack_exports__, "StateRegistry", (function() {
        return _params_index__WEBPACK_IMPORTED_MODULE_1__.StateRegistry
    })), __webpack_require__.o(_params_index__WEBPACK_IMPORTED_MODULE_1__, "StateService") && __webpack_require__.d(__webpack_exports__, "StateService", (function() {
        return _params_index__WEBPACK_IMPORTED_MODULE_1__.StateService
    })), __webpack_require__.o(_params_index__WEBPACK_IMPORTED_MODULE_1__, "TransitionService") && __webpack_require__.d(__webpack_exports__, "TransitionService", (function() {
        return _params_index__WEBPACK_IMPORTED_MODULE_1__.TransitionService
    })), __webpack_require__.o(_params_index__WEBPACK_IMPORTED_MODULE_1__, "UIRouter") && __webpack_require__.d(__webpack_exports__, "UIRouter", (function() {
        return _params_index__WEBPACK_IMPORTED_MODULE_1__.UIRouter
    })), __webpack_require__.o(_params_index__WEBPACK_IMPORTED_MODULE_1__, "UIRouterGlobals") && __webpack_require__.d(__webpack_exports__, "UIRouterGlobals", (function() {
        return _params_index__WEBPACK_IMPORTED_MODULE_1__.UIRouterGlobals
    })), __webpack_require__.o(_params_index__WEBPACK_IMPORTED_MODULE_1__, "UrlMatcherFactory") && __webpack_require__.d(__webpack_exports__, "UrlMatcherFactory", (function() {
        return _params_index__WEBPACK_IMPORTED_MODULE_1__.UrlMatcherFactory
    })), __webpack_require__.o(_params_index__WEBPACK_IMPORTED_MODULE_1__, "UrlRouter") && __webpack_require__.d(__webpack_exports__, "UrlRouter", (function() {
        return _params_index__WEBPACK_IMPORTED_MODULE_1__.UrlRouter
    })), __webpack_require__.o(_params_index__WEBPACK_IMPORTED_MODULE_1__, "UrlService") && __webpack_require__.d(__webpack_exports__, "UrlService", (function() {
        return _params_index__WEBPACK_IMPORTED_MODULE_1__.UrlService
    })), __webpack_require__.o(_params_index__WEBPACK_IMPORTED_MODULE_1__, "ViewService") && __webpack_require__.d(__webpack_exports__, "ViewService", (function() {
        return _params_index__WEBPACK_IMPORTED_MODULE_1__.ViewService
    })), __webpack_require__.o(_params_index__WEBPACK_IMPORTED_MODULE_1__, "parseUrl") && __webpack_require__.d(__webpack_exports__, "parseUrl", (function() {
        return _params_index__WEBPACK_IMPORTED_MODULE_1__.parseUrl
    })), __webpack_require__.o(_params_index__WEBPACK_IMPORTED_MODULE_1__, "servicesPlugin") && __webpack_require__.d(__webpack_exports__, "servicesPlugin", (function() {
        return _params_index__WEBPACK_IMPORTED_MODULE_1__.servicesPlugin
    }));
    var _path_index__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(243);
    __webpack_require__.d(__webpack_exports__, "PathUtils", (function() {
        return _path_index__WEBPACK_IMPORTED_MODULE_2__.a
    }));
    var _resolve_index__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(33);
    __webpack_require__.d(__webpack_exports__, "NATIVE_INJECTOR_TOKEN", (function() {
        return _resolve_index__WEBPACK_IMPORTED_MODULE_3__.a
    })), __webpack_require__.d(__webpack_exports__, "Resolvable", (function() {
        return _resolve_index__WEBPACK_IMPORTED_MODULE_3__.b
    })), __webpack_require__.d(__webpack_exports__, "ResolveContext", (function() {
        return _resolve_index__WEBPACK_IMPORTED_MODULE_3__.c
    }));
    var _state_index__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(36);
    __webpack_require__.o(_state_index__WEBPACK_IMPORTED_MODULE_4__, "BaseLocationServices") && __webpack_require__.d(__webpack_exports__, "BaseLocationServices", (function() {
        return _state_index__WEBPACK_IMPORTED_MODULE_4__.BaseLocationServices
    })), __webpack_require__.o(_state_index__WEBPACK_IMPORTED_MODULE_4__, "BaseUrlRule") && __webpack_require__.d(__webpack_exports__, "BaseUrlRule", (function() {
        return _state_index__WEBPACK_IMPORTED_MODULE_4__.BaseUrlRule
    })), __webpack_require__.o(_state_index__WEBPACK_IMPORTED_MODULE_4__, "BrowserLocationConfig") && __webpack_require__.d(__webpack_exports__, "BrowserLocationConfig", (function() {
        return _state_index__WEBPACK_IMPORTED_MODULE_4__.BrowserLocationConfig
    })), __webpack_require__.o(_state_index__WEBPACK_IMPORTED_MODULE_4__, "Param") && __webpack_require__.d(__webpack_exports__, "Param", (function() {
        return _state_index__WEBPACK_IMPORTED_MODULE_4__.Param
    })), __webpack_require__.o(_state_index__WEBPACK_IMPORTED_MODULE_4__, "StateRegistry") && __webpack_require__.d(__webpack_exports__, "StateRegistry", (function() {
        return _state_index__WEBPACK_IMPORTED_MODULE_4__.StateRegistry
    })), __webpack_require__.o(_state_index__WEBPACK_IMPORTED_MODULE_4__, "StateService") && __webpack_require__.d(__webpack_exports__, "StateService", (function() {
        return _state_index__WEBPACK_IMPORTED_MODULE_4__.StateService
    })), __webpack_require__.o(_state_index__WEBPACK_IMPORTED_MODULE_4__, "TransitionService") && __webpack_require__.d(__webpack_exports__, "TransitionService", (function() {
        return _state_index__WEBPACK_IMPORTED_MODULE_4__.TransitionService
    })), __webpack_require__.o(_state_index__WEBPACK_IMPORTED_MODULE_4__, "UIRouter") && __webpack_require__.d(__webpack_exports__, "UIRouter", (function() {
        return _state_index__WEBPACK_IMPORTED_MODULE_4__.UIRouter
    })), __webpack_require__.o(_state_index__WEBPACK_IMPORTED_MODULE_4__, "UIRouterGlobals") && __webpack_require__.d(__webpack_exports__, "UIRouterGlobals", (function() {
        return _state_index__WEBPACK_IMPORTED_MODULE_4__.UIRouterGlobals
    })), __webpack_require__.o(_state_index__WEBPACK_IMPORTED_MODULE_4__, "UrlMatcherFactory") && __webpack_require__.d(__webpack_exports__, "UrlMatcherFactory", (function() {
        return _state_index__WEBPACK_IMPORTED_MODULE_4__.UrlMatcherFactory
    })), __webpack_require__.o(_state_index__WEBPACK_IMPORTED_MODULE_4__, "UrlRouter") && __webpack_require__.d(__webpack_exports__, "UrlRouter", (function() {
        return _state_index__WEBPACK_IMPORTED_MODULE_4__.UrlRouter
    })), __webpack_require__.o(_state_index__WEBPACK_IMPORTED_MODULE_4__, "UrlService") && __webpack_require__.d(__webpack_exports__, "UrlService", (function() {
        return _state_index__WEBPACK_IMPORTED_MODULE_4__.UrlService
    })), __webpack_require__.o(_state_index__WEBPACK_IMPORTED_MODULE_4__, "ViewService") && __webpack_require__.d(__webpack_exports__, "ViewService", (function() {
        return _state_index__WEBPACK_IMPORTED_MODULE_4__.ViewService
    })), __webpack_require__.o(_state_index__WEBPACK_IMPORTED_MODULE_4__, "parseUrl") && __webpack_require__.d(__webpack_exports__, "parseUrl", (function() {
        return _state_index__WEBPACK_IMPORTED_MODULE_4__.parseUrl
    })), __webpack_require__.o(_state_index__WEBPACK_IMPORTED_MODULE_4__, "servicesPlugin") && __webpack_require__.d(__webpack_exports__, "servicesPlugin", (function() {
        return _state_index__WEBPACK_IMPORTED_MODULE_4__.servicesPlugin
    }));
    var _transition_index__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(245);
    __webpack_require__.d(__webpack_exports__, "TransitionService", (function() {
        return _transition_index__WEBPACK_IMPORTED_MODULE_5__.a
    }));
    var _url_index__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(246);
    __webpack_require__.o(_url_index__WEBPACK_IMPORTED_MODULE_6__, "BaseLocationServices") && __webpack_require__.d(__webpack_exports__, "BaseLocationServices", (function() {
        return _url_index__WEBPACK_IMPORTED_MODULE_6__.BaseLocationServices
    })), __webpack_require__.o(_url_index__WEBPACK_IMPORTED_MODULE_6__, "BaseUrlRule") && __webpack_require__.d(__webpack_exports__, "BaseUrlRule", (function() {
        return _url_index__WEBPACK_IMPORTED_MODULE_6__.BaseUrlRule
    })), __webpack_require__.o(_url_index__WEBPACK_IMPORTED_MODULE_6__, "BrowserLocationConfig") && __webpack_require__.d(__webpack_exports__, "BrowserLocationConfig", (function() {
        return _url_index__WEBPACK_IMPORTED_MODULE_6__.BrowserLocationConfig
    })), __webpack_require__.o(_url_index__WEBPACK_IMPORTED_MODULE_6__, "Param") && __webpack_require__.d(__webpack_exports__, "Param", (function() {
        return _url_index__WEBPACK_IMPORTED_MODULE_6__.Param
    })), __webpack_require__.o(_url_index__WEBPACK_IMPORTED_MODULE_6__, "StateRegistry") && __webpack_require__.d(__webpack_exports__, "StateRegistry", (function() {
        return _url_index__WEBPACK_IMPORTED_MODULE_6__.StateRegistry
    })), __webpack_require__.o(_url_index__WEBPACK_IMPORTED_MODULE_6__, "StateService") && __webpack_require__.d(__webpack_exports__, "StateService", (function() {
        return _url_index__WEBPACK_IMPORTED_MODULE_6__.StateService
    })), __webpack_require__.o(_url_index__WEBPACK_IMPORTED_MODULE_6__, "UIRouter") && __webpack_require__.d(__webpack_exports__, "UIRouter", (function() {
        return _url_index__WEBPACK_IMPORTED_MODULE_6__.UIRouter
    })), __webpack_require__.o(_url_index__WEBPACK_IMPORTED_MODULE_6__, "UIRouterGlobals") && __webpack_require__.d(__webpack_exports__, "UIRouterGlobals", (function() {
        return _url_index__WEBPACK_IMPORTED_MODULE_6__.UIRouterGlobals
    })), __webpack_require__.o(_url_index__WEBPACK_IMPORTED_MODULE_6__, "UrlMatcherFactory") && __webpack_require__.d(__webpack_exports__, "UrlMatcherFactory", (function() {
        return _url_index__WEBPACK_IMPORTED_MODULE_6__.UrlMatcherFactory
    })), __webpack_require__.o(_url_index__WEBPACK_IMPORTED_MODULE_6__, "UrlRouter") && __webpack_require__.d(__webpack_exports__, "UrlRouter", (function() {
        return _url_index__WEBPACK_IMPORTED_MODULE_6__.UrlRouter
    })), __webpack_require__.o(_url_index__WEBPACK_IMPORTED_MODULE_6__, "UrlService") && __webpack_require__.d(__webpack_exports__, "UrlService", (function() {
        return _url_index__WEBPACK_IMPORTED_MODULE_6__.UrlService
    })), __webpack_require__.o(_url_index__WEBPACK_IMPORTED_MODULE_6__, "ViewService") && __webpack_require__.d(__webpack_exports__, "ViewService", (function() {
        return _url_index__WEBPACK_IMPORTED_MODULE_6__.ViewService
    })), __webpack_require__.o(_url_index__WEBPACK_IMPORTED_MODULE_6__, "parseUrl") && __webpack_require__.d(__webpack_exports__, "parseUrl", (function() {
        return _url_index__WEBPACK_IMPORTED_MODULE_6__.parseUrl
    })), __webpack_require__.o(_url_index__WEBPACK_IMPORTED_MODULE_6__, "servicesPlugin") && __webpack_require__.d(__webpack_exports__, "servicesPlugin", (function() {
        return _url_index__WEBPACK_IMPORTED_MODULE_6__.servicesPlugin
    }));
    var _view_index__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(248);
    __webpack_require__.o(_view_index__WEBPACK_IMPORTED_MODULE_7__, "BaseLocationServices") && __webpack_require__.d(__webpack_exports__, "BaseLocationServices", (function() {
        return _view_index__WEBPACK_IMPORTED_MODULE_7__.BaseLocationServices
    })), __webpack_require__.o(_view_index__WEBPACK_IMPORTED_MODULE_7__, "BaseUrlRule") && __webpack_require__.d(__webpack_exports__, "BaseUrlRule", (function() {
        return _view_index__WEBPACK_IMPORTED_MODULE_7__.BaseUrlRule
    })), __webpack_require__.o(_view_index__WEBPACK_IMPORTED_MODULE_7__, "BrowserLocationConfig") && __webpack_require__.d(__webpack_exports__, "BrowserLocationConfig", (function() {
        return _view_index__WEBPACK_IMPORTED_MODULE_7__.BrowserLocationConfig
    })), __webpack_require__.o(_view_index__WEBPACK_IMPORTED_MODULE_7__, "Param") && __webpack_require__.d(__webpack_exports__, "Param", (function() {
        return _view_index__WEBPACK_IMPORTED_MODULE_7__.Param
    })), __webpack_require__.o(_view_index__WEBPACK_IMPORTED_MODULE_7__, "StateRegistry") && __webpack_require__.d(__webpack_exports__, "StateRegistry", (function() {
        return _view_index__WEBPACK_IMPORTED_MODULE_7__.StateRegistry
    })), __webpack_require__.o(_view_index__WEBPACK_IMPORTED_MODULE_7__, "StateService") && __webpack_require__.d(__webpack_exports__, "StateService", (function() {
        return _view_index__WEBPACK_IMPORTED_MODULE_7__.StateService
    })), __webpack_require__.o(_view_index__WEBPACK_IMPORTED_MODULE_7__, "UIRouter") && __webpack_require__.d(__webpack_exports__, "UIRouter", (function() {
        return _view_index__WEBPACK_IMPORTED_MODULE_7__.UIRouter
    })), __webpack_require__.o(_view_index__WEBPACK_IMPORTED_MODULE_7__, "UIRouterGlobals") && __webpack_require__.d(__webpack_exports__, "UIRouterGlobals", (function() {
        return _view_index__WEBPACK_IMPORTED_MODULE_7__.UIRouterGlobals
    })), __webpack_require__.o(_view_index__WEBPACK_IMPORTED_MODULE_7__, "UrlMatcherFactory") && __webpack_require__.d(__webpack_exports__, "UrlMatcherFactory", (function() {
        return _view_index__WEBPACK_IMPORTED_MODULE_7__.UrlMatcherFactory
    })), __webpack_require__.o(_view_index__WEBPACK_IMPORTED_MODULE_7__, "UrlRouter") && __webpack_require__.d(__webpack_exports__, "UrlRouter", (function() {
        return _view_index__WEBPACK_IMPORTED_MODULE_7__.UrlRouter
    })), __webpack_require__.o(_view_index__WEBPACK_IMPORTED_MODULE_7__, "UrlService") && __webpack_require__.d(__webpack_exports__, "UrlService", (function() {
        return _view_index__WEBPACK_IMPORTED_MODULE_7__.UrlService
    })), __webpack_require__.o(_view_index__WEBPACK_IMPORTED_MODULE_7__, "ViewService") && __webpack_require__.d(__webpack_exports__, "ViewService", (function() {
        return _view_index__WEBPACK_IMPORTED_MODULE_7__.ViewService
    })), __webpack_require__.o(_view_index__WEBPACK_IMPORTED_MODULE_7__, "parseUrl") && __webpack_require__.d(__webpack_exports__, "parseUrl", (function() {
        return _view_index__WEBPACK_IMPORTED_MODULE_7__.parseUrl
    })), __webpack_require__.o(_view_index__WEBPACK_IMPORTED_MODULE_7__, "servicesPlugin") && __webpack_require__.d(__webpack_exports__, "servicesPlugin", (function() {
        return _view_index__WEBPACK_IMPORTED_MODULE_7__.servicesPlugin
    }));
    var _globals__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(77);
    __webpack_require__.d(__webpack_exports__, "UIRouterGlobals", (function() {
        return _globals__WEBPACK_IMPORTED_MODULE_8__.a
    }));
    var _router__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(73);
    __webpack_require__.d(__webpack_exports__, "UIRouter", (function() {
        return _router__WEBPACK_IMPORTED_MODULE_9__.a
    }));
    var _vanilla__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(250);
    __webpack_require__.o(_vanilla__WEBPACK_IMPORTED_MODULE_10__, "BaseLocationServices") && __webpack_require__.d(__webpack_exports__, "BaseLocationServices", (function() {
        return _vanilla__WEBPACK_IMPORTED_MODULE_10__.BaseLocationServices
    })), __webpack_require__.o(_vanilla__WEBPACK_IMPORTED_MODULE_10__, "BaseUrlRule") && __webpack_require__.d(__webpack_exports__, "BaseUrlRule", (function() {
        return _vanilla__WEBPACK_IMPORTED_MODULE_10__.BaseUrlRule
    })), __webpack_require__.o(_vanilla__WEBPACK_IMPORTED_MODULE_10__, "BrowserLocationConfig") && __webpack_require__.d(__webpack_exports__, "BrowserLocationConfig", (function() {
        return _vanilla__WEBPACK_IMPORTED_MODULE_10__.BrowserLocationConfig
    })), __webpack_require__.o(_vanilla__WEBPACK_IMPORTED_MODULE_10__, "Param") && __webpack_require__.d(__webpack_exports__, "Param", (function() {
        return _vanilla__WEBPACK_IMPORTED_MODULE_10__.Param
    })), __webpack_require__.o(_vanilla__WEBPACK_IMPORTED_MODULE_10__, "StateRegistry") && __webpack_require__.d(__webpack_exports__, "StateRegistry", (function() {
        return _vanilla__WEBPACK_IMPORTED_MODULE_10__.StateRegistry
    })), __webpack_require__.o(_vanilla__WEBPACK_IMPORTED_MODULE_10__, "StateService") && __webpack_require__.d(__webpack_exports__, "StateService", (function() {
        return _vanilla__WEBPACK_IMPORTED_MODULE_10__.StateService
    })), __webpack_require__.o(_vanilla__WEBPACK_IMPORTED_MODULE_10__, "UrlMatcherFactory") && __webpack_require__.d(__webpack_exports__, "UrlMatcherFactory", (function() {
        return _vanilla__WEBPACK_IMPORTED_MODULE_10__.UrlMatcherFactory
    })), __webpack_require__.o(_vanilla__WEBPACK_IMPORTED_MODULE_10__, "UrlRouter") && __webpack_require__.d(__webpack_exports__, "UrlRouter", (function() {
        return _vanilla__WEBPACK_IMPORTED_MODULE_10__.UrlRouter
    })), __webpack_require__.o(_vanilla__WEBPACK_IMPORTED_MODULE_10__, "UrlService") && __webpack_require__.d(__webpack_exports__, "UrlService", (function() {
        return _vanilla__WEBPACK_IMPORTED_MODULE_10__.UrlService
    })), __webpack_require__.o(_vanilla__WEBPACK_IMPORTED_MODULE_10__, "ViewService") && __webpack_require__.d(__webpack_exports__, "ViewService", (function() {
        return _vanilla__WEBPACK_IMPORTED_MODULE_10__.ViewService
    })), __webpack_require__.o(_vanilla__WEBPACK_IMPORTED_MODULE_10__, "parseUrl") && __webpack_require__.d(__webpack_exports__, "parseUrl", (function() {
        return _vanilla__WEBPACK_IMPORTED_MODULE_10__.parseUrl
    })), __webpack_require__.o(_vanilla__WEBPACK_IMPORTED_MODULE_10__, "servicesPlugin") && __webpack_require__.d(__webpack_exports__, "servicesPlugin", (function() {
        return _vanilla__WEBPACK_IMPORTED_MODULE_10__.servicesPlugin
    }));
    __webpack_require__(254)
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    (function(global) {
        __webpack_require__.d(__webpack_exports__, "D", (function() {
            return root
        })), __webpack_require__.d(__webpack_exports__, "q", (function() {
            return fromJson
        })), __webpack_require__.d(__webpack_exports__, "H", (function() {
            return toJson
        })), __webpack_require__.d(__webpack_exports__, "p", (function() {
            return forEach
        })), __webpack_require__.d(__webpack_exports__, "l", (function() {
            return extend
        })), __webpack_require__.d(__webpack_exports__, "k", (function() {
            return equals
        })), __webpack_require__.d(__webpack_exports__, "r", (function() {
            return identity
        })), __webpack_require__.d(__webpack_exports__, "x", (function() {
            return noop
        })), __webpack_require__.d(__webpack_exports__, "h", (function() {
            return createProxyFunctions
        })), __webpack_require__.d(__webpack_exports__, "t", (function() {
            return inherit
        })), __webpack_require__.d(__webpack_exports__, "s", (function() {
            return inArray
        })), __webpack_require__.d(__webpack_exports__, "C", (function() {
            return removeFrom
        })), __webpack_require__.d(__webpack_exports__, "B", (function() {
            return pushTo
        })), __webpack_require__.d(__webpack_exports__, "j", (function() {
            return deregAll
        })), __webpack_require__.d(__webpack_exports__, "i", (function() {
            return defaults
        })), __webpack_require__.d(__webpack_exports__, "w", (function() {
            return mergeR
        })), __webpack_require__.d(__webpack_exports__, "b", (function() {
            return ancestors
        })), __webpack_require__.d(__webpack_exports__, "z", (function() {
            return pick
        })), __webpack_require__.d(__webpack_exports__, "y", (function() {
            return omit
        })), __webpack_require__.d(__webpack_exports__, "m", (function() {
            return filter
        })), __webpack_require__.d(__webpack_exports__, "n", (function() {
            return find
        })), __webpack_require__.d(__webpack_exports__, "v", (function() {
            return mapObj
        })), __webpack_require__.d(__webpack_exports__, "u", (function() {
            return map
        })), __webpack_require__.d(__webpack_exports__, "L", (function() {
            return values
        })), __webpack_require__.d(__webpack_exports__, "a", (function() {
            return allTrueR
        })), __webpack_require__.d(__webpack_exports__, "c", (function() {
            return anyTrueR
        })), __webpack_require__.d(__webpack_exports__, "K", (function() {
            return unnestR
        })), __webpack_require__.d(__webpack_exports__, "o", (function() {
            return flattenR
        })), __webpack_require__.d(__webpack_exports__, "A", (function() {
            return pushR
        })), __webpack_require__.d(__webpack_exports__, "I", (function() {
            return uniqR
        })), __webpack_require__.d(__webpack_exports__, "J", (function() {
            return unnest
        })), __webpack_require__.d(__webpack_exports__, "f", (function() {
            return assertPredicate
        })), __webpack_require__.d(__webpack_exports__, "e", (function() {
            return arrayTuples
        })), __webpack_require__.d(__webpack_exports__, "d", (function() {
            return applyPairs
        })), __webpack_require__.d(__webpack_exports__, "G", (function() {
            return tail
        })), __webpack_require__.d(__webpack_exports__, "g", (function() {
            return copy
        })), __webpack_require__.d(__webpack_exports__, "E", (function() {
            return silenceUncaughtInPromise
        })), __webpack_require__.d(__webpack_exports__, "F", (function() {
            return silentRejection
        }));
        var _predicates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4),
            _hof__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5),
            _coreservices__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(9),
            __spreadArrays = function() {
                for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
                var r = Array(s),
                    k = 0;
                for (i = 0; i < il; i++)
                    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];
                return r
            },
            root = "object" == typeof self && self.self === self && self || "object" == typeof global && global.global === global && global || void 0,
            angular = root.angular || {},
            fromJson = angular.fromJson || JSON.parse.bind(JSON),
            toJson = angular.toJson || JSON.stringify.bind(JSON),
            forEach = angular.forEach || function(obj, cb, _this) {
                if (Object(_predicates__WEBPACK_IMPORTED_MODULE_0__.a)(obj)) return obj.forEach(cb, _this);
                Object.keys(obj).forEach((function(key) {
                    return cb(obj[key], key)
                }))
            },
            extend = Object.assign || function(toObj) {
                for (var i = 1; i < arguments.length; i++) {
                    var obj = arguments[i];
                    if (obj)
                        for (var keys = Object.keys(obj), j = 0; j < keys.length; j++) toObj[keys[j]] = obj[keys[j]]
                }
                return toObj
            },
            equals = angular.equals || _equals;

        function identity(x) {
            return x
        }

        function noop() {}

        function createProxyFunctions(source, target, bind, fnNames, latebind) {
            void 0 === latebind && (latebind = !1);
            var bindFunction = function(fnName) {
                return source()[fnName].bind(bind())
            };
            return (fnNames = fnNames || Object.keys(source())).reduce((function(acc, name) {
                var fnName;
                return acc[name] = latebind ? (fnName = name, function() {
                    return target[fnName] = bindFunction(fnName), target[fnName].apply(null, arguments)
                }) : bindFunction(name), acc
            }), target)
        }
        var inherit = function(parent, extra) {
                return extend(Object.create(parent), extra)
            },
            inArray = Object(_hof__WEBPACK_IMPORTED_MODULE_1__.d)((function(array, obj) {
                return -1 !== array.indexOf(obj)
            }));
        var removeFrom = Object(_hof__WEBPACK_IMPORTED_MODULE_1__.d)((function(array, obj) {
            var idx = array.indexOf(obj);
            idx >= 0 && array.splice(idx, 1);
            return array
        }));
        var pushTo = Object(_hof__WEBPACK_IMPORTED_MODULE_1__.d)((function(arr, val) {
            return arr.push(val), val
        }));
        var deregAll = function(functions) {
            return functions.slice().forEach((function(fn) {
                "function" == typeof fn && fn(), removeFrom(functions, fn)
            }))
        };

        function defaults(opts) {
            for (var defaultsList = [], _i = 1; _i < arguments.length; _i++) defaultsList[_i - 1] = arguments[_i];
            var defaultVals = extend.apply(void 0, __spreadArrays([{}], defaultsList.reverse()));
            return extend(defaultVals, pick(opts || {}, Object.keys(defaultVals)))
        }
        var mergeR = function(memo, item) {
            return extend(memo, item)
        };

        function ancestors(first, second) {
            var path = [];
            for (var n in first.path) {
                if (first.path[n] !== second.path[n]) break;
                path.push(first.path[n])
            }
            return path
        }

        function pick(obj, propNames) {
            var objCopy = {};
            for (var _prop in obj) - 1 !== propNames.indexOf(_prop) && (objCopy[_prop] = obj[_prop]);
            return objCopy
        }

        function omit(obj, propNames) {
            return Object.keys(obj).filter(Object(_hof__WEBPACK_IMPORTED_MODULE_1__.f)(inArray(propNames))).reduce((function(acc, key) {
                return acc[key] = obj[key], acc
            }), {})
        }

        function filter(collection, callback) {
            var arr = Object(_predicates__WEBPACK_IMPORTED_MODULE_0__.a)(collection),
                result = arr ? [] : {},
                accept = arr ? function(x) {
                    return result.push(x)
                } : function(x, key) {
                    return result[key] = x
                };
            return forEach(collection, (function(item, i) {
                callback(item, i) && accept(item, i)
            })), result
        }

        function find(collection, callback) {
            var result;
            return forEach(collection, (function(item, i) {
                result || callback(item, i) && (result = item)
            })), result
        }
        var mapObj = map;

        function map(collection, callback, target) {
            return target = target || (Object(_predicates__WEBPACK_IMPORTED_MODULE_0__.a)(collection) ? [] : {}), forEach(collection, (function(item, i) {
                return target[i] = callback(item, i)
            })), target
        }
        var values = function(obj) {
                return Object.keys(obj).map((function(key) {
                    return obj[key]
                }))
            },
            allTrueR = function(memo, elem) {
                return memo && elem
            },
            anyTrueR = function(memo, elem) {
                return memo || elem
            },
            unnestR = function(memo, elem) {
                return memo.concat(elem)
            },
            flattenR = function(memo, elem) {
                return Object(_predicates__WEBPACK_IMPORTED_MODULE_0__.a)(elem) ? memo.concat(elem.reduce(flattenR, [])) : pushR(memo, elem)
            };

        function pushR(arr, obj) {
            return arr.push(obj), arr
        }
        var uniqR = function(acc, token) {
                return inArray(acc, token) ? acc : pushR(acc, token)
            },
            unnest = function(arr) {
                return arr.reduce(unnestR, [])
            },
            assertPredicate = assertFn;

        function assertFn(predicateOrMap, errMsg) {
            return void 0 === errMsg && (errMsg = "assert failure"),
                function(obj) {
                    var result = predicateOrMap(obj);
                    if (!result) throw new Error(Object(_predicates__WEBPACK_IMPORTED_MODULE_0__.d)(errMsg) ? errMsg(obj) : errMsg);
                    return result
                }
        }

        function arrayTuples() {
            for (var args = [], _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
            if (0 === args.length) return [];
            for (var maxArrayLen = args.reduce((function(min, arr) {
                    return Math.min(arr.length, min)
                }), 9007199254740991), result = [], _loop_1 = function(i) {
                    switch (args.length) {
                        case 1:
                            result.push([args[0][i]]);
                            break;
                        case 2:
                            result.push([args[0][i], args[1][i]]);
                            break;
                        case 3:
                            result.push([args[0][i], args[1][i], args[2][i]]);
                            break;
                        case 4:
                            result.push([args[0][i], args[1][i], args[2][i], args[3][i]]);
                            break;
                        default:
                            result.push(args.map((function(array) {
                                return array[i]
                            })))
                    }
                }, i = 0; i < maxArrayLen; i++) _loop_1(i);
            return result
        }

        function applyPairs(memo, keyValTuple) {
            var key, value;
            if (Object(_predicates__WEBPACK_IMPORTED_MODULE_0__.a)(keyValTuple) && (key = keyValTuple[0], value = keyValTuple[1]), !Object(_predicates__WEBPACK_IMPORTED_MODULE_0__.l)(key)) throw new Error("invalid parameters to applyPairs");
            return memo[key] = value, memo
        }

        function tail(arr) {
            return arr.length && arr[arr.length - 1] || void 0
        }

        function copy(src, dest) {
            return dest && Object.keys(dest).forEach((function(key) {
                return delete dest[key]
            })), dest || (dest = {}), extend(dest, src)
        }

        function _equals(o1, o2) {
            if (o1 === o2) return !0;
            if (null === o1 || null === o2) return !1;
            if (o1 != o1 && o2 != o2) return !0;
            var t1 = typeof o1;
            if (t1 !== typeof o2 || "object" !== t1) return !1;
            var a1, a2, tup = [o1, o2];
            if (Object(_hof__WEBPACK_IMPORTED_MODULE_1__.a)(_predicates__WEBPACK_IMPORTED_MODULE_0__.a)(tup)) return a2 = o2, (a1 = o1).length === a2.length && arrayTuples(a1, a2).reduce((function(b, t) {
                return b && _equals(t[0], t[1])
            }), !0);
            if (Object(_hof__WEBPACK_IMPORTED_MODULE_1__.a)(_predicates__WEBPACK_IMPORTED_MODULE_0__.b)(tup)) return o1.getTime() === o2.getTime();
            if (Object(_hof__WEBPACK_IMPORTED_MODULE_1__.a)(_predicates__WEBPACK_IMPORTED_MODULE_0__.k)(tup)) return o1.toString() === o2.toString();
            if (Object(_hof__WEBPACK_IMPORTED_MODULE_1__.a)(_predicates__WEBPACK_IMPORTED_MODULE_0__.d)(tup)) return !0;
            if ([_predicates__WEBPACK_IMPORTED_MODULE_0__.d, _predicates__WEBPACK_IMPORTED_MODULE_0__.a, _predicates__WEBPACK_IMPORTED_MODULE_0__.b, _predicates__WEBPACK_IMPORTED_MODULE_0__.k].map(_hof__WEBPACK_IMPORTED_MODULE_1__.c).reduce((function(b, fn) {
                    return b || !!fn(tup)
                }), !1)) return !1;
            var keys = {};
            for (var key in o1) {
                if (!_equals(o1[key], o2[key])) return !1;
                keys[key] = !0
            }
            for (var key in o2)
                if (!keys[key]) return !1;
            return !0
        }
        var silenceUncaughtInPromise = function(promise) {
                return promise.catch((function(e) {
                    return 0
                })) && promise
            },
            silentRejection = function(error) {
                return silenceUncaughtInPromise(_coreservices__WEBPACK_IMPORTED_MODULE_2__.b.$q.reject(error))
            }
    }).call(this, __webpack_require__(65))
}, function(module, exports, __webpack_require__) {
    var ___EXPOSE_LOADER_IMPORT___ = __webpack_require__(260),
        ___EXPOSE_LOADER_GLOBAL_THIS___ = __webpack_require__(101);
    void 0 === ___EXPOSE_LOADER_GLOBAL_THIS___.moment && (___EXPOSE_LOADER_GLOBAL_THIS___.moment = ___EXPOSE_LOADER_IMPORT___), module.exports = ___EXPOSE_LOADER_IMPORT___
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "m", (function() {
        return isUndefined
    })), __webpack_require__.d(__webpack_exports__, "c", (function() {
        return isDefined
    })), __webpack_require__.d(__webpack_exports__, "f", (function() {
        return isNull
    })), __webpack_require__.d(__webpack_exports__, "g", (function() {
        return isNullOrUndefined
    })), __webpack_require__.d(__webpack_exports__, "d", (function() {
        return isFunction
    })), __webpack_require__.d(__webpack_exports__, "h", (function() {
        return isNumber
    })), __webpack_require__.d(__webpack_exports__, "l", (function() {
        return isString
    })), __webpack_require__.d(__webpack_exports__, "i", (function() {
        return isObject
    })), __webpack_require__.d(__webpack_exports__, "a", (function() {
        return isArray
    })), __webpack_require__.d(__webpack_exports__, "b", (function() {
        return isDate
    })), __webpack_require__.d(__webpack_exports__, "k", (function() {
        return isRegExp
    })), __webpack_require__.d(__webpack_exports__, "e", (function() {
        return isInjectable
    })), __webpack_require__.d(__webpack_exports__, "j", (function() {
        return isPromise
    }));
    var _hof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5),
        toStr = Object.prototype.toString,
        tis = function(t) {
            return function(x) {
                return typeof x === t
            }
        },
        isUndefined = tis("undefined"),
        isDefined = Object(_hof__WEBPACK_IMPORTED_MODULE_0__.f)(isUndefined),
        isNull = function(o) {
            return null === o
        },
        isNullOrUndefined = Object(_hof__WEBPACK_IMPORTED_MODULE_0__.g)(isNull, isUndefined),
        isFunction = tis("function"),
        isNumber = tis("number"),
        isString = tis("string"),
        isObject = function(x) {
            return null !== x && "object" == typeof x
        },
        isArray = Array.isArray,
        isDate = function(x) {
            return "[object Date]" === toStr.call(x)
        },
        isRegExp = function(x) {
            return "[object RegExp]" === toStr.call(x)
        };

    function isInjectable(val) {
        if (isArray(val) && val.length) {
            var head = val.slice(0, -1),
                tail = val.slice(-1);
            return !(head.filter(Object(_hof__WEBPACK_IMPORTED_MODULE_0__.f)(isString)).length || tail.filter(Object(_hof__WEBPACK_IMPORTED_MODULE_0__.f)(isFunction)).length)
        }
        return isFunction(val)
    }
    var isPromise = Object(_hof__WEBPACK_IMPORTED_MODULE_0__.b)(isObject, Object(_hof__WEBPACK_IMPORTED_MODULE_0__.j)(Object(_hof__WEBPACK_IMPORTED_MODULE_0__.k)("then"), isFunction))
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "d", (function() {
        return curry
    })), __webpack_require__.d(__webpack_exports__, "j", (function() {
        return pipe
    })), __webpack_require__.d(__webpack_exports__, "k", (function() {
        return prop
    })), __webpack_require__.d(__webpack_exports__, "l", (function() {
        return propEq
    })), __webpack_require__.d(__webpack_exports__, "h", (function() {
        return parse
    })), __webpack_require__.d(__webpack_exports__, "f", (function() {
        return not
    })), __webpack_require__.d(__webpack_exports__, "b", (function() {
        return and
    })), __webpack_require__.d(__webpack_exports__, "g", (function() {
        return or
    })), __webpack_require__.d(__webpack_exports__, "a", (function() {
        return all
    })), __webpack_require__.d(__webpack_exports__, "c", (function() {
        return any
    })), __webpack_require__.d(__webpack_exports__, "e", (function() {
        return is
    })), __webpack_require__.d(__webpack_exports__, "m", (function() {
        return val
    })), __webpack_require__.d(__webpack_exports__, "i", (function() {
        return pattern
    }));
    var __spreadArrays = function() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
        var r = Array(s),
            k = 0;
        for (i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) r[k] = a[j];
        return r
    };

    function curry(fn) {
        return function curried() {
            if (arguments.length >= fn.length) return fn.apply(this, arguments);
            var args = Array.prototype.slice.call(arguments);
            return curried.bind.apply(curried, __spreadArrays([this], args))
        }
    }

    function compose() {
        var args = arguments,
            start = args.length - 1;
        return function() {
            for (var i = start, result = args[start].apply(this, arguments); i--;) result = args[i].call(this, result);
            return result
        }
    }

    function pipe() {
        for (var funcs = [], _i = 0; _i < arguments.length; _i++) funcs[_i] = arguments[_i];
        return compose.apply(null, [].slice.call(arguments).reverse())
    }
    var prop = function(name) {
            return function(obj) {
                return obj && obj[name]
            }
        },
        propEq = curry((function(name, _val, obj) {
            return obj && obj[name] === _val
        })),
        parse = function(name) {
            return pipe.apply(null, name.split(".").map(prop))
        },
        not = function(fn) {
            return function() {
                for (var args = [], _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
                return !fn.apply(null, args)
            }
        };

    function and(fn1, fn2) {
        return function() {
            for (var args = [], _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
            return fn1.apply(null, args) && fn2.apply(null, args)
        }
    }

    function or(fn1, fn2) {
        return function() {
            for (var args = [], _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
            return fn1.apply(null, args) || fn2.apply(null, args)
        }
    }
    var all = function(fn1) {
            return function(arr) {
                return arr.reduce((function(b, x) {
                    return b && !!fn1(x)
                }), !0)
            }
        },
        any = function(fn1) {
            return function(arr) {
                return arr.reduce((function(b, x) {
                    return b || !!fn1(x)
                }), !1)
            }
        },
        is = function(ctor) {
            return function(obj) {
                return null != obj && obj.constructor === ctor || obj instanceof ctor
            }
        },
        val = function(v) {
            return function() {
                return v
            }
        };

    function pattern(struct) {
        return function(x) {
            for (var i = 0; i < struct.length; i++)
                if (struct[i][0](x)) return struct[i][1](x)
        }
    }
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2);
    __webpack_require__.d(__webpack_exports__, "b", (function() {
        return _common__WEBPACK_IMPORTED_MODULE_0__.c
    })), __webpack_require__.d(__webpack_exports__, "c", (function() {
        return _common__WEBPACK_IMPORTED_MODULE_0__.d
    })), __webpack_require__.d(__webpack_exports__, "d", (function() {
        return _common__WEBPACK_IMPORTED_MODULE_0__.f
    })), __webpack_require__.d(__webpack_exports__, "e", (function() {
        return _common__WEBPACK_IMPORTED_MODULE_0__.h
    })), __webpack_require__.d(__webpack_exports__, "f", (function() {
        return _common__WEBPACK_IMPORTED_MODULE_0__.i
    })), __webpack_require__.d(__webpack_exports__, "g", (function() {
        return _common__WEBPACK_IMPORTED_MODULE_0__.j
    })), __webpack_require__.d(__webpack_exports__, "h", (function() {
        return _common__WEBPACK_IMPORTED_MODULE_0__.l
    })), __webpack_require__.d(__webpack_exports__, "i", (function() {
        return _common__WEBPACK_IMPORTED_MODULE_0__.m
    })), __webpack_require__.d(__webpack_exports__, "j", (function() {
        return _common__WEBPACK_IMPORTED_MODULE_0__.o
    })), __webpack_require__.d(__webpack_exports__, "k", (function() {
        return _common__WEBPACK_IMPORTED_MODULE_0__.p
    })), __webpack_require__.d(__webpack_exports__, "l", (function() {
        return _common__WEBPACK_IMPORTED_MODULE_0__.r
    })), __webpack_require__.d(__webpack_exports__, "m", (function() {
        return _common__WEBPACK_IMPORTED_MODULE_0__.s
    })), __webpack_require__.d(__webpack_exports__, "z", (function() {
        return _common__WEBPACK_IMPORTED_MODULE_0__.v
    })), __webpack_require__.d(__webpack_exports__, "A", (function() {
        return _common__WEBPACK_IMPORTED_MODULE_0__.x
    })), __webpack_require__.d(__webpack_exports__, "D", (function() {
        return _common__WEBPACK_IMPORTED_MODULE_0__.z
    })), __webpack_require__.d(__webpack_exports__, "F", (function() {
        return _common__WEBPACK_IMPORTED_MODULE_0__.C
    })), __webpack_require__.d(__webpack_exports__, "G", (function() {
        return _common__WEBPACK_IMPORTED_MODULE_0__.D
    })), __webpack_require__.d(__webpack_exports__, "M", (function() {
        return _common__WEBPACK_IMPORTED_MODULE_0__.G
    })), __webpack_require__.d(__webpack_exports__, "P", (function() {
        return _common__WEBPACK_IMPORTED_MODULE_0__.I
    })), __webpack_require__.d(__webpack_exports__, "Q", (function() {
        return _common__WEBPACK_IMPORTED_MODULE_0__.K
    })), __webpack_require__.d(__webpack_exports__, "S", (function() {
        return _common__WEBPACK_IMPORTED_MODULE_0__.L
    }));
    var _coreservices__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9);
    __webpack_require__.d(__webpack_exports__, "y", (function() {
        return _coreservices__WEBPACK_IMPORTED_MODULE_1__.a
    })), __webpack_require__.d(__webpack_exports__, "H", (function() {
        return _coreservices__WEBPACK_IMPORTED_MODULE_1__.b
    }));
    var _glob__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(49);
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return _glob__WEBPACK_IMPORTED_MODULE_2__.a
    }));
    var _hof__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5);
    __webpack_require__.d(__webpack_exports__, "n", (function() {
        return _hof__WEBPACK_IMPORTED_MODULE_3__.e
    })), __webpack_require__.d(__webpack_exports__, "B", (function() {
        return _hof__WEBPACK_IMPORTED_MODULE_3__.h
    })), __webpack_require__.d(__webpack_exports__, "C", (function() {
        return _hof__WEBPACK_IMPORTED_MODULE_3__.i
    })), __webpack_require__.d(__webpack_exports__, "E", (function() {
        return _hof__WEBPACK_IMPORTED_MODULE_3__.k
    })), __webpack_require__.d(__webpack_exports__, "R", (function() {
        return _hof__WEBPACK_IMPORTED_MODULE_3__.m
    }));
    var _predicates__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(4);
    __webpack_require__.d(__webpack_exports__, "o", (function() {
        return _predicates__WEBPACK_IMPORTED_MODULE_4__.a
    })), __webpack_require__.d(__webpack_exports__, "p", (function() {
        return _predicates__WEBPACK_IMPORTED_MODULE_4__.c
    })), __webpack_require__.d(__webpack_exports__, "q", (function() {
        return _predicates__WEBPACK_IMPORTED_MODULE_4__.d
    })), __webpack_require__.d(__webpack_exports__, "r", (function() {
        return _predicates__WEBPACK_IMPORTED_MODULE_4__.e
    })), __webpack_require__.d(__webpack_exports__, "s", (function() {
        return _predicates__WEBPACK_IMPORTED_MODULE_4__.g
    })), __webpack_require__.d(__webpack_exports__, "t", (function() {
        return _predicates__WEBPACK_IMPORTED_MODULE_4__.h
    })), __webpack_require__.d(__webpack_exports__, "u", (function() {
        return _predicates__WEBPACK_IMPORTED_MODULE_4__.i
    })), __webpack_require__.d(__webpack_exports__, "v", (function() {
        return _predicates__WEBPACK_IMPORTED_MODULE_4__.l
    })), __webpack_require__.d(__webpack_exports__, "w", (function() {
        return _predicates__WEBPACK_IMPORTED_MODULE_4__.m
    }));
    __webpack_require__(41);
    var _strings__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(10);
    __webpack_require__.d(__webpack_exports__, "x", (function() {
        return _strings__WEBPACK_IMPORTED_MODULE_6__.d
    })), __webpack_require__.d(__webpack_exports__, "I", (function() {
        return _strings__WEBPACK_IMPORTED_MODULE_6__.g
    })), __webpack_require__.d(__webpack_exports__, "J", (function() {
        return _strings__WEBPACK_IMPORTED_MODULE_6__.h
    })), __webpack_require__.d(__webpack_exports__, "K", (function() {
        return _strings__WEBPACK_IMPORTED_MODULE_6__.j
    })), __webpack_require__.d(__webpack_exports__, "L", (function() {
        return _strings__WEBPACK_IMPORTED_MODULE_6__.l
    })), __webpack_require__.d(__webpack_exports__, "O", (function() {
        return _strings__WEBPACK_IMPORTED_MODULE_6__.m
    }));
    var _trace__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(14);
    __webpack_require__.d(__webpack_exports__, "N", (function() {
        return _trace__WEBPACK_IMPORTED_MODULE_7__.a
    }))
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return __extends
    }));
    var extendStatics = function(d, b) {
        return (extendStatics = Object.setPrototypeOf || {
                __proto__: []
            }
            instanceof Array && function(d, b) {
                d.__proto__ = b
            } || function(d, b) {
                for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p])
            })(d, b)
    };

    function __extends(d, b) {
        function __() {
            this.constructor = d
        }
        extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __)
    }
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return CommonModule
    })), __webpack_require__.d(__webpack_exports__, "b", (function() {
        return DOCUMENT
    })), __webpack_require__.d(__webpack_exports__, "c", (function() {
        return HashLocationStrategy
    })), __webpack_require__.d(__webpack_exports__, "d", (function() {
        return LocationStrategy
    })), __webpack_require__.d(__webpack_exports__, "e", (function() {
        return PathLocationStrategy
    })), __webpack_require__.d(__webpack_exports__, "f", (function() {
        return isPlatformBrowser
    })), __webpack_require__.d(__webpack_exports__, "g", (function() {
        return DomAdapter
    })), __webpack_require__.d(__webpack_exports__, "h", (function() {
        return PLATFORM_BROWSER_ID
    })), __webpack_require__.d(__webpack_exports__, "i", (function() {
        return getDOM
    })), __webpack_require__.d(__webpack_exports__, "j", (function() {
        return parseCookieValue
    })), __webpack_require__.d(__webpack_exports__, "k", (function() {
        return setRootDomAdapter
    }));
    var _angular_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(0);
    let _DOM = null;

    function getDOM() {
        return _DOM
    }

    function setRootDomAdapter(adapter) {
        _DOM || (_DOM = adapter)
    }
    class DomAdapter {}
    const DOCUMENT = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.w("DocumentToken");
    class PlatformLocation {}

    function useBrowserPlatformLocation() {
        return Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Jb)(BrowserPlatformLocation)
    }
    PlatformLocation.ɵprov = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Ib)({
        factory: useBrowserPlatformLocation,
        token: PlatformLocation,
        providedIn: "platform"
    }), PlatformLocation.decorators = [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.v,
        args: [{
            providedIn: "platform",
            useFactory: useBrowserPlatformLocation
        }]
    }];
    new _angular_core__WEBPACK_IMPORTED_MODULE_0__.w("Location Initialized");
    class BrowserPlatformLocation extends PlatformLocation {
        constructor(_doc) {
            super(), this._doc = _doc, this._init()
        }
        _init() {
            this.location = getDOM().getLocation(), this._history = getDOM().getHistory()
        }
        getBaseHrefFromDOM() {
            return getDOM().getBaseHref(this._doc)
        }
        onPopState(fn) {
            getDOM().getGlobalEventTarget(this._doc, "window").addEventListener("popstate", fn, !1)
        }
        onHashChange(fn) {
            getDOM().getGlobalEventTarget(this._doc, "window").addEventListener("hashchange", fn, !1)
        }
        get href() {
            return this.location.href
        }
        get protocol() {
            return this.location.protocol
        }
        get hostname() {
            return this.location.hostname
        }
        get port() {
            return this.location.port
        }
        get pathname() {
            return this.location.pathname
        }
        get search() {
            return this.location.search
        }
        get hash() {
            return this.location.hash
        }
        set pathname(newPath) {
            this.location.pathname = newPath
        }
        pushState(state, title, url) {
            supportsState() ? this._history.pushState(state, title, url) : this.location.hash = url
        }
        replaceState(state, title, url) {
            supportsState() ? this._history.replaceState(state, title, url) : this.location.hash = url
        }
        forward() {
            this._history.forward()
        }
        back() {
            this._history.back()
        }
        getState() {
            return this._history.state
        }
    }

    function supportsState() {
        return !!window.history.pushState
    }

    function createBrowserPlatformLocation() {
        return new BrowserPlatformLocation(Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Jb)(DOCUMENT))
    }

    function joinWithSlash(start, end) {
        if (0 == start.length) return end;
        if (0 == end.length) return start;
        let slashes = 0;
        return start.endsWith("/") && slashes++, end.startsWith("/") && slashes++, 2 == slashes ? start + end.substring(1) : 1 == slashes ? start + end : start + "/" + end
    }

    function stripTrailingSlash(url) {
        const match = url.match(/#|\?|$/),
            pathEndIdx = match && match.index || url.length,
            droppedSlashIdx = pathEndIdx - ("/" === url[pathEndIdx - 1] ? 1 : 0);
        return url.slice(0, droppedSlashIdx) + url.slice(pathEndIdx)
    }

    function normalizeQueryParams(params) {
        return params && "?" !== params[0] ? "?" + params : params
    }
    BrowserPlatformLocation.ɵprov = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Ib)({
        factory: createBrowserPlatformLocation,
        token: BrowserPlatformLocation,
        providedIn: "platform"
    }), BrowserPlatformLocation.decorators = [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.v,
        args: [{
            providedIn: "platform",
            useFactory: createBrowserPlatformLocation
        }]
    }], BrowserPlatformLocation.ctorParameters = () => [{
        type: void 0,
        decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.u,
            args: [DOCUMENT]
        }]
    }];
    class LocationStrategy {}

    function provideLocationStrategy(platformLocation) {
        const location = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Jb)(DOCUMENT).location;
        return new PathLocationStrategy(Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Jb)(PlatformLocation), location && location.origin || "")
    }
    LocationStrategy.ɵprov = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Ib)({
        factory: provideLocationStrategy,
        token: LocationStrategy,
        providedIn: "root"
    }), LocationStrategy.decorators = [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.v,
        args: [{
            providedIn: "root",
            useFactory: provideLocationStrategy
        }]
    }];
    const APP_BASE_HREF = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.w("appBaseHref");
    class PathLocationStrategy extends LocationStrategy {
        constructor(_platformLocation, href) {
            if (super(), this._platformLocation = _platformLocation, null == href && (href = this._platformLocation.getBaseHrefFromDOM()), null == href) throw new Error("No base href set. Please provide a value for the APP_BASE_HREF token or add a base element to the document.");
            this._baseHref = href
        }
        onPopState(fn) {
            this._platformLocation.onPopState(fn), this._platformLocation.onHashChange(fn)
        }
        getBaseHref() {
            return this._baseHref
        }
        prepareExternalUrl(internal) {
            return joinWithSlash(this._baseHref, internal)
        }
        path(includeHash = !1) {
            const pathname = this._platformLocation.pathname + normalizeQueryParams(this._platformLocation.search),
                hash = this._platformLocation.hash;
            return hash && includeHash ? `${pathname}${hash}` : pathname
        }
        pushState(state, title, url, queryParams) {
            const externalUrl = this.prepareExternalUrl(url + normalizeQueryParams(queryParams));
            this._platformLocation.pushState(state, title, externalUrl)
        }
        replaceState(state, title, url, queryParams) {
            const externalUrl = this.prepareExternalUrl(url + normalizeQueryParams(queryParams));
            this._platformLocation.replaceState(state, title, externalUrl)
        }
        forward() {
            this._platformLocation.forward()
        }
        back() {
            this._platformLocation.back()
        }
    }
    PathLocationStrategy.decorators = [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.v
    }], PathLocationStrategy.ctorParameters = () => [{
        type: PlatformLocation
    }, {
        type: String,
        decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.I
        }, {
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.u,
            args: [APP_BASE_HREF]
        }]
    }];
    class HashLocationStrategy extends LocationStrategy {
        constructor(_platformLocation, _baseHref) {
            super(), this._platformLocation = _platformLocation, this._baseHref = "", null != _baseHref && (this._baseHref = _baseHref)
        }
        onPopState(fn) {
            this._platformLocation.onPopState(fn), this._platformLocation.onHashChange(fn)
        }
        getBaseHref() {
            return this._baseHref
        }
        path(includeHash = !1) {
            let path = this._platformLocation.hash;
            return null == path && (path = "#"), path.length > 0 ? path.substring(1) : path
        }
        prepareExternalUrl(internal) {
            const url = joinWithSlash(this._baseHref, internal);
            return url.length > 0 ? "#" + url : url
        }
        pushState(state, title, path, queryParams) {
            let url = this.prepareExternalUrl(path + normalizeQueryParams(queryParams));
            0 == url.length && (url = this._platformLocation.pathname), this._platformLocation.pushState(state, title, url)
        }
        replaceState(state, title, path, queryParams) {
            let url = this.prepareExternalUrl(path + normalizeQueryParams(queryParams));
            0 == url.length && (url = this._platformLocation.pathname), this._platformLocation.replaceState(state, title, url)
        }
        forward() {
            this._platformLocation.forward()
        }
        back() {
            this._platformLocation.back()
        }
    }
    HashLocationStrategy.decorators = [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.v
    }], HashLocationStrategy.ctorParameters = () => [{
        type: PlatformLocation
    }, {
        type: String,
        decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.I
        }, {
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.u,
            args: [APP_BASE_HREF]
        }]
    }];
    class Location {
        constructor(platformStrategy, platformLocation) {
            this._subject = new _angular_core__WEBPACK_IMPORTED_MODULE_0__.q, this._urlChangeListeners = [], this._platformStrategy = platformStrategy;
            const browserBaseHref = this._platformStrategy.getBaseHref();
            this._platformLocation = platformLocation, this._baseHref = stripTrailingSlash(_stripIndexHtml(browserBaseHref)), this._platformStrategy.onPopState((ev => {
                this._subject.emit({
                    url: this.path(!0),
                    pop: !0,
                    state: ev.state,
                    type: ev.type
                })
            }))
        }
        path(includeHash = !1) {
            return this.normalize(this._platformStrategy.path(includeHash))
        }
        getState() {
            return this._platformLocation.getState()
        }
        isCurrentPathEqualTo(path, query = "") {
            return this.path() == this.normalize(path + normalizeQueryParams(query))
        }
        normalize(url) {
            return Location.stripTrailingSlash(function(baseHref, url) {
                return baseHref && url.startsWith(baseHref) ? url.substring(baseHref.length) : url
            }(this._baseHref, _stripIndexHtml(url)))
        }
        prepareExternalUrl(url) {
            return url && "/" !== url[0] && (url = "/" + url), this._platformStrategy.prepareExternalUrl(url)
        }
        go(path, query = "", state = null) {
            this._platformStrategy.pushState(state, "", path, query), this._notifyUrlChangeListeners(this.prepareExternalUrl(path + normalizeQueryParams(query)), state)
        }
        replaceState(path, query = "", state = null) {
            this._platformStrategy.replaceState(state, "", path, query), this._notifyUrlChangeListeners(this.prepareExternalUrl(path + normalizeQueryParams(query)), state)
        }
        forward() {
            this._platformStrategy.forward()
        }
        back() {
            this._platformStrategy.back()
        }
        onUrlChange(fn) {
            this._urlChangeListeners.push(fn), this._urlChangeSubscription || (this._urlChangeSubscription = this.subscribe((v => {
                this._notifyUrlChangeListeners(v.url, v.state)
            })))
        }
        _notifyUrlChangeListeners(url = "", state) {
            this._urlChangeListeners.forEach((fn => fn(url, state)))
        }
        subscribe(onNext, onThrow, onReturn) {
            return this._subject.subscribe({
                next: onNext,
                error: onThrow,
                complete: onReturn
            })
        }
    }

    function createLocation() {
        return new Location(Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Jb)(LocationStrategy), Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Jb)(PlatformLocation))
    }

    function _stripIndexHtml(url) {
        return url.replace(/\/index.html$/, "")
    }
    Location.normalizeQueryParams = normalizeQueryParams, Location.joinWithSlash = joinWithSlash, Location.stripTrailingSlash = stripTrailingSlash, Location.ɵprov = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Ib)({
        factory: createLocation,
        token: Location,
        providedIn: "root"
    }), Location.decorators = [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.v,
        args: [{
            providedIn: "root",
            useFactory: createLocation
        }]
    }], Location.ctorParameters = () => [{
        type: LocationStrategy
    }, {
        type: PlatformLocation
    }];
    const CURRENCIES_EN = {
        ADP: [void 0, void 0, 0],
        AFN: [void 0, void 0, 0],
        ALL: [void 0, void 0, 0],
        AMD: [void 0, void 0, 2],
        AOA: [void 0, "Kz"],
        ARS: [void 0, "$"],
        AUD: ["A$", "$"],
        BAM: [void 0, "KM"],
        BBD: [void 0, "$"],
        BDT: [void 0, "৳"],
        BHD: [void 0, void 0, 3],
        BIF: [void 0, void 0, 0],
        BMD: [void 0, "$"],
        BND: [void 0, "$"],
        BOB: [void 0, "Bs"],
        BRL: ["R$"],
        BSD: [void 0, "$"],
        BWP: [void 0, "P"],
        BYN: [void 0, "р.", 2],
        BYR: [void 0, void 0, 0],
        BZD: [void 0, "$"],
        CAD: ["CA$", "$", 2],
        CHF: [void 0, void 0, 2],
        CLF: [void 0, void 0, 4],
        CLP: [void 0, "$", 0],
        CNY: ["CN¥", "¥"],
        COP: [void 0, "$", 2],
        CRC: [void 0, "₡", 2],
        CUC: [void 0, "$"],
        CUP: [void 0, "$"],
        CZK: [void 0, "Kč", 2],
        DJF: [void 0, void 0, 0],
        DKK: [void 0, "kr", 2],
        DOP: [void 0, "$"],
        EGP: [void 0, "E£"],
        ESP: [void 0, "₧", 0],
        EUR: ["€"],
        FJD: [void 0, "$"],
        FKP: [void 0, "£"],
        GBP: ["£"],
        GEL: [void 0, "₾"],
        GIP: [void 0, "£"],
        GNF: [void 0, "FG", 0],
        GTQ: [void 0, "Q"],
        GYD: [void 0, "$", 2],
        HKD: ["HK$", "$"],
        HNL: [void 0, "L"],
        HRK: [void 0, "kn"],
        HUF: [void 0, "Ft", 2],
        IDR: [void 0, "Rp", 2],
        ILS: ["₪"],
        INR: ["₹"],
        IQD: [void 0, void 0, 0],
        IRR: [void 0, void 0, 0],
        ISK: [void 0, "kr", 0],
        ITL: [void 0, void 0, 0],
        JMD: [void 0, "$"],
        JOD: [void 0, void 0, 3],
        JPY: ["¥", void 0, 0],
        KHR: [void 0, "៛"],
        KMF: [void 0, "CF", 0],
        KPW: [void 0, "₩", 0],
        KRW: ["₩", void 0, 0],
        KWD: [void 0, void 0, 3],
        KYD: [void 0, "$"],
        KZT: [void 0, "₸"],
        LAK: [void 0, "₭", 0],
        LBP: [void 0, "L£", 0],
        LKR: [void 0, "Rs"],
        LRD: [void 0, "$"],
        LTL: [void 0, "Lt"],
        LUF: [void 0, void 0, 0],
        LVL: [void 0, "Ls"],
        LYD: [void 0, void 0, 3],
        MGA: [void 0, "Ar", 0],
        MGF: [void 0, void 0, 0],
        MMK: [void 0, "K", 0],
        MNT: [void 0, "₮", 2],
        MRO: [void 0, void 0, 0],
        MUR: [void 0, "Rs", 2],
        MXN: ["MX$", "$"],
        MYR: [void 0, "RM"],
        NAD: [void 0, "$"],
        NGN: [void 0, "₦"],
        NIO: [void 0, "C$"],
        NOK: [void 0, "kr", 2],
        NPR: [void 0, "Rs"],
        NZD: ["NZ$", "$"],
        OMR: [void 0, void 0, 3],
        PHP: [void 0, "₱"],
        PKR: [void 0, "Rs", 2],
        PLN: [void 0, "zł"],
        PYG: [void 0, "₲", 0],
        RON: [void 0, "lei"],
        RSD: [void 0, void 0, 0],
        RUB: [void 0, "₽"],
        RUR: [void 0, "р."],
        RWF: [void 0, "RF", 0],
        SBD: [void 0, "$"],
        SEK: [void 0, "kr", 2],
        SGD: [void 0, "$"],
        SHP: [void 0, "£"],
        SLL: [void 0, void 0, 0],
        SOS: [void 0, void 0, 0],
        SRD: [void 0, "$"],
        SSP: [void 0, "£"],
        STD: [void 0, void 0, 0],
        STN: [void 0, "Db"],
        SYP: [void 0, "£", 0],
        THB: [void 0, "฿"],
        TMM: [void 0, void 0, 0],
        TND: [void 0, void 0, 3],
        TOP: [void 0, "T$"],
        TRL: [void 0, void 0, 0],
        TRY: [void 0, "₺"],
        TTD: [void 0, "$"],
        TWD: ["NT$", "$", 2],
        TZS: [void 0, void 0, 2],
        UAH: [void 0, "₴"],
        UGX: [void 0, void 0, 0],
        USD: ["$"],
        UYI: [void 0, void 0, 0],
        UYU: [void 0, "$"],
        UYW: [void 0, void 0, 4],
        UZS: [void 0, void 0, 2],
        VEF: [void 0, "Bs", 2],
        VND: ["₫", void 0, 0],
        VUV: [void 0, void 0, 0],
        XAF: ["FCFA", void 0, 0],
        XCD: ["EC$", "$"],
        XOF: ["CFA", void 0, 0],
        XPF: ["CFPF", void 0, 0],
        XXX: ["¤"],
        YER: [void 0, void 0, 0],
        ZAR: [void 0, "R"],
        ZMK: [void 0, void 0, 0],
        ZMW: [void 0, "ZK"],
        ZWD: [void 0, void 0, 0]
    };
    var NumberFormatStyle, Plural, FormStyle, TranslationWidth, FormatWidth, NumberSymbol, WeekDay;

    function getLocaleDateFormat(locale, width) {
        return getLastDefinedValue(Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.vb)(locale)[_angular_core__WEBPACK_IMPORTED_MODULE_0__.lb.DateFormat], width)
    }

    function getLocaleTimeFormat(locale, width) {
        return getLastDefinedValue(Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.vb)(locale)[_angular_core__WEBPACK_IMPORTED_MODULE_0__.lb.TimeFormat], width)
    }

    function getLocaleDateTimeFormat(locale, width) {
        return getLastDefinedValue(Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.vb)(locale)[_angular_core__WEBPACK_IMPORTED_MODULE_0__.lb.DateTimeFormat], width)
    }

    function getLocaleNumberSymbol(locale, symbol) {
        const data = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.vb)(locale),
            res = data[_angular_core__WEBPACK_IMPORTED_MODULE_0__.lb.NumberSymbols][symbol];
        if (void 0 === res) {
            if (symbol === NumberSymbol.CurrencyDecimal) return data[_angular_core__WEBPACK_IMPORTED_MODULE_0__.lb.NumberSymbols][NumberSymbol.Decimal];
            if (symbol === NumberSymbol.CurrencyGroup) return data[_angular_core__WEBPACK_IMPORTED_MODULE_0__.lb.NumberSymbols][NumberSymbol.Group]
        }
        return res
    }

    function getLocaleNumberFormat(locale, type) {
        return Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.vb)(locale)[_angular_core__WEBPACK_IMPORTED_MODULE_0__.lb.NumberFormats][type]
    }! function(NumberFormatStyle) {
        NumberFormatStyle[NumberFormatStyle.Decimal = 0] = "Decimal", NumberFormatStyle[NumberFormatStyle.Percent = 1] = "Percent", NumberFormatStyle[NumberFormatStyle.Currency = 2] = "Currency", NumberFormatStyle[NumberFormatStyle.Scientific = 3] = "Scientific"
    }(NumberFormatStyle || (NumberFormatStyle = {})),
    function(Plural) {
        Plural[Plural.Zero = 0] = "Zero", Plural[Plural.One = 1] = "One", Plural[Plural.Two = 2] = "Two", Plural[Plural.Few = 3] = "Few", Plural[Plural.Many = 4] = "Many", Plural[Plural.Other = 5] = "Other"
    }(Plural || (Plural = {})),
    function(FormStyle) {
        FormStyle[FormStyle.Format = 0] = "Format", FormStyle[FormStyle.Standalone = 1] = "Standalone"
    }(FormStyle || (FormStyle = {})),
    function(TranslationWidth) {
        TranslationWidth[TranslationWidth.Narrow = 0] = "Narrow", TranslationWidth[TranslationWidth.Abbreviated = 1] = "Abbreviated", TranslationWidth[TranslationWidth.Wide = 2] = "Wide", TranslationWidth[TranslationWidth.Short = 3] = "Short"
    }(TranslationWidth || (TranslationWidth = {})),
    function(FormatWidth) {
        FormatWidth[FormatWidth.Short = 0] = "Short", FormatWidth[FormatWidth.Medium = 1] = "Medium", FormatWidth[FormatWidth.Long = 2] = "Long", FormatWidth[FormatWidth.Full = 3] = "Full"
    }(FormatWidth || (FormatWidth = {})),
    function(NumberSymbol) {
        NumberSymbol[NumberSymbol.Decimal = 0] = "Decimal", NumberSymbol[NumberSymbol.Group = 1] = "Group", NumberSymbol[NumberSymbol.List = 2] = "List", NumberSymbol[NumberSymbol.PercentSign = 3] = "PercentSign", NumberSymbol[NumberSymbol.PlusSign = 4] = "PlusSign", NumberSymbol[NumberSymbol.MinusSign = 5] = "MinusSign", NumberSymbol[NumberSymbol.Exponential = 6] = "Exponential", NumberSymbol[NumberSymbol.SuperscriptingExponent = 7] = "SuperscriptingExponent", NumberSymbol[NumberSymbol.PerMille = 8] = "PerMille", NumberSymbol[NumberSymbol[1 / 0] = 9] = "Infinity", NumberSymbol[NumberSymbol.NaN = 10] = "NaN", NumberSymbol[NumberSymbol.TimeSeparator = 11] = "TimeSeparator", NumberSymbol[NumberSymbol.CurrencyDecimal = 12] = "CurrencyDecimal", NumberSymbol[NumberSymbol.CurrencyGroup = 13] = "CurrencyGroup"
    }(NumberSymbol || (NumberSymbol = {})),
    function(WeekDay) {
        WeekDay[WeekDay.Sunday = 0] = "Sunday", WeekDay[WeekDay.Monday = 1] = "Monday", WeekDay[WeekDay.Tuesday = 2] = "Tuesday", WeekDay[WeekDay.Wednesday = 3] = "Wednesday", WeekDay[WeekDay.Thursday = 4] = "Thursday", WeekDay[WeekDay.Friday = 5] = "Friday", WeekDay[WeekDay.Saturday = 6] = "Saturday"
    }(WeekDay || (WeekDay = {}));
    const getLocalePluralCase = _angular_core__WEBPACK_IMPORTED_MODULE_0__.yb;

    function checkFullData(data) {
        if (!data[_angular_core__WEBPACK_IMPORTED_MODULE_0__.lb.ExtraData]) throw new Error(`Missing extra locale data for the locale "${data[_angular_core__WEBPACK_IMPORTED_MODULE_0__.lb.LocaleId]}". Use "registerLocaleData" to load new data. See the "I18n guide" on angular.io to know more.`)
    }

    function getLastDefinedValue(data, index) {
        for (let i = index; i > -1; i--)
            if (void 0 !== data[i]) return data[i];
        throw new Error("Locale data API: locale data undefined")
    }

    function extractTime(time) {
        const [h, m] = time.split(":");
        return {
            hours: +h,
            minutes: +m
        }
    }

    function getCurrencySymbol(code, format, locale = "en") {
        const currency = function(locale) {
                return Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.vb)(locale)[_angular_core__WEBPACK_IMPORTED_MODULE_0__.lb.Currencies]
            }(locale)[code] || CURRENCIES_EN[code] || [],
            symbolNarrow = currency[1];
        return "narrow" === format && "string" == typeof symbolNarrow ? symbolNarrow : currency[0] || code
    }
    const ISO8601_DATE_REGEX = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/,
        NAMED_FORMATS = {},
        DATE_FORMATS_SPLIT = /((?:[^GyYMLwWdEabBhHmsSzZO']+)|(?:'(?:[^']|'')*')|(?:G{1,5}|y{1,4}|Y{1,4}|M{1,5}|L{1,5}|w{1,2}|W{1}|d{1,2}|E{1,6}|a{1,5}|b{1,5}|B{1,5}|h{1,2}|H{1,2}|m{1,2}|s{1,2}|S{1,3}|z{1,4}|Z{1,5}|O{1,4}))([\s\S]*)/;
    var ZoneWidth, DateType, TranslationType;

    function formatDate(value, format, locale, timezone) {
        let date = function(value) {
            if (isDate(value)) return value;
            if ("number" == typeof value && !isNaN(value)) return new Date(value);
            if ("string" == typeof value) {
                value = value.trim();
                const parsedNb = parseFloat(value);
                if (!isNaN(value - parsedNb)) return new Date(parsedNb);
                if (/^(\d{4}-\d{1,2}-\d{1,2})$/.test(value)) {
                    const [y, m, d] = value.split("-").map((val => +val));
                    return new Date(y, m - 1, d)
                }
                let match;
                if (match = value.match(ISO8601_DATE_REGEX)) return function(match) {
                    const date = new Date(0);
                    let tzHour = 0,
                        tzMin = 0;
                    const dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear,
                        timeSetter = match[8] ? date.setUTCHours : date.setHours;
                    match[9] && (tzHour = Number(match[9] + match[10]), tzMin = Number(match[9] + match[11]));
                    dateSetter.call(date, Number(match[1]), Number(match[2]) - 1, Number(match[3]));
                    const h = Number(match[4] || 0) - tzHour,
                        m = Number(match[5] || 0) - tzMin,
                        s = Number(match[6] || 0),
                        ms = Math.floor(1e3 * parseFloat("0." + (match[7] || 0)));
                    return timeSetter.call(date, h, m, s, ms), date
                }(match)
            }
            const date = new Date(value);
            if (!isDate(date)) throw new Error(`Unable to convert "${value}" into a date`);
            return date
        }(value);
        format = getNamedFormat(locale, format) || format;
        let match, parts = [];
        for (; format;) {
            if (match = DATE_FORMATS_SPLIT.exec(format), !match) {
                parts.push(format);
                break
            } {
                parts = parts.concat(match.slice(1));
                const part = parts.pop();
                if (!part) break;
                format = part
            }
        }
        let dateTimezoneOffset = date.getTimezoneOffset();
        timezone && (dateTimezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset), date = function(date, timezone, reverse) {
            const reverseValue = reverse ? -1 : 1,
                dateTimezoneOffset = date.getTimezoneOffset(),
                timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
            return function(date, minutes) {
                return (date = new Date(date.getTime())).setMinutes(date.getMinutes() + minutes), date
            }(date, reverseValue * (timezoneOffset - dateTimezoneOffset))
        }(date, timezone, !0));
        let text = "";
        return parts.forEach((value => {
            const dateFormatter = function(format) {
                if (DATE_FORMATS[format]) return DATE_FORMATS[format];
                let formatter;
                switch (format) {
                    case "G":
                    case "GG":
                    case "GGG":
                        formatter = dateStrGetter(TranslationType.Eras, TranslationWidth.Abbreviated);
                        break;
                    case "GGGG":
                        formatter = dateStrGetter(TranslationType.Eras, TranslationWidth.Wide);
                        break;
                    case "GGGGG":
                        formatter = dateStrGetter(TranslationType.Eras, TranslationWidth.Narrow);
                        break;
                    case "y":
                        formatter = dateGetter(DateType.FullYear, 1, 0, !1, !0);
                        break;
                    case "yy":
                        formatter = dateGetter(DateType.FullYear, 2, 0, !0, !0);
                        break;
                    case "yyy":
                        formatter = dateGetter(DateType.FullYear, 3, 0, !1, !0);
                        break;
                    case "yyyy":
                        formatter = dateGetter(DateType.FullYear, 4, 0, !1, !0);
                        break;
                    case "Y":
                        formatter = weekNumberingYearGetter(1);
                        break;
                    case "YY":
                        formatter = weekNumberingYearGetter(2, !0);
                        break;
                    case "YYY":
                        formatter = weekNumberingYearGetter(3);
                        break;
                    case "YYYY":
                        formatter = weekNumberingYearGetter(4);
                        break;
                    case "M":
                    case "L":
                        formatter = dateGetter(DateType.Month, 1, 1);
                        break;
                    case "MM":
                    case "LL":
                        formatter = dateGetter(DateType.Month, 2, 1);
                        break;
                    case "MMM":
                        formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Abbreviated);
                        break;
                    case "MMMM":
                        formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Wide);
                        break;
                    case "MMMMM":
                        formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Narrow);
                        break;
                    case "LLL":
                        formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Abbreviated, FormStyle.Standalone);
                        break;
                    case "LLLL":
                        formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Wide, FormStyle.Standalone);
                        break;
                    case "LLLLL":
                        formatter = dateStrGetter(TranslationType.Months, TranslationWidth.Narrow, FormStyle.Standalone);
                        break;
                    case "w":
                        formatter = weekGetter(1);
                        break;
                    case "ww":
                        formatter = weekGetter(2);
                        break;
                    case "W":
                        formatter = weekGetter(1, !0);
                        break;
                    case "d":
                        formatter = dateGetter(DateType.Date, 1);
                        break;
                    case "dd":
                        formatter = dateGetter(DateType.Date, 2);
                        break;
                    case "E":
                    case "EE":
                    case "EEE":
                        formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Abbreviated);
                        break;
                    case "EEEE":
                        formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Wide);
                        break;
                    case "EEEEE":
                        formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Narrow);
                        break;
                    case "EEEEEE":
                        formatter = dateStrGetter(TranslationType.Days, TranslationWidth.Short);
                        break;
                    case "a":
                    case "aa":
                    case "aaa":
                        formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Abbreviated);
                        break;
                    case "aaaa":
                        formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Wide);
                        break;
                    case "aaaaa":
                        formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Narrow);
                        break;
                    case "b":
                    case "bb":
                    case "bbb":
                        formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Abbreviated, FormStyle.Standalone, !0);
                        break;
                    case "bbbb":
                        formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Wide, FormStyle.Standalone, !0);
                        break;
                    case "bbbbb":
                        formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Narrow, FormStyle.Standalone, !0);
                        break;
                    case "B":
                    case "BB":
                    case "BBB":
                        formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Abbreviated, FormStyle.Format, !0);
                        break;
                    case "BBBB":
                        formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Wide, FormStyle.Format, !0);
                        break;
                    case "BBBBB":
                        formatter = dateStrGetter(TranslationType.DayPeriods, TranslationWidth.Narrow, FormStyle.Format, !0);
                        break;
                    case "h":
                        formatter = dateGetter(DateType.Hours, 1, -12);
                        break;
                    case "hh":
                        formatter = dateGetter(DateType.Hours, 2, -12);
                        break;
                    case "H":
                        formatter = dateGetter(DateType.Hours, 1);
                        break;
                    case "HH":
                        formatter = dateGetter(DateType.Hours, 2);
                        break;
                    case "m":
                        formatter = dateGetter(DateType.Minutes, 1);
                        break;
                    case "mm":
                        formatter = dateGetter(DateType.Minutes, 2);
                        break;
                    case "s":
                        formatter = dateGetter(DateType.Seconds, 1);
                        break;
                    case "ss":
                        formatter = dateGetter(DateType.Seconds, 2);
                        break;
                    case "S":
                        formatter = dateGetter(DateType.FractionalSeconds, 1);
                        break;
                    case "SS":
                        formatter = dateGetter(DateType.FractionalSeconds, 2);
                        break;
                    case "SSS":
                        formatter = dateGetter(DateType.FractionalSeconds, 3);
                        break;
                    case "Z":
                    case "ZZ":
                    case "ZZZ":
                        formatter = timeZoneGetter(ZoneWidth.Short);
                        break;
                    case "ZZZZZ":
                        formatter = timeZoneGetter(ZoneWidth.Extended);
                        break;
                    case "O":
                    case "OO":
                    case "OOO":
                    case "z":
                    case "zz":
                    case "zzz":
                        formatter = timeZoneGetter(ZoneWidth.ShortGMT);
                        break;
                    case "OOOO":
                    case "ZZZZ":
                    case "zzzz":
                        formatter = timeZoneGetter(ZoneWidth.Long);
                        break;
                    default:
                        return null
                }
                return DATE_FORMATS[format] = formatter, formatter
            }(value);
            text += dateFormatter ? dateFormatter(date, locale, dateTimezoneOffset) : "''" === value ? "'" : value.replace(/(^'|'$)/g, "").replace(/''/g, "'")
        })), text
    }

    function getNamedFormat(locale, format) {
        const localeId = function(locale) {
            return Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.vb)(locale)[_angular_core__WEBPACK_IMPORTED_MODULE_0__.lb.LocaleId]
        }(locale);
        if (NAMED_FORMATS[localeId] = NAMED_FORMATS[localeId] || {}, NAMED_FORMATS[localeId][format]) return NAMED_FORMATS[localeId][format];
        let formatValue = "";
        switch (format) {
            case "shortDate":
                formatValue = getLocaleDateFormat(locale, FormatWidth.Short);
                break;
            case "mediumDate":
                formatValue = getLocaleDateFormat(locale, FormatWidth.Medium);
                break;
            case "longDate":
                formatValue = getLocaleDateFormat(locale, FormatWidth.Long);
                break;
            case "fullDate":
                formatValue = getLocaleDateFormat(locale, FormatWidth.Full);
                break;
            case "shortTime":
                formatValue = getLocaleTimeFormat(locale, FormatWidth.Short);
                break;
            case "mediumTime":
                formatValue = getLocaleTimeFormat(locale, FormatWidth.Medium);
                break;
            case "longTime":
                formatValue = getLocaleTimeFormat(locale, FormatWidth.Long);
                break;
            case "fullTime":
                formatValue = getLocaleTimeFormat(locale, FormatWidth.Full);
                break;
            case "short":
                const shortTime = getNamedFormat(locale, "shortTime"),
                    shortDate = getNamedFormat(locale, "shortDate");
                formatValue = formatDateTime(getLocaleDateTimeFormat(locale, FormatWidth.Short), [shortTime, shortDate]);
                break;
            case "medium":
                const mediumTime = getNamedFormat(locale, "mediumTime"),
                    mediumDate = getNamedFormat(locale, "mediumDate");
                formatValue = formatDateTime(getLocaleDateTimeFormat(locale, FormatWidth.Medium), [mediumTime, mediumDate]);
                break;
            case "long":
                const longTime = getNamedFormat(locale, "longTime"),
                    longDate = getNamedFormat(locale, "longDate");
                formatValue = formatDateTime(getLocaleDateTimeFormat(locale, FormatWidth.Long), [longTime, longDate]);
                break;
            case "full":
                const fullTime = getNamedFormat(locale, "fullTime"),
                    fullDate = getNamedFormat(locale, "fullDate");
                formatValue = formatDateTime(getLocaleDateTimeFormat(locale, FormatWidth.Full), [fullTime, fullDate])
        }
        return formatValue && (NAMED_FORMATS[localeId][format] = formatValue), formatValue
    }

    function formatDateTime(str, opt_values) {
        return opt_values && (str = str.replace(/\{([^}]+)}/g, (function(match, key) {
            return null != opt_values && key in opt_values ? opt_values[key] : match
        }))), str
    }

    function padNumber(num, digits, minusSign = "-", trim, negWrap) {
        let neg = "";
        (num < 0 || negWrap && num <= 0) && (negWrap ? num = 1 - num : (num = -num, neg = minusSign));
        let strNum = String(num);
        for (; strNum.length < digits;) strNum = "0" + strNum;
        return trim && (strNum = strNum.substr(strNum.length - digits)), neg + strNum
    }

    function dateGetter(name, size, offset = 0, trim = !1, negWrap = !1) {
        return function(date, locale) {
            let part = function(part, date) {
                switch (part) {
                    case DateType.FullYear:
                        return date.getFullYear();
                    case DateType.Month:
                        return date.getMonth();
                    case DateType.Date:
                        return date.getDate();
                    case DateType.Hours:
                        return date.getHours();
                    case DateType.Minutes:
                        return date.getMinutes();
                    case DateType.Seconds:
                        return date.getSeconds();
                    case DateType.FractionalSeconds:
                        return date.getMilliseconds();
                    case DateType.Day:
                        return date.getDay();
                    default:
                        throw new Error(`Unknown DateType value "${part}".`)
                }
            }(name, date);
            if ((offset > 0 || part > -offset) && (part += offset), name === DateType.Hours) 0 === part && -12 === offset && (part = 12);
            else if (name === DateType.FractionalSeconds) return digits = size, padNumber(part, 3).substr(0, digits);
            var digits;
            const localeMinus = getLocaleNumberSymbol(locale, NumberSymbol.MinusSign);
            return padNumber(part, size, localeMinus, trim, negWrap)
        }
    }

    function dateStrGetter(name, width, form = FormStyle.Format, extended = !1) {
        return function(date, locale) {
            return function(date, locale, name, width, form, extended) {
                switch (name) {
                    case TranslationType.Months:
                        return function(locale, formStyle, width) {
                            const data = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.vb)(locale),
                                months = getLastDefinedValue([data[_angular_core__WEBPACK_IMPORTED_MODULE_0__.lb.MonthsFormat], data[_angular_core__WEBPACK_IMPORTED_MODULE_0__.lb.MonthsStandalone]], formStyle);
                            return getLastDefinedValue(months, width)
                        }(locale, form, width)[date.getMonth()];
                    case TranslationType.Days:
                        return function(locale, formStyle, width) {
                            const data = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.vb)(locale),
                                days = getLastDefinedValue([data[_angular_core__WEBPACK_IMPORTED_MODULE_0__.lb.DaysFormat], data[_angular_core__WEBPACK_IMPORTED_MODULE_0__.lb.DaysStandalone]], formStyle);
                            return getLastDefinedValue(days, width)
                        }(locale, form, width)[date.getDay()];
                    case TranslationType.DayPeriods:
                        const currentHours = date.getHours(),
                            currentMinutes = date.getMinutes();
                        if (extended) {
                            const rules = function(locale) {
                                    const data = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.vb)(locale);
                                    return checkFullData(data), (data[_angular_core__WEBPACK_IMPORTED_MODULE_0__.lb.ExtraData][2] || []).map((rule => "string" == typeof rule ? extractTime(rule) : [extractTime(rule[0]), extractTime(rule[1])]))
                                }(locale),
                                dayPeriods = function(locale, formStyle, width) {
                                    const data = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.vb)(locale);
                                    checkFullData(data);
                                    const dayPeriods = getLastDefinedValue([data[_angular_core__WEBPACK_IMPORTED_MODULE_0__.lb.ExtraData][0], data[_angular_core__WEBPACK_IMPORTED_MODULE_0__.lb.ExtraData][1]], formStyle) || [];
                                    return getLastDefinedValue(dayPeriods, width) || []
                                }(locale, form, width),
                                index = rules.findIndex((rule => {
                                    if (Array.isArray(rule)) {
                                        const [from, to] = rule, afterFrom = currentHours >= from.hours && currentMinutes >= from.minutes, beforeTo = currentHours < to.hours || currentHours === to.hours && currentMinutes < to.minutes;
                                        if (from.hours < to.hours) {
                                            if (afterFrom && beforeTo) return !0
                                        } else if (afterFrom || beforeTo) return !0
                                    } else if (rule.hours === currentHours && rule.minutes === currentMinutes) return !0;
                                    return !1
                                }));
                            if (-1 !== index) return dayPeriods[index]
                        }
                        return function(locale, formStyle, width) {
                            const data = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.vb)(locale),
                                amPm = getLastDefinedValue([data[_angular_core__WEBPACK_IMPORTED_MODULE_0__.lb.DayPeriodsFormat], data[_angular_core__WEBPACK_IMPORTED_MODULE_0__.lb.DayPeriodsStandalone]], formStyle);
                            return getLastDefinedValue(amPm, width)
                        }(locale, form, width)[currentHours < 12 ? 0 : 1];
                    case TranslationType.Eras:
                        return function(locale, width) {
                            return getLastDefinedValue(Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.vb)(locale)[_angular_core__WEBPACK_IMPORTED_MODULE_0__.lb.Eras], width)
                        }(locale, width)[date.getFullYear() <= 0 ? 0 : 1];
                    default:
                        throw new Error(`unexpected translation type ${name}`)
                }
            }(date, locale, name, width, form, extended)
        }
    }

    function timeZoneGetter(width) {
        return function(date, locale, offset) {
            const zone = -1 * offset,
                minusSign = getLocaleNumberSymbol(locale, NumberSymbol.MinusSign),
                hours = zone > 0 ? Math.floor(zone / 60) : Math.ceil(zone / 60);
            switch (width) {
                case ZoneWidth.Short:
                    return (zone >= 0 ? "+" : "") + padNumber(hours, 2, minusSign) + padNumber(Math.abs(zone % 60), 2, minusSign);
                case ZoneWidth.ShortGMT:
                    return "GMT" + (zone >= 0 ? "+" : "") + padNumber(hours, 1, minusSign);
                case ZoneWidth.Long:
                    return "GMT" + (zone >= 0 ? "+" : "") + padNumber(hours, 2, minusSign) + ":" + padNumber(Math.abs(zone % 60), 2, minusSign);
                case ZoneWidth.Extended:
                    return 0 === offset ? "Z" : (zone >= 0 ? "+" : "") + padNumber(hours, 2, minusSign) + ":" + padNumber(Math.abs(zone % 60), 2, minusSign);
                default:
                    throw new Error(`Unknown zone width "${width}"`)
            }
        }
    }! function(ZoneWidth) {
        ZoneWidth[ZoneWidth.Short = 0] = "Short", ZoneWidth[ZoneWidth.ShortGMT = 1] = "ShortGMT", ZoneWidth[ZoneWidth.Long = 2] = "Long", ZoneWidth[ZoneWidth.Extended = 3] = "Extended"
    }(ZoneWidth || (ZoneWidth = {})),
    function(DateType) {
        DateType[DateType.FullYear = 0] = "FullYear", DateType[DateType.Month = 1] = "Month", DateType[DateType.Date = 2] = "Date", DateType[DateType.Hours = 3] = "Hours", DateType[DateType.Minutes = 4] = "Minutes", DateType[DateType.Seconds = 5] = "Seconds", DateType[DateType.FractionalSeconds = 6] = "FractionalSeconds", DateType[DateType.Day = 7] = "Day"
    }(DateType || (DateType = {})),
    function(TranslationType) {
        TranslationType[TranslationType.DayPeriods = 0] = "DayPeriods", TranslationType[TranslationType.Days = 1] = "Days", TranslationType[TranslationType.Months = 2] = "Months", TranslationType[TranslationType.Eras = 3] = "Eras"
    }(TranslationType || (TranslationType = {}));

    function getThursdayThisWeek(datetime) {
        return new Date(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + (4 - datetime.getDay()))
    }

    function weekGetter(size, monthBased = !1) {
        return function(date, locale) {
            let result;
            if (monthBased) {
                const nbDaysBefore1stDayOfMonth = new Date(date.getFullYear(), date.getMonth(), 1).getDay() - 1,
                    today = date.getDate();
                result = 1 + Math.floor((today + nbDaysBefore1stDayOfMonth) / 7)
            } else {
                const thisThurs = getThursdayThisWeek(date),
                    firstThurs = function(year) {
                        const firstDayOfYear = new Date(year, 0, 1).getDay();
                        return new Date(year, 0, 1 + (firstDayOfYear <= 4 ? 4 : 11) - firstDayOfYear)
                    }(thisThurs.getFullYear()),
                    diff = thisThurs.getTime() - firstThurs.getTime();
                result = 1 + Math.round(diff / 6048e5)
            }
            return padNumber(result, size, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign))
        }
    }

    function weekNumberingYearGetter(size, trim = !1) {
        return function(date, locale) {
            return padNumber(getThursdayThisWeek(date).getFullYear(), size, getLocaleNumberSymbol(locale, NumberSymbol.MinusSign), trim)
        }
    }
    const DATE_FORMATS = {};

    function timezoneToOffset(timezone, fallback) {
        timezone = timezone.replace(/:/g, "");
        const requestedTimezoneOffset = Date.parse("Jan 01, 1970 00:00:00 " + timezone) / 6e4;
        return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset
    }

    function isDate(value) {
        return value instanceof Date && !isNaN(value.valueOf())
    }
    const NUMBER_FORMAT_REGEXP = /^(\d+)?\.((\d+)(-(\d+))?)?$/;

    function formatNumberToLocaleString(value, pattern, locale, groupSymbol, decimalSymbol, digitsInfo, isPercent = !1) {
        let formattedText = "",
            isZero = !1;
        if (isFinite(value)) {
            let parsedNumber = function(num) {
                let digits, integerLen, i, j, zeros, numStr = Math.abs(num) + "",
                    exponent = 0;
                (integerLen = numStr.indexOf(".")) > -1 && (numStr = numStr.replace(".", ""));
                (i = numStr.search(/e/i)) > 0 ? (integerLen < 0 && (integerLen = i), integerLen += +numStr.slice(i + 1), numStr = numStr.substring(0, i)) : integerLen < 0 && (integerLen = numStr.length);
                for (i = 0;
                    "0" === numStr.charAt(i); i++);
                if (i === (zeros = numStr.length)) digits = [0], integerLen = 1;
                else {
                    for (zeros--;
                        "0" === numStr.charAt(zeros);) zeros--;
                    for (integerLen -= i, digits = [], j = 0; i <= zeros; i++, j++) digits[j] = Number(numStr.charAt(i))
                }
                integerLen > 22 && (digits = digits.splice(0, 21), exponent = integerLen - 1, integerLen = 1);
                return {
                    digits: digits,
                    exponent: exponent,
                    integerLen: integerLen
                }
            }(value);
            isPercent && (parsedNumber = function(parsedNumber) {
                if (0 === parsedNumber.digits[0]) return parsedNumber;
                const fractionLen = parsedNumber.digits.length - parsedNumber.integerLen;
                parsedNumber.exponent ? parsedNumber.exponent += 2 : (0 === fractionLen ? parsedNumber.digits.push(0, 0) : 1 === fractionLen && parsedNumber.digits.push(0), parsedNumber.integerLen += 2);
                return parsedNumber
            }(parsedNumber));
            let minInt = pattern.minInt,
                minFraction = pattern.minFrac,
                maxFraction = pattern.maxFrac;
            if (digitsInfo) {
                const parts = digitsInfo.match(NUMBER_FORMAT_REGEXP);
                if (null === parts) throw new Error(`${digitsInfo} is not a valid digit info`);
                const minIntPart = parts[1],
                    minFractionPart = parts[3],
                    maxFractionPart = parts[5];
                null != minIntPart && (minInt = parseIntAutoRadix(minIntPart)), null != minFractionPart && (minFraction = parseIntAutoRadix(minFractionPart)), null != maxFractionPart ? maxFraction = parseIntAutoRadix(maxFractionPart) : null != minFractionPart && minFraction > maxFraction && (maxFraction = minFraction)
            }! function(parsedNumber, minFrac, maxFrac) {
                if (minFrac > maxFrac) throw new Error(`The minimum number of digits after fraction (${minFrac}) is higher than the maximum (${maxFrac}).`);
                let digits = parsedNumber.digits,
                    fractionLen = digits.length - parsedNumber.integerLen;
                const fractionSize = Math.min(Math.max(minFrac, fractionLen), maxFrac);
                let roundAt = fractionSize + parsedNumber.integerLen,
                    digit = digits[roundAt];
                if (roundAt > 0) {
                    digits.splice(Math.max(parsedNumber.integerLen, roundAt));
                    for (let j = roundAt; j < digits.length; j++) digits[j] = 0
                } else {
                    fractionLen = Math.max(0, fractionLen), parsedNumber.integerLen = 1, digits.length = Math.max(1, roundAt = fractionSize + 1), digits[0] = 0;
                    for (let i = 1; i < roundAt; i++) digits[i] = 0
                }
                if (digit >= 5)
                    if (roundAt - 1 < 0) {
                        for (let k = 0; k > roundAt; k--) digits.unshift(0), parsedNumber.integerLen++;
                        digits.unshift(1), parsedNumber.integerLen++
                    } else digits[roundAt - 1]++;
                for (; fractionLen < Math.max(0, fractionSize); fractionLen++) digits.push(0);
                let dropTrailingZeros = 0 !== fractionSize;
                const minLen = minFrac + parsedNumber.integerLen,
                    carry = digits.reduceRight((function(carry, d, i, digits) {
                        return d += carry, digits[i] = d < 10 ? d : d - 10, dropTrailingZeros && (0 === digits[i] && i >= minLen ? digits.pop() : dropTrailingZeros = !1), d >= 10 ? 1 : 0
                    }), 0);
                carry && (digits.unshift(carry), parsedNumber.integerLen++)
            }(parsedNumber, minFraction, maxFraction);
            let digits = parsedNumber.digits,
                integerLen = parsedNumber.integerLen;
            const exponent = parsedNumber.exponent;
            let decimals = [];
            for (isZero = digits.every((d => !d)); integerLen < minInt; integerLen++) digits.unshift(0);
            for (; integerLen < 0; integerLen++) digits.unshift(0);
            integerLen > 0 ? decimals = digits.splice(integerLen, digits.length) : (decimals = digits, digits = [0]);
            const groups = [];
            for (digits.length >= pattern.lgSize && groups.unshift(digits.splice(-pattern.lgSize, digits.length).join("")); digits.length > pattern.gSize;) groups.unshift(digits.splice(-pattern.gSize, digits.length).join(""));
            digits.length && groups.unshift(digits.join("")), formattedText = groups.join(getLocaleNumberSymbol(locale, groupSymbol)), decimals.length && (formattedText += getLocaleNumberSymbol(locale, decimalSymbol) + decimals.join("")), exponent && (formattedText += getLocaleNumberSymbol(locale, NumberSymbol.Exponential) + "+" + exponent)
        } else formattedText = getLocaleNumberSymbol(locale, NumberSymbol.Infinity);
        return formattedText = value < 0 && !isZero ? pattern.negPre + formattedText + pattern.negSuf : pattern.posPre + formattedText + pattern.posSuf, formattedText
    }

    function formatCurrency(value, locale, currency, currencyCode, digitsInfo) {
        const pattern = parseNumberFormat(getLocaleNumberFormat(locale, NumberFormatStyle.Currency), getLocaleNumberSymbol(locale, NumberSymbol.MinusSign));
        pattern.minFrac = function(code) {
            let digits;
            const currency = CURRENCIES_EN[code];
            return currency && (digits = currency[2]), "number" == typeof digits ? digits : 2
        }(currencyCode), pattern.maxFrac = pattern.minFrac;
        return formatNumberToLocaleString(value, pattern, locale, NumberSymbol.CurrencyGroup, NumberSymbol.CurrencyDecimal, digitsInfo).replace("¤", currency).replace("¤", "").trim()
    }

    function parseNumberFormat(format, minusSign = "-") {
        const p = {
                minInt: 1,
                minFrac: 0,
                maxFrac: 0,
                posPre: "",
                posSuf: "",
                negPre: "",
                negSuf: "",
                gSize: 0,
                lgSize: 0
            },
            patternParts = format.split(";"),
            positive = patternParts[0],
            negative = patternParts[1],
            positiveParts = -1 !== positive.indexOf(".") ? positive.split(".") : [positive.substring(0, positive.lastIndexOf("0") + 1), positive.substring(positive.lastIndexOf("0") + 1)],
            integer = positiveParts[0],
            fraction = positiveParts[1] || "";
        p.posPre = integer.substr(0, integer.indexOf("#"));
        for (let i = 0; i < fraction.length; i++) {
            const ch = fraction.charAt(i);
            "0" === ch ? p.minFrac = p.maxFrac = i + 1 : "#" === ch ? p.maxFrac = i + 1 : p.posSuf += ch
        }
        const groups = integer.split(",");
        if (p.gSize = groups[1] ? groups[1].length : 0, p.lgSize = groups[2] || groups[1] ? (groups[2] || groups[1]).length : 0, negative) {
            const trunkLen = positive.length - p.posPre.length - p.posSuf.length,
                pos = negative.indexOf("#");
            p.negPre = negative.substr(0, pos).replace(/'/g, ""), p.negSuf = negative.substr(pos + trunkLen).replace(/'/g, "")
        } else p.negPre = minusSign + p.posPre, p.negSuf = p.posSuf;
        return p
    }

    function parseIntAutoRadix(text) {
        const result = parseInt(text);
        if (isNaN(result)) throw new Error("Invalid integer literal when parsing " + text);
        return result
    }
    class NgLocalization {}

    function getPluralCategory(value, cases, ngLocalization, locale) {
        let key = `=${value}`;
        if (cases.indexOf(key) > -1) return key;
        if (key = ngLocalization.getPluralCategory(value, locale), cases.indexOf(key) > -1) return key;
        if (cases.indexOf("other") > -1) return "other";
        throw new Error(`No plural message found for value "${value}"`)
    }
    class NgLocaleLocalization extends NgLocalization {
        constructor(locale) {
            super(), this.locale = locale
        }
        getPluralCategory(value, locale) {
            switch (getLocalePluralCase(locale || this.locale)(value)) {
                case Plural.Zero:
                    return "zero";
                case Plural.One:
                    return "one";
                case Plural.Two:
                    return "two";
                case Plural.Few:
                    return "few";
                case Plural.Many:
                    return "many";
                default:
                    return "other"
            }
        }
    }

    function parseCookieValue(cookieStr, name) {
        name = encodeURIComponent(name);
        for (const cookie of cookieStr.split(";")) {
            const eqIndex = cookie.indexOf("="),
                [cookieName, cookieValue] = -1 == eqIndex ? [cookie, ""] : [cookie.slice(0, eqIndex), cookie.slice(eqIndex + 1)];
            if (cookieName.trim() === name) return decodeURIComponent(cookieValue)
        }
        return null
    }
    NgLocaleLocalization.decorators = [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.v
    }], NgLocaleLocalization.ctorParameters = () => [{
        type: String,
        decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.u,
            args: [_angular_core__WEBPACK_IMPORTED_MODULE_0__.B]
        }]
    }];
    class NgClass {
        constructor(_iterableDiffers, _keyValueDiffers, _ngEl, _renderer) {
            this._iterableDiffers = _iterableDiffers, this._keyValueDiffers = _keyValueDiffers, this._ngEl = _ngEl, this._renderer = _renderer, this._iterableDiffer = null, this._keyValueDiffer = null, this._initialClasses = [], this._rawClass = null
        }
        set klass(value) {
            this._removeClasses(this._initialClasses), this._initialClasses = "string" == typeof value ? value.split(/\s+/) : [], this._applyClasses(this._initialClasses), this._applyClasses(this._rawClass)
        }
        set ngClass(value) {
            this._removeClasses(this._rawClass), this._applyClasses(this._initialClasses), this._iterableDiffer = null, this._keyValueDiffer = null, this._rawClass = "string" == typeof value ? value.split(/\s+/) : value, this._rawClass && (Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Bb)(this._rawClass) ? this._iterableDiffer = this._iterableDiffers.find(this._rawClass).create() : this._keyValueDiffer = this._keyValueDiffers.find(this._rawClass).create())
        }
        ngDoCheck() {
            if (this._iterableDiffer) {
                const iterableChanges = this._iterableDiffer.diff(this._rawClass);
                iterableChanges && this._applyIterableChanges(iterableChanges)
            } else if (this._keyValueDiffer) {
                const keyValueChanges = this._keyValueDiffer.diff(this._rawClass);
                keyValueChanges && this._applyKeyValueChanges(keyValueChanges)
            }
        }
        _applyKeyValueChanges(changes) {
            changes.forEachAddedItem((record => this._toggleClass(record.key, record.currentValue))), changes.forEachChangedItem((record => this._toggleClass(record.key, record.currentValue))), changes.forEachRemovedItem((record => {
                record.previousValue && this._toggleClass(record.key, !1)
            }))
        }
        _applyIterableChanges(changes) {
            changes.forEachAddedItem((record => {
                if ("string" != typeof record.item) throw new Error(`NgClass can only toggle CSS classes expressed as strings, got ${Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Gb)(record.item)}`);
                this._toggleClass(record.item, !0)
            })), changes.forEachRemovedItem((record => this._toggleClass(record.item, !1)))
        }
        _applyClasses(rawClassVal) {
            rawClassVal && (Array.isArray(rawClassVal) || rawClassVal instanceof Set ? rawClassVal.forEach((klass => this._toggleClass(klass, !0))) : Object.keys(rawClassVal).forEach((klass => this._toggleClass(klass, !!rawClassVal[klass]))))
        }
        _removeClasses(rawClassVal) {
            rawClassVal && (Array.isArray(rawClassVal) || rawClassVal instanceof Set ? rawClassVal.forEach((klass => this._toggleClass(klass, !1))) : Object.keys(rawClassVal).forEach((klass => this._toggleClass(klass, !1))))
        }
        _toggleClass(klass, enabled) {
            (klass = klass.trim()) && klass.split(/\s+/g).forEach((klass => {
                enabled ? this._renderer.addClass(this._ngEl.nativeElement, klass) : this._renderer.removeClass(this._ngEl.nativeElement, klass)
            }))
        }
    }
    NgClass.decorators = [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.n,
        args: [{
            selector: "[ngClass]"
        }]
    }], NgClass.ctorParameters = () => [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.z
    }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.A
    }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.o
    }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.P
    }], NgClass.propDecorators = {
        klass: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.y,
            args: ["class"]
        }],
        ngClass: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.y,
            args: ["ngClass"]
        }]
    };
    class NgComponentOutlet {
        constructor(_viewContainerRef) {
            this._viewContainerRef = _viewContainerRef, this._componentRef = null, this._moduleRef = null
        }
        ngOnChanges(changes) {
            if (this._viewContainerRef.clear(), this._componentRef = null, this.ngComponentOutlet) {
                const elInjector = this.ngComponentOutletInjector || this._viewContainerRef.parentInjector;
                if (changes.ngComponentOutletNgModuleFactory)
                    if (this._moduleRef && this._moduleRef.destroy(), this.ngComponentOutletNgModuleFactory) {
                        const parentModule = elInjector.get(_angular_core__WEBPACK_IMPORTED_MODULE_0__.F);
                        this._moduleRef = this.ngComponentOutletNgModuleFactory.create(parentModule.injector)
                    } else this._moduleRef = null;
                const componentFactory = (this._moduleRef ? this._moduleRef.componentFactoryResolver : elInjector.get(_angular_core__WEBPACK_IMPORTED_MODULE_0__.k)).resolveComponentFactory(this.ngComponentOutlet);
                this._componentRef = this._viewContainerRef.createComponent(componentFactory, this._viewContainerRef.length, elInjector, this.ngComponentOutletContent)
            }
        }
        ngOnDestroy() {
            this._moduleRef && this._moduleRef.destroy()
        }
    }
    NgComponentOutlet.decorators = [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.n,
        args: [{
            selector: "[ngComponentOutlet]"
        }]
    }], NgComponentOutlet.ctorParameters = () => [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.cb
    }], NgComponentOutlet.propDecorators = {
        ngComponentOutlet: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.y
        }],
        ngComponentOutletInjector: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.y
        }],
        ngComponentOutletContent: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.y
        }],
        ngComponentOutletNgModuleFactory: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.y
        }]
    };
    class NgForOfContext {
        constructor($implicit, ngForOf, index, count) {
            this.$implicit = $implicit, this.ngForOf = ngForOf, this.index = index, this.count = count
        }
        get first() {
            return 0 === this.index
        }
        get last() {
            return this.index === this.count - 1
        }
        get even() {
            return this.index % 2 == 0
        }
        get odd() {
            return !this.even
        }
    }
    class NgForOf {
        constructor(_viewContainer, _template, _differs) {
            this._viewContainer = _viewContainer, this._template = _template, this._differs = _differs, this._ngForOf = null, this._ngForOfDirty = !0, this._differ = null
        }
        set ngForOf(ngForOf) {
            this._ngForOf = ngForOf, this._ngForOfDirty = !0
        }
        set ngForTrackBy(fn) {
            "undefined" != typeof ngDevMode && !ngDevMode || null == fn || "function" == typeof fn || console && console.warn && console.warn(`trackBy must be a function, but received ${JSON.stringify(fn)}. See https://angular.io/api/common/NgForOf#change-propagation for more information.`), this._trackByFn = fn
        }
        get ngForTrackBy() {
            return this._trackByFn
        }
        set ngForTemplate(value) {
            value && (this._template = value)
        }
        ngDoCheck() {
            if (this._ngForOfDirty) {
                this._ngForOfDirty = !1;
                const value = this._ngForOf;
                if (!this._differ && value) try {
                    this._differ = this._differs.find(value).create(this.ngForTrackBy)
                } catch (_a) {
                    throw new Error(`Cannot find a differ supporting object '${value}' of type '${type=value,type.name||typeof type}'. NgFor only supports binding to Iterables such as Arrays.`)
                }
            }
            var type;
            if (this._differ) {
                const changes = this._differ.diff(this._ngForOf);
                changes && this._applyChanges(changes)
            }
        }
        _applyChanges(changes) {
            const insertTuples = [];
            changes.forEachOperation(((item, adjustedPreviousIndex, currentIndex) => {
                if (null == item.previousIndex) {
                    const view = this._viewContainer.createEmbeddedView(this._template, new NgForOfContext(null, this._ngForOf, -1, -1), null === currentIndex ? void 0 : currentIndex),
                        tuple = new RecordViewTuple(item, view);
                    insertTuples.push(tuple)
                } else if (null == currentIndex) this._viewContainer.remove(null === adjustedPreviousIndex ? void 0 : adjustedPreviousIndex);
                else if (null !== adjustedPreviousIndex) {
                    const view = this._viewContainer.get(adjustedPreviousIndex);
                    this._viewContainer.move(view, currentIndex);
                    const tuple = new RecordViewTuple(item, view);
                    insertTuples.push(tuple)
                }
            }));
            for (let i = 0; i < insertTuples.length; i++) this._perViewChange(insertTuples[i].view, insertTuples[i].record);
            for (let i = 0, ilen = this._viewContainer.length; i < ilen; i++) {
                const viewRef = this._viewContainer.get(i);
                viewRef.context.index = i, viewRef.context.count = ilen, viewRef.context.ngForOf = this._ngForOf
            }
            changes.forEachIdentityChange((record => {
                this._viewContainer.get(record.currentIndex).context.$implicit = record.item
            }))
        }
        _perViewChange(view, record) {
            view.context.$implicit = record.item
        }
        static ngTemplateContextGuard(dir, ctx) {
            return !0
        }
    }
    NgForOf.decorators = [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.n,
        args: [{
            selector: "[ngFor][ngForOf]"
        }]
    }], NgForOf.ctorParameters = () => [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.cb
    }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.X
    }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.z
    }], NgForOf.propDecorators = {
        ngForOf: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.y
        }],
        ngForTrackBy: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.y
        }],
        ngForTemplate: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.y
        }]
    };
    class RecordViewTuple {
        constructor(record, view) {
            this.record = record, this.view = view
        }
    }
    class NgIf {
        constructor(_viewContainer, templateRef) {
            this._viewContainer = _viewContainer, this._context = new NgIfContext, this._thenTemplateRef = null, this._elseTemplateRef = null, this._thenViewRef = null, this._elseViewRef = null, this._thenTemplateRef = templateRef
        }
        set ngIf(condition) {
            this._context.$implicit = this._context.ngIf = condition, this._updateView()
        }
        set ngIfThen(templateRef) {
            assertTemplate("ngIfThen", templateRef), this._thenTemplateRef = templateRef, this._thenViewRef = null, this._updateView()
        }
        set ngIfElse(templateRef) {
            assertTemplate("ngIfElse", templateRef), this._elseTemplateRef = templateRef, this._elseViewRef = null, this._updateView()
        }
        _updateView() {
            this._context.$implicit ? this._thenViewRef || (this._viewContainer.clear(), this._elseViewRef = null, this._thenTemplateRef && (this._thenViewRef = this._viewContainer.createEmbeddedView(this._thenTemplateRef, this._context))) : this._elseViewRef || (this._viewContainer.clear(), this._thenViewRef = null, this._elseTemplateRef && (this._elseViewRef = this._viewContainer.createEmbeddedView(this._elseTemplateRef, this._context)))
        }
        static ngTemplateContextGuard(dir, ctx) {
            return !0
        }
    }
    NgIf.decorators = [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.n,
        args: [{
            selector: "[ngIf]"
        }]
    }], NgIf.ctorParameters = () => [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.cb
    }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.X
    }], NgIf.propDecorators = {
        ngIf: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.y
        }],
        ngIfThen: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.y
        }],
        ngIfElse: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.y
        }]
    };
    class NgIfContext {
        constructor() {
            this.$implicit = null, this.ngIf = null
        }
    }

    function assertTemplate(property, templateRef) {
        if (!!(templateRef && !templateRef.createEmbeddedView)) throw new Error(`${property} must be a TemplateRef, but received '${Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Gb)(templateRef)}'.`)
    }
    class SwitchView {
        constructor(_viewContainerRef, _templateRef) {
            this._viewContainerRef = _viewContainerRef, this._templateRef = _templateRef, this._created = !1
        }
        create() {
            this._created = !0, this._viewContainerRef.createEmbeddedView(this._templateRef)
        }
        destroy() {
            this._created = !1, this._viewContainerRef.clear()
        }
        enforceState(created) {
            created && !this._created ? this.create() : !created && this._created && this.destroy()
        }
    }
    class NgSwitch {
        constructor() {
            this._defaultUsed = !1, this._caseCount = 0, this._lastCaseCheckIndex = 0, this._lastCasesMatched = !1
        }
        set ngSwitch(newValue) {
            this._ngSwitch = newValue, 0 === this._caseCount && this._updateDefaultCases(!0)
        }
        _addCase() {
            return this._caseCount++
        }
        _addDefault(view) {
            this._defaultViews || (this._defaultViews = []), this._defaultViews.push(view)
        }
        _matchCase(value) {
            const matched = value == this._ngSwitch;
            return this._lastCasesMatched = this._lastCasesMatched || matched, this._lastCaseCheckIndex++, this._lastCaseCheckIndex === this._caseCount && (this._updateDefaultCases(!this._lastCasesMatched), this._lastCaseCheckIndex = 0, this._lastCasesMatched = !1), matched
        }
        _updateDefaultCases(useDefault) {
            if (this._defaultViews && useDefault !== this._defaultUsed) {
                this._defaultUsed = useDefault;
                for (let i = 0; i < this._defaultViews.length; i++) {
                    this._defaultViews[i].enforceState(useDefault)
                }
            }
        }
    }
    NgSwitch.decorators = [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.n,
        args: [{
            selector: "[ngSwitch]"
        }]
    }], NgSwitch.propDecorators = {
        ngSwitch: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.y
        }]
    };
    class NgSwitchCase {
        constructor(viewContainer, templateRef, ngSwitch) {
            this.ngSwitch = ngSwitch, ngSwitch._addCase(), this._view = new SwitchView(viewContainer, templateRef)
        }
        ngDoCheck() {
            this._view.enforceState(this.ngSwitch._matchCase(this.ngSwitchCase))
        }
    }
    NgSwitchCase.decorators = [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.n,
        args: [{
            selector: "[ngSwitchCase]"
        }]
    }], NgSwitchCase.ctorParameters = () => [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.cb
    }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.X
    }, {
        type: NgSwitch,
        decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.r
        }]
    }], NgSwitchCase.propDecorators = {
        ngSwitchCase: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.y
        }]
    };
    class NgSwitchDefault {
        constructor(viewContainer, templateRef, ngSwitch) {
            ngSwitch._addDefault(new SwitchView(viewContainer, templateRef))
        }
    }
    NgSwitchDefault.decorators = [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.n,
        args: [{
            selector: "[ngSwitchDefault]"
        }]
    }], NgSwitchDefault.ctorParameters = () => [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.cb
    }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.X
    }, {
        type: NgSwitch,
        decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.r
        }]
    }];
    class NgPlural {
        constructor(_localization) {
            this._localization = _localization, this._caseViews = {}
        }
        set ngPlural(value) {
            this._switchValue = value, this._updateView()
        }
        addCase(value, switchView) {
            this._caseViews[value] = switchView
        }
        _updateView() {
            this._clearViews();
            const cases = Object.keys(this._caseViews),
                key = getPluralCategory(this._switchValue, cases, this._localization);
            this._activateView(this._caseViews[key])
        }
        _clearViews() {
            this._activeView && this._activeView.destroy()
        }
        _activateView(view) {
            view && (this._activeView = view, this._activeView.create())
        }
    }
    NgPlural.decorators = [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.n,
        args: [{
            selector: "[ngPlural]"
        }]
    }], NgPlural.ctorParameters = () => [{
        type: NgLocalization
    }], NgPlural.propDecorators = {
        ngPlural: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.y
        }]
    };
    class NgPluralCase {
        constructor(value, template, viewContainer, ngPlural) {
            this.value = value;
            const isANumber = !isNaN(Number(value));
            ngPlural.addCase(isANumber ? `=${value}` : value, new SwitchView(viewContainer, template))
        }
    }
    NgPluralCase.decorators = [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.n,
        args: [{
            selector: "[ngPluralCase]"
        }]
    }], NgPluralCase.ctorParameters = () => [{
        type: String,
        decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.g,
            args: ["ngPluralCase"]
        }]
    }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.X
    }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.cb
    }, {
        type: NgPlural,
        decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.r
        }]
    }];
    class NgStyle {
        constructor(_ngEl, _differs, _renderer) {
            this._ngEl = _ngEl, this._differs = _differs, this._renderer = _renderer, this._ngStyle = null, this._differ = null
        }
        set ngStyle(values) {
            this._ngStyle = values, !this._differ && values && (this._differ = this._differs.find(values).create())
        }
        ngDoCheck() {
            if (this._differ) {
                const changes = this._differ.diff(this._ngStyle);
                changes && this._applyChanges(changes)
            }
        }
        _setStyle(nameAndUnit, value) {
            const [name, unit] = nameAndUnit.split(".");
            null != (value = null != value && unit ? `${value}${unit}` : value) ? this._renderer.setStyle(this._ngEl.nativeElement, name, value) : this._renderer.removeStyle(this._ngEl.nativeElement, name)
        }
        _applyChanges(changes) {
            changes.forEachRemovedItem((record => this._setStyle(record.key, null))), changes.forEachAddedItem((record => this._setStyle(record.key, record.currentValue))), changes.forEachChangedItem((record => this._setStyle(record.key, record.currentValue)))
        }
    }
    NgStyle.decorators = [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.n,
        args: [{
            selector: "[ngStyle]"
        }]
    }], NgStyle.ctorParameters = () => [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.o
    }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.A
    }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.P
    }], NgStyle.propDecorators = {
        ngStyle: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.y,
            args: ["ngStyle"]
        }]
    };
    class NgTemplateOutlet {
        constructor(_viewContainerRef) {
            this._viewContainerRef = _viewContainerRef, this._viewRef = null, this.ngTemplateOutletContext = null, this.ngTemplateOutlet = null
        }
        ngOnChanges(changes) {
            if (this._shouldRecreateView(changes)) {
                const viewContainerRef = this._viewContainerRef;
                this._viewRef && viewContainerRef.remove(viewContainerRef.indexOf(this._viewRef)), this._viewRef = this.ngTemplateOutlet ? viewContainerRef.createEmbeddedView(this.ngTemplateOutlet, this.ngTemplateOutletContext) : null
            } else this._viewRef && this.ngTemplateOutletContext && this._updateExistingContext(this.ngTemplateOutletContext)
        }
        _shouldRecreateView(changes) {
            const ctxChange = changes.ngTemplateOutletContext;
            return !!changes.ngTemplateOutlet || ctxChange && this._hasContextShapeChanged(ctxChange)
        }
        _hasContextShapeChanged(ctxChange) {
            const prevCtxKeys = Object.keys(ctxChange.previousValue || {}),
                currCtxKeys = Object.keys(ctxChange.currentValue || {});
            if (prevCtxKeys.length === currCtxKeys.length) {
                for (let propName of currCtxKeys)
                    if (-1 === prevCtxKeys.indexOf(propName)) return !0;
                return !1
            }
            return !0
        }
        _updateExistingContext(ctx) {
            for (let propName of Object.keys(ctx)) this._viewRef.context[propName] = this.ngTemplateOutletContext[propName]
        }
    }
    NgTemplateOutlet.decorators = [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.n,
        args: [{
            selector: "[ngTemplateOutlet]"
        }]
    }], NgTemplateOutlet.ctorParameters = () => [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.cb
    }], NgTemplateOutlet.propDecorators = {
        ngTemplateOutletContext: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.y
        }],
        ngTemplateOutlet: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.y
        }]
    };
    const COMMON_DIRECTIVES = [NgClass, NgComponentOutlet, NgForOf, NgIf, NgTemplateOutlet, NgStyle, NgSwitch, NgSwitchCase, NgSwitchDefault, NgPlural, NgPluralCase];

    function invalidPipeArgumentError(type, value) {
        return Error(`InvalidPipeArgument: '${value}' for pipe '${Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Gb)(type)}'`)
    }
    const _promiseStrategy = new class {
            createSubscription(async, updateLatestValue) {
                return async.then(updateLatestValue, (e => {
                    throw e
                }))
            }
            dispose(subscription) {}
            onDestroy(subscription) {}
        },
        _observableStrategy = new class {
            createSubscription(async, updateLatestValue) {
                return async.subscribe({
                    next: updateLatestValue,
                    error: e => {
                        throw e
                    }
                })
            }
            dispose(subscription) {
                subscription.unsubscribe()
            }
            onDestroy(subscription) {
                subscription.unsubscribe()
            }
        };
    class AsyncPipe {
        constructor(_ref) {
            this._ref = _ref, this._latestValue = null, this._subscription = null, this._obj = null, this._strategy = null
        }
        ngOnDestroy() {
            this._subscription && this._dispose()
        }
        transform(obj) {
            return this._obj ? obj !== this._obj ? (this._dispose(), this.transform(obj)) : this._latestValue : (obj && this._subscribe(obj), this._latestValue)
        }
        _subscribe(obj) {
            this._obj = obj, this._strategy = this._selectStrategy(obj), this._subscription = this._strategy.createSubscription(obj, (value => this._updateLatestValue(obj, value)))
        }
        _selectStrategy(obj) {
            if (Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Db)(obj)) return _promiseStrategy;
            if (Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Cb)(obj)) return _observableStrategy;
            throw invalidPipeArgumentError(AsyncPipe, obj)
        }
        _dispose() {
            this._strategy.dispose(this._subscription), this._latestValue = null, this._subscription = null, this._obj = null
        }
        _updateLatestValue(async, value) {
            async === this._obj && (this._latestValue = value, this._ref.markForCheck())
        }
    }
    AsyncPipe.decorators = [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.M,
        args: [{
            name: "async",
            pure: !1
        }]
    }], AsyncPipe.ctorParameters = () => [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.h
    }];
    class LowerCasePipe {
        transform(value) {
            if (null == value) return null;
            if ("string" != typeof value) throw invalidPipeArgumentError(LowerCasePipe, value);
            return value.toLowerCase()
        }
    }
    LowerCasePipe.decorators = [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.M,
        args: [{
            name: "lowercase"
        }]
    }];
    const unicodeWordMatch = /(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312E\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FEA\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE83\uDE86-\uDE89\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0\uDFE1]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00-\uDD1E\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D])\S*/g;
    class TitleCasePipe {
        transform(value) {
            if (null == value) return null;
            if ("string" != typeof value) throw invalidPipeArgumentError(TitleCasePipe, value);
            return value.replace(unicodeWordMatch, (txt => txt[0].toUpperCase() + txt.substr(1).toLowerCase()))
        }
    }
    TitleCasePipe.decorators = [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.M,
        args: [{
            name: "titlecase"
        }]
    }];
    class UpperCasePipe {
        transform(value) {
            if (null == value) return null;
            if ("string" != typeof value) throw invalidPipeArgumentError(UpperCasePipe, value);
            return value.toUpperCase()
        }
    }
    UpperCasePipe.decorators = [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.M,
        args: [{
            name: "uppercase"
        }]
    }];
    class DatePipe {
        constructor(locale) {
            this.locale = locale
        }
        transform(value, format = "mediumDate", timezone, locale) {
            if (null == value || "" === value || value != value) return null;
            try {
                return formatDate(value, format, locale || this.locale, timezone)
            } catch (error) {
                throw invalidPipeArgumentError(DatePipe, error.message)
            }
        }
    }
    DatePipe.decorators = [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.M,
        args: [{
            name: "date",
            pure: !0
        }]
    }], DatePipe.ctorParameters = () => [{
        type: String,
        decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.u,
            args: [_angular_core__WEBPACK_IMPORTED_MODULE_0__.B]
        }]
    }];
    const _INTERPOLATION_REGEXP = /#/g;
    class I18nPluralPipe {
        constructor(_localization) {
            this._localization = _localization
        }
        transform(value, pluralMap, locale) {
            if (null == value) return "";
            if ("object" != typeof pluralMap || null === pluralMap) throw invalidPipeArgumentError(I18nPluralPipe, pluralMap);
            return pluralMap[getPluralCategory(value, Object.keys(pluralMap), this._localization, locale)].replace(_INTERPOLATION_REGEXP, value.toString())
        }
    }
    I18nPluralPipe.decorators = [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.M,
        args: [{
            name: "i18nPlural",
            pure: !0
        }]
    }], I18nPluralPipe.ctorParameters = () => [{
        type: NgLocalization
    }];
    class I18nSelectPipe {
        transform(value, mapping) {
            if (null == value) return "";
            if ("object" != typeof mapping || "string" != typeof value) throw invalidPipeArgumentError(I18nSelectPipe, mapping);
            return mapping.hasOwnProperty(value) ? mapping[value] : mapping.hasOwnProperty("other") ? mapping.other : ""
        }
    }
    I18nSelectPipe.decorators = [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.M,
        args: [{
            name: "i18nSelect",
            pure: !0
        }]
    }];
    class JsonPipe {
        transform(value) {
            return JSON.stringify(value, null, 2)
        }
    }
    JsonPipe.decorators = [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.M,
        args: [{
            name: "json",
            pure: !1
        }]
    }];
    class KeyValuePipe {
        constructor(differs) {
            this.differs = differs, this.keyValues = []
        }
        transform(input, compareFn = defaultComparator) {
            if (!input || !(input instanceof Map) && "object" != typeof input) return null;
            this.differ || (this.differ = this.differs.find(input).create());
            const differChanges = this.differ.diff(input);
            return differChanges && (this.keyValues = [], differChanges.forEachItem((r => {
                var key, value;
                this.keyValues.push((key = r.key, value = r.currentValue, {
                    key: key,
                    value: value
                }))
            })), this.keyValues.sort(compareFn)), this.keyValues
        }
    }

    function defaultComparator(keyValueA, keyValueB) {
        const a = keyValueA.key,
            b = keyValueB.key;
        if (a === b) return 0;
        if (void 0 === a) return 1;
        if (void 0 === b) return -1;
        if (null === a) return 1;
        if (null === b) return -1;
        if ("string" == typeof a && "string" == typeof b) return a < b ? -1 : 1;
        if ("number" == typeof a && "number" == typeof b) return a - b;
        if ("boolean" == typeof a && "boolean" == typeof b) return a < b ? -1 : 1;
        const aString = String(a),
            bString = String(b);
        return aString == bString ? 0 : aString < bString ? -1 : 1
    }
    KeyValuePipe.decorators = [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.M,
        args: [{
            name: "keyvalue",
            pure: !1
        }]
    }], KeyValuePipe.ctorParameters = () => [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.A
    }];
    class DecimalPipe {
        constructor(_locale) {
            this._locale = _locale
        }
        transform(value, digitsInfo, locale) {
            if (!isValue(value)) return null;
            locale = locale || this._locale;
            try {
                return function(value, locale, digitsInfo) {
                    return formatNumberToLocaleString(value, parseNumberFormat(getLocaleNumberFormat(locale, NumberFormatStyle.Decimal), getLocaleNumberSymbol(locale, NumberSymbol.MinusSign)), locale, NumberSymbol.Group, NumberSymbol.Decimal, digitsInfo)
                }(strToNumber(value), locale, digitsInfo)
            } catch (error) {
                throw invalidPipeArgumentError(DecimalPipe, error.message)
            }
        }
    }
    DecimalPipe.decorators = [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.M,
        args: [{
            name: "number"
        }]
    }], DecimalPipe.ctorParameters = () => [{
        type: String,
        decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.u,
            args: [_angular_core__WEBPACK_IMPORTED_MODULE_0__.B]
        }]
    }];
    class PercentPipe {
        constructor(_locale) {
            this._locale = _locale
        }
        transform(value, digitsInfo, locale) {
            if (!isValue(value)) return null;
            locale = locale || this._locale;
            try {
                return function(value, locale, digitsInfo) {
                    return formatNumberToLocaleString(value, parseNumberFormat(getLocaleNumberFormat(locale, NumberFormatStyle.Percent), getLocaleNumberSymbol(locale, NumberSymbol.MinusSign)), locale, NumberSymbol.Group, NumberSymbol.Decimal, digitsInfo, !0).replace(new RegExp("%", "g"), getLocaleNumberSymbol(locale, NumberSymbol.PercentSign))
                }(strToNumber(value), locale, digitsInfo)
            } catch (error) {
                throw invalidPipeArgumentError(PercentPipe, error.message)
            }
        }
    }
    PercentPipe.decorators = [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.M,
        args: [{
            name: "percent"
        }]
    }], PercentPipe.ctorParameters = () => [{
        type: String,
        decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.u,
            args: [_angular_core__WEBPACK_IMPORTED_MODULE_0__.B]
        }]
    }];
    class CurrencyPipe {
        constructor(_locale, _defaultCurrencyCode = "USD") {
            this._locale = _locale, this._defaultCurrencyCode = _defaultCurrencyCode
        }
        transform(value, currencyCode, display = "symbol", digitsInfo, locale) {
            if (!isValue(value)) return null;
            locale = locale || this._locale, "boolean" == typeof display && (("undefined" == typeof ngDevMode || ngDevMode) && console && console.warn && console.warn('Warning: the currency pipe has been changed in Angular v5. The symbolDisplay option (third parameter) is now a string instead of a boolean. The accepted values are "code", "symbol" or "symbol-narrow".'), display = display ? "symbol" : "code");
            let currency = currencyCode || this._defaultCurrencyCode;
            "code" !== display && (currency = "symbol" === display || "symbol-narrow" === display ? getCurrencySymbol(currency, "symbol" === display ? "wide" : "narrow", locale) : display);
            try {
                return formatCurrency(strToNumber(value), locale, currency, currencyCode, digitsInfo)
            } catch (error) {
                throw invalidPipeArgumentError(CurrencyPipe, error.message)
            }
        }
    }

    function isValue(value) {
        return !(null == value || "" === value || value != value)
    }

    function strToNumber(value) {
        if ("string" == typeof value && !isNaN(Number(value) - parseFloat(value))) return Number(value);
        if ("number" != typeof value) throw new Error(`${value} is not a number`);
        return value
    }
    CurrencyPipe.decorators = [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.M,
        args: [{
            name: "currency"
        }]
    }], CurrencyPipe.ctorParameters = () => [{
        type: String,
        decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.u,
            args: [_angular_core__WEBPACK_IMPORTED_MODULE_0__.B]
        }]
    }, {
        type: String,
        decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.u,
            args: [_angular_core__WEBPACK_IMPORTED_MODULE_0__.m]
        }]
    }];
    class SlicePipe {
        transform(value, start, end) {
            if (null == value) return null;
            if (!this.supports(value)) throw invalidPipeArgumentError(SlicePipe, value);
            return value.slice(start, end)
        }
        supports(obj) {
            return "string" == typeof obj || Array.isArray(obj)
        }
    }
    SlicePipe.decorators = [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.M,
        args: [{
            name: "slice",
            pure: !1
        }]
    }];
    const COMMON_PIPES = [AsyncPipe, UpperCasePipe, LowerCasePipe, JsonPipe, SlicePipe, DecimalPipe, PercentPipe, TitleCasePipe, CurrencyPipe, DatePipe, I18nPluralPipe, I18nSelectPipe, KeyValuePipe];
    class CommonModule {}
    CommonModule.decorators = [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_0__.C,
        args: [{
            declarations: [COMMON_DIRECTIVES, COMMON_PIPES],
            exports: [COMMON_DIRECTIVES, COMMON_PIPES],
            providers: [{
                provide: NgLocalization,
                useClass: NgLocaleLocalization
            }]
        }]
    }];
    const PLATFORM_BROWSER_ID = "browser";

    function isPlatformBrowser(platformId) {
        return platformId === PLATFORM_BROWSER_ID
    }
    new _angular_core__WEBPACK_IMPORTED_MODULE_0__.ab("11.0.5");
    class ViewportScroller {}
    ViewportScroller.ɵprov = Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Ib)({
        token: ViewportScroller,
        providedIn: "root",
        factory: () => new BrowserViewportScroller(Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Jb)(DOCUMENT), window, Object(_angular_core__WEBPACK_IMPORTED_MODULE_0__.Jb)(_angular_core__WEBPACK_IMPORTED_MODULE_0__.p))
    });
    class BrowserViewportScroller {
        constructor(document, window, errorHandler) {
            this.document = document, this.window = window, this.errorHandler = errorHandler, this.offset = () => [0, 0]
        }
        setOffset(offset) {
            Array.isArray(offset) ? this.offset = () => offset : this.offset = offset
        }
        getScrollPosition() {
            return this.supportsScrolling() ? [this.window.pageXOffset, this.window.pageYOffset] : [0, 0]
        }
        scrollToPosition(position) {
            this.supportsScrolling() && this.window.scrollTo(position[0], position[1])
        }
        scrollToAnchor(anchor) {
            if (this.supportsScrolling()) {
                const elSelected = this.document.getElementById(anchor) || this.document.getElementsByName(anchor)[0];
                elSelected && this.scrollToElement(elSelected)
            }
        }
        setHistoryScrollRestoration(scrollRestoration) {
            if (this.supportScrollRestoration()) {
                const history = this.window.history;
                history && history.scrollRestoration && (history.scrollRestoration = scrollRestoration)
            }
        }
        scrollToElement(el) {
            const rect = el.getBoundingClientRect(),
                left = rect.left + this.window.pageXOffset,
                top = rect.top + this.window.pageYOffset,
                offset = this.offset();
            this.window.scrollTo(left - offset[0], top - offset[1])
        }
        supportScrollRestoration() {
            try {
                if (!this.supportsScrolling()) return !1;
                const scrollRestorationDescriptor = getScrollRestorationProperty(this.window.history) || getScrollRestorationProperty(Object.getPrototypeOf(this.window.history));
                return !(!scrollRestorationDescriptor || !scrollRestorationDescriptor.writable && !scrollRestorationDescriptor.set)
            } catch (_a) {
                return !1
            }
        }
        supportsScrolling() {
            try {
                return !!this.window && !!this.window.scrollTo && "pageXOffset" in this.window
            } catch (_a) {
                return !1
            }
        }
    }

    function getScrollRestorationProperty(obj) {
        return Object.getOwnPropertyDescriptor(obj, "scrollRestoration")
    }
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return makeStub
    })), __webpack_require__.d(__webpack_exports__, "b", (function() {
        return services
    }));
    var makeStub = function(service, methods) {
            return methods.reduce((function(acc, key) {
                return acc[key] = (fnname = service + "." + key + "()", function() {
                    throw new Error("No implementation for " + fnname + ". The framework specific code did not implement this method.")
                }), acc;
                var fnname
            }), {})
        },
        services = {
            $q: void 0,
            $injector: void 0
        }
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "e", (function() {
        return maxLength
    })), __webpack_require__.d(__webpack_exports__, "f", (function() {
        return padString
    })), __webpack_require__.d(__webpack_exports__, "d", (function() {
        return kebobString
    })), __webpack_require__.d(__webpack_exports__, "b", (function() {
        return functionToString
    })), __webpack_require__.d(__webpack_exports__, "a", (function() {
        return fnToString
    })), __webpack_require__.d(__webpack_exports__, "k", (function() {
        return stringify
    })), __webpack_require__.d(__webpack_exports__, "l", (function() {
        return stripLastPathElement
    })), __webpack_require__.d(__webpack_exports__, "h", (function() {
        return splitHash
    })), __webpack_require__.d(__webpack_exports__, "j", (function() {
        return splitQuery
    })), __webpack_require__.d(__webpack_exports__, "g", (function() {
        return splitEqual
    })), __webpack_require__.d(__webpack_exports__, "m", (function() {
        return trimHashVal
    })), __webpack_require__.d(__webpack_exports__, "i", (function() {
        return splitOnDelim
    })), __webpack_require__.d(__webpack_exports__, "c", (function() {
        return joinNeighborsR
    }));
    var _predicates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4),
        _transition_rejectFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(13),
        _common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2),
        _hof__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5);

    function maxLength(max, str) {
        return str.length <= max ? str : str.substr(0, max - 3) + "..."
    }

    function padString(length, str) {
        for (; str.length < length;) str += " ";
        return str
    }

    function kebobString(camelCase) {
        return camelCase.replace(/^([A-Z])/, (function($1) {
            return $1.toLowerCase()
        })).replace(/([A-Z])/g, (function($1) {
            return "-" + $1.toLowerCase()
        }))
    }

    function functionToString(fn) {
        var fnStr = fnToString(fn),
            namedFunctionMatch = fnStr.match(/^(function [^ ]+\([^)]*\))/),
            toStr = namedFunctionMatch ? namedFunctionMatch[1] : fnStr,
            fnName = fn.name || "";
        return fnName && toStr.match(/function \(/) ? "function " + fnName + toStr.substr(9) : toStr
    }

    function fnToString(fn) {
        var _fn = Object(_predicates__WEBPACK_IMPORTED_MODULE_0__.a)(fn) ? fn.slice(-1)[0] : fn;
        return _fn && _fn.toString() || "undefined"
    }
    var isRejection = _transition_rejectFactory__WEBPACK_IMPORTED_MODULE_1__.b.isRejectionPromise,
        stringifyPattern = Object(_hof__WEBPACK_IMPORTED_MODULE_3__.i)([
            [_predicates__WEBPACK_IMPORTED_MODULE_0__.m, Object(_hof__WEBPACK_IMPORTED_MODULE_3__.m)("undefined")],
            [_predicates__WEBPACK_IMPORTED_MODULE_0__.f, Object(_hof__WEBPACK_IMPORTED_MODULE_3__.m)("null")],
            [_predicates__WEBPACK_IMPORTED_MODULE_0__.j, Object(_hof__WEBPACK_IMPORTED_MODULE_3__.m)("[Promise]")],
            [isRejection, function(x) {
                return x._transitionRejection.toString()
            }],
            [function(obj) {
                return Object(_predicates__WEBPACK_IMPORTED_MODULE_0__.i)(obj) && !Object(_predicates__WEBPACK_IMPORTED_MODULE_0__.a)(obj) && obj.constructor !== Object && Object(_predicates__WEBPACK_IMPORTED_MODULE_0__.d)(obj.toString)
            }, function(x) {
                return x.toString()
            }],
            [_predicates__WEBPACK_IMPORTED_MODULE_0__.e, functionToString],
            [Object(_hof__WEBPACK_IMPORTED_MODULE_3__.m)(!0), _common__WEBPACK_IMPORTED_MODULE_2__.r]
        ]);

    function stringify(o) {
        var seen = [];

        function format(value) {
            if (Object(_predicates__WEBPACK_IMPORTED_MODULE_0__.i)(value)) {
                if (-1 !== seen.indexOf(value)) return "[circular ref]";
                seen.push(value)
            }
            return stringifyPattern(value)
        }
        return Object(_predicates__WEBPACK_IMPORTED_MODULE_0__.m)(o) ? format(o) : JSON.stringify(o, (function(key, value) {
            return format(value)
        })).replace(/\\"/g, '"')
    }
    var beforeAfterSubstr = function(char) {
            return function(str) {
                if (!str) return ["", ""];
                var idx = str.indexOf(char);
                return -1 === idx ? [str, ""] : [str.substr(0, idx), str.substr(idx + 1)]
            }
        },
        stripLastPathElement = (new RegExp("^(?:[a-z]+:)?//[^/]+/"), function(str) {
            return str.replace(/\/[^/]*$/, "")
        }),
        splitHash = beforeAfterSubstr("#"),
        splitQuery = beforeAfterSubstr("?"),
        splitEqual = beforeAfterSubstr("="),
        trimHashVal = function(str) {
            return str ? str.replace(/^#/, "") : ""
        };

    function splitOnDelim(delim) {
        var re = new RegExp("(" + delim + ")", "g");
        return function(str) {
            return str.split(re).filter(_common__WEBPACK_IMPORTED_MODULE_2__.r)
        }
    }

    function joinNeighborsR(acc, x) {
        return Object(_predicates__WEBPACK_IMPORTED_MODULE_0__.l)(Object(_common__WEBPACK_IMPORTED_MODULE_2__.G)(acc)) && Object(_predicates__WEBPACK_IMPORTED_MODULE_0__.l)(x) ? acc.slice(0, -1).concat(Object(_common__WEBPACK_IMPORTED_MODULE_2__.G)(acc) + x) : Object(_common__WEBPACK_IMPORTED_MODULE_2__.A)(acc, x)
    }
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return Subscriber
    }));
    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7),
        _util_isFunction__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(61),
        _Observer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(56),
        _Subscription__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(15),
        _internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(48),
        _config__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(24),
        _util_hostReportError__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(34),
        Subscriber = function(_super) {
            function Subscriber(destinationOrNext, error, complete) {
                var _this = _super.call(this) || this;
                switch (_this.syncErrorValue = null, _this.syncErrorThrown = !1, _this.syncErrorThrowable = !1, _this.isStopped = !1, arguments.length) {
                    case 0:
                        _this.destination = _Observer__WEBPACK_IMPORTED_MODULE_2__.a;
                        break;
                    case 1:
                        if (!destinationOrNext) {
                            _this.destination = _Observer__WEBPACK_IMPORTED_MODULE_2__.a;
                            break
                        }
                        if ("object" == typeof destinationOrNext) {
                            destinationOrNext instanceof Subscriber ? (_this.syncErrorThrowable = destinationOrNext.syncErrorThrowable, _this.destination = destinationOrNext, destinationOrNext.add(_this)) : (_this.syncErrorThrowable = !0, _this.destination = new SafeSubscriber(_this, destinationOrNext));
                            break
                        }
                    default:
                        _this.syncErrorThrowable = !0, _this.destination = new SafeSubscriber(_this, destinationOrNext, error, complete)
                }
                return _this
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(Subscriber, _super), Subscriber.prototype[_internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_4__.a] = function() {
                return this
            }, Subscriber.create = function(next, error, complete) {
                var subscriber = new Subscriber(next, error, complete);
                return subscriber.syncErrorThrowable = !1, subscriber
            }, Subscriber.prototype.next = function(value) {
                this.isStopped || this._next(value)
            }, Subscriber.prototype.error = function(err) {
                this.isStopped || (this.isStopped = !0, this._error(err))
            }, Subscriber.prototype.complete = function() {
                this.isStopped || (this.isStopped = !0, this._complete())
            }, Subscriber.prototype.unsubscribe = function() {
                this.closed || (this.isStopped = !0, _super.prototype.unsubscribe.call(this))
            }, Subscriber.prototype._next = function(value) {
                this.destination.next(value)
            }, Subscriber.prototype._error = function(err) {
                this.destination.error(err), this.unsubscribe()
            }, Subscriber.prototype._complete = function() {
                this.destination.complete(), this.unsubscribe()
            }, Subscriber.prototype._unsubscribeAndRecycle = function() {
                var _parentOrParents = this._parentOrParents;
                return this._parentOrParents = null, this.unsubscribe(), this.closed = !1, this.isStopped = !1, this._parentOrParents = _parentOrParents, this
            }, Subscriber
        }(_Subscription__WEBPACK_IMPORTED_MODULE_3__.a),
        SafeSubscriber = function(_super) {
            function SafeSubscriber(_parentSubscriber, observerOrNext, error, complete) {
                var next, _this = _super.call(this) || this;
                _this._parentSubscriber = _parentSubscriber;
                var context = _this;
                return Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_1__.a)(observerOrNext) ? next = observerOrNext : observerOrNext && (next = observerOrNext.next, error = observerOrNext.error, complete = observerOrNext.complete, observerOrNext !== _Observer__WEBPACK_IMPORTED_MODULE_2__.a && (context = Object.create(observerOrNext), Object(_util_isFunction__WEBPACK_IMPORTED_MODULE_1__.a)(context.unsubscribe) && _this.add(context.unsubscribe.bind(context)), context.unsubscribe = _this.unsubscribe.bind(_this))), _this._context = context, _this._next = next, _this._error = error, _this._complete = complete, _this
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(SafeSubscriber, _super), SafeSubscriber.prototype.next = function(value) {
                if (!this.isStopped && this._next) {
                    var _parentSubscriber = this._parentSubscriber;
                    _config__WEBPACK_IMPORTED_MODULE_5__.a.useDeprecatedSynchronousErrorHandling && _parentSubscriber.syncErrorThrowable ? this.__tryOrSetError(_parentSubscriber, this._next, value) && this.unsubscribe() : this.__tryOrUnsub(this._next, value)
                }
            }, SafeSubscriber.prototype.error = function(err) {
                if (!this.isStopped) {
                    var _parentSubscriber = this._parentSubscriber,
                        useDeprecatedSynchronousErrorHandling = _config__WEBPACK_IMPORTED_MODULE_5__.a.useDeprecatedSynchronousErrorHandling;
                    if (this._error) useDeprecatedSynchronousErrorHandling && _parentSubscriber.syncErrorThrowable ? (this.__tryOrSetError(_parentSubscriber, this._error, err), this.unsubscribe()) : (this.__tryOrUnsub(this._error, err), this.unsubscribe());
                    else if (_parentSubscriber.syncErrorThrowable) useDeprecatedSynchronousErrorHandling ? (_parentSubscriber.syncErrorValue = err, _parentSubscriber.syncErrorThrown = !0) : Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__.a)(err), this.unsubscribe();
                    else {
                        if (this.unsubscribe(), useDeprecatedSynchronousErrorHandling) throw err;
                        Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__.a)(err)
                    }
                }
            }, SafeSubscriber.prototype.complete = function() {
                var _this = this;
                if (!this.isStopped) {
                    var _parentSubscriber = this._parentSubscriber;
                    if (this._complete) {
                        var wrappedComplete = function() {
                            return _this._complete.call(_this._context)
                        };
                        _config__WEBPACK_IMPORTED_MODULE_5__.a.useDeprecatedSynchronousErrorHandling && _parentSubscriber.syncErrorThrowable ? (this.__tryOrSetError(_parentSubscriber, wrappedComplete), this.unsubscribe()) : (this.__tryOrUnsub(wrappedComplete), this.unsubscribe())
                    } else this.unsubscribe()
                }
            }, SafeSubscriber.prototype.__tryOrUnsub = function(fn, value) {
                try {
                    fn.call(this._context, value)
                } catch (err) {
                    if (this.unsubscribe(), _config__WEBPACK_IMPORTED_MODULE_5__.a.useDeprecatedSynchronousErrorHandling) throw err;
                    Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__.a)(err)
                }
            }, SafeSubscriber.prototype.__tryOrSetError = function(parent, fn, value) {
                if (!_config__WEBPACK_IMPORTED_MODULE_5__.a.useDeprecatedSynchronousErrorHandling) throw new Error("bad call");
                try {
                    fn.call(this._context, value)
                } catch (err) {
                    return _config__WEBPACK_IMPORTED_MODULE_5__.a.useDeprecatedSynchronousErrorHandling ? (parent.syncErrorValue = err, parent.syncErrorThrown = !0, !0) : (Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_6__.a)(err), !0)
                }
                return !1
            }, SafeSubscriber.prototype._unsubscribe = function() {
                var _parentSubscriber = this._parentSubscriber;
                this._context = null, this._parentSubscriber = null, _parentSubscriber.unsubscribe()
            }, SafeSubscriber
        }(Subscriber)
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return Observable_Observable
    }));
    var Subscriber = __webpack_require__(11);
    var rxSubscriber = __webpack_require__(48),
        Observer = __webpack_require__(56);
    var observable = __webpack_require__(30),
        identity = __webpack_require__(53);

    function pipeFromArray(fns) {
        return 0 === fns.length ? identity.a : 1 === fns.length ? fns[0] : function(input) {
            return fns.reduce((function(prev, fn) {
                return fn(prev)
            }), input)
        }
    }
    var config = __webpack_require__(24),
        Observable_Observable = function() {
            function Observable(subscribe) {
                this._isScalar = !1, subscribe && (this._subscribe = subscribe)
            }
            return Observable.prototype.lift = function(operator) {
                var observable = new Observable;
                return observable.source = this, observable.operator = operator, observable
            }, Observable.prototype.subscribe = function(observerOrNext, error, complete) {
                var operator = this.operator,
                    sink = function(nextOrObserver, error, complete) {
                        if (nextOrObserver) {
                            if (nextOrObserver instanceof Subscriber.a) return nextOrObserver;
                            if (nextOrObserver[rxSubscriber.a]) return nextOrObserver[rxSubscriber.a]()
                        }
                        return nextOrObserver || error || complete ? new Subscriber.a(nextOrObserver, error, complete) : new Subscriber.a(Observer.a)
                    }(observerOrNext, error, complete);
                if (operator ? sink.add(operator.call(sink, this.source)) : sink.add(this.source || config.a.useDeprecatedSynchronousErrorHandling && !sink.syncErrorThrowable ? this._subscribe(sink) : this._trySubscribe(sink)), config.a.useDeprecatedSynchronousErrorHandling && sink.syncErrorThrowable && (sink.syncErrorThrowable = !1, sink.syncErrorThrown)) throw sink.syncErrorValue;
                return sink
            }, Observable.prototype._trySubscribe = function(sink) {
                try {
                    return this._subscribe(sink)
                } catch (err) {
                    config.a.useDeprecatedSynchronousErrorHandling && (sink.syncErrorThrown = !0, sink.syncErrorValue = err), ! function(observer) {
                        for (; observer;) {
                            var _a = observer,
                                closed_1 = _a.closed,
                                destination = _a.destination,
                                isStopped = _a.isStopped;
                            if (closed_1 || isStopped) return !1;
                            observer = destination && destination instanceof Subscriber.a ? destination : null
                        }
                        return !0
                    }(sink) ? console.warn(err) : sink.error(err)
                }
            }, Observable.prototype.forEach = function(next, promiseCtor) {
                var _this = this;
                return new(promiseCtor = getPromiseCtor(promiseCtor))((function(resolve, reject) {
                    var subscription;
                    subscription = _this.subscribe((function(value) {
                        try {
                            next(value)
                        } catch (err) {
                            reject(err), subscription && subscription.unsubscribe()
                        }
                    }), reject, resolve)
                }))
            }, Observable.prototype._subscribe = function(subscriber) {
                var source = this.source;
                return source && source.subscribe(subscriber)
            }, Observable.prototype[observable.a] = function() {
                return this
            }, Observable.prototype.pipe = function() {
                for (var operations = [], _i = 0; _i < arguments.length; _i++) operations[_i] = arguments[_i];
                return 0 === operations.length ? this : pipeFromArray(operations)(this)
            }, Observable.prototype.toPromise = function(promiseCtor) {
                var _this = this;
                return new(promiseCtor = getPromiseCtor(promiseCtor))((function(resolve, reject) {
                    var value;
                    _this.subscribe((function(x) {
                        return value = x
                    }), (function(err) {
                        return reject(err)
                    }), (function() {
                        return resolve(value)
                    }))
                }))
            }, Observable.create = function(subscribe) {
                return new Observable(subscribe)
            }, Observable
        }();

    function getPromiseCtor(promiseCtor) {
        if (promiseCtor || (promiseCtor = config.a.Promise || Promise), !promiseCtor) throw new Error("no Promise impl found");
        return promiseCtor
    }
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return RejectType
    })), __webpack_require__.d(__webpack_exports__, "b", (function() {
        return Rejection
    }));
    var RejectType, _common_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2),
        _common_strings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10),
        _common_hof__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5);
    ! function(RejectType) {
        RejectType[RejectType.SUPERSEDED = 2] = "SUPERSEDED", RejectType[RejectType.ABORTED = 3] = "ABORTED", RejectType[RejectType.INVALID = 4] = "INVALID", RejectType[RejectType.IGNORED = 5] = "IGNORED", RejectType[RejectType.ERROR = 6] = "ERROR"
    }(RejectType || (RejectType = {}));
    var id = 0,
        Rejection = function() {
            function Rejection(type, message, detail) {
                this.$id = id++, this.type = type, this.message = message, this.detail = detail
            }
            return Rejection.isRejectionPromise = function(obj) {
                return obj && "function" == typeof obj.then && Object(_common_hof__WEBPACK_IMPORTED_MODULE_2__.e)(Rejection)(obj._transitionRejection)
            }, Rejection.superseded = function(detail, options) {
                var rejection = new Rejection(RejectType.SUPERSEDED, "The transition has been superseded by a different transition", detail);
                return options && options.redirected && (rejection.redirected = !0), rejection
            }, Rejection.redirected = function(detail) {
                return Rejection.superseded(detail, {
                    redirected: !0
                })
            }, Rejection.invalid = function(detail) {
                return new Rejection(RejectType.INVALID, "This transition is invalid", detail)
            }, Rejection.ignored = function(detail) {
                return new Rejection(RejectType.IGNORED, "The transition was ignored", detail)
            }, Rejection.aborted = function(detail) {
                return new Rejection(RejectType.ABORTED, "The transition has been aborted", detail)
            }, Rejection.errored = function(detail) {
                return new Rejection(RejectType.ERROR, "The transition errored", detail)
            }, Rejection.normalize = function(detail) {
                return Object(_common_hof__WEBPACK_IMPORTED_MODULE_2__.e)(Rejection)(detail) ? detail : Rejection.errored(detail)
            }, Rejection.prototype.toString = function() {
                var d, detail = (d = this.detail) && d.toString !== Object.prototype.toString ? d.toString() : Object(_common_strings__WEBPACK_IMPORTED_MODULE_1__.k)(d);
                return "Transition Rejection($id: " + this.$id + " type: " + this.type + ", message: " + this.message + ", detail: " + detail + ")"
            }, Rejection.prototype.toPromise = function() {
                return Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.l)(Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.F)(this), {
                    _transitionRejection: this
                })
            }, Rejection
        }()
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return trace
    }));
    var _common_hof__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(5),
        _common_predicates__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4),
        _strings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10),
        _safeConsole__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(23);

    function uiViewString(uiview) {
        if (!uiview) return "ui-view (defunct)";
        var state = uiview.creationContext ? uiview.creationContext.name || "(root)" : "(none)";
        return "[ui-view#" + uiview.id + " " + uiview.$type + ":" + uiview.fqn + " (" + uiview.name + "@" + state + ")]"
    }
    var Category;

    function normalizedCat(input) {
        return Object(_common_predicates__WEBPACK_IMPORTED_MODULE_1__.h)(input) ? Category[input] : Category[Category[input]]
    }! function(Category) {
        Category[Category.RESOLVE = 0] = "RESOLVE", Category[Category.TRANSITION = 1] = "TRANSITION", Category[Category.HOOK = 2] = "HOOK", Category[Category.UIVIEW = 3] = "UIVIEW", Category[Category.VIEWCONFIG = 4] = "VIEWCONFIG"
    }(Category || (Category = {}));
    var _tid = Object(_common_hof__WEBPACK_IMPORTED_MODULE_0__.h)("$id"),
        _rid = Object(_common_hof__WEBPACK_IMPORTED_MODULE_0__.h)("router.$id"),
        transLbl = function(trans) {
            return "Transition #" + _tid(trans) + "-" + _rid(trans)
        },
        trace = new(function() {
            function Trace() {
                this._enabled = {}, this.approximateDigests = 0
            }
            return Trace.prototype._set = function(enabled, categories) {
                var _this = this;
                categories.length || (categories = Object.keys(Category).map((function(k) {
                    return parseInt(k, 10)
                })).filter((function(k) {
                    return !isNaN(k)
                })).map((function(key) {
                    return Category[key]
                }))), categories.map(normalizedCat).forEach((function(category) {
                    return _this._enabled[category] = enabled
                }))
            }, Trace.prototype.enable = function() {
                for (var categories = [], _i = 0; _i < arguments.length; _i++) categories[_i] = arguments[_i];
                this._set(!0, categories)
            }, Trace.prototype.disable = function() {
                for (var categories = [], _i = 0; _i < arguments.length; _i++) categories[_i] = arguments[_i];
                this._set(!1, categories)
            }, Trace.prototype.enabled = function(category) {
                return !!this._enabled[normalizedCat(category)]
            }, Trace.prototype.traceTransitionStart = function(trans) {
                this.enabled(Category.TRANSITION) && _safeConsole__WEBPACK_IMPORTED_MODULE_3__.a.log(transLbl(trans) + ": Started  -> " + Object(_strings__WEBPACK_IMPORTED_MODULE_2__.k)(trans))
            }, Trace.prototype.traceTransitionIgnored = function(trans) {
                this.enabled(Category.TRANSITION) && _safeConsole__WEBPACK_IMPORTED_MODULE_3__.a.log(transLbl(trans) + ": Ignored  <> " + Object(_strings__WEBPACK_IMPORTED_MODULE_2__.k)(trans))
            }, Trace.prototype.traceHookInvocation = function(step, trans, options) {
                if (this.enabled(Category.HOOK)) {
                    var event = Object(_common_hof__WEBPACK_IMPORTED_MODULE_0__.h)("traceData.hookType")(options) || "internal",
                        context = Object(_common_hof__WEBPACK_IMPORTED_MODULE_0__.h)("traceData.context.state.name")(options) || Object(_common_hof__WEBPACK_IMPORTED_MODULE_0__.h)("traceData.context")(options) || "unknown",
                        name = Object(_strings__WEBPACK_IMPORTED_MODULE_2__.b)(step.registeredHook.callback);
                    _safeConsole__WEBPACK_IMPORTED_MODULE_3__.a.log(transLbl(trans) + ":   Hook -> " + event + " context: " + context + ", " + Object(_strings__WEBPACK_IMPORTED_MODULE_2__.e)(200, name))
                }
            }, Trace.prototype.traceHookResult = function(hookResult, trans, transitionOptions) {
                this.enabled(Category.HOOK) && _safeConsole__WEBPACK_IMPORTED_MODULE_3__.a.log(transLbl(trans) + ":   <- Hook returned: " + Object(_strings__WEBPACK_IMPORTED_MODULE_2__.e)(200, Object(_strings__WEBPACK_IMPORTED_MODULE_2__.k)(hookResult)))
            }, Trace.prototype.traceResolvePath = function(path, when, trans) {
                this.enabled(Category.RESOLVE) && _safeConsole__WEBPACK_IMPORTED_MODULE_3__.a.log(transLbl(trans) + ":         Resolving " + path + " (" + when + ")")
            }, Trace.prototype.traceResolvableResolved = function(resolvable, trans) {
                this.enabled(Category.RESOLVE) && _safeConsole__WEBPACK_IMPORTED_MODULE_3__.a.log(transLbl(trans) + ":               <- Resolved  " + resolvable + " to: " + Object(_strings__WEBPACK_IMPORTED_MODULE_2__.e)(200, Object(_strings__WEBPACK_IMPORTED_MODULE_2__.k)(resolvable.data)))
            }, Trace.prototype.traceError = function(reason, trans) {
                this.enabled(Category.TRANSITION) && _safeConsole__WEBPACK_IMPORTED_MODULE_3__.a.log(transLbl(trans) + ": <- Rejected " + Object(_strings__WEBPACK_IMPORTED_MODULE_2__.k)(trans) + ", reason: " + reason)
            }, Trace.prototype.traceSuccess = function(finalState, trans) {
                this.enabled(Category.TRANSITION) && _safeConsole__WEBPACK_IMPORTED_MODULE_3__.a.log(transLbl(trans) + ": <- Success  " + Object(_strings__WEBPACK_IMPORTED_MODULE_2__.k)(trans) + ", final state: " + finalState.name)
            }, Trace.prototype.traceUIViewEvent = function(event, viewData, extra) {
                void 0 === extra && (extra = ""), this.enabled(Category.UIVIEW) && _safeConsole__WEBPACK_IMPORTED_MODULE_3__.a.log("ui-view: " + Object(_strings__WEBPACK_IMPORTED_MODULE_2__.f)(30, event) + " " + uiViewString(viewData) + extra)
            }, Trace.prototype.traceUIViewConfigUpdated = function(viewData, context) {
                this.enabled(Category.UIVIEW) && this.traceUIViewEvent("Updating", viewData, " with ViewConfig from context='" + context + "'")
            }, Trace.prototype.traceUIViewFill = function(viewData, html) {
                this.enabled(Category.UIVIEW) && this.traceUIViewEvent("Fill", viewData, " with: " + Object(_strings__WEBPACK_IMPORTED_MODULE_2__.e)(200, html))
            }, Trace.prototype.traceViewSync = function(pairs) {
                if (this.enabled(Category.VIEWCONFIG)) {
                    var uivheader = "uiview component fqn",
                        mapping = pairs.map((function(_a) {
                            var _b, uiView = _a.uiView,
                                viewConfig = _a.viewConfig,
                                uiv = uiView && uiView.fqn,
                                cfg = viewConfig && viewConfig.viewDecl.$context.name + ": (" + viewConfig.viewDecl.$name + ")";
                            return (_b = {})[uivheader] = uiv, _b["view config state (view name)"] = cfg, _b
                        })).sort((function(a, b) {
                            return (a[uivheader] || "").localeCompare(b[uivheader] || "")
                        }));
                    _safeConsole__WEBPACK_IMPORTED_MODULE_3__.a.table(mapping)
                }
            }, Trace.prototype.traceViewServiceEvent = function(event, viewConfig) {
                this.enabled(Category.VIEWCONFIG) && _safeConsole__WEBPACK_IMPORTED_MODULE_3__.a.log("VIEWCONFIG: " + event + " " + function(viewConfig) {
                    var view = viewConfig.viewDecl,
                        state = view.$context.name || "(root)";
                    return "[View#" + viewConfig.$id + " from '" + state + "' state]: target ui-view: '" + view.$uiViewName + "@" + view.$uiViewContextAnchor + "'"
                }(viewConfig))
            }, Trace.prototype.traceViewServiceUIViewEvent = function(event, viewData) {
                this.enabled(Category.VIEWCONFIG) && _safeConsole__WEBPACK_IMPORTED_MODULE_3__.a.log("VIEWCONFIG: " + event + " " + uiViewString(viewData))
            }, Trace
        }())
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return Subscription_Subscription
    }));
    var isArray = __webpack_require__(90),
        isObject = __webpack_require__(91),
        isFunction = __webpack_require__(61),
        UnsubscriptionError = function() {
            function UnsubscriptionErrorImpl(errors) {
                return Error.call(this), this.message = errors ? errors.length + " errors occurred during unsubscription:\n" + errors.map((function(err, i) {
                    return i + 1 + ") " + err.toString()
                })).join("\n  ") : "", this.name = "UnsubscriptionError", this.errors = errors, this
            }
            return UnsubscriptionErrorImpl.prototype = Object.create(Error.prototype), UnsubscriptionErrorImpl
        }(),
        Subscription_Subscription = function() {
            function Subscription(unsubscribe) {
                this.closed = !1, this._parentOrParents = null, this._subscriptions = null, unsubscribe && (this._ctorUnsubscribe = !0, this._unsubscribe = unsubscribe)
            }
            var empty;
            return Subscription.prototype.unsubscribe = function() {
                var errors;
                if (!this.closed) {
                    var _parentOrParents = this._parentOrParents,
                        _ctorUnsubscribe = this._ctorUnsubscribe,
                        _unsubscribe = this._unsubscribe,
                        _subscriptions = this._subscriptions;
                    if (this.closed = !0, this._parentOrParents = null, this._subscriptions = null, _parentOrParents instanceof Subscription) _parentOrParents.remove(this);
                    else if (null !== _parentOrParents)
                        for (var index = 0; index < _parentOrParents.length; ++index) {
                            _parentOrParents[index].remove(this)
                        }
                    if (Object(isFunction.a)(_unsubscribe)) {
                        _ctorUnsubscribe && (this._unsubscribe = void 0);
                        try {
                            _unsubscribe.call(this)
                        } catch (e) {
                            errors = e instanceof UnsubscriptionError ? flattenUnsubscriptionErrors(e.errors) : [e]
                        }
                    }
                    if (Object(isArray.a)(_subscriptions)) {
                        index = -1;
                        for (var len = _subscriptions.length; ++index < len;) {
                            var sub = _subscriptions[index];
                            if (Object(isObject.a)(sub)) try {
                                sub.unsubscribe()
                            } catch (e) {
                                errors = errors || [], e instanceof UnsubscriptionError ? errors = errors.concat(flattenUnsubscriptionErrors(e.errors)) : errors.push(e)
                            }
                        }
                    }
                    if (errors) throw new UnsubscriptionError(errors)
                }
            }, Subscription.prototype.add = function(teardown) {
                var subscription = teardown;
                if (!teardown) return Subscription.EMPTY;
                switch (typeof teardown) {
                    case "function":
                        subscription = new Subscription(teardown);
                    case "object":
                        if (subscription === this || subscription.closed || "function" != typeof subscription.unsubscribe) return subscription;
                        if (this.closed) return subscription.unsubscribe(), subscription;
                        if (!(subscription instanceof Subscription)) {
                            var tmp = subscription;
                            (subscription = new Subscription)._subscriptions = [tmp]
                        }
                        break;
                    default:
                        throw new Error("unrecognized teardown " + teardown + " added to Subscription.")
                }
                var _parentOrParents = subscription._parentOrParents;
                if (null === _parentOrParents) subscription._parentOrParents = this;
                else if (_parentOrParents instanceof Subscription) {
                    if (_parentOrParents === this) return subscription;
                    subscription._parentOrParents = [_parentOrParents, this]
                } else {
                    if (-1 !== _parentOrParents.indexOf(this)) return subscription;
                    _parentOrParents.push(this)
                }
                var subscriptions = this._subscriptions;
                return null === subscriptions ? this._subscriptions = [subscription] : subscriptions.push(subscription), subscription
            }, Subscription.prototype.remove = function(subscription) {
                var subscriptions = this._subscriptions;
                if (subscriptions) {
                    var subscriptionIndex = subscriptions.indexOf(subscription); - 1 !== subscriptionIndex && subscriptions.splice(subscriptionIndex, 1)
                }
            }, Subscription.EMPTY = ((empty = new Subscription).closed = !0, empty), Subscription
        }();

    function flattenUnsubscriptionErrors(errors) {
        return errors.reduce((function(errs, err) {
            return errs.concat(err instanceof UnsubscriptionError ? err.errors : err)
        }), [])
    }
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return ng
    }));
    var angular__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(50),
        ng_from_global = angular,
        ng = angular__WEBPACK_IMPORTED_MODULE_0__ && angular__WEBPACK_IMPORTED_MODULE_0__.module ? angular__WEBPACK_IMPORTED_MODULE_0__ : ng_from_global
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var TransitionHookPhase, TransitionHookScope;
    __webpack_require__.d(__webpack_exports__, "a", (function() {
            return TransitionHookPhase
        })), __webpack_require__.d(__webpack_exports__, "b", (function() {
            return TransitionHookScope
        })),
        function(TransitionHookPhase) {
            TransitionHookPhase[TransitionHookPhase.CREATE = 0] = "CREATE", TransitionHookPhase[TransitionHookPhase.BEFORE = 1] = "BEFORE", TransitionHookPhase[TransitionHookPhase.RUN = 2] = "RUN", TransitionHookPhase[TransitionHookPhase.SUCCESS = 3] = "SUCCESS", TransitionHookPhase[TransitionHookPhase.ERROR = 4] = "ERROR"
        }(TransitionHookPhase || (TransitionHookPhase = {})),
        function(TransitionHookScope) {
            TransitionHookScope[TransitionHookScope.TRANSITION = 0] = "TRANSITION", TransitionHookScope[TransitionHookScope.STATE = 1] = "STATE"
        }(TransitionHookScope || (TransitionHookScope = {}))
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return Resolvable
    }));
    var _common_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2),
        _common_coreservices__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9),
        _common_trace__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(14),
        _common_strings__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(10),
        _common_predicates__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(4),
        defaultResolvePolicy_when = "LAZY",
        defaultResolvePolicy_async = "WAIT",
        Resolvable = function() {
            function Resolvable(arg1, resolveFn, deps, policy, data) {
                if (this.resolved = !1, this.promise = void 0, arg1 instanceof Resolvable) Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.l)(this, arg1);
                else if (Object(_common_predicates__WEBPACK_IMPORTED_MODULE_4__.d)(resolveFn)) {
                    if (Object(_common_predicates__WEBPACK_IMPORTED_MODULE_4__.g)(arg1)) throw new Error("new Resolvable(): token argument is required");
                    if (!Object(_common_predicates__WEBPACK_IMPORTED_MODULE_4__.d)(resolveFn)) throw new Error("new Resolvable(): resolveFn argument must be a function");
                    this.token = arg1, this.policy = policy, this.resolveFn = resolveFn, this.deps = deps || [], this.data = data, this.resolved = void 0 !== data, this.promise = this.resolved ? _common_coreservices__WEBPACK_IMPORTED_MODULE_1__.b.$q.when(this.data) : void 0
                } else if (Object(_common_predicates__WEBPACK_IMPORTED_MODULE_4__.i)(arg1) && arg1.token && (arg1.hasOwnProperty("resolveFn") || arg1.hasOwnProperty("data"))) {
                    var literal = arg1;
                    return new Resolvable(literal.token, literal.resolveFn, literal.deps, literal.policy, literal.data)
                }
            }
            return Resolvable.prototype.getPolicy = function(state) {
                var thisPolicy = this.policy || {},
                    statePolicy = state && state.resolvePolicy || {};
                return {
                    when: thisPolicy.when || statePolicy.when || defaultResolvePolicy_when,
                    async: thisPolicy.async || statePolicy.async || defaultResolvePolicy_async
                }
            }, Resolvable.prototype.resolve = function(resolveContext, trans) {
                var _this = this,
                    $q = _common_coreservices__WEBPACK_IMPORTED_MODULE_1__.b.$q,
                    node = resolveContext.findNode(this),
                    state = node && node.state,
                    asyncPolicy = this.getPolicy(state).async,
                    customAsyncPolicy = Object(_common_predicates__WEBPACK_IMPORTED_MODULE_4__.d)(asyncPolicy) ? asyncPolicy : _common_common__WEBPACK_IMPORTED_MODULE_0__.r;
                return this.promise = $q.when().then((function() {
                    return $q.all(resolveContext.getDependencies(_this).map((function(resolvable) {
                        return resolvable.get(resolveContext, trans)
                    })))
                })).then((function(resolvedDeps) {
                    return _this.resolveFn.apply(null, resolvedDeps)
                })).then(customAsyncPolicy).then((function(resolvedValue) {
                    return _this.data = resolvedValue, _this.resolved = !0, _this.resolveFn = null, _common_trace__WEBPACK_IMPORTED_MODULE_2__.a.traceResolvableResolved(_this, trans), _this.data
                }))
            }, Resolvable.prototype.get = function(resolveContext, trans) {
                return this.promise || this.resolve(resolveContext, trans)
            }, Resolvable.prototype.toString = function() {
                return "Resolvable(token: " + Object(_common_strings__WEBPACK_IMPORTED_MODULE_3__.k)(this.token) + ", requires: [" + this.deps.map(_common_strings__WEBPACK_IMPORTED_MODULE_3__.k) + "])"
            }, Resolvable.prototype.clone = function() {
                return new Resolvable(this)
            }, Resolvable.fromData = function(token, data) {
                return new Resolvable(token, (function() {
                    return data
                }), null, null, data)
            }, Resolvable
        }()
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return DefType
    })), __webpack_require__.d(__webpack_exports__, "b", (function() {
        return Param
    }));
    var DefType, _common_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2),
        _common_hof__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5),
        _common_predicates__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4),
        _common_coreservices__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(9),
        _paramType__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(42),
        hasOwn = Object.prototype.hasOwnProperty;

    function getParamDeclaration(paramName, location, state) {
        var noReloadOnSearch = !1 === state.reloadOnSearch && location === DefType.SEARCH || void 0,
            dynamic = Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.n)([state.dynamic, noReloadOnSearch], _common_predicates__WEBPACK_IMPORTED_MODULE_2__.c),
            defaultConfig = Object(_common_predicates__WEBPACK_IMPORTED_MODULE_2__.c)(dynamic) ? {
                dynamic: dynamic
            } : {},
            paramConfig = function(cfg) {
                function getStaticDefaultValue() {
                    return cfg.value
                }
                cfg = function(cfg) {
                    return 0 === ["value", "type", "squash", "array", "dynamic"].filter(hasOwn.bind(cfg || {})).length
                }(cfg) ? {
                    value: cfg
                } : cfg, getStaticDefaultValue.__cacheable = !0;
                var $$fn = Object(_common_predicates__WEBPACK_IMPORTED_MODULE_2__.e)(cfg.value) ? cfg.value : getStaticDefaultValue;
                return Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.l)(cfg, {
                    $$fn: $$fn
                })
            }(state && state.params && state.params[paramName]);
        return Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.l)(defaultConfig, paramConfig)
    }! function(DefType) {
        DefType[DefType.PATH = 0] = "PATH", DefType[DefType.SEARCH = 1] = "SEARCH", DefType[DefType.CONFIG = 2] = "CONFIG"
    }(DefType || (DefType = {}));
    var Param = function() {
        function Param(id, type, location, urlConfig, state) {
            var config = getParamDeclaration(id, location, state);
            type = function(cfg, urlType, location, id, paramTypes) {
                if (cfg.type && urlType && "string" !== urlType.name) throw new Error("Param '" + id + "' has two type configurations.");
                if (cfg.type && urlType && "string" === urlType.name && paramTypes.type(cfg.type)) return paramTypes.type(cfg.type);
                if (urlType) return urlType;
                if (!cfg.type) {
                    var type = location === DefType.CONFIG ? "any" : location === DefType.PATH ? "path" : location === DefType.SEARCH ? "query" : "string";
                    return paramTypes.type(type)
                }
                return cfg.type instanceof _paramType__WEBPACK_IMPORTED_MODULE_4__.a ? cfg.type : paramTypes.type(cfg.type)
            }(config, type, location, id, urlConfig.paramTypes);
            var arrayDefaults, arrayParamNomenclature, arrayMode = (arrayDefaults = {
                array: location === DefType.SEARCH && "auto"
            }, arrayParamNomenclature = id.match(/\[\]$/) ? {
                array: !0
            } : {}, Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.l)(arrayDefaults, arrayParamNomenclature, config).array);
            type = arrayMode ? type.$asArray(arrayMode, location === DefType.SEARCH) : type;
            var isOptional = void 0 !== config.value || location === DefType.SEARCH,
                dynamic = Object(_common_predicates__WEBPACK_IMPORTED_MODULE_2__.c)(config.dynamic) ? !!config.dynamic : !!type.dynamic,
                raw = Object(_common_predicates__WEBPACK_IMPORTED_MODULE_2__.c)(config.raw) ? !!config.raw : !!type.raw,
                squash = function(config, isOptional, defaultPolicy) {
                    var squash = config.squash;
                    if (!isOptional || !1 === squash) return !1;
                    if (!Object(_common_predicates__WEBPACK_IMPORTED_MODULE_2__.c)(squash) || null == squash) return defaultPolicy;
                    if (!0 === squash || Object(_common_predicates__WEBPACK_IMPORTED_MODULE_2__.l)(squash)) return squash;
                    throw new Error("Invalid squash policy: '" + squash + "'. Valid policies: false, true, or arbitrary string")
                }(config, isOptional, urlConfig.defaultSquashPolicy()),
                replace = function(config, arrayMode, isOptional, squash) {
                    var defaultPolicy = [{
                            from: "",
                            to: isOptional || arrayMode ? void 0 : ""
                        }, {
                            from: null,
                            to: isOptional || arrayMode ? void 0 : ""
                        }],
                        replace = Object(_common_predicates__WEBPACK_IMPORTED_MODULE_2__.a)(config.replace) ? config.replace : [];
                    Object(_common_predicates__WEBPACK_IMPORTED_MODULE_2__.l)(squash) && replace.push({
                        from: squash,
                        to: void 0
                    });
                    var configuredKeys = Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.u)(replace, Object(_common_hof__WEBPACK_IMPORTED_MODULE_1__.k)("from"));
                    return Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.m)(defaultPolicy, (function(item) {
                        return -1 === configuredKeys.indexOf(item.from)
                    })).concat(replace)
                }(config, arrayMode, isOptional, squash),
                inherit = Object(_common_predicates__WEBPACK_IMPORTED_MODULE_2__.c)(config.inherit) ? !!config.inherit : !!type.inherit;
            Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.l)(this, {
                id: id,
                type: type,
                location: location,
                isOptional: isOptional,
                dynamic: dynamic,
                raw: raw,
                squash: squash,
                replace: replace,
                inherit: inherit,
                array: arrayMode,
                config: config
            })
        }
        return Param.values = function(params, values) {
            void 0 === values && (values = {});
            for (var paramValues = {}, _i = 0, params_1 = params; _i < params_1.length; _i++) {
                var param = params_1[_i];
                paramValues[param.id] = param.value(values[param.id])
            }
            return paramValues
        }, Param.changed = function(params, values1, values2) {
            return void 0 === values1 && (values1 = {}), void 0 === values2 && (values2 = {}), params.filter((function(param) {
                return !param.type.equals(values1[param.id], values2[param.id])
            }))
        }, Param.equals = function(params, values1, values2) {
            return void 0 === values1 && (values1 = {}), void 0 === values2 && (values2 = {}), 0 === Param.changed(params, values1, values2).length
        }, Param.validates = function(params, values) {
            return void 0 === values && (values = {}), params.map((function(param) {
                return param.validates(values[param.id])
            })).reduce(_common_common__WEBPACK_IMPORTED_MODULE_0__.a, !0)
        }, Param.prototype.isDefaultValue = function(value) {
            return this.isOptional && this.type.equals(this.value(), value)
        }, Param.prototype.value = function(value) {
            var _this = this;
            return value = function(val) {
                for (var _i = 0, _a = _this.replace; _i < _a.length; _i++) {
                    var tuple = _a[_i];
                    if (tuple.from === val) return tuple.to
                }
                return val
            }(value), Object(_common_predicates__WEBPACK_IMPORTED_MODULE_2__.m)(value) ? function() {
                if (_this._defaultValueCache) return _this._defaultValueCache.defaultValue;
                if (!_common_coreservices__WEBPACK_IMPORTED_MODULE_3__.b.$injector) throw new Error("Injectable functions cannot be called at configuration time");
                var defaultValue = _common_coreservices__WEBPACK_IMPORTED_MODULE_3__.b.$injector.invoke(_this.config.$$fn);
                if (null != defaultValue && !_this.type.is(defaultValue)) throw new Error("Default value (" + defaultValue + ") for parameter '" + _this.id + "' is not an instance of ParamType (" + _this.type.name + ")");
                return _this.config.$$fn.__cacheable && (_this._defaultValueCache = {
                    defaultValue: defaultValue
                }), defaultValue
            }() : this.type.$normalize(value)
        }, Param.prototype.isSearch = function() {
            return this.location === DefType.SEARCH
        }, Param.prototype.validates = function(value) {
            if ((Object(_common_predicates__WEBPACK_IMPORTED_MODULE_2__.m)(value) || null === value) && this.isOptional) return !0;
            var normalized = this.type.$normalize(value);
            if (!this.type.is(normalized)) return !1;
            var encoded = this.type.encode(normalized);
            return !(Object(_common_predicates__WEBPACK_IMPORTED_MODULE_2__.l)(encoded) && !this.type.pattern.exec(encoded))
        }, Param.prototype.toString = function() {
            return "{Param:" + this.id + " " + this.type + " squash: '" + this.squash + "' optional: " + this.isOptional + "}"
        }, Param
    }()
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return TransitionHook
    }));
    var _interface__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(17),
        _common_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2),
        _common_strings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10),
        _common_predicates__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4),
        _common_hof__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5),
        _common_trace__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(14),
        _common_coreservices__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(9),
        _rejectFactory__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(13),
        _state_targetState__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(25),
        defaultOptions = {
            current: _common_common__WEBPACK_IMPORTED_MODULE_1__.x,
            transition: null,
            traceData: {},
            bind: null
        },
        TransitionHook = function() {
            function TransitionHook(transition, stateContext, registeredHook, options) {
                var _this = this;
                this.transition = transition, this.stateContext = stateContext, this.registeredHook = registeredHook, this.options = options, this.isSuperseded = function() {
                    return _this.type.hookPhase === _interface__WEBPACK_IMPORTED_MODULE_0__.a.RUN && !_this.options.transition.isActive()
                }, this.options = Object(_common_common__WEBPACK_IMPORTED_MODULE_1__.i)(options, defaultOptions), this.type = registeredHook.eventType
            }
            return TransitionHook.chain = function(hooks, waitFor) {
                return hooks.reduce((function(prev, nextHook) {
                    return prev.then((function() {
                        return nextHook.invokeHook()
                    }))
                }), waitFor || _common_coreservices__WEBPACK_IMPORTED_MODULE_6__.b.$q.when())
            }, TransitionHook.invokeHooks = function(hooks, doneCallback) {
                for (var idx = 0; idx < hooks.length; idx++) {
                    var hookResult = hooks[idx].invokeHook();
                    if (Object(_common_predicates__WEBPACK_IMPORTED_MODULE_3__.j)(hookResult)) {
                        var remainingHooks = hooks.slice(idx + 1);
                        return TransitionHook.chain(remainingHooks, hookResult).then(doneCallback)
                    }
                }
                return doneCallback()
            }, TransitionHook.runAllHooks = function(hooks) {
                hooks.forEach((function(hook) {
                    return hook.invokeHook()
                }))
            }, TransitionHook.prototype.logError = function(err) {
                this.transition.router.stateService.defaultErrorHandler()(err)
            }, TransitionHook.prototype.invokeHook = function() {
                var _this = this,
                    hook = this.registeredHook;
                if (!hook._deregistered) {
                    var notCurrent = this.getNotCurrentRejection();
                    if (notCurrent) return notCurrent;
                    var options = this.options;
                    _common_trace__WEBPACK_IMPORTED_MODULE_5__.a.traceHookInvocation(this, this.transition, options);
                    var handleError = function(err) {
                            return hook.eventType.getErrorHandler(_this)(err)
                        },
                        handleResult = function(result) {
                            return hook.eventType.getResultHandler(_this)(result)
                        };
                    try {
                        var result = hook.callback.call(options.bind, _this.transition, _this.stateContext);
                        return !this.type.synchronous && Object(_common_predicates__WEBPACK_IMPORTED_MODULE_3__.j)(result) ? result.catch((function(err) {
                            return _rejectFactory__WEBPACK_IMPORTED_MODULE_7__.b.normalize(err).toPromise()
                        })).then(handleResult, handleError) : handleResult(result)
                    } catch (err) {
                        return handleError(_rejectFactory__WEBPACK_IMPORTED_MODULE_7__.b.normalize(err))
                    } finally {
                        hook.invokeLimit && ++hook.invokeCount >= hook.invokeLimit && hook.deregister()
                    }
                }
            }, TransitionHook.prototype.handleHookResult = function(result) {
                var _this = this,
                    notCurrent = this.getNotCurrentRejection();
                return notCurrent || (Object(_common_predicates__WEBPACK_IMPORTED_MODULE_3__.j)(result) ? result.then((function(val) {
                    return _this.handleHookResult(val)
                })) : (_common_trace__WEBPACK_IMPORTED_MODULE_5__.a.traceHookResult(result, this.transition, this.options), !1 === result ? _rejectFactory__WEBPACK_IMPORTED_MODULE_7__.b.aborted("Hook aborted transition").toPromise() : Object(_common_hof__WEBPACK_IMPORTED_MODULE_4__.e)(_state_targetState__WEBPACK_IMPORTED_MODULE_8__.a)(result) ? _rejectFactory__WEBPACK_IMPORTED_MODULE_7__.b.redirected(result).toPromise() : void 0))
            }, TransitionHook.prototype.getNotCurrentRejection = function() {
                var router = this.transition.router;
                return router._disposed ? _rejectFactory__WEBPACK_IMPORTED_MODULE_7__.b.aborted("UIRouter instance #" + router.$id + " has been stopped (disposed)").toPromise() : this.transition._aborted ? _rejectFactory__WEBPACK_IMPORTED_MODULE_7__.b.aborted().toPromise() : this.isSuperseded() ? _rejectFactory__WEBPACK_IMPORTED_MODULE_7__.b.superseded(this.options.current()).toPromise() : void 0
            }, TransitionHook.prototype.toString = function() {
                var options = this.options,
                    registeredHook = this.registeredHook,
                    event = Object(_common_hof__WEBPACK_IMPORTED_MODULE_4__.h)("traceData.hookType")(options) || "internal",
                    context = Object(_common_hof__WEBPACK_IMPORTED_MODULE_4__.h)("traceData.context.state.name")(options) || Object(_common_hof__WEBPACK_IMPORTED_MODULE_4__.h)("traceData.context")(options) || "unknown",
                    name = Object(_common_strings__WEBPACK_IMPORTED_MODULE_2__.a)(registeredHook.callback);
                return event + " context: " + context + ", " + Object(_common_strings__WEBPACK_IMPORTED_MODULE_2__.e)(200, name)
            }, TransitionHook.HANDLE_RESULT = function(hook) {
                return function(result) {
                    return hook.handleHookResult(result)
                }
            }, TransitionHook.LOG_REJECTED_RESULT = function(hook) {
                return function(result) {
                    Object(_common_predicates__WEBPACK_IMPORTED_MODULE_3__.j)(result) && result.catch((function(err) {
                        return hook.logError(_rejectFactory__WEBPACK_IMPORTED_MODULE_7__.b.normalize(err))
                    }))
                }
            }, TransitionHook.LOG_ERROR = function(hook) {
                return function(error) {
                    return hook.logError(error)
                }
            }, TransitionHook.REJECT_ERROR = function(hook) {
                return function(error) {
                    return Object(_common_common__WEBPACK_IMPORTED_MODULE_1__.F)(error)
                }
            }, TransitionHook.THROW_ERROR = function(hook) {
                return function(error) {
                    throw error
                }
            }, TransitionHook
        }()
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return PathUtils
    }));
    var _common_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2),
        _common_hof__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5),
        _state_targetState__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(25),
        _pathNode__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(43),
        PathUtils = function() {
            function PathUtils() {}
            return PathUtils.makeTargetState = function(registry, path) {
                var state = Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.G)(path).state;
                return new _state_targetState__WEBPACK_IMPORTED_MODULE_2__.a(registry, state, path.map(Object(_common_hof__WEBPACK_IMPORTED_MODULE_1__.k)("paramValues")).reduce(_common_common__WEBPACK_IMPORTED_MODULE_0__.w, {}), {})
            }, PathUtils.buildPath = function(targetState) {
                var toParams = targetState.params();
                return targetState.$state().path.map((function(state) {
                    return new _pathNode__WEBPACK_IMPORTED_MODULE_3__.a(state).applyRawParams(toParams)
                }))
            }, PathUtils.buildToPath = function(fromPath, targetState) {
                var toPath = PathUtils.buildPath(targetState);
                return targetState.options().inherit ? PathUtils.inheritParams(fromPath, toPath, Object.keys(targetState.params())) : toPath
            }, PathUtils.applyViewConfigs = function($view, path, states) {
                path.filter((function(node) {
                    return Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.s)(states, node.state)
                })).forEach((function(node) {
                    var viewDecls = Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.L)(node.state.views || {}),
                        subPath = PathUtils.subPath(path, (function(n) {
                            return n === node
                        })),
                        viewConfigs = viewDecls.map((function(view) {
                            return $view.createViewConfig(subPath, view)
                        }));
                    node.views = viewConfigs.reduce(_common_common__WEBPACK_IMPORTED_MODULE_0__.K, [])
                }))
            }, PathUtils.inheritParams = function(fromPath, toPath, toKeys) {
                void 0 === toKeys && (toKeys = []);
                var noInherit = fromPath.map((function(node) {
                    return node.paramSchema
                })).reduce(_common_common__WEBPACK_IMPORTED_MODULE_0__.K, []).filter((function(param) {
                    return !param.inherit
                })).map(Object(_common_hof__WEBPACK_IMPORTED_MODULE_1__.k)("id"));
                return toPath.map((function(toNode) {
                    var toParamVals = Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.l)({}, toNode && toNode.paramValues),
                        incomingParamVals = Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.z)(toParamVals, toKeys);
                    toParamVals = Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.y)(toParamVals, toKeys);
                    var path, state, node, fromParamVals = Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.y)((path = fromPath, state = toNode.state, node = Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.n)(path, Object(_common_hof__WEBPACK_IMPORTED_MODULE_1__.l)("state", state)), Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.l)({}, node && node.paramValues) || {}), noInherit),
                        ownParamVals = Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.l)(toParamVals, fromParamVals, incomingParamVals);
                    return new _pathNode__WEBPACK_IMPORTED_MODULE_3__.a(toNode.state).applyRawParams(ownParamVals)
                }))
            }, PathUtils.treeChanges = function(fromPath, toPath, reloadState) {
                for (var node1, node2, from, retained, exiting, entering, max = Math.min(fromPath.length, toPath.length), keep = 0; keep < max && fromPath[keep].state !== reloadState && (node1 = fromPath[keep], node2 = toPath[keep], node1.equals(node2, PathUtils.nonDynamicParams));) keep++;
                retained = (from = fromPath).slice(0, keep), exiting = from.slice(keep);
                var retainedWithToParams = retained.map((function(retainedNode, idx) {
                    var cloned = retainedNode.clone();
                    return cloned.paramValues = toPath[idx].paramValues, cloned
                }));
                return entering = toPath.slice(keep), {
                    from: from,
                    to: retainedWithToParams.concat(entering),
                    retained: retained,
                    retainedWithToParams: retainedWithToParams,
                    exiting: exiting,
                    entering: entering
                }
            }, PathUtils.matching = function(pathA, pathB, paramsFn) {
                var done = !1;
                return Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.e)(pathA, pathB).reduce((function(matching, _a) {
                    var nodeA = _a[0],
                        nodeB = _a[1];
                    return (done = done || !nodeA.equals(nodeB, paramsFn)) ? matching : matching.concat(nodeA)
                }), [])
            }, PathUtils.equals = function(pathA, pathB, paramsFn) {
                return pathA.length === pathB.length && PathUtils.matching(pathA, pathB, paramsFn).length === pathA.length
            }, PathUtils.subPath = function(path, predicate) {
                var node = Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.n)(path, predicate),
                    elementIdx = path.indexOf(node);
                return -1 === elementIdx ? void 0 : path.slice(0, elementIdx + 1)
            }, PathUtils.nonDynamicParams = function(node) {
                return node.state.parameters({
                    inherit: !1
                }).filter((function(param) {
                    return !param.dynamic
                }))
            }, PathUtils.paramValues = function(path) {
                return path.reduce((function(acc, node) {
                    return Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.l)(acc, node.paramValues)
                }), {})
            }, PathUtils
        }()
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "Ng2ViewConfig", (function() {
        return Ng2ViewConfig
    })), __webpack_require__.d(__webpack_exports__, "UIROUTER_MODULE_TOKEN", (function() {
        return UIROUTER_MODULE_TOKEN
    })), __webpack_require__.d(__webpack_exports__, "UIROUTER_ROOT_MODULE", (function() {
        return UIROUTER_ROOT_MODULE
    })), __webpack_require__.d(__webpack_exports__, "UIRouterModule", (function() {
        return UIRouterModule
    })), __webpack_require__.d(__webpack_exports__, "UIView", (function() {
        return UIView
    })), __webpack_require__.d(__webpack_exports__, "_UIROUTER_SERVICE_PROVIDERS", (function() {
        return _UIROUTER_SERVICE_PROVIDERS
    })), __webpack_require__.d(__webpack_exports__, "applyModuleConfig", (function() {
        return applyModuleConfig
    })), __webpack_require__.d(__webpack_exports__, "makeChildProviders", (function() {
        return makeChildProviders
    })), __webpack_require__.d(__webpack_exports__, "ng2LazyLoadBuilder", (function() {
        return ng2LazyLoadBuilder
    }));
    var _uirouter_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1),
        _angular_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(0),
        rxjs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(102),
        rxjs__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(62),
        rxjs__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(64),
        rxjs__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(285),
        rxjs__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(282),
        rxjs__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(284),
        rxjs_operators__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(103),
        rxjs_operators__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(63),
        _angular_common__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(8),
        _uirouter_rx__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(98);

    function ng2ViewsBuilder(state) {
        const views = {},
            viewsObject = state.views || {
                $default: Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.pick)(state, ["component", "bindings"])
            };
        return Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.forEach)(viewsObject, (function(config, name) {
            if (name = name || "$default", Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.isFunction)(config) && (config = {
                    component: config
                }), 0 === Object.keys(config).length) return;
            config.$type = "ng2", config.$context = state, config.$name = name;
            const normalized = _uirouter_core__WEBPACK_IMPORTED_MODULE_0__.ViewService.normalizeUIViewTarget(config.$context, config.$name);
            config.$uiViewName = normalized.uiViewName, config.$uiViewContextAnchor = normalized.uiViewContextAnchor, views[name] = config
        })), views
    }
    let id = 0;
    class Ng2ViewConfig {
        constructor(path, viewDecl) {
            this.path = path, this.viewDecl = viewDecl, this.$id = id++, this.loaded = !0
        }
        load() {
            return _uirouter_core__WEBPACK_IMPORTED_MODULE_0__.services.$q.when(this)
        }
    }
    class MergeInjector {
        constructor(...injectors) {
            if (injectors.length < 2) throw new Error("pass at least two injectors");
            this.injectors = injectors
        }
        get(token, notFoundValue) {
            for (let i = 0; i < this.injectors.length; i++) {
                const val = this.injectors[i].get(token, MergeInjector.NOT_FOUND);
                if (val !== MergeInjector.NOT_FOUND) return val
            }
            if (arguments.length >= 2) return notFoundValue;
            this.injectors[0].get(token)
        }
    }
    MergeInjector.NOT_FOUND = {};
    let id$1 = 0;
    const ng2ComponentInputs = factory => factory.inputs.map((input => ({
        prop: input.propName,
        token: input.templateName
    })));
    class UIView {
        constructor(router, parent, viewContainerRef) {
            this.router = router, this.viewContainerRef = viewContainerRef, this._uiViewData = {}, this._parent = parent
        }
        set _name(val) {
            this.name = val
        }
        get state() {
            return Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.parse)("_uiViewData.config.viewDecl.$context.self")(this)
        }
        ngOnInit() {
            const router = this.router,
                parentFqn = this._parent.fqn,
                name = this.name || "$default";
            this._uiViewData = {
                $type: "ng2",
                id: id$1++,
                name: name,
                fqn: parentFqn ? parentFqn + "." + name : name,
                creationContext: this._parent.context,
                configUpdated: this._viewConfigUpdated.bind(this),
                config: void 0
            }, this._deregisterUiCanExitHook = router.transitionService.onBefore({}, (trans => this._invokeUiCanExitHook(trans))), this._deregisterUiOnParamsChangedHook = router.transitionService.onSuccess({}, (trans => this._invokeUiOnParamsChangedHook(trans))), this._deregisterUIView = router.viewService.registerUIView(this._uiViewData)
        }
        _invokeUiCanExitHook(trans) {
            const instance = this._componentRef && this._componentRef.instance,
                uiCanExitFn = instance && instance.uiCanExit;
            if (Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.isFunction)(uiCanExitFn)) {
                const state = this.state; - 1 !== trans.exiting().indexOf(state) && trans.onStart({}, (function() {
                    return uiCanExitFn.call(instance, trans)
                }))
            }
        }
        _invokeUiOnParamsChangedHook($transition$) {
            const instance = this._componentRef && this._componentRef.instance,
                uiOnParamsChanged = instance && instance.uiOnParamsChanged;
            if (Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.isFunction)(uiOnParamsChanged)) {
                const viewState = this.state;
                if ($transition$ === new _uirouter_core__WEBPACK_IMPORTED_MODULE_0__.ResolveContext(this._uiViewData.config.path).getResolvable("$transition$").data || -1 !== $transition$.exiting().indexOf(viewState)) return;
                const toParams = $transition$.params("to"),
                    fromParams = $transition$.params("from"),
                    getNodeSchema = node => node.paramSchema,
                    toSchema = $transition$.treeChanges("to").map(getNodeSchema).reduce(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.unnestR, []),
                    fromSchema = $transition$.treeChanges("from").map(getNodeSchema).reduce(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.unnestR, []),
                    changedToParams = toSchema.filter((param => {
                        const idx = fromSchema.indexOf(param);
                        return -1 === idx || !fromSchema[idx].type.equals(toParams[param.id], fromParams[param.id])
                    }));
                if (changedToParams.length) {
                    const changedKeys = changedToParams.map((x => x.id)),
                        newValues = Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.filter)(toParams, ((val, key) => -1 !== changedKeys.indexOf(key)));
                    instance.uiOnParamsChanged(newValues, $transition$)
                }
            }
        }
        _disposeLast() {
            this._componentRef && this._componentRef.destroy(), this._componentRef = null
        }
        ngOnDestroy() {
            this._deregisterUIView && this._deregisterUIView(), this._deregisterUiCanExitHook && this._deregisterUiCanExitHook(), this._deregisterUiOnParamsChangedHook && this._deregisterUiOnParamsChangedHook(), this._deregisterUIView = this._deregisterUiCanExitHook = this._deregisterUiOnParamsChangedHook = null, this._disposeLast()
        }
        _viewConfigUpdated(config) {
            if (!config) return this._disposeLast();
            config instanceof Ng2ViewConfig && this._uiViewData.config !== config && (this._disposeLast(), _uirouter_core__WEBPACK_IMPORTED_MODULE_0__.trace.traceUIViewConfigUpdated(this._uiViewData, config && config.viewDecl.$context), this._applyUpdatedConfig(config), this._componentRef.changeDetectorRef.markForCheck())
        }
        _applyUpdatedConfig(config) {
            this._uiViewData.config = config;
            const context = new _uirouter_core__WEBPACK_IMPORTED_MODULE_0__.ResolveContext(config.path),
                componentInjector = this._getComponentInjector(context),
                componentClass = config.viewDecl.component,
                compFactory = componentInjector.get(_angular_core__WEBPACK_IMPORTED_MODULE_1__.k).resolveComponentFactory(componentClass);
            this._componentRef = this._componentTarget.createComponent(compFactory, void 0, componentInjector), this._applyInputBindings(compFactory, this._componentRef.instance, context, componentClass)
        }
        _getComponentInjector(context) {
            const newProviders = context.getTokens().map((token => context.getResolvable(token))).filter((r => r.resolved)).map((r => ({
                    provide: r.token,
                    useValue: context.injector().get(r.token)
                }))),
                parentInject = {
                    context: this._uiViewData.config.viewDecl.$context,
                    fqn: this._uiViewData.fqn
                };
            newProviders.push({
                provide: UIView.PARENT_INJECT,
                useValue: parentInject
            });
            const parentComponentInjector = this.viewContainerRef.injector,
                moduleInjector = context.getResolvable(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.NATIVE_INJECTOR_TOKEN).data,
                mergedParentInjector = new MergeInjector(moduleInjector, parentComponentInjector);
            return _angular_core__WEBPACK_IMPORTED_MODULE_1__.O.resolveAndCreate(newProviders, mergedParentInjector)
        }
        _applyInputBindings(factory, component, context, componentClass) {
            const bindings = this._uiViewData.config.viewDecl.bindings || {},
                explicitBoundProps = Object.keys(bindings),
                renamedInputProp = prop => {
                    const input = factory.inputs.find((i => i.templateName === prop));
                    return input && input.propName || prop
                },
                explicitInputTuples = explicitBoundProps.reduce(((acc, key) => acc.concat([{
                    prop: renamedInputProp(key),
                    token: bindings[key]
                }])), []),
                implicitInputTuples = ng2ComponentInputs(factory).filter((tuple => !Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.inArray)(explicitBoundProps, tuple.prop))),
                injector = context.injector();
            explicitInputTuples.concat(implicitInputTuples).map((tuple => ({
                prop: tuple.prop,
                resolvable: context.getResolvable(tuple.token)
            }))).filter((tuple => tuple.resolvable && tuple.resolvable.resolved)).forEach((tuple => {
                component[tuple.prop] = injector.get(tuple.resolvable.token)
            }))
        }
    }
    UIView.PARENT_INJECT = "UIView.PARENT_INJECT", UIView.decorators = [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.j,
        args: [{
            selector: "ui-view, [ui-view]",
            exportAs: "uiView",
            template: '\n    <ng-template #componentTarget></ng-template>\n    <ng-content *ngIf="!_componentRef"></ng-content>\n  '
        }]
    }], UIView.ctorParameters = () => [{
        type: _uirouter_core__WEBPACK_IMPORTED_MODULE_0__.UIRouter
    }, {
        type: void 0,
        decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.u,
            args: [UIView.PARENT_INJECT]
        }]
    }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.cb
    }], UIView.propDecorators = {
        _componentTarget: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.bb,
            args: ["componentTarget", {
                read: _angular_core__WEBPACK_IMPORTED_MODULE_1__.cb,
                static: !0
            }]
        }],
        name: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.y,
            args: ["name"]
        }],
        _name: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.y,
            args: ["ui-view"]
        }]
    };
    class AnchorUISref {
        constructor(_el, _renderer) {
            this._el = _el, this._renderer = _renderer
        }
        openInNewTab() {
            return "_blank" === this._el.nativeElement.target
        }
        update(href) {
            Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.isNullOrUndefined)(href) ? this._renderer.removeAttribute(this._el.nativeElement, "href") : this._renderer.setProperty(this._el.nativeElement, "href", href)
        }
    }
    AnchorUISref.decorators = [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.n,
        args: [{
            selector: "a[uiSref]"
        }]
    }], AnchorUISref.ctorParameters = () => [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.o
    }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.P
    }];
    class UISref {
        constructor(_router, _anchorUISref, parent) {
            this.targetState$ = new rxjs__WEBPACK_IMPORTED_MODULE_2__.a(1), this._emit = !1, this._router = _router, this._anchorUISref = _anchorUISref, this._parent = parent, this._statesSub = _router.globals.states$.subscribe((() => this.update()))
        }
        set uiSref(val) {
            this.state = val, this.update()
        }
        set uiParams(val) {
            this.params = val, this.update()
        }
        set uiOptions(val) {
            this.options = val, this.update()
        }
        ngOnInit() {
            this._emit = !0, this.update()
        }
        ngOnChanges(changes) {
            this.update()
        }
        ngOnDestroy() {
            this._emit = !1, this._statesSub.unsubscribe(), this.targetState$.unsubscribe()
        }
        update() {
            const $state = this._router.stateService;
            if (this._emit) {
                const newTarget = $state.target(this.state, this.params, this.getOptions());
                this.targetState$.next(newTarget)
            }
            if (this._anchorUISref)
                if (this.state) {
                    const href = $state.href(this.state, this.params, this.getOptions()) || "";
                    this._anchorUISref.update(href)
                } else this._anchorUISref.update(null)
        }
        getOptions() {
            const defaultOpts = {
                relative: this._parent && this._parent.context && this._parent.context.name,
                inherit: !0,
                source: "sref"
            };
            return Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.extend)(defaultOpts, this.options || {})
        }
        go(button, ctrlKey, metaKey) {
            if (!(this._anchorUISref && (this._anchorUISref.openInNewTab() || button || !Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.isNumber)(button) || ctrlKey || metaKey) || !this.state)) return this._router.stateService.go(this.state, this.params, this.getOptions()), !1
        }
    }
    UISref.decorators = [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.n,
        args: [{
            selector: "[uiSref]",
            exportAs: "uiSref"
        }]
    }], UISref.ctorParameters = () => [{
        type: _uirouter_core__WEBPACK_IMPORTED_MODULE_0__.UIRouter
    }, {
        type: AnchorUISref,
        decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.I
        }]
    }, {
        type: void 0,
        decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.u,
            args: [UIView.PARENT_INJECT]
        }]
    }], UISref.propDecorators = {
        state: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.y,
            args: ["uiSref"]
        }],
        params: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.y,
            args: ["uiParams"]
        }],
        options: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.y,
            args: ["uiOptions"]
        }],
        go: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.s,
            args: ["click", ["$event.button", "$event.ctrlKey", "$event.metaKey"]]
        }]
    };
    const inactiveStatus = {
            active: !1,
            exact: !1,
            entering: !1,
            exiting: !1,
            targetStates: []
        },
        pathMatches = target => {
            if (!target.exists()) return () => !1;
            const state = target.$state(),
                targetParamVals = target.params(),
                paramSchema = _uirouter_core__WEBPACK_IMPORTED_MODULE_0__.PathUtils.buildPath(target).map((node => node.paramSchema)).reduce(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.unnestR, []).filter((param => targetParamVals.hasOwnProperty(param.id)));
            return path => {
                const tailNode = Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.tail)(path);
                if (!tailNode || tailNode.state !== state) return !1;
                const paramValues = _uirouter_core__WEBPACK_IMPORTED_MODULE_0__.PathUtils.paramValues(path);
                return _uirouter_core__WEBPACK_IMPORTED_MODULE_0__.Param.equals(paramSchema, paramValues, targetParamVals)
            }
        };

    function spreadToSubPaths(basePath, appendPath) {
        return appendPath.map((node => basePath.concat(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.PathUtils.subPath(appendPath, (n => n.state === node.state)))))
    }

    function mergeSrefStatus(left, right) {
        return {
            active: left.active || right.active,
            exact: left.exact || right.exact,
            entering: left.entering || right.entering,
            exiting: left.exiting || right.exiting,
            targetStates: left.targetStates.concat(right.targetStates)
        }
    }
    class UISrefStatus {
        constructor(_hostUiSref, _globals) {
            this.uiSrefStatus = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.q(!1), this._globals = _globals, this._hostUiSref = _hostUiSref, this.status = Object.assign({}, inactiveStatus)
        }
        ngAfterContentInit() {
            const transEvents$ = this._globals.start$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_8__.a)((trans => {
                    const event = evt => ({
                            evt: evt,
                            trans: trans
                        }),
                        transStart$ = Object(rxjs__WEBPACK_IMPORTED_MODULE_3__.a)(event("start")),
                        transResult = trans.promise.then((() => event("success")), (() => event("error"))),
                        transFinish$ = Object(rxjs__WEBPACK_IMPORTED_MODULE_4__.a)(transResult);
                    return Object(rxjs__WEBPACK_IMPORTED_MODULE_5__.a)(transStart$, transFinish$)
                }))),
                withHostSref = childrenSrefs => childrenSrefs.concat(this._hostUiSref).filter(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.identity).reduce(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.uniqR, []);
            this._srefs$ = new rxjs__WEBPACK_IMPORTED_MODULE_6__.a(withHostSref(this._srefs.toArray())), this._srefChangesSub = this._srefs.changes.subscribe((srefs => this._srefs$.next(withHostSref(srefs.toArray()))));
            const targetStates$ = this._srefs$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_8__.a)((srefs => Object(rxjs__WEBPACK_IMPORTED_MODULE_7__.a)(srefs.map((sref => sref.targetState$))))));
            this._subscription = transEvents$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_8__.a)((evt => targetStates$.pipe(Object(rxjs_operators__WEBPACK_IMPORTED_MODULE_9__.a)((targets => targets.map((target => function(event, srefTarget) {
                const pathMatchesTarget = pathMatches(srefTarget),
                    tc = event.trans.treeChanges(),
                    isStartEvent = "start" === event.evt,
                    activePath = "success" === event.evt ? tc.to : tc.from;
                return {
                    active: spreadToSubPaths([], activePath).map(pathMatchesTarget).reduce(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.anyTrueR, !1),
                    exact: pathMatchesTarget(activePath),
                    entering: !!isStartEvent && spreadToSubPaths(tc.retained, tc.entering).map(pathMatchesTarget).reduce(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.anyTrueR, !1),
                    exiting: !!isStartEvent && spreadToSubPaths(tc.retained, tc.exiting).map(pathMatchesTarget).reduce(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.anyTrueR, !1),
                    targetStates: [srefTarget]
                }
            }(evt, target))).reduce(mergeSrefStatus))))))).subscribe(this._setStatus.bind(this))
        }
        ngOnDestroy() {
            this._subscription && this._subscription.unsubscribe(), this._srefChangesSub && this._srefChangesSub.unsubscribe(), this._srefs$ && this._srefs$.unsubscribe(), this._subscription = this._srefChangesSub = this._srefs$ = void 0
        }
        _setStatus(status) {
            this.status = status, this.uiSrefStatus.emit(status)
        }
    }
    UISrefStatus.decorators = [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.n,
        args: [{
            selector: "[uiSrefStatus],[uiSrefActive],[uiSrefActiveEq]",
            exportAs: "uiSrefStatus"
        }]
    }], UISrefStatus.ctorParameters = () => [{
        type: UISref,
        decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.r
        }, {
            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.U
        }, {
            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.I
        }]
    }, {
        type: _uirouter_core__WEBPACK_IMPORTED_MODULE_0__.UIRouterGlobals
    }], UISrefStatus.propDecorators = {
        uiSrefStatus: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.J,
            args: ["uiSrefStatus"]
        }],
        _srefs: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.l,
            args: [UISref, {
                descendants: !0
            }]
        }]
    };
    class UISrefActive {
        constructor(uiSrefStatus, rnd, host) {
            this._classes = [], this._classesEq = [], this._subscription = uiSrefStatus.uiSrefStatus.subscribe((next => {
                this._classes.forEach((cls => {
                    next.active ? rnd.addClass(host.nativeElement, cls) : rnd.removeClass(host.nativeElement, cls)
                })), this._classesEq.forEach((cls => {
                    next.exact ? rnd.addClass(host.nativeElement, cls) : rnd.removeClass(host.nativeElement, cls)
                }))
            }))
        }
        set active(val) {
            this._classes = val.split(/\s+/)
        }
        set activeEq(val) {
            this._classesEq = val.split(/\s+/)
        }
        ngOnDestroy() {
            this._subscription.unsubscribe()
        }
    }
    UISrefActive.decorators = [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.n,
        args: [{
            selector: "[uiSrefActive],[uiSrefActiveEq]"
        }]
    }], UISrefActive.ctorParameters = () => [{
        type: UISrefStatus
    }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.P
    }, {
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.o,
        decorators: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.r
        }]
    }], UISrefActive.propDecorators = {
        active: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.y,
            args: ["uiSrefActive"]
        }],
        activeEq: [{
            type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.y,
            args: ["uiSrefActiveEq"]
        }]
    };
    const _UIROUTER_DIRECTIVES = [UISref, AnchorUISref, UIView, UISrefActive, UISrefStatus],
        UIROUTER_ROOT_MODULE = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.w("UIRouter Root Module"),
        UIROUTER_MODULE_TOKEN = new _angular_core__WEBPACK_IMPORTED_MODULE_1__.w("UIRouter Module");
    new _angular_core__WEBPACK_IMPORTED_MODULE_1__.w("UIRouter States");

    function applyModuleConfig(uiRouter, injector, module = {}) {
        Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.isFunction)(module.config) && module.config(uiRouter, injector, module);
        return (module.states || []).map((state => uiRouter.stateRegistry.register(state)))
    }

    function loadNgModule(moduleToLoad) {
        return (transition, stateObject) => {
            const ng2Injector = transition.injector().get(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.NATIVE_INJECTOR_TOKEN);
            return function(moduleToLoad, ng2Injector) {
                if (Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.isString)(moduleToLoad)) return ng2Injector.get(_angular_core__WEBPACK_IMPORTED_MODULE_1__.E).load(moduleToLoad);
                const compiler = ng2Injector.get(_angular_core__WEBPACK_IMPORTED_MODULE_1__.i),
                    unwrapEsModuleDefault = x => x && x.__esModule && x.default ? x.default : x;
                return Promise.resolve(moduleToLoad()).then(unwrapEsModuleDefault).then((t => t instanceof _angular_core__WEBPACK_IMPORTED_MODULE_1__.D ? t : compiler.compileModuleAsync(t)))
            }(moduleToLoad, ng2Injector).then((factory => factory.create(ng2Injector))).then((moduleRef => function(transition, ng2Module, parentInjector, lazyLoadState) {
                const injector = ng2Module.injector,
                    uiRouter = injector.get(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.UIRouter),
                    registry = uiRouter.stateRegistry,
                    originalName = lazyLoadState.name,
                    originalState = registry.get(originalName),
                    isFuture = /^(.*)\.\*\*$/.exec(originalName),
                    replacementName = isFuture && isFuture[1],
                    newRootModules = multiProviderParentChildDelta(parentInjector, injector, UIROUTER_ROOT_MODULE).reduce(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.uniqR, []),
                    newChildModules = multiProviderParentChildDelta(parentInjector, injector, UIROUTER_MODULE_TOKEN).reduce(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.uniqR, []);
                if (newRootModules.length) throw console.log(newRootModules), new Error("Lazy loaded modules should not contain a UIRouterModule.forRoot() module");
                const newStateObjects = newChildModules.map((module => applyModuleConfig(uiRouter, injector, module))).reduce(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.unnestR, []).reduce(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.uniqR, []);
                if (isFuture) {
                    const replacementState = registry.get(replacementName);
                    if (!replacementState || replacementState === originalState) throw new Error(`The Future State named '${originalName}' lazy loaded an NgModule. The lazy loaded NgModule must have a state named '${replacementName}' which replaces the (placeholder) '${originalName}' Future State. Add a '${replacementName}' state to the lazy loaded NgModule using UIRouterModule.forChild({ states: CHILD_STATES }).`)
                }
                return newStateObjects.filter((state => !Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__["inArray"])(newStateObjects, state.parent))).forEach((state => state.resolvables.push(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.Resolvable.fromData(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.NATIVE_INJECTOR_TOKEN, injector)))), {}
            }(0, moduleRef, ng2Injector, stateObject)))
        }
    }

    function multiProviderParentChildDelta(parent, child, token) {
        const childVals = child.get(token, []),
            parentVals = parent.get(token, []);
        return childVals.filter((val => -1 === parentVals.indexOf(val)))
    }

    function ng2LazyLoadBuilder(state, parent) {
        const loadNgModuleFn = state.loadChildren;
        return loadNgModuleFn ? loadNgModule(loadNgModuleFn) : state.lazyLoad
    }
    class Ng2LocationServices extends _uirouter_core__WEBPACK_IMPORTED_MODULE_0__.BaseLocationServices {
        constructor(router, _locationStrategy, isBrowser) {
            super(router, isBrowser), this._locationStrategy = _locationStrategy, this._locationStrategy.onPopState((evt => {
                "hashchange" !== evt.type && this._listener(evt)
            }))
        }
        _get() {
            return this._locationStrategy.path(!0).replace(this._locationStrategy.getBaseHref().replace(/\/$/, ""), "")
        }
        _set(state, title, url, replace) {
            const {
                path: path,
                search: search,
                hash: hash
            } = Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.parseUrl)(url), urlPart = search ? path : path + (hash ? "#" + hash : ""), searchPart = search + (hash ? "#" + hash : "");
            replace ? this._locationStrategy.replaceState(state, title, urlPart, searchPart) : this._locationStrategy.pushState(state, title, urlPart, searchPart)
        }
        dispose(router) {
            super.dispose(router)
        }
    }
    class Ng2LocationConfig extends _uirouter_core__WEBPACK_IMPORTED_MODULE_0__.BrowserLocationConfig {
        constructor(router, _locationStrategy) {
            super(router, Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.is)(_angular_common__WEBPACK_IMPORTED_MODULE_10__.e)(_locationStrategy)), this._locationStrategy = _locationStrategy
        }
        baseHref(href) {
            return this._locationStrategy.getBaseHref()
        }
    }
    const _UIROUTER_INSTANCE_PROVIDERS = [{
        provide: _uirouter_core__WEBPACK_IMPORTED_MODULE_0__.UIRouter,
        useFactory: function(locationStrategy, rootModules, modules, injector) {
            if (1 !== rootModules.length) throw new Error("Exactly one UIRouterModule.forRoot() should be in the bootstrapped app module's imports: []");
            const router = new _uirouter_core__WEBPACK_IMPORTED_MODULE_0__.UIRouter;
            router.plugin(_uirouter_rx__WEBPACK_IMPORTED_MODULE_11__.a), router.plugin(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.servicesPlugin), _uirouter_core__WEBPACK_IMPORTED_MODULE_0__.services.$injector.get = injector.get.bind(injector), router.locationService = new Ng2LocationServices(router, locationStrategy, Object(_angular_common__WEBPACK_IMPORTED_MODULE_10__.f)(injector.get(_angular_core__WEBPACK_IMPORTED_MODULE_1__.K))), router.locationConfig = new Ng2LocationConfig(router, locationStrategy), router.viewService._pluginapi._viewConfigFactory("ng2", ((path, config) => new Ng2ViewConfig(path, config)));
            const registry = router.stateRegistry;
            registry.decorator("views", ng2ViewsBuilder), registry.decorator("lazyLoad", ng2LazyLoadBuilder);
            const ng2InjectorResolvable = _uirouter_core__WEBPACK_IMPORTED_MODULE_0__.Resolvable.fromData(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.NATIVE_INJECTOR_TOKEN, injector);
            return registry.root().resolvables.push(ng2InjectorResolvable), router.urlMatcherFactory.$get(), rootModules.forEach((moduleConfig => function(uiRouter, injector, module) {
                Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.isDefined)(module.deferIntercept) && uiRouter.urlService.deferIntercept(module.deferIntercept), Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.isDefined)(module.otherwise) && uiRouter.urlService.rules.otherwise(module.otherwise), Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.isDefined)(module.initial) && uiRouter.urlService.rules.initial(module.initial)
            }(router, 0, moduleConfig))), modules.forEach((moduleConfig => applyModuleConfig(router, injector, moduleConfig))), router
        },
        deps: [_angular_common__WEBPACK_IMPORTED_MODULE_10__.d, UIROUTER_ROOT_MODULE, UIROUTER_MODULE_TOKEN, _angular_core__WEBPACK_IMPORTED_MODULE_1__.x]
    }, {
        provide: UIView.PARENT_INJECT,
        useFactory: function(r) {
            return {
                fqn: null,
                context: r.root()
            }
        },
        deps: [_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.StateRegistry]
    }, {
        provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__.c,
        useFactory: function(router) {
            return () => {
                router.urlRouter.interceptDeferred || (router.urlService.listen(), router.urlService.sync())
            }
        },
        deps: [_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.UIRouter],
        multi: !0
    }];
    const _UIROUTER_SERVICE_PROVIDERS = [{
        provide: _uirouter_core__WEBPACK_IMPORTED_MODULE_0__.StateService,
        useFactory: function(r) {
            return r.stateService
        },
        deps: [_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.UIRouter]
    }, {
        provide: _uirouter_core__WEBPACK_IMPORTED_MODULE_0__.TransitionService,
        useFactory: function(r) {
            return r.transitionService
        },
        deps: [_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.UIRouter]
    }, {
        provide: _uirouter_core__WEBPACK_IMPORTED_MODULE_0__.UrlMatcherFactory,
        useFactory: function(r) {
            return r.urlMatcherFactory
        },
        deps: [_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.UIRouter]
    }, {
        provide: _uirouter_core__WEBPACK_IMPORTED_MODULE_0__.UrlRouter,
        useFactory: function(r) {
            return r.urlRouter
        },
        deps: [_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.UIRouter]
    }, {
        provide: _uirouter_core__WEBPACK_IMPORTED_MODULE_0__.UrlService,
        useFactory: function(r) {
            return r.urlService
        },
        deps: [_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.UIRouter]
    }, {
        provide: _uirouter_core__WEBPACK_IMPORTED_MODULE_0__.ViewService,
        useFactory: function(r) {
            return r.viewService
        },
        deps: [_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.UIRouter]
    }, {
        provide: _uirouter_core__WEBPACK_IMPORTED_MODULE_0__.StateRegistry,
        useFactory: function(r) {
            return r.stateRegistry
        },
        deps: [_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.UIRouter]
    }, {
        provide: _uirouter_core__WEBPACK_IMPORTED_MODULE_0__.UIRouterGlobals,
        useFactory: function(r) {
            return r.globals
        },
        deps: [_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.UIRouter]
    }];
    _UIROUTER_INSTANCE_PROVIDERS.concat(_UIROUTER_SERVICE_PROVIDERS);

    function onTransitionReady(transitionService, root) {
        const mod = root[0];
        return mod && mod.deferInitialRender ? () => new Promise((resolve => {
            transitionService.onStart({}, (trans => {
                trans.promise.then(resolve, resolve)
            }), {
                invokeLimit: 1
            })
        })) : () => Promise.resolve()
    }

    function makeRootProviders(module) {
        return [{
            provide: UIROUTER_ROOT_MODULE,
            useValue: module,
            multi: !0
        }, {
            provide: UIROUTER_MODULE_TOKEN,
            useValue: module,
            multi: !0
        }, {
            provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__.a,
            useValue: module.states || [],
            multi: !0
        }, {
            provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__.c,
            useFactory: onTransitionReady,
            deps: [_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.TransitionService, UIROUTER_ROOT_MODULE],
            multi: !0
        }]
    }

    function makeChildProviders(module) {
        return [{
            provide: UIROUTER_MODULE_TOKEN,
            useValue: module,
            multi: !0
        }, {
            provide: _angular_core__WEBPACK_IMPORTED_MODULE_1__.a,
            useValue: module.states || [],
            multi: !0
        }]
    }
    class UIRouterModule {
        static forRoot(config = {}) {
            return {
                ngModule: UIRouterModule,
                providers: [_UIROUTER_INSTANCE_PROVIDERS, _UIROUTER_SERVICE_PROVIDERS, (useHash = config.useHash, {
                    provide: _angular_common__WEBPACK_IMPORTED_MODULE_10__.d,
                    useClass: useHash ? _angular_common__WEBPACK_IMPORTED_MODULE_10__.c : _angular_common__WEBPACK_IMPORTED_MODULE_10__.e
                }), ...makeRootProviders(config)]
            };
            var useHash
        }
        static forChild(module = {}) {
            return {
                ngModule: UIRouterModule,
                providers: makeChildProviders(module)
            }
        }
    }
    UIRouterModule.decorators = [{
        type: _angular_core__WEBPACK_IMPORTED_MODULE_1__.C,
        args: [{
            imports: [_angular_common__WEBPACK_IMPORTED_MODULE_10__.a],
            declarations: [_UIROUTER_DIRECTIVES],
            exports: [_UIROUTER_DIRECTIVES],
            entryComponents: [UIView]
        }]
    }]
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return safeConsole
    }));
    var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2),
        noopConsoleStub = {
            log: _common__WEBPACK_IMPORTED_MODULE_0__.x,
            error: _common__WEBPACK_IMPORTED_MODULE_0__.x,
            table: _common__WEBPACK_IMPORTED_MODULE_0__.x
        };
    var safeConsole = "undefined" != typeof document && document.documentMode && 9 === document.documentMode ? window && window.console ? function(console) {
        var bound = function(fn) {
            return Function.prototype.bind.call(fn, console)
        };
        return {
            log: bound(console.log),
            error: bound(console.log),
            table: bound(console.log)
        }
    }(window.console) : noopConsoleStub : console.table && console.error ? console : function(console) {
        var log = console.log.bind(console);
        return {
            log: log,
            error: console.error ? console.error.bind(console) : log,
            table: console.table ? console.table.bind(console) : log
        }
    }(console)
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return config
    }));
    var _enable_super_gross_mode_that_will_cause_bad_things = !1,
        config = {
            Promise: void 0,
            set useDeprecatedSynchronousErrorHandling(value) {
                value && (new Error).stack;
                _enable_super_gross_mode_that_will_cause_bad_things = value
            },
            get useDeprecatedSynchronousErrorHandling() {
                return _enable_super_gross_mode_that_will_cause_bad_things
            }
        }
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return TargetState
    }));
    var _common_predicates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4),
        _common_strings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(10),
        _common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6),
        TargetState = function() {
            function TargetState(_stateRegistry, _identifier, _params, _options) {
                this._stateRegistry = _stateRegistry, this._identifier = _identifier, this._identifier = _identifier, this._params = Object(_common__WEBPACK_IMPORTED_MODULE_2__.h)({}, _params || {}), this._options = Object(_common__WEBPACK_IMPORTED_MODULE_2__.h)({}, _options || {}), this._definition = _stateRegistry.matcher.find(_identifier, this._options.relative)
            }
            return TargetState.prototype.name = function() {
                return this._definition && this._definition.name || this._identifier
            }, TargetState.prototype.identifier = function() {
                return this._identifier
            }, TargetState.prototype.params = function() {
                return this._params
            }, TargetState.prototype.$state = function() {
                return this._definition
            }, TargetState.prototype.state = function() {
                return this._definition && this._definition.self
            }, TargetState.prototype.options = function() {
                return this._options
            }, TargetState.prototype.exists = function() {
                return !(!this._definition || !this._definition.self)
            }, TargetState.prototype.valid = function() {
                return !this.error()
            }, TargetState.prototype.error = function() {
                var base = this.options().relative;
                if (!this._definition && base) {
                    var stateName = base.name ? base.name : base;
                    return "Could not resolve '" + this.name() + "' from state '" + stateName + "'"
                }
                return this._definition ? this._definition.self ? void 0 : "State '" + this.name() + "' has an invalid definition" : "No such state '" + this.name() + "'"
            }, TargetState.prototype.toString = function() {
                return "'" + this.name() + "'" + Object(_common_strings__WEBPACK_IMPORTED_MODULE_1__.k)(this.params())
            }, TargetState.prototype.withState = function(state) {
                return new TargetState(this._stateRegistry, state, this._params, this._options)
            }, TargetState.prototype.withParams = function(params, replace) {
                void 0 === replace && (replace = !1);
                var newParams = replace ? params : Object(_common__WEBPACK_IMPORTED_MODULE_2__.h)({}, this._params, params);
                return new TargetState(this._stateRegistry, this._identifier, newParams, this._options)
            }, TargetState.prototype.withOptions = function(options, replace) {
                void 0 === replace && (replace = !1);
                var newOpts = replace ? options : Object(_common__WEBPACK_IMPORTED_MODULE_2__.h)({}, this._options, options);
                return new TargetState(this._stateRegistry, this._identifier, this._params, newOpts)
            }, TargetState.isDef = function(obj) {
                return obj && obj.state && (Object(_common_predicates__WEBPACK_IMPORTED_MODULE_0__.l)(obj.state) || Object(_common_predicates__WEBPACK_IMPORTED_MODULE_0__.i)(obj.state) && Object(_common_predicates__WEBPACK_IMPORTED_MODULE_0__.l)(obj.state.name))
            }, TargetState
        }()
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return NATIVE_INJECTOR_TOKEN
    })), __webpack_require__.d(__webpack_exports__, "b", (function() {
        return ResolveContext
    }));
    var _common_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2),
        _common_hof__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5),
        _common_trace__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(14),
        _common_coreservices__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(9),
        _interface__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(57),
        _resolvable__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(18),
        _path_pathUtils__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(21),
        _common_strings__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(10),
        _common__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(6),
        whens = _interface__WEBPACK_IMPORTED_MODULE_4__.a.when,
        ALL_WHENS = [whens.EAGER, whens.LAZY],
        EAGER_WHENS = [whens.EAGER],
        NATIVE_INJECTOR_TOKEN = "Native Injector",
        ResolveContext = function() {
            function ResolveContext(_path) {
                this._path = _path
            }
            return ResolveContext.prototype.getTokens = function() {
                return this._path.reduce((function(acc, node) {
                    return acc.concat(node.resolvables.map((function(r) {
                        return r.token
                    })))
                }), []).reduce(_common_common__WEBPACK_IMPORTED_MODULE_0__.I, [])
            }, ResolveContext.prototype.getResolvable = function(token) {
                var matching = this._path.map((function(node) {
                    return node.resolvables
                })).reduce(_common_common__WEBPACK_IMPORTED_MODULE_0__.K, []).filter((function(r) {
                    return r.token === token
                }));
                return Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.G)(matching)
            }, ResolveContext.prototype.getPolicy = function(resolvable) {
                var node = this.findNode(resolvable);
                return resolvable.getPolicy(node.state)
            }, ResolveContext.prototype.subContext = function(state) {
                return new ResolveContext(_path_pathUtils__WEBPACK_IMPORTED_MODULE_6__.a.subPath(this._path, (function(node) {
                    return node.state === state
                })))
            }, ResolveContext.prototype.addResolvables = function(newResolvables, state) {
                var node = Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.n)(this._path, Object(_common_hof__WEBPACK_IMPORTED_MODULE_1__.l)("state", state)),
                    keys = newResolvables.map((function(r) {
                        return r.token
                    }));
                node.resolvables = node.resolvables.filter((function(r) {
                    return -1 === keys.indexOf(r.token)
                })).concat(newResolvables)
            }, ResolveContext.prototype.resolvePath = function(when, trans) {
                var _this = this;
                void 0 === when && (when = "LAZY");
                var matchedWhens = (Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.s)(ALL_WHENS, when) ? when : "LAZY") === _interface__WEBPACK_IMPORTED_MODULE_4__.a.when.EAGER ? EAGER_WHENS : ALL_WHENS;
                _common_trace__WEBPACK_IMPORTED_MODULE_2__.a.traceResolvePath(this._path, when, trans);
                var matchesPolicy = function(acceptedVals, whenOrAsync) {
                        return function(resolvable) {
                            return Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.s)(acceptedVals, _this.getPolicy(resolvable)[whenOrAsync])
                        }
                    },
                    promises = this._path.reduce((function(acc, node) {
                        var nodeResolvables = node.resolvables.filter(matchesPolicy(matchedWhens, "when")),
                            nowait = nodeResolvables.filter(matchesPolicy(["NOWAIT"], "async")),
                            wait = nodeResolvables.filter(Object(_common_hof__WEBPACK_IMPORTED_MODULE_1__.f)(matchesPolicy(["NOWAIT"], "async"))),
                            subContext = _this.subContext(node.state),
                            getResult = function(r) {
                                return r.get(subContext, trans).then((function(value) {
                                    return {
                                        token: r.token,
                                        value: value
                                    }
                                }))
                            };
                        return nowait.forEach(getResult), acc.concat(wait.map(getResult))
                    }), []);
                return _common_coreservices__WEBPACK_IMPORTED_MODULE_3__.b.$q.all(promises)
            }, ResolveContext.prototype.injector = function() {
                return this._injector || (this._injector = new UIInjectorImpl(this))
            }, ResolveContext.prototype.findNode = function(resolvable) {
                return Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.n)(this._path, (function(node) {
                    return Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.s)(node.resolvables, resolvable)
                }))
            }, ResolveContext.prototype.getDependencies = function(resolvable) {
                var _this = this,
                    node = this.findNode(resolvable),
                    availableResolvables = (_path_pathUtils__WEBPACK_IMPORTED_MODULE_6__.a.subPath(this._path, (function(x) {
                        return x === node
                    })) || this._path).reduce((function(acc, _node) {
                        return acc.concat(_node.resolvables)
                    }), []).filter((function(res) {
                        return res !== resolvable
                    }));
                return resolvable.deps.map((function(token) {
                    var matching = availableResolvables.filter((function(r) {
                        return r.token === token
                    }));
                    if (matching.length) return Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.G)(matching);
                    var fromInjector = _this.injector().getNative(token);
                    if (Object(_common__WEBPACK_IMPORTED_MODULE_8__.w)(fromInjector)) throw new Error("Could not find Dependency Injection token: " + Object(_common_strings__WEBPACK_IMPORTED_MODULE_7__.k)(token));
                    return new _resolvable__WEBPACK_IMPORTED_MODULE_5__.a(token, (function() {
                        return fromInjector
                    }), [], fromInjector)
                }))
            }, ResolveContext
        }(),
        UIInjectorImpl = function() {
            function UIInjectorImpl(context) {
                this.context = context, this.native = this.get(NATIVE_INJECTOR_TOKEN) || _common_coreservices__WEBPACK_IMPORTED_MODULE_3__.b.$injector
            }
            return UIInjectorImpl.prototype.get = function(token) {
                var resolvable = this.context.getResolvable(token);
                if (resolvable) {
                    if ("NOWAIT" === this.context.getPolicy(resolvable).async) return resolvable.get(this.context);
                    if (!resolvable.resolved) throw new Error("Resolvable async .get() not complete:" + Object(_common_strings__WEBPACK_IMPORTED_MODULE_7__.k)(resolvable.token));
                    return resolvable.data
                }
                return this.getNative(token)
            }, UIInjectorImpl.prototype.getAsync = function(token) {
                var resolvable = this.context.getResolvable(token);
                return resolvable ? resolvable.get(this.context) : _common_coreservices__WEBPACK_IMPORTED_MODULE_3__.b.$q.when(this.native.get(token))
            }, UIInjectorImpl.prototype.getNative = function(token) {
                return this.native && this.native.get(token)
            }, UIInjectorImpl
        }()
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var _interface__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(241);
    __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "BaseLocationServices") && __webpack_require__.d(__webpack_exports__, "BaseLocationServices", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.BaseLocationServices
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "BaseUrlRule") && __webpack_require__.d(__webpack_exports__, "BaseUrlRule", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.BaseUrlRule
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "BrowserLocationConfig") && __webpack_require__.d(__webpack_exports__, "BrowserLocationConfig", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.BrowserLocationConfig
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "DefType") && __webpack_require__.d(__webpack_exports__, "DefType", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.DefType
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "NATIVE_INJECTOR_TOKEN") && __webpack_require__.d(__webpack_exports__, "NATIVE_INJECTOR_TOKEN", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.NATIVE_INJECTOR_TOKEN
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "Param") && __webpack_require__.d(__webpack_exports__, "Param", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.Param
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "ParamTypes") && __webpack_require__.d(__webpack_exports__, "ParamTypes", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.ParamTypes
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "PathUtils") && __webpack_require__.d(__webpack_exports__, "PathUtils", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.PathUtils
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "Resolvable") && __webpack_require__.d(__webpack_exports__, "Resolvable", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.Resolvable
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "ResolveContext") && __webpack_require__.d(__webpack_exports__, "ResolveContext", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.ResolveContext
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "StateRegistry") && __webpack_require__.d(__webpack_exports__, "StateRegistry", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.StateRegistry
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "StateService") && __webpack_require__.d(__webpack_exports__, "StateService", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.StateService
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "TransitionService") && __webpack_require__.d(__webpack_exports__, "TransitionService", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.TransitionService
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "UIRouter") && __webpack_require__.d(__webpack_exports__, "UIRouter", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.UIRouter
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "UIRouterGlobals") && __webpack_require__.d(__webpack_exports__, "UIRouterGlobals", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.UIRouterGlobals
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "UrlMatcherFactory") && __webpack_require__.d(__webpack_exports__, "UrlMatcherFactory", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.UrlMatcherFactory
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "UrlRouter") && __webpack_require__.d(__webpack_exports__, "UrlRouter", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.UrlRouter
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "UrlService") && __webpack_require__.d(__webpack_exports__, "UrlService", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.UrlService
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "ViewService") && __webpack_require__.d(__webpack_exports__, "ViewService", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.ViewService
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "parseUrl") && __webpack_require__.d(__webpack_exports__, "parseUrl", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.parseUrl
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "servicesPlugin") && __webpack_require__.d(__webpack_exports__, "servicesPlugin", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.servicesPlugin
    }));
    var _param__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(19);
    __webpack_require__.d(__webpack_exports__, "DefType", (function() {
        return _param__WEBPACK_IMPORTED_MODULE_1__.a
    })), __webpack_require__.d(__webpack_exports__, "Param", (function() {
        return _param__WEBPACK_IMPORTED_MODULE_1__.b
    }));
    var _paramTypes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(242);
    __webpack_require__.d(__webpack_exports__, "ParamTypes", (function() {
        return _paramTypes__WEBPACK_IMPORTED_MODULE_2__.a
    }));
    __webpack_require__(66), __webpack_require__(42)
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "b", (function() {
        return getParams
    })), __webpack_require__.d(__webpack_exports__, "d", (function() {
        return parseUrl
    })), __webpack_require__.d(__webpack_exports__, "a", (function() {
        return buildUrl
    })), __webpack_require__.d(__webpack_exports__, "c", (function() {
        return locationPluginFactory
    }));
    var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6),
        keyValsToObjectR = function(accum, _a) {
            var key = _a[0],
                val = _a[1];
            return accum.hasOwnProperty(key) ? Object(_common__WEBPACK_IMPORTED_MODULE_0__.o)(accum[key]) ? accum[key].push(val) : accum[key] = [accum[key], val] : accum[key] = val, accum
        },
        getParams = function(queryString) {
            return queryString.split("&").filter(_common__WEBPACK_IMPORTED_MODULE_0__.l).map(_common__WEBPACK_IMPORTED_MODULE_0__.I).reduce(keyValsToObjectR, {})
        };

    function parseUrl(url) {
        var orEmptyString = function(x) {
                return x || ""
            },
            _a = Object(_common__WEBPACK_IMPORTED_MODULE_0__.J)(url).map(orEmptyString),
            beforehash = _a[0],
            hash = _a[1],
            _b = Object(_common__WEBPACK_IMPORTED_MODULE_0__.K)(beforehash).map(orEmptyString);
        return {
            path: _b[0],
            search: _b[1],
            hash: hash,
            url: url
        }
    }
    var buildUrl = function(loc) {
        var path = loc.path(),
            searchObject = loc.search(),
            hash = loc.hash(),
            search = Object.keys(searchObject).map((function(key) {
                var param = searchObject[key];
                return (Object(_common__WEBPACK_IMPORTED_MODULE_0__.o)(param) ? param : [param]).map((function(val) {
                    return key + "=" + val
                }))
            })).reduce(_common__WEBPACK_IMPORTED_MODULE_0__.Q, []).join("&");
        return path + (search ? "?" + search : "") + (hash ? "#" + hash : "")
    };

    function locationPluginFactory(name, isHtml5, serviceClass, configurationClass) {
        return function(uiRouter) {
            var service = uiRouter.locationService = new serviceClass(uiRouter),
                configuration = uiRouter.locationConfig = new configurationClass(uiRouter, isHtml5);
            return {
                name: name,
                service: service,
                configuration: configuration,
                dispose: function(router) {
                    router.dispose(service), router.dispose(configuration)
                }
            }
        }
    }
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return UrlMatcher
    }));
    var _common_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2),
        _common_hof__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5),
        _common_predicates__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4),
        _params_param__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(19),
        _common_strings__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(10),
        _common__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(6);

    function quoteRegExp(str, param) {
        var surroundPattern = ["", ""],
            result = str.replace(/[\\\[\]\^$*+?.()|{}]/g, "\\$&");
        if (!param) return result;
        switch (param.squash) {
            case !1:
                surroundPattern = ["(", ")" + (param.isOptional ? "?" : "")];
                break;
            case !0:
                result = result.replace(/\/$/, ""), surroundPattern = ["(?:/(", ")|/)?"];
                break;
            default:
                surroundPattern = ["(" + param.squash + "|", ")?"]
        }
        return result + surroundPattern[0] + param.type.pattern.source + surroundPattern[1]
    }
    var splitOnSlash = Object(_common_strings__WEBPACK_IMPORTED_MODULE_4__.i)("/"),
        defaultConfig = {
            state: {
                params: {}
            },
            strict: !0,
            caseInsensitive: !0,
            decodeParams: !0
        },
        UrlMatcher = function() {
            function UrlMatcher(pattern, paramTypes, paramFactory, config) {
                var _this = this;
                this._cache = {
                    path: [this]
                }, this._children = [], this._params = [], this._segments = [], this._compiled = [], this.config = config = Object(_common__WEBPACK_IMPORTED_MODULE_5__.f)(config, defaultConfig), this.pattern = pattern;
                for (var matchArray, details, segment, placeholder = /([:*])([\w\[\]]+)|\{([\w\[\]]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g, searchPlaceholder = /([:]?)([\w\[\].-]+)|\{([\w\[\].-]+)(?:\:\s*((?:[^{}\\]+|\\.|\{(?:[^{}\\]+|\\.)*\})+))?\}/g, patterns = [], last = 0, checkParamErrors = function(id) {
                        if (!UrlMatcher.nameValidator.test(id)) throw new Error("Invalid parameter name '" + id + "' in pattern '" + pattern + "'");
                        if (Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.n)(_this._params, Object(_common_hof__WEBPACK_IMPORTED_MODULE_1__.l)("id", id))) throw new Error("Duplicate parameter name '" + id + "' in pattern '" + pattern + "'")
                    }, matchDetails = function(m, isSearch) {
                        var str, id = m[2] || m[3],
                            regexp = isSearch ? m[4] : m[4] || ("*" === m[1] ? "[\\s\\S]*" : null);
                        return {
                            id: id,
                            regexp: regexp,
                            segment: pattern.substring(last, m.index),
                            type: regexp ? paramTypes.type(regexp) || (str = regexp, Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.t)(paramTypes.type(isSearch ? "query" : "path"), {
                                pattern: new RegExp(str, _this.config.caseInsensitive ? "i" : void 0)
                            })) : null
                        }
                    };
                    (matchArray = placeholder.exec(pattern)) && !((details = matchDetails(matchArray, !1)).segment.indexOf("?") >= 0);) checkParamErrors(details.id), this._params.push(paramFactory.fromPath(details.id, details.type, config.state)), this._segments.push(details.segment), patterns.push([details.segment, Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.G)(this._params)]), last = placeholder.lastIndex;
                var i = (segment = pattern.substring(last)).indexOf("?");
                if (i >= 0) {
                    var search = segment.substring(i);
                    if (segment = segment.substring(0, i), search.length > 0)
                        for (last = 0; matchArray = searchPlaceholder.exec(search);) checkParamErrors((details = matchDetails(matchArray, !0)).id), this._params.push(paramFactory.fromSearch(details.id, details.type, config.state)), last = placeholder.lastIndex
                }
                this._segments.push(segment), this._compiled = patterns.map((function(_pattern) {
                    return quoteRegExp.apply(null, _pattern)
                })).concat(quoteRegExp(segment))
            }
            return UrlMatcher.encodeDashes = function(str) {
                return encodeURIComponent(str).replace(/-/g, (function(c) {
                    return "%5C%" + c.charCodeAt(0).toString(16).toUpperCase()
                }))
            }, UrlMatcher.pathSegmentsAndParams = function(matcher) {
                var staticSegments = matcher._segments,
                    pathParams = matcher._params.filter((function(p) {
                        return p.location === _params_param__WEBPACK_IMPORTED_MODULE_3__.a.PATH
                    }));
                return Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.e)(staticSegments, pathParams.concat(void 0)).reduce(_common_common__WEBPACK_IMPORTED_MODULE_0__.K, []).filter((function(x) {
                    return "" !== x && Object(_common_predicates__WEBPACK_IMPORTED_MODULE_2__.c)(x)
                }))
            }, UrlMatcher.queryParams = function(matcher) {
                return matcher._params.filter((function(p) {
                    return p.location === _params_param__WEBPACK_IMPORTED_MODULE_3__.a.SEARCH
                }))
            }, UrlMatcher.compare = function(a, b) {
                var weights = function(matcher) {
                        return matcher._cache.weights = matcher._cache.weights || function(matcher) {
                            return matcher._cache.segments = matcher._cache.segments || matcher._cache.path.map(UrlMatcher.pathSegmentsAndParams).reduce(_common_common__WEBPACK_IMPORTED_MODULE_0__.K, []).reduce(_common_strings__WEBPACK_IMPORTED_MODULE_4__.c, []).map((function(x) {
                                return Object(_common_predicates__WEBPACK_IMPORTED_MODULE_2__.l)(x) ? splitOnSlash(x) : x
                            })).reduce(_common_common__WEBPACK_IMPORTED_MODULE_0__.K, [])
                        }(matcher).map((function(segment) {
                            return "/" === segment ? 1 : Object(_common_predicates__WEBPACK_IMPORTED_MODULE_2__.l)(segment) ? 2 : segment instanceof _params_param__WEBPACK_IMPORTED_MODULE_3__.b ? 3 : void 0
                        }))
                    },
                    weightsA = weights(a),
                    weightsB = weights(b);
                ! function(l, r, padVal) {
                    for (var len = Math.max(l.length, r.length); l.length < len;) l.push(padVal);
                    for (; r.length < len;) r.push(padVal)
                }(weightsA, weightsB, 0);
                var cmp, i, _pairs = Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.e)(weightsA, weightsB);
                for (i = 0; i < _pairs.length; i++)
                    if (0 !== (cmp = _pairs[i][0] - _pairs[i][1])) return cmp;
                return 0
            }, UrlMatcher.prototype.append = function(url) {
                return this._children.push(url), url._cache = {
                    path: this._cache.path.concat(url),
                    parent: this,
                    pattern: null
                }, url
            }, UrlMatcher.prototype.isRoot = function() {
                return this._cache.path[0] === this
            }, UrlMatcher.prototype.toString = function() {
                return this.pattern
            }, UrlMatcher.prototype._getDecodedParamValue = function(value, param) {
                return Object(_common_predicates__WEBPACK_IMPORTED_MODULE_2__.c)(value) && (this.config.decodeParams && !param.type.raw && (value = Object(_common_predicates__WEBPACK_IMPORTED_MODULE_2__.a)(value) ? value.map((function(paramValue) {
                    return decodeURIComponent(paramValue)
                })) : decodeURIComponent(value)), value = param.type.decode(value)), param.value(value)
            }, UrlMatcher.prototype.exec = function(path, search, hash, options) {
                var _this = this;
                void 0 === search && (search = {}), void 0 === options && (options = {});
                var obj, _prop, fn, match = (obj = this._cache, _prop = "pattern", fn = function() {
                    return new RegExp(["^", Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.J)(_this._cache.path.map(Object(_common_hof__WEBPACK_IMPORTED_MODULE_1__.k)("_compiled"))).join(""), !1 === _this.config.strict ? "/?" : "", "$"].join(""), _this.config.caseInsensitive ? "i" : void 0)
                }, obj[_prop] = obj[_prop] || fn()).exec(path);
                if (!match) return null;
                var reverseString, split, allReversed, allParams = this.parameters(),
                    pathParams = allParams.filter((function(param) {
                        return !param.isSearch()
                    })),
                    searchParams = allParams.filter((function(param) {
                        return param.isSearch()
                    })),
                    nPathSegments = this._cache.path.map((function(urlm) {
                        return urlm._segments.length - 1
                    })).reduce((function(a, x) {
                        return a + x
                    })),
                    values = {};
                if (nPathSegments !== match.length - 1) throw new Error("Unbalanced capture group in route '" + this.pattern + "'");
                for (var i = 0; i < nPathSegments; i++) {
                    for (var param = pathParams[i], value = match[i + 1], j = 0; j < param.replace.length; j++) param.replace[j].from === value && (value = param.replace[j].to);
                    value && !0 === param.array && (reverseString = void 0, split = void 0, allReversed = void 0, split = (reverseString = function(str) {
                        return str.split("").reverse().join("")
                    })(value).split(/-(?!\\)/), allReversed = Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.u)(split, reverseString), value = Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.u)(allReversed, (function(str) {
                        return str.replace(/\\-/g, "-")
                    })).reverse()), values[param.id] = this._getDecodedParamValue(value, param)
                }
                return searchParams.forEach((function(param) {
                    for (var value = search[param.id], j = 0; j < param.replace.length; j++) param.replace[j].from === value && (value = param.replace[j].to);
                    values[param.id] = _this._getDecodedParamValue(value, param)
                })), hash && (values["#"] = hash), values
            }, UrlMatcher.prototype.parameters = function(opts) {
                return void 0 === opts && (opts = {}), !1 === opts.inherit ? this._params : Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.J)(this._cache.path.map((function(matcher) {
                    return matcher._params
                })))
            }, UrlMatcher.prototype.parameter = function(id, opts) {
                var _this = this;
                void 0 === opts && (opts = {});
                var parent = this._cache.parent;
                return function() {
                    for (var _i = 0, _a = _this._params; _i < _a.length; _i++) {
                        var param = _a[_i];
                        if (param.id === id) return param
                    }
                }() || !1 !== opts.inherit && parent && parent.parameter(id, opts) || null
            }, UrlMatcher.prototype.validates = function(params) {
                return params = params || {}, this.parameters().filter((function(paramDef) {
                    return params.hasOwnProperty(paramDef.id)
                })).map((function(paramDef) {
                    return param = paramDef, val = params[paramDef.id], !param || param.validates(val);
                    var param, val
                })).reduce(_common_common__WEBPACK_IMPORTED_MODULE_0__.a, !0)
            }, UrlMatcher.prototype.format = function(values) {
                void 0 === values && (values = {});
                var urlMatchers = this._cache.path,
                    pathSegmentsAndParams = urlMatchers.map(UrlMatcher.pathSegmentsAndParams).reduce(_common_common__WEBPACK_IMPORTED_MODULE_0__.K, []).map((function(x) {
                        return Object(_common_predicates__WEBPACK_IMPORTED_MODULE_2__.l)(x) ? x : getDetails(x)
                    })),
                    queryParams = urlMatchers.map(UrlMatcher.queryParams).reduce(_common_common__WEBPACK_IMPORTED_MODULE_0__.K, []).map(getDetails);
                if (pathSegmentsAndParams.concat(queryParams).filter((function(param) {
                        return !1 === param.isValid
                    })).length) return null;

                function getDetails(param) {
                    var value = param.value(values[param.id]),
                        isValid = param.validates(value),
                        isDefaultValue = param.isDefaultValue(value),
                        squash = !!isDefaultValue && param.squash,
                        encoded = param.type.encode(value);
                    return {
                        param: param,
                        value: value,
                        isValid: isValid,
                        isDefaultValue: isDefaultValue,
                        squash: squash,
                        encoded: encoded
                    }
                }
                var pathString = pathSegmentsAndParams.reduce((function(acc, x) {
                        if (Object(_common_predicates__WEBPACK_IMPORTED_MODULE_2__.l)(x)) return acc + x;
                        var squash = x.squash,
                            encoded = x.encoded,
                            param = x.param;
                        return !0 === squash ? acc.match(/\/$/) ? acc.slice(0, -1) : acc : Object(_common_predicates__WEBPACK_IMPORTED_MODULE_2__.l)(squash) ? acc + squash : !1 !== squash || null == encoded ? acc : Object(_common_predicates__WEBPACK_IMPORTED_MODULE_2__.a)(encoded) ? acc + Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.u)(encoded, UrlMatcher.encodeDashes).join("-") : param.raw ? acc + encoded : acc + encodeURIComponent(encoded)
                    }), ""),
                    queryString = queryParams.map((function(paramDetails) {
                        var param = paramDetails.param,
                            squash = paramDetails.squash,
                            encoded = paramDetails.encoded,
                            isDefaultValue = paramDetails.isDefaultValue;
                        if (!(null == encoded || isDefaultValue && !1 !== squash) && (Object(_common_predicates__WEBPACK_IMPORTED_MODULE_2__.a)(encoded) || (encoded = [encoded]), 0 !== encoded.length)) return param.raw || (encoded = Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.u)(encoded, encodeURIComponent)), encoded.map((function(val) {
                            return param.id + "=" + val
                        }))
                    })).filter(_common_common__WEBPACK_IMPORTED_MODULE_0__.r).reduce(_common_common__WEBPACK_IMPORTED_MODULE_0__.K, []).join("&");
                return pathString + (queryString ? "?" + queryString : "") + (values["#"] ? "#" + values["#"] : "")
            }, UrlMatcher.nameValidator = /^\w+([-.]+\w+)*(?:\[\])?$/, UrlMatcher
        }()
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return observable
    }));
    var observable = function() {
        return "function" == typeof Symbol && Symbol.observable || "@@observable"
    }()
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return ObjectUnsubscribedError
    }));
    var ObjectUnsubscribedError = function() {
        function ObjectUnsubscribedErrorImpl() {
            return Error.call(this), this.message = "object unsubscribed", this.name = "ObjectUnsubscribedError", this
        }
        return ObjectUnsubscribedErrorImpl.prototype = Object.create(Error.prototype), ObjectUnsubscribedErrorImpl
    }()
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "b", (function() {
        return SubjectSubscriber
    })), __webpack_require__.d(__webpack_exports__, "a", (function() {
        return Subject
    }));
    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7),
        _Observable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(12),
        _Subscriber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(11),
        _Subscription__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(15),
        _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(31),
        _SubjectSubscription__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(92),
        _internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(48),
        SubjectSubscriber = function(_super) {
            function SubjectSubscriber(destination) {
                var _this = _super.call(this, destination) || this;
                return _this.destination = destination, _this
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(SubjectSubscriber, _super), SubjectSubscriber
        }(_Subscriber__WEBPACK_IMPORTED_MODULE_2__.a),
        Subject = function(_super) {
            function Subject() {
                var _this = _super.call(this) || this;
                return _this.observers = [], _this.closed = !1, _this.isStopped = !1, _this.hasError = !1, _this.thrownError = null, _this
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(Subject, _super), Subject.prototype[_internal_symbol_rxSubscriber__WEBPACK_IMPORTED_MODULE_6__.a] = function() {
                return new SubjectSubscriber(this)
            }, Subject.prototype.lift = function(operator) {
                var subject = new AnonymousSubject(this, this);
                return subject.operator = operator, subject
            }, Subject.prototype.next = function(value) {
                if (this.closed) throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__.a;
                if (!this.isStopped)
                    for (var observers = this.observers, len = observers.length, copy = observers.slice(), i = 0; i < len; i++) copy[i].next(value)
            }, Subject.prototype.error = function(err) {
                if (this.closed) throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__.a;
                this.hasError = !0, this.thrownError = err, this.isStopped = !0;
                for (var observers = this.observers, len = observers.length, copy = observers.slice(), i = 0; i < len; i++) copy[i].error(err);
                this.observers.length = 0
            }, Subject.prototype.complete = function() {
                if (this.closed) throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__.a;
                this.isStopped = !0;
                for (var observers = this.observers, len = observers.length, copy = observers.slice(), i = 0; i < len; i++) copy[i].complete();
                this.observers.length = 0
            }, Subject.prototype.unsubscribe = function() {
                this.isStopped = !0, this.closed = !0, this.observers = null
            }, Subject.prototype._trySubscribe = function(subscriber) {
                if (this.closed) throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__.a;
                return _super.prototype._trySubscribe.call(this, subscriber)
            }, Subject.prototype._subscribe = function(subscriber) {
                if (this.closed) throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_4__.a;
                return this.hasError ? (subscriber.error(this.thrownError), _Subscription__WEBPACK_IMPORTED_MODULE_3__.a.EMPTY) : this.isStopped ? (subscriber.complete(), _Subscription__WEBPACK_IMPORTED_MODULE_3__.a.EMPTY) : (this.observers.push(subscriber), new _SubjectSubscription__WEBPACK_IMPORTED_MODULE_5__.a(this, subscriber))
            }, Subject.prototype.asObservable = function() {
                var observable = new _Observable__WEBPACK_IMPORTED_MODULE_1__.a;
                return observable.source = this, observable
            }, Subject.create = function(destination, source) {
                return new AnonymousSubject(destination, source)
            }, Subject
        }(_Observable__WEBPACK_IMPORTED_MODULE_1__.a),
        AnonymousSubject = function(_super) {
            function AnonymousSubject(destination, source) {
                var _this = _super.call(this) || this;
                return _this.destination = destination, _this.source = source, _this
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(AnonymousSubject, _super), AnonymousSubject.prototype.next = function(value) {
                var destination = this.destination;
                destination && destination.next && destination.next(value)
            }, AnonymousSubject.prototype.error = function(err) {
                var destination = this.destination;
                destination && destination.error && this.destination.error(err)
            }, AnonymousSubject.prototype.complete = function() {
                var destination = this.destination;
                destination && destination.complete && this.destination.complete()
            }, AnonymousSubject.prototype._subscribe = function(subscriber) {
                return this.source ? this.source.subscribe(subscriber) : _Subscription__WEBPACK_IMPORTED_MODULE_3__.a.EMPTY
            }, AnonymousSubject
        }(Subject)
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__(57);
    var _resolvable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(18);
    __webpack_require__.d(__webpack_exports__, "b", (function() {
        return _resolvable__WEBPACK_IMPORTED_MODULE_1__.a
    }));
    var _resolveContext__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(26);
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return _resolveContext__WEBPACK_IMPORTED_MODULE_2__.a
    })), __webpack_require__.d(__webpack_exports__, "c", (function() {
        return _resolveContext__WEBPACK_IMPORTED_MODULE_2__.b
    }))
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    function hostReportError(err) {
        setTimeout((function() {
            throw err
        }), 0)
    }
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return hostReportError
    }))
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return BaseLocationServices
    }));
    var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6),
        _utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(28),
        BaseLocationServices = function() {
            function BaseLocationServices(router, fireAfterUpdate) {
                var _this = this;
                this.fireAfterUpdate = fireAfterUpdate, this._listeners = [], this._listener = function(evt) {
                    return _this._listeners.forEach((function(cb) {
                        return cb(evt)
                    }))
                }, this.hash = function() {
                    return Object(_utils__WEBPACK_IMPORTED_MODULE_1__.d)(_this._get()).hash
                }, this.path = function() {
                    return Object(_utils__WEBPACK_IMPORTED_MODULE_1__.d)(_this._get()).path
                }, this.search = function() {
                    return Object(_utils__WEBPACK_IMPORTED_MODULE_1__.b)(Object(_utils__WEBPACK_IMPORTED_MODULE_1__.d)(_this._get()).search)
                }, this._location = _common__WEBPACK_IMPORTED_MODULE_0__.G.location, this._history = _common__WEBPACK_IMPORTED_MODULE_0__.G.history
            }
            return BaseLocationServices.prototype.url = function(url, replace) {
                return void 0 === replace && (replace = !0), Object(_common__WEBPACK_IMPORTED_MODULE_0__.p)(url) && url !== this._get() && (this._set(null, null, url, replace), this.fireAfterUpdate && this._listeners.forEach((function(cb) {
                    return cb({
                        url: url
                    })
                }))), Object(_utils__WEBPACK_IMPORTED_MODULE_1__.a)(this)
            }, BaseLocationServices.prototype.onChange = function(cb) {
                var _this = this;
                return this._listeners.push(cb),
                    function() {
                        return Object(_common__WEBPACK_IMPORTED_MODULE_0__.F)(_this._listeners, cb)
                    }
            }, BaseLocationServices.prototype.dispose = function(router) {
                Object(_common__WEBPACK_IMPORTED_MODULE_0__.g)(this._listeners)
            }, BaseLocationServices
        }()
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var _interface__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(244);
    __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "BaseLocationServices") && __webpack_require__.d(__webpack_exports__, "BaseLocationServices", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.BaseLocationServices
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "BaseUrlRule") && __webpack_require__.d(__webpack_exports__, "BaseUrlRule", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.BaseUrlRule
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "BrowserLocationConfig") && __webpack_require__.d(__webpack_exports__, "BrowserLocationConfig", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.BrowserLocationConfig
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "Param") && __webpack_require__.d(__webpack_exports__, "Param", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.Param
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "StateRegistry") && __webpack_require__.d(__webpack_exports__, "StateRegistry", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.StateRegistry
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "StateService") && __webpack_require__.d(__webpack_exports__, "StateService", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.StateService
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "TargetState") && __webpack_require__.d(__webpack_exports__, "TargetState", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.TargetState
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "TransitionService") && __webpack_require__.d(__webpack_exports__, "TransitionService", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.TransitionService
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "UIRouter") && __webpack_require__.d(__webpack_exports__, "UIRouter", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.UIRouter
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "UIRouterGlobals") && __webpack_require__.d(__webpack_exports__, "UIRouterGlobals", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.UIRouterGlobals
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "UrlMatcherFactory") && __webpack_require__.d(__webpack_exports__, "UrlMatcherFactory", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.UrlMatcherFactory
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "UrlRouter") && __webpack_require__.d(__webpack_exports__, "UrlRouter", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.UrlRouter
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "UrlService") && __webpack_require__.d(__webpack_exports__, "UrlService", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.UrlService
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "ViewService") && __webpack_require__.d(__webpack_exports__, "ViewService", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.ViewService
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "parseUrl") && __webpack_require__.d(__webpack_exports__, "parseUrl", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.parseUrl
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "servicesPlugin") && __webpack_require__.d(__webpack_exports__, "servicesPlugin", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.servicesPlugin
    }));
    __webpack_require__(67), __webpack_require__(37), __webpack_require__(68), __webpack_require__(69);
    var _stateRegistry__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(70);
    __webpack_require__.d(__webpack_exports__, "StateRegistry", (function() {
        return _stateRegistry__WEBPACK_IMPORTED_MODULE_5__.a
    }));
    var _stateService__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(71);
    __webpack_require__.d(__webpack_exports__, "StateService", (function() {
        return _stateService__WEBPACK_IMPORTED_MODULE_6__.a
    }));
    var _targetState__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(25);
    __webpack_require__.d(__webpack_exports__, "TargetState", (function() {
        return _targetState__WEBPACK_IMPORTED_MODULE_7__.a
    }))
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return StateObject
    }));
    var _common_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2),
        _common_hof__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5),
        _common_glob__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(49),
        _common_predicates__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(4),
        StateObject = function() {
            function StateObject(config) {
                return StateObject.create(config || {})
            }
            return StateObject.create = function(stateDecl) {
                stateDecl = StateObject.isStateClass(stateDecl) ? new stateDecl : stateDecl;
                var state = Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.t)(Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.t)(stateDecl, StateObject.prototype));
                return stateDecl.$$state = function() {
                    return state
                }, state.self = stateDecl, state.__stateObjectCache = {
                    nameGlob: _common_glob__WEBPACK_IMPORTED_MODULE_2__.a.fromString(state.name)
                }, state
            }, StateObject.prototype.is = function(ref) {
                return this === ref || this.self === ref || this.fqn() === ref
            }, StateObject.prototype.fqn = function() {
                if (!(this.parent && this.parent instanceof this.constructor)) return this.name;
                var name = this.parent.fqn();
                return name ? name + "." + this.name : this.name
            }, StateObject.prototype.root = function() {
                return this.parent && this.parent.root() || this
            }, StateObject.prototype.parameters = function(opts) {
                return ((opts = Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.i)(opts, {
                    inherit: !0,
                    matchingKeys: null
                })).inherit && this.parent && this.parent.parameters() || []).concat(Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.L)(this.params)).filter((function(param) {
                    return !opts.matchingKeys || opts.matchingKeys.hasOwnProperty(param.id)
                }))
            }, StateObject.prototype.parameter = function(id, opts) {
                return void 0 === opts && (opts = {}), this.url && this.url.parameter(id, opts) || Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.n)(Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.L)(this.params), Object(_common_hof__WEBPACK_IMPORTED_MODULE_1__.l)("id", id)) || opts.inherit && this.parent && this.parent.parameter(id)
            }, StateObject.prototype.toString = function() {
                return this.fqn()
            }, StateObject.isStateClass = function(stateDecl) {
                return Object(_common_predicates__WEBPACK_IMPORTED_MODULE_3__.d)(stateDecl) && !0 === stateDecl.__uiRouterState
            }, StateObject.isStateDeclaration = function(obj) {
                return Object(_common_predicates__WEBPACK_IMPORTED_MODULE_3__.d)(obj.$$state)
            }, StateObject.isState = function(obj) {
                return Object(_common_predicates__WEBPACK_IMPORTED_MODULE_3__.i)(obj.__stateObjectCache)
            }, StateObject
        }()
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "b", (function() {
        return matchState
    })), __webpack_require__.d(__webpack_exports__, "a", (function() {
        return makeEvent
    }));
    var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6),
        _interface__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(17);

    function matchState(state, criterion, transition) {
        var toMatch = Object(_common__WEBPACK_IMPORTED_MODULE_0__.v)(criterion) ? [criterion] : criterion;
        return !!(Object(_common__WEBPACK_IMPORTED_MODULE_0__.q)(toMatch) ? toMatch : function(_state) {
            for (var globStrings = toMatch, i = 0; i < globStrings.length; i++) {
                var glob = new _common__WEBPACK_IMPORTED_MODULE_0__.a(globStrings[i]);
                if (glob && glob.matches(_state.name) || !glob && globStrings[i] === _state.name) return !0
            }
            return !1
        })(state, transition)
    }
    var RegisteredHook = function() {
        function RegisteredHook(tranSvc, eventType, callback, matchCriteria, removeHookFromRegistry, options) {
            void 0 === options && (options = {}), this.tranSvc = tranSvc, this.eventType = eventType, this.callback = callback, this.matchCriteria = matchCriteria, this.removeHookFromRegistry = removeHookFromRegistry, this.invokeCount = 0, this._deregistered = !1, this.priority = options.priority || 0, this.bind = options.bind || null, this.invokeLimit = options.invokeLimit
        }
        return RegisteredHook.prototype._matchingNodes = function(nodes, criterion, transition) {
            if (!0 === criterion) return nodes;
            var matching = nodes.filter((function(node) {
                return matchState(node.state, criterion, transition)
            }));
            return matching.length ? matching : null
        }, RegisteredHook.prototype._getDefaultMatchCriteria = function() {
            return Object(_common__WEBPACK_IMPORTED_MODULE_0__.z)(this.tranSvc._pluginapi._getPathTypes(), (function() {
                return !0
            }))
        }, RegisteredHook.prototype._getMatchingNodes = function(treeChanges, transition) {
            var _this = this,
                criteria = Object(_common__WEBPACK_IMPORTED_MODULE_0__.h)(this._getDefaultMatchCriteria(), this.matchCriteria);
            return Object(_common__WEBPACK_IMPORTED_MODULE_0__.S)(this.tranSvc._pluginapi._getPathTypes()).reduce((function(mn, pathtype) {
                var isStateHook = pathtype.scope === _interface__WEBPACK_IMPORTED_MODULE_1__.b.STATE,
                    path = treeChanges[pathtype.name] || [],
                    nodes = isStateHook ? path : [Object(_common__WEBPACK_IMPORTED_MODULE_0__.M)(path)];
                return mn[pathtype.name] = _this._matchingNodes(nodes, criteria[pathtype.name], transition), mn
            }), {})
        }, RegisteredHook.prototype.matches = function(treeChanges, transition) {
            var matches = this._getMatchingNodes(treeChanges, transition);
            return Object(_common__WEBPACK_IMPORTED_MODULE_0__.S)(matches).every(_common__WEBPACK_IMPORTED_MODULE_0__.l) ? matches : null
        }, RegisteredHook.prototype.deregister = function() {
            this.removeHookFromRegistry(this), this._deregistered = !0
        }, RegisteredHook
    }();

    function makeEvent(registry, transitionService, eventType) {
        var hooks = (registry._registeredHooks = registry._registeredHooks || {})[eventType.name] = [],
            removeHookFn = Object(_common__WEBPACK_IMPORTED_MODULE_0__.F)(hooks);

        function hookRegistrationFn(matchObject, callback, options) {
            void 0 === options && (options = {});
            var registeredHook = new RegisteredHook(transitionService, eventType, callback, matchObject, removeHookFn, options);
            return hooks.push(registeredHook), registeredHook.deregister.bind(registeredHook)
        }
        return registry[eventType.name] = hookRegistrationFn, hookRegistrationFn
    }
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    function getSymbolIterator() {
        return "function" == typeof Symbol && Symbol.iterator ? Symbol.iterator : "@@iterator"
    }
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return iterator
    }));
    var iterator = getSymbolIterator()
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return SimpleInnerSubscriber
    })), __webpack_require__.d(__webpack_exports__, "b", (function() {
        return SimpleOuterSubscriber
    })), __webpack_require__.d(__webpack_exports__, "c", (function() {
        return innerSubscribe
    }));
    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7),
        _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(11),
        _Observable__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(12),
        _util_subscribeTo__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(55),
        SimpleInnerSubscriber = function(_super) {
            function SimpleInnerSubscriber(parent) {
                var _this = _super.call(this) || this;
                return _this.parent = parent, _this
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(SimpleInnerSubscriber, _super), SimpleInnerSubscriber.prototype._next = function(value) {
                this.parent.notifyNext(value)
            }, SimpleInnerSubscriber.prototype._error = function(error) {
                this.parent.notifyError(error), this.unsubscribe()
            }, SimpleInnerSubscriber.prototype._complete = function() {
                this.parent.notifyComplete(), this.unsubscribe()
            }, SimpleInnerSubscriber
        }(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.a),
        SimpleOuterSubscriber = (_Subscriber__WEBPACK_IMPORTED_MODULE_1__.a, function(_super) {
            function SimpleOuterSubscriber() {
                return null !== _super && _super.apply(this, arguments) || this
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(SimpleOuterSubscriber, _super), SimpleOuterSubscriber.prototype.notifyNext = function(innerValue) {
                this.destination.next(innerValue)
            }, SimpleOuterSubscriber.prototype.notifyError = function(err) {
                this.destination.error(err)
            }, SimpleOuterSubscriber.prototype.notifyComplete = function() {
                this.destination.complete()
            }, SimpleOuterSubscriber
        }(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.a));
    _Subscriber__WEBPACK_IMPORTED_MODULE_1__.a;

    function innerSubscribe(result, innerSubscriber) {
        if (!innerSubscriber.closed) return result instanceof _Observable__WEBPACK_IMPORTED_MODULE_2__.a ? result.subscribe(innerSubscriber) : Object(_util_subscribeTo__WEBPACK_IMPORTED_MODULE_3__.a)(result)(innerSubscriber)
    }
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return Queue
    }));
    var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2),
        Queue = function() {
            function Queue(_items, _limit) {
                void 0 === _items && (_items = []), void 0 === _limit && (_limit = null), this._items = _items, this._limit = _limit, this._evictListeners = [], this.onEvict = Object(_common__WEBPACK_IMPORTED_MODULE_0__.B)(this._evictListeners)
            }
            return Queue.prototype.enqueue = function(item) {
                var items = this._items;
                return items.push(item), this._limit && items.length > this._limit && this.evict(), item
            }, Queue.prototype.evict = function() {
                var item = this._items.shift();
                return this._evictListeners.forEach((function(fn) {
                    return fn(item)
                })), item
            }, Queue.prototype.dequeue = function() {
                if (this.size()) return this._items.splice(0, 1)[0]
            }, Queue.prototype.clear = function() {
                var current = this._items;
                return this._items = [], current
            }, Queue.prototype.size = function() {
                return this._items.length
            }, Queue.prototype.remove = function(item) {
                var idx = this._items.indexOf(item);
                return idx > -1 && this._items.splice(idx, 1)[0]
            }, Queue.prototype.peekTail = function() {
                return this._items[this._items.length - 1]
            }, Queue.prototype.peekHead = function() {
                if (this.size()) return this._items[0]
            }, Queue
        }()
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return ParamType
    }));
    var _common_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2),
        _common_predicates__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4),
        ParamType = function() {
            function ParamType(def) {
                this.pattern = /.*/, this.inherit = !0, Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.l)(this, def)
            }
            return ParamType.prototype.is = function(val, key) {
                return !0
            }, ParamType.prototype.encode = function(val, key) {
                return val
            }, ParamType.prototype.decode = function(val, key) {
                return val
            }, ParamType.prototype.equals = function(a, b) {
                return a == b
            }, ParamType.prototype.$subPattern = function() {
                var sub = this.pattern.toString();
                return sub.substr(1, sub.length - 2)
            }, ParamType.prototype.toString = function() {
                return "{ParamType:" + this.name + "}"
            }, ParamType.prototype.$normalize = function(val) {
                return this.is(val) ? val : this.decode(val)
            }, ParamType.prototype.$asArray = function(mode, isSearch) {
                if (!mode) return this;
                if ("auto" === mode && !isSearch) throw new Error("'auto' array mode is for query parameters only");
                return new ArrayType(this, mode)
            }, ParamType
        }();

    function ArrayType(type, mode) {
        var _this = this;

        function arrayWrap(val) {
            return Object(_common_predicates__WEBPACK_IMPORTED_MODULE_1__.a)(val) ? val : Object(_common_predicates__WEBPACK_IMPORTED_MODULE_1__.c)(val) ? [val] : []
        }

        function arrayHandler(callback, allTruthyMode) {
            return function(val) {
                if (Object(_common_predicates__WEBPACK_IMPORTED_MODULE_1__.a)(val) && 0 === val.length) return val;
                var arr = arrayWrap(val),
                    result = Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.u)(arr, callback);
                return !0 === allTruthyMode ? 0 === Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.m)(result, (function(x) {
                    return !x
                })).length : function(val) {
                    switch (val.length) {
                        case 0:
                            return;
                        case 1:
                            return "auto" === mode ? val[0] : val;
                        default:
                            return val
                    }
                }(result)
            }
        }

        function arrayEqualsHandler(callback) {
            return function(val1, val2) {
                var left = arrayWrap(val1),
                    right = arrayWrap(val2);
                if (left.length !== right.length) return !1;
                for (var i = 0; i < left.length; i++)
                    if (!callback(left[i], right[i])) return !1;
                return !0
            }
        }["encode", "decode", "equals", "$normalize"].forEach((function(name) {
            var paramTypeFn = type[name].bind(type),
                wrapperFn = "equals" === name ? arrayEqualsHandler : arrayHandler;
            _this[name] = wrapperFn(paramTypeFn)
        })), Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.l)(this, {
            dynamic: type.dynamic,
            name: type.name,
            pattern: type.pattern,
            inherit: type.inherit,
            raw: type.raw,
            is: arrayHandler(type.is.bind(type), !0),
            $arrayMode: mode
        })
    }
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return PathNode
    }));
    var _common_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2),
        _common_hof__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5),
        _params_param__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(19),
        PathNode = function() {
            function PathNode(stateOrNode) {
                if (stateOrNode instanceof PathNode) {
                    var node = stateOrNode;
                    this.state = node.state, this.paramSchema = node.paramSchema.slice(), this.paramValues = Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.l)({}, node.paramValues), this.resolvables = node.resolvables.slice(), this.views = node.views && node.views.slice()
                } else {
                    var state = stateOrNode;
                    this.state = state, this.paramSchema = state.parameters({
                        inherit: !1
                    }), this.paramValues = {}, this.resolvables = state.resolvables.map((function(res) {
                        return res.clone()
                    }))
                }
            }
            return PathNode.prototype.clone = function() {
                return new PathNode(this)
            }, PathNode.prototype.applyRawParams = function(params) {
                return this.paramValues = this.paramSchema.reduce((function(memo, pDef) {
                    return Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.d)(memo, [(paramDef = pDef).id, paramDef.value(params[paramDef.id])]);
                    var paramDef
                }), {}), this
            }, PathNode.prototype.parameter = function(name) {
                return Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.n)(this.paramSchema, Object(_common_hof__WEBPACK_IMPORTED_MODULE_1__.l)("id", name))
            }, PathNode.prototype.equals = function(node, paramsFn) {
                var diff = this.diff(node, paramsFn);
                return diff && 0 === diff.length
            }, PathNode.prototype.diff = function(node, paramsFn) {
                if (this.state !== node.state) return !1;
                var params = paramsFn ? paramsFn(this) : this.paramSchema;
                return _params_param__WEBPACK_IMPORTED_MODULE_2__.b.changed(params, this.paramValues, node.paramValues)
            }, PathNode.clone = function(node) {
                return node.clone()
            }, PathNode
        }()
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return Transition
    }));
    var _common_trace__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(14),
        _common_coreservices__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(9),
        _common_strings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10),
        _common_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2),
        _common_predicates__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(4),
        _common_hof__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(5),
        _interface__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(17),
        _transitionHook__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(20),
        _hookRegistry__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(38),
        _hookBuilder__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(72),
        _path_pathUtils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(21),
        _params_param__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(19),
        _resolve_resolvable__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(18),
        _resolve_resolveContext__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(26),
        _rejectFactory__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(13),
        _common__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(6),
        stateSelf = Object(_common_hof__WEBPACK_IMPORTED_MODULE_5__.k)("self"),
        Transition = function() {
            function Transition(fromPath, targetState, router) {
                var _this = this;
                if (this._deferred = _common_coreservices__WEBPACK_IMPORTED_MODULE_1__.b.$q.defer(), this.promise = this._deferred.promise, this._registeredHooks = {}, this._hookBuilder = new _hookBuilder__WEBPACK_IMPORTED_MODULE_9__.a(this), this.isActive = function() {
                        return _this.router.globals.transition === _this
                    }, this.router = router, this._targetState = targetState, !targetState.valid()) throw new Error(targetState.error());
                this._options = Object(_common_common__WEBPACK_IMPORTED_MODULE_3__.l)({
                    current: Object(_common_hof__WEBPACK_IMPORTED_MODULE_5__.m)(this)
                }, targetState.options()), this.$id = router.transitionService._transitionCount++;
                var toPath = _path_pathUtils__WEBPACK_IMPORTED_MODULE_10__.a.buildToPath(fromPath, targetState);
                this._treeChanges = _path_pathUtils__WEBPACK_IMPORTED_MODULE_10__.a.treeChanges(fromPath, toPath, this._options.reloadState), this.createTransitionHookRegFns();
                var onCreateHooks = this._hookBuilder.buildHooksForPhase(_interface__WEBPACK_IMPORTED_MODULE_6__.a.CREATE);
                _transitionHook__WEBPACK_IMPORTED_MODULE_7__.a.invokeHooks(onCreateHooks, (function() {
                    return null
                })), this.applyViewConfigs(router)
            }
            return Transition.prototype.onBefore = function(criteria, callback, options) {}, Transition.prototype.onStart = function(criteria, callback, options) {}, Transition.prototype.onExit = function(criteria, callback, options) {}, Transition.prototype.onRetain = function(criteria, callback, options) {}, Transition.prototype.onEnter = function(criteria, callback, options) {}, Transition.prototype.onFinish = function(criteria, callback, options) {}, Transition.prototype.onSuccess = function(criteria, callback, options) {}, Transition.prototype.onError = function(criteria, callback, options) {}, Transition.prototype.createTransitionHookRegFns = function() {
                var _this = this;
                this.router.transitionService._pluginapi._getEvents().filter((function(type) {
                    return type.hookPhase !== _interface__WEBPACK_IMPORTED_MODULE_6__.a.CREATE
                })).forEach((function(type) {
                    return Object(_hookRegistry__WEBPACK_IMPORTED_MODULE_8__.a)(_this, _this.router.transitionService, type)
                }))
            }, Transition.prototype.getHooks = function(hookName) {
                return this._registeredHooks[hookName]
            }, Transition.prototype.applyViewConfigs = function(router) {
                var enteringStates = this._treeChanges.entering.map((function(node) {
                    return node.state
                }));
                _path_pathUtils__WEBPACK_IMPORTED_MODULE_10__.a.applyViewConfigs(router.transitionService.$view, this._treeChanges.to, enteringStates)
            }, Transition.prototype.$from = function() {
                return Object(_common_common__WEBPACK_IMPORTED_MODULE_3__.G)(this._treeChanges.from).state
            }, Transition.prototype.$to = function() {
                return Object(_common_common__WEBPACK_IMPORTED_MODULE_3__.G)(this._treeChanges.to).state
            }, Transition.prototype.from = function() {
                return this.$from().self
            }, Transition.prototype.to = function() {
                return this.$to().self
            }, Transition.prototype.targetState = function() {
                return this._targetState
            }, Transition.prototype.is = function(compare) {
                return compare instanceof Transition ? this.is({
                    to: compare.$to().name,
                    from: compare.$from().name
                }) : !(compare.to && !Object(_hookRegistry__WEBPACK_IMPORTED_MODULE_8__.b)(this.$to(), compare.to, this) || compare.from && !Object(_hookRegistry__WEBPACK_IMPORTED_MODULE_8__.b)(this.$from(), compare.from, this))
            }, Transition.prototype.params = function(pathname) {
                return void 0 === pathname && (pathname = "to"), Object.freeze(this._treeChanges[pathname].map(Object(_common_hof__WEBPACK_IMPORTED_MODULE_5__.k)("paramValues")).reduce(_common_common__WEBPACK_IMPORTED_MODULE_3__.w, {}))
            }, Transition.prototype.paramsChanged = function() {
                var fromParams = this.params("from"),
                    toParams = this.params("to"),
                    allParamDescriptors = [].concat(this._treeChanges.to).concat(this._treeChanges.from).map((function(pathNode) {
                        return pathNode.paramSchema
                    })).reduce(_common__WEBPACK_IMPORTED_MODULE_15__.j, []).reduce(_common__WEBPACK_IMPORTED_MODULE_15__.P, []);
                return _params_param__WEBPACK_IMPORTED_MODULE_11__.b.changed(allParamDescriptors, fromParams, toParams).reduce((function(changedValues, descriptor) {
                    return changedValues[descriptor.id] = toParams[descriptor.id], changedValues
                }), {})
            }, Transition.prototype.injector = function(state, pathName) {
                void 0 === pathName && (pathName = "to");
                var path = this._treeChanges[pathName];
                return state && (path = _path_pathUtils__WEBPACK_IMPORTED_MODULE_10__.a.subPath(path, (function(node) {
                    return node.state === state || node.state.name === state
                }))), new _resolve_resolveContext__WEBPACK_IMPORTED_MODULE_13__.b(path).injector()
            }, Transition.prototype.getResolveTokens = function(pathname) {
                return void 0 === pathname && (pathname = "to"), new _resolve_resolveContext__WEBPACK_IMPORTED_MODULE_13__.b(this._treeChanges[pathname]).getTokens()
            }, Transition.prototype.addResolvable = function(resolvable, state) {
                void 0 === state && (state = ""), resolvable = Object(_common_hof__WEBPACK_IMPORTED_MODULE_5__.e)(_resolve_resolvable__WEBPACK_IMPORTED_MODULE_12__.a)(resolvable) ? resolvable : new _resolve_resolvable__WEBPACK_IMPORTED_MODULE_12__.a(resolvable);
                var stateName = "string" == typeof state ? state : state.name,
                    topath = this._treeChanges.to,
                    targetNode = Object(_common_common__WEBPACK_IMPORTED_MODULE_3__.n)(topath, (function(node) {
                        return node.state.name === stateName
                    }));
                new _resolve_resolveContext__WEBPACK_IMPORTED_MODULE_13__.b(topath).addResolvables([resolvable], targetNode.state)
            }, Transition.prototype.redirectedFrom = function() {
                return this._options.redirectedFrom || null
            }, Transition.prototype.originalTransition = function() {
                var rf = this.redirectedFrom();
                return rf && rf.originalTransition() || this
            }, Transition.prototype.options = function() {
                return this._options
            }, Transition.prototype.entering = function() {
                return Object(_common_common__WEBPACK_IMPORTED_MODULE_3__.u)(this._treeChanges.entering, Object(_common_hof__WEBPACK_IMPORTED_MODULE_5__.k)("state")).map(stateSelf)
            }, Transition.prototype.exiting = function() {
                return Object(_common_common__WEBPACK_IMPORTED_MODULE_3__.u)(this._treeChanges.exiting, Object(_common_hof__WEBPACK_IMPORTED_MODULE_5__.k)("state")).map(stateSelf).reverse()
            }, Transition.prototype.retained = function() {
                return Object(_common_common__WEBPACK_IMPORTED_MODULE_3__.u)(this._treeChanges.retained, Object(_common_hof__WEBPACK_IMPORTED_MODULE_5__.k)("state")).map(stateSelf)
            }, Transition.prototype.views = function(pathname, state) {
                void 0 === pathname && (pathname = "entering");
                var path = this._treeChanges[pathname];
                return (path = state ? path.filter(Object(_common_hof__WEBPACK_IMPORTED_MODULE_5__.l)("state", state)) : path).map(Object(_common_hof__WEBPACK_IMPORTED_MODULE_5__.k)("views")).filter(_common_common__WEBPACK_IMPORTED_MODULE_3__.r).reduce(_common_common__WEBPACK_IMPORTED_MODULE_3__.K, [])
            }, Transition.prototype.treeChanges = function(pathname) {
                return pathname ? this._treeChanges[pathname] : this._treeChanges
            }, Transition.prototype.redirect = function(targetState) {
                for (var redirects = 1, trans = this; null != (trans = trans.redirectedFrom());)
                    if (++redirects > 20) throw new Error("Too many consecutive Transition redirects (20+)");
                var redirectOpts = {
                    redirectedFrom: this,
                    source: "redirect"
                };
                "url" === this.options().source && !1 !== targetState.options().location && (redirectOpts.location = "replace");
                var newOptions = Object(_common_common__WEBPACK_IMPORTED_MODULE_3__.l)({}, this.options(), targetState.options(), redirectOpts);
                targetState = targetState.withOptions(newOptions, !0);
                var reloadState, newTransition = this.router.transitionService.create(this._treeChanges.from, targetState),
                    originalEnteringNodes = this._treeChanges.entering,
                    redirectEnteringNodes = newTransition._treeChanges.entering;
                return _path_pathUtils__WEBPACK_IMPORTED_MODULE_10__.a.matching(redirectEnteringNodes, originalEnteringNodes, _path_pathUtils__WEBPACK_IMPORTED_MODULE_10__.a.nonDynamicParams).filter(Object(_common_hof__WEBPACK_IMPORTED_MODULE_5__.f)((reloadState = targetState.options().reloadState, function(node) {
                    return reloadState && node.state.includes[reloadState.name]
                }))).forEach((function(node, idx) {
                    node.resolvables = originalEnteringNodes[idx].resolvables
                })), newTransition
            }, Transition.prototype._changedParams = function() {
                var tc = this._treeChanges;
                if (!this._options.reload && (!tc.exiting.length && !tc.entering.length && tc.to.length === tc.from.length && !Object(_common_common__WEBPACK_IMPORTED_MODULE_3__.e)(tc.to, tc.from).map((function(tuple) {
                        return tuple[0].state !== tuple[1].state
                    })).reduce(_common_common__WEBPACK_IMPORTED_MODULE_3__.c, !1))) {
                    var nodeSchemas = tc.to.map((function(node) {
                            return node.paramSchema
                        })),
                        _a = [tc.to, tc.from].map((function(path) {
                            return path.map((function(x) {
                                return x.paramValues
                            }))
                        })),
                        toValues = _a[0],
                        fromValues = _a[1];
                    return Object(_common_common__WEBPACK_IMPORTED_MODULE_3__.e)(nodeSchemas, toValues, fromValues).map((function(_a) {
                        var schema = _a[0],
                            toVals = _a[1],
                            fromVals = _a[2];
                        return _params_param__WEBPACK_IMPORTED_MODULE_11__.b.changed(schema, toVals, fromVals)
                    })).reduce(_common_common__WEBPACK_IMPORTED_MODULE_3__.K, [])
                }
            }, Transition.prototype.dynamic = function() {
                var changes = this._changedParams();
                return !!changes && changes.map((function(x) {
                    return x.dynamic
                })).reduce(_common_common__WEBPACK_IMPORTED_MODULE_3__.c, !1)
            }, Transition.prototype.ignored = function() {
                return !!this._ignoredReason()
            }, Transition.prototype._ignoredReason = function() {
                var pending = this.router.globals.transition,
                    reloadState = this._options.reloadState,
                    same = function(pathA, pathB) {
                        if (pathA.length !== pathB.length) return !1;
                        var matching = _path_pathUtils__WEBPACK_IMPORTED_MODULE_10__.a.matching(pathA, pathB);
                        return pathA.length === matching.filter((function(node) {
                            return !reloadState || !node.state.includes[reloadState.name]
                        })).length
                    },
                    newTC = this.treeChanges(),
                    pendTC = pending && pending.treeChanges();
                return pendTC && same(pendTC.to, newTC.to) && same(pendTC.exiting, newTC.exiting) ? "SameAsPending" : 0 === newTC.exiting.length && 0 === newTC.entering.length && same(newTC.from, newTC.to) ? "SameAsCurrent" : void 0
            }, Transition.prototype.run = function() {
                var _this = this,
                    runAllHooks = _transitionHook__WEBPACK_IMPORTED_MODULE_7__.a.runAllHooks,
                    getHooksFor = function(phase) {
                        return _this._hookBuilder.buildHooksForPhase(phase)
                    },
                    allBeforeHooks = getHooksFor(_interface__WEBPACK_IMPORTED_MODULE_6__.a.BEFORE);
                return _transitionHook__WEBPACK_IMPORTED_MODULE_7__.a.invokeHooks(allBeforeHooks, (function() {
                    var globals = _this.router.globals;
                    return globals.lastStartedTransitionId = _this.$id, globals.transition = _this, globals.transitionHistory.enqueue(_this), _common_trace__WEBPACK_IMPORTED_MODULE_0__.a.traceTransitionStart(_this), _common_coreservices__WEBPACK_IMPORTED_MODULE_1__.b.$q.when(void 0)
                })).then((function() {
                    var allRunHooks = getHooksFor(_interface__WEBPACK_IMPORTED_MODULE_6__.a.RUN);
                    return _transitionHook__WEBPACK_IMPORTED_MODULE_7__.a.invokeHooks(allRunHooks, (function() {
                        return _common_coreservices__WEBPACK_IMPORTED_MODULE_1__.b.$q.when(void 0)
                    }))
                })).then((function() {
                    _common_trace__WEBPACK_IMPORTED_MODULE_0__.a.traceSuccess(_this.$to(), _this), _this.success = !0, _this._deferred.resolve(_this.to()), runAllHooks(getHooksFor(_interface__WEBPACK_IMPORTED_MODULE_6__.a.SUCCESS))
                }), (function(reason) {
                    _common_trace__WEBPACK_IMPORTED_MODULE_0__.a.traceError(reason, _this), _this.success = !1, _this._deferred.reject(reason), _this._error = reason, runAllHooks(getHooksFor(_interface__WEBPACK_IMPORTED_MODULE_6__.a.ERROR))
                })), this.promise
            }, Transition.prototype.valid = function() {
                return !this.error() || void 0 !== this.success
            }, Transition.prototype.abort = function() {
                Object(_common_predicates__WEBPACK_IMPORTED_MODULE_4__.m)(this.success) && (this._aborted = !0)
            }, Transition.prototype.error = function() {
                var state = this.$to();
                if (state.self.abstract) return _rejectFactory__WEBPACK_IMPORTED_MODULE_14__.b.invalid("Cannot transition to abstract state '" + state.name + "'");
                var paramDefs = state.parameters(),
                    values = this.params(),
                    invalidParams = paramDefs.filter((function(param) {
                        return !param.validates(values[param.id])
                    }));
                if (invalidParams.length) {
                    var invalidValues = invalidParams.map((function(param) {
                            return "[" + param.id + ":" + Object(_common_strings__WEBPACK_IMPORTED_MODULE_2__.k)(values[param.id]) + "]"
                        })).join(", "),
                        detail = "The following parameter values are not valid for state '" + state.name + "': " + invalidValues;
                    return _rejectFactory__WEBPACK_IMPORTED_MODULE_14__.b.invalid(detail)
                }
                return !1 === this.success ? this._error : void 0
            }, Transition.prototype.toString = function() {
                var fromStateOrName = this.from(),
                    toStateOrName = this.to(),
                    avoidEmptyHash = function(params) {
                        return null !== params["#"] && void 0 !== params["#"] ? params : Object(_common_common__WEBPACK_IMPORTED_MODULE_3__.y)(params, ["#"])
                    };
                return "Transition#" + this.$id + "( '" + (Object(_common_predicates__WEBPACK_IMPORTED_MODULE_4__.i)(fromStateOrName) ? fromStateOrName.name : fromStateOrName) + "'" + Object(_common_strings__WEBPACK_IMPORTED_MODULE_2__.k)(avoidEmptyHash(this._treeChanges.from.map(Object(_common_hof__WEBPACK_IMPORTED_MODULE_5__.k)("paramValues")).reduce(_common_common__WEBPACK_IMPORTED_MODULE_3__.w, {}))) + " -> " + (this.valid() ? "" : "(X) ") + "'" + (Object(_common_predicates__WEBPACK_IMPORTED_MODULE_4__.i)(toStateOrName) ? toStateOrName.name : toStateOrName) + "'" + Object(_common_strings__WEBPACK_IMPORTED_MODULE_2__.k)(avoidEmptyHash(this.params())) + " )"
            }, Transition.diToken = Transition, Transition
        }()
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "b", (function() {
        return UrlRuleFactory
    })), __webpack_require__.d(__webpack_exports__, "a", (function() {
        return BaseUrlRule
    }));
    var _urlMatcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(29),
        _common_predicates__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4),
        _common_common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(2),
        _common_hof__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5),
        _state_stateObject__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(37),
        UrlRuleFactory = function() {
            function UrlRuleFactory(router) {
                this.router = router
            }
            return UrlRuleFactory.prototype.compile = function(str) {
                return this.router.urlMatcherFactory.compile(str)
            }, UrlRuleFactory.prototype.create = function(what, handler) {
                var _this = this,
                    isState = _state_stateObject__WEBPACK_IMPORTED_MODULE_4__.a.isState,
                    isStateDeclaration = _state_stateObject__WEBPACK_IMPORTED_MODULE_4__.a.isStateDeclaration,
                    makeRule = Object(_common_hof__WEBPACK_IMPORTED_MODULE_3__.i)([
                        [_common_predicates__WEBPACK_IMPORTED_MODULE_1__.l, function(_what) {
                            return makeRule(_this.compile(_what))
                        }],
                        [Object(_common_hof__WEBPACK_IMPORTED_MODULE_3__.e)(_urlMatcher__WEBPACK_IMPORTED_MODULE_0__.a), function(_what) {
                            return _this.fromUrlMatcher(_what, handler)
                        }],
                        [Object(_common_hof__WEBPACK_IMPORTED_MODULE_3__.g)(isState, isStateDeclaration), function(_what) {
                            return _this.fromState(_what, _this.router)
                        }],
                        [Object(_common_hof__WEBPACK_IMPORTED_MODULE_3__.e)(RegExp), function(_what) {
                            return _this.fromRegExp(_what, handler)
                        }],
                        [_common_predicates__WEBPACK_IMPORTED_MODULE_1__.d, function(_what) {
                            return new BaseUrlRule(_what, handler)
                        }]
                    ]),
                    rule = makeRule(what);
                if (!rule) throw new Error("invalid 'what' in when()");
                return rule
            }, UrlRuleFactory.prototype.fromUrlMatcher = function(urlMatcher, handler) {
                var _handler = handler;
                Object(_common_predicates__WEBPACK_IMPORTED_MODULE_1__.l)(handler) && (handler = this.router.urlMatcherFactory.compile(handler)), Object(_common_hof__WEBPACK_IMPORTED_MODULE_3__.e)(_urlMatcher__WEBPACK_IMPORTED_MODULE_0__.a)(handler) && (_handler = function(match) {
                    return handler.format(match)
                });
                var details = {
                    urlMatcher: urlMatcher,
                    matchPriority: function(params) {
                        var optional = urlMatcher.parameters().filter((function(param) {
                            return param.isOptional
                        }));
                        return optional.length ? optional.filter((function(param) {
                            return params[param.id]
                        })).length / optional.length : 1e-6
                    },
                    type: "URLMATCHER"
                };
                return Object(_common_common__WEBPACK_IMPORTED_MODULE_2__.l)(new BaseUrlRule((function(url) {
                    var params = urlMatcher.exec(url.path, url.search, url.hash);
                    return urlMatcher.validates(params) && params
                }), _handler), details)
            }, UrlRuleFactory.prototype.fromState = function(stateOrDecl, router) {
                var state = _state_stateObject__WEBPACK_IMPORTED_MODULE_4__.a.isStateDeclaration(stateOrDecl) ? stateOrDecl.$$state() : stateOrDecl,
                    details = {
                        state: state,
                        type: "STATE"
                    };
                return Object(_common_common__WEBPACK_IMPORTED_MODULE_2__.l)(this.fromUrlMatcher(state.url, (function(match) {
                    var $state = router.stateService,
                        globals = router.globals;
                    $state.href(state, match) !== $state.href(globals.current, globals.params) && $state.transitionTo(state, match, {
                        inherit: !0,
                        source: "url"
                    })
                })), details)
            }, UrlRuleFactory.prototype.fromRegExp = function(regexp, handler) {
                if (regexp.global || regexp.sticky) throw new Error("Rule RegExp must not be global or sticky");
                var _handler = Object(_common_predicates__WEBPACK_IMPORTED_MODULE_1__.l)(handler) ? function(match) {
                        return handler.replace(/\$(\$|\d{1,2})/, (function(m, what) {
                            return match["$" === what ? 0 : Number(what)]
                        }))
                    } : handler,
                    details = {
                        regexp: regexp,
                        type: "REGEXP"
                    };
                return Object(_common_common__WEBPACK_IMPORTED_MODULE_2__.l)(new BaseUrlRule((function(url) {
                    return regexp.exec(url.path)
                }), _handler), details)
            }, UrlRuleFactory.isUrlRule = function(obj) {
                return obj && ["type", "match", "handler"].every((function(key) {
                    return Object(_common_predicates__WEBPACK_IMPORTED_MODULE_1__.c)(obj[key])
                }))
            }, UrlRuleFactory
        }(),
        BaseUrlRule = function(match, handler) {
            var _this = this;
            this.match = match, this.type = "RAW", this.matchPriority = function(match) {
                return 0 - _this.$id
            }, this.handler = handler || _common_common__WEBPACK_IMPORTED_MODULE_2__.r
        }
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "b", (function() {
        return getNg1ViewConfigFactory
    })), __webpack_require__.d(__webpack_exports__, "c", (function() {
        return ng1ViewsBuilder
    })), __webpack_require__.d(__webpack_exports__, "a", (function() {
        return Ng1ViewConfig
    }));
    var _uirouter_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);

    function getNg1ViewConfigFactory() {
        var templateFactory = null;
        return function(path, view) {
            return templateFactory = templateFactory || _uirouter_core__WEBPACK_IMPORTED_MODULE_0__.services.$injector.get("$templateFactory"), [new Ng1ViewConfig(path, view, templateFactory)]
        }
    }
    var hasAnyKey = function(keys, obj) {
        return keys.reduce((function(acc, key) {
            return acc || Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.isDefined)(obj[key])
        }), !1)
    };

    function ng1ViewsBuilder(state) {
        if (!state.parent) return {};
        var compKeys = ["component", "bindings", "componentProvider"],
            nonCompKeys = ["templateProvider", "templateUrl", "template", "notify", "async"].concat(["controller", "controllerProvider", "controllerAs", "resolveAs"]),
            allViewKeys = compKeys.concat(nonCompKeys);
        if (Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.isDefined)(state.views) && hasAnyKey(allViewKeys, state)) throw new Error("State '" + state.name + "' has a 'views' object. It cannot also have \"view properties\" at the state level.  Move the following properties into a view (in the 'views' object):  " + allViewKeys.filter((function(key) {
            return Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.isDefined)(state[key])
        })).join(", "));
        var views = {},
            viewsObject = state.views || {
                $default: Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.pick)(state, allViewKeys)
            };
        return Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.forEach)(viewsObject, (function(config, name) {
            if (name = name || "$default", Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.isString)(config) && (config = {
                    component: config
                }), config = Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.extend)({}, config), hasAnyKey(compKeys, config) && hasAnyKey(nonCompKeys, config)) throw new Error("Cannot combine: " + compKeys.join("|") + " with: " + nonCompKeys.join("|") + " in stateview: '" + name + "@" + state.name + "'");
            config.resolveAs = config.resolveAs || "$resolve", config.$type = "ng1", config.$context = state, config.$name = name;
            var normalized = _uirouter_core__WEBPACK_IMPORTED_MODULE_0__.ViewService.normalizeUIViewTarget(config.$context, config.$name);
            config.$uiViewName = normalized.uiViewName, config.$uiViewContextAnchor = normalized.uiViewContextAnchor, views[name] = config
        })), views
    }
    var id = 0,
        Ng1ViewConfig = function() {
            function Ng1ViewConfig(path, viewDecl, factory) {
                var _this = this;
                this.path = path, this.viewDecl = viewDecl, this.factory = factory, this.$id = id++, this.loaded = !1, this.getTemplate = function(uiView, context) {
                    return _this.component ? _this.factory.makeComponentTemplate(uiView, context, _this.component, _this.viewDecl.bindings) : _this.template
                }
            }
            return Ng1ViewConfig.prototype.load = function() {
                var _this = this,
                    $q = _uirouter_core__WEBPACK_IMPORTED_MODULE_0__.services.$q,
                    context = new _uirouter_core__WEBPACK_IMPORTED_MODULE_0__.ResolveContext(this.path),
                    params = this.path.reduce((function(acc, node) {
                        return Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.extend)(acc, node.paramValues)
                    }), {}),
                    promises = {
                        template: $q.when(this.factory.fromConfig(this.viewDecl, params, context)),
                        controller: $q.when(this.getController(context))
                    };
                return $q.all(promises).then((function(results) {
                    return _uirouter_core__WEBPACK_IMPORTED_MODULE_0__.trace.traceViewServiceEvent("Loaded", _this), _this.controller = results.controller, Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.extend)(_this, results.template), _this
                }))
            }, Ng1ViewConfig.prototype.getController = function(context) {
                var provider = this.viewDecl.controllerProvider;
                if (!Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.isInjectable)(provider)) return this.viewDecl.controller;
                var deps = _uirouter_core__WEBPACK_IMPORTED_MODULE_0__.services.$injector.annotate(provider),
                    providerFn = Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.isArray)(provider) ? Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.tail)(provider) : provider;
                return new _uirouter_core__WEBPACK_IMPORTED_MODULE_0__.Resolvable("", providerFn, deps).get(context)
            }, Ng1ViewConfig
        }()
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "b", (function() {
        return defaultTransOpts
    })), __webpack_require__.d(__webpack_exports__, "a", (function() {
        return transitionService_TransitionService
    }));
    var transition_interface = __webpack_require__(17),
        transition_transition = __webpack_require__(44),
        hookRegistry = __webpack_require__(38),
        lib_esm_router = __webpack_require__(73),
        resolve = __webpack_require__(33),
        common = __webpack_require__(6);

    function addCoreResolvables(trans) {
        trans.addResolvable(resolve.b.fromData(lib_esm_router.a, trans.router), ""), trans.addResolvable(resolve.b.fromData(transition_transition.a, trans), ""), trans.addResolvable(resolve.b.fromData("$transition$", trans), ""), trans.addResolvable(resolve.b.fromData("$stateParams", trans.params()), ""), trans.entering().forEach((function(state) {
            trans.addResolvable(resolve.b.fromData("$state$", state), state)
        }))
    }
    var TRANSITION_TOKENS = ["$transition$", transition_transition.a],
        isTransition = Object(common.m)(TRANSITION_TOKENS),
        treeChangesCleanup = function(trans) {
            var nodes = Object(common.S)(trans.treeChanges()).reduce(common.Q, []).reduce(common.P, []),
                replaceTransitionWithNull = function(r) {
                    return isTransition(r.token) ? resolve.b.fromData(r.token, null) : r
                };
            nodes.forEach((function(node) {
                node.resolvables = node.resolvables.map(replaceTransitionWithNull)
            }))
        },
        predicates = __webpack_require__(4),
        coreservices = __webpack_require__(9),
        state_targetState = __webpack_require__(25),
        redirectToHook = function(trans) {
            var redirect = trans.to().redirectTo;
            if (redirect) {
                var $state = trans.router.stateService;
                return Object(predicates.d)(redirect) ? coreservices.b.$q.when(redirect(trans)).then(handleResult) : handleResult(redirect)
            }

            function handleResult(result) {
                if (result) return result instanceof state_targetState.a ? result : Object(predicates.l)(result) ? $state.target(result, trans.params(), trans.options()) : result.state || result.params ? $state.target(result.state || trans.to(), result.params || trans.params(), trans.options()) : void 0
            }
        };

    function makeEnterExitRetainHook(hookName) {
        return function(transition, state) {
            return (0, state.$$state()[hookName])(transition, state)
        }
    }
    var onExitHook = makeEnterExitRetainHook("onExit"),
        onRetainHook = makeEnterExitRetainHook("onRetain"),
        onEnterHook = makeEnterExitRetainHook("onEnter"),
        common_common = __webpack_require__(2),
        resolveContext = __webpack_require__(26),
        hof = __webpack_require__(5),
        eagerResolvePath = function(trans) {
            return new resolveContext.b(trans.treeChanges().to).resolvePath("EAGER", trans).then(common_common.x)
        },
        lazyResolveState = function(trans, state) {
            return new resolveContext.b(trans.treeChanges().to).subContext(state.$$state()).resolvePath("LAZY", trans).then(common_common.x)
        },
        resolveRemaining = function(trans) {
            return new resolveContext.b(trans.treeChanges().to).resolvePath("LAZY", trans).then(common_common.x)
        },
        loadEnteringViews = function(transition) {
            var $q = coreservices.b.$q,
                enteringViews = transition.views("entering");
            if (enteringViews.length) return $q.all(enteringViews.map((function(view) {
                return $q.when(view.load())
            }))).then(common_common.x)
        },
        activateViews = function(transition) {
            var enteringViews = transition.views("entering"),
                exitingViews = transition.views("exiting");
            if (enteringViews.length || exitingViews.length) {
                var $view = transition.router.viewService;
                exitingViews.forEach((function(vc) {
                    return $view.deactivateViewConfig(vc)
                })), enteringViews.forEach((function(vc) {
                    return $view.activateViewConfig(vc)
                })), $view.sync()
            }
        },
        updateGlobalState = function(trans) {
            var globals = trans.router.globals,
                clearCurrentTransition = function() {
                    globals.transition === trans && (globals.transition = null)
                };
            trans.onSuccess({}, (function() {
                globals.successfulTransitions.enqueue(trans), globals.$current = trans.$to(), globals.current = globals.$current.self, Object(common_common.g)(trans.params(), globals.params)
            }), {
                priority: 1e4
            }), trans.promise.then(clearCurrentTransition, clearCurrentTransition)
        },
        updateUrl = function(transition) {
            var options = transition.options(),
                $state = transition.router.stateService,
                $urlRouter = transition.router.urlRouter;
            if ("url" !== options.source && options.location && $state.$current.navigable) {
                var urlOptions = {
                    replace: "replace" === options.location
                };
                $urlRouter.push($state.$current.navigable.url, $state.params, urlOptions)
            }
            $urlRouter.update(!0)
        },
        lazyLoad = __webpack_require__(89),
        transitionEventType = __webpack_require__(81),
        transitionHook = __webpack_require__(20),
        trace = __webpack_require__(14),
        rejectFactory = __webpack_require__(13);

    function ignoredHook(trans) {
        var ignoredReason = trans._ignoredReason();
        if (ignoredReason) {
            trace.a.traceTransitionIgnored(trans);
            var pending = trans.router.globals.transition;
            return "SameAsCurrent" === ignoredReason && pending && pending.abort(), rejectFactory.b.ignored().toPromise()
        }
    }

    function invalidTransitionHook(trans) {
        if (!trans.valid()) throw new Error(trans.error().toString())
    }
    var defaultTransOpts = {
            location: !0,
            relative: null,
            inherit: !1,
            notify: !0,
            reload: !1,
            supercede: !0,
            custom: {},
            current: function() {
                return null
            },
            source: "unknown"
        },
        transitionService_TransitionService = function() {
            function TransitionService(_router) {
                this._transitionCount = 0, this._eventTypes = [], this._registeredHooks = {}, this._criteriaPaths = {}, this._router = _router, this.$view = _router.viewService, this._deregisterHookFns = {}, this._pluginapi = Object(common_common.h)(Object(hof.m)(this), {}, Object(hof.m)(this), ["_definePathType", "_defineEvent", "_getPathTypes", "_getEvents", "getHooks"]), this._defineCorePaths(), this._defineCoreEvents(), this._registerCoreTransitionHooks(), _router.globals.successfulTransitions.onEvict(treeChangesCleanup)
            }
            return TransitionService.prototype.onCreate = function(criteria, callback, options) {}, TransitionService.prototype.onBefore = function(criteria, callback, options) {}, TransitionService.prototype.onStart = function(criteria, callback, options) {}, TransitionService.prototype.onExit = function(criteria, callback, options) {}, TransitionService.prototype.onRetain = function(criteria, callback, options) {}, TransitionService.prototype.onEnter = function(criteria, callback, options) {}, TransitionService.prototype.onFinish = function(criteria, callback, options) {}, TransitionService.prototype.onSuccess = function(criteria, callback, options) {}, TransitionService.prototype.onError = function(criteria, callback, options) {}, TransitionService.prototype.dispose = function(router) {
                Object(common_common.L)(this._registeredHooks).forEach((function(hooksArray) {
                    return hooksArray.forEach((function(hook) {
                        hook._deregistered = !0, Object(common_common.C)(hooksArray, hook)
                    }))
                }))
            }, TransitionService.prototype.create = function(fromPath, targetState) {
                return new transition_transition.a(fromPath, targetState, this._router)
            }, TransitionService.prototype._defineCoreEvents = function() {
                var Phase = transition_interface.a,
                    TH = transitionHook.a,
                    paths = this._criteriaPaths;
                this._defineEvent("onCreate", Phase.CREATE, 0, paths.to, false, TH.LOG_REJECTED_RESULT, TH.THROW_ERROR, true), this._defineEvent("onBefore", Phase.BEFORE, 0, paths.to), this._defineEvent("onStart", Phase.RUN, 0, paths.to), this._defineEvent("onExit", Phase.RUN, 100, paths.exiting, !0), this._defineEvent("onRetain", Phase.RUN, 200, paths.retained), this._defineEvent("onEnter", Phase.RUN, 300, paths.entering), this._defineEvent("onFinish", Phase.RUN, 400, paths.to), this._defineEvent("onSuccess", Phase.SUCCESS, 0, paths.to, false, TH.LOG_REJECTED_RESULT, TH.LOG_ERROR, true), this._defineEvent("onError", Phase.ERROR, 0, paths.to, false, TH.LOG_REJECTED_RESULT, TH.LOG_ERROR, true)
            }, TransitionService.prototype._defineCorePaths = function() {
                var STATE = transition_interface.b.STATE,
                    TRANSITION = transition_interface.b.TRANSITION;
                this._definePathType("to", TRANSITION), this._definePathType("from", TRANSITION), this._definePathType("exiting", STATE), this._definePathType("retained", STATE), this._definePathType("entering", STATE)
            }, TransitionService.prototype._defineEvent = function(name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, synchronous) {
                void 0 === reverseSort && (reverseSort = !1), void 0 === getResultHandler && (getResultHandler = transitionHook.a.HANDLE_RESULT), void 0 === getErrorHandler && (getErrorHandler = transitionHook.a.REJECT_ERROR), void 0 === synchronous && (synchronous = !1);
                var eventType = new transitionEventType.a(name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, synchronous);
                this._eventTypes.push(eventType), Object(hookRegistry.a)(this, this, eventType)
            }, TransitionService.prototype._getEvents = function(phase) {
                return (Object(predicates.c)(phase) ? this._eventTypes.filter((function(type) {
                    return type.hookPhase === phase
                })) : this._eventTypes.slice()).sort((function(l, r) {
                    var cmpByPhase = l.hookPhase - r.hookPhase;
                    return 0 === cmpByPhase ? l.hookOrder - r.hookOrder : cmpByPhase
                }))
            }, TransitionService.prototype._definePathType = function(name, hookScope) {
                this._criteriaPaths[name] = {
                    name: name,
                    scope: hookScope
                }
            }, TransitionService.prototype._getPathTypes = function() {
                return this._criteriaPaths
            }, TransitionService.prototype.getHooks = function(hookName) {
                return this._registeredHooks[hookName]
            }, TransitionService.prototype._registerCoreTransitionHooks = function() {
                var fns = this._deregisterHookFns;
                fns.addCoreResolves = this.onCreate({}, addCoreResolvables), fns.ignored = function(transitionService) {
                    return transitionService.onBefore({}, ignoredHook, {
                        priority: -9999
                    })
                }(this), fns.invalid = function(transitionService) {
                    return transitionService.onBefore({}, invalidTransitionHook, {
                        priority: -1e4
                    })
                }(this), fns.redirectTo = function(transitionService) {
                    return transitionService.onStart({
                        to: function(state) {
                            return !!state.redirectTo
                        }
                    }, redirectToHook)
                }(this), fns.onExit = function(transitionService) {
                    return transitionService.onExit({
                        exiting: function(state) {
                            return !!state.onExit
                        }
                    }, onExitHook)
                }(this), fns.onRetain = function(transitionService) {
                    return transitionService.onRetain({
                        retained: function(state) {
                            return !!state.onRetain
                        }
                    }, onRetainHook)
                }(this), fns.onEnter = function(transitionService) {
                    return transitionService.onEnter({
                        entering: function(state) {
                            return !!state.onEnter
                        }
                    }, onEnterHook)
                }(this), fns.eagerResolve = function(transitionService) {
                    return transitionService.onStart({}, eagerResolvePath, {
                        priority: 1e3
                    })
                }(this), fns.lazyResolve = function(transitionService) {
                    return transitionService.onEnter({
                        entering: Object(hof.m)(!0)
                    }, lazyResolveState, {
                        priority: 1e3
                    })
                }(this), fns.resolveAll = function(transitionService) {
                    return transitionService.onFinish({}, resolveRemaining, {
                        priority: 1e3
                    })
                }(this), fns.loadViews = function(transitionService) {
                    return transitionService.onFinish({}, loadEnteringViews)
                }(this), fns.activateViews = function(transitionService) {
                    return transitionService.onSuccess({}, activateViews)
                }(this), fns.updateGlobals = function(transitionService) {
                    return transitionService.onCreate({}, updateGlobalState)
                }(this), fns.updateUrl = function(transitionService) {
                    return transitionService.onSuccess({}, updateUrl, {
                        priority: 9999
                    })
                }(this), fns.lazyLoad = Object(lazyLoad.b)(this)
            }, TransitionService
        }()
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return rxSubscriber
    }));
    var rxSubscriber = function() {
        return "function" == typeof Symbol ? Symbol("rxSubscriber") : "@@rxSubscriber_" + Math.random()
    }()
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return Glob
    }));
    var Glob = function() {
        function Glob(text) {
            this.text = text, this.glob = text.split(".");
            var regexpString = this.text.split(".").map((function(seg) {
                return "**" === seg ? "(?:|(?:\\.[^.]*)*)" : "*" === seg ? "\\.[^.]*" : "\\." + seg
            })).join("");
            this.regexp = new RegExp("^" + regexpString + "$")
        }
        return Glob.is = function(text) {
            return !!/[!,*]+/.exec(text)
        }, Glob.fromString = function(text) {
            return Glob.is(text) ? new Glob(text) : null
        }, Glob.prototype.matches = function(name) {
            return this.regexp.test("." + name)
        }, Glob
    }()
}, function(module, exports, __webpack_require__) {
    __webpack_require__(265), module.exports = angular
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    function isScheduler(value) {
        return value && "function" == typeof value.schedule
    }
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return isScheduler
    }))
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return scheduleArray
    }));
    var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12),
        _Subscription__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(15);

    function scheduleArray(input, scheduler) {
        return new _Observable__WEBPACK_IMPORTED_MODULE_0__.a((function(subscriber) {
            var sub = new _Subscription__WEBPACK_IMPORTED_MODULE_1__.a,
                i = 0;
            return sub.add(scheduler.schedule((function() {
                i !== input.length ? (subscriber.next(input[i++]), subscriber.closed || sub.add(this.schedule())) : subscriber.complete()
            }))), sub
        }))
    }
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    function identity(x) {
        return x
    }
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return identity
    }))
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return fromArray
    }));
    var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12),
        _util_subscribeToArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(93),
        _scheduled_scheduleArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(52);

    function fromArray(input, scheduler) {
        return scheduler ? Object(_scheduled_scheduleArray__WEBPACK_IMPORTED_MODULE_2__.a)(input, scheduler) : new _Observable__WEBPACK_IMPORTED_MODULE_0__.a(Object(_util_subscribeToArray__WEBPACK_IMPORTED_MODULE_1__.a)(input))
    }
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return subscribeTo
    }));
    var subscribeToArray = __webpack_require__(93),
        hostReportError = __webpack_require__(34),
        symbol_iterator = __webpack_require__(39),
        observable = __webpack_require__(30),
        isArrayLike = __webpack_require__(95),
        isPromise = __webpack_require__(96),
        isObject = __webpack_require__(91),
        subscribeTo = function(result) {
            if (result && "function" == typeof result[observable.a]) return obj = result,
                function(subscriber) {
                    var obs = obj[observable.a]();
                    if ("function" != typeof obs.subscribe) throw new TypeError("Provided object does not correctly implement Symbol.observable");
                    return obs.subscribe(subscriber)
                };
            if (Object(isArrayLike.a)(result)) return Object(subscribeToArray.a)(result);
            if (Object(isPromise.a)(result)) return promise = result,
                function(subscriber) {
                    return promise.then((function(value) {
                        subscriber.closed || (subscriber.next(value), subscriber.complete())
                    }), (function(err) {
                        return subscriber.error(err)
                    })).then(null, hostReportError.a), subscriber
                };
            if (result && "function" == typeof result[symbol_iterator.a]) return iterable = result,
                function(subscriber) {
                    for (var iterator = iterable[symbol_iterator.a]();;) {
                        var item = void 0;
                        try {
                            item = iterator.next()
                        } catch (err) {
                            return subscriber.error(err), subscriber
                        }
                        if (item.done) {
                            subscriber.complete();
                            break
                        }
                        if (subscriber.next(item.value), subscriber.closed) break
                    }
                    return "function" == typeof iterator.return && subscriber.add((function() {
                        iterator.return && iterator.return()
                    })), subscriber
                };
            var iterable, promise, obj, value = Object(isObject.a)(result) ? "an invalid object" : "'" + result + "'";
            throw new TypeError("You provided " + value + " where a stream was expected. You can provide an Observable, Promise, Array, or Iterable.")
        }
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return empty
    }));
    var _config__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(24),
        _util_hostReportError__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(34),
        empty = {
            closed: !0,
            next: function(value) {},
            error: function(err) {
                if (_config__WEBPACK_IMPORTED_MODULE_0__.a.useDeprecatedSynchronousErrorHandling) throw err;
                Object(_util_hostReportError__WEBPACK_IMPORTED_MODULE_1__.a)(err)
            },
            complete: function() {}
        }
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return resolvePolicies
    }));
    var resolvePolicies = {
        when: {
            LAZY: "LAZY",
            EAGER: "EAGER"
        },
        async: {
            WAIT: "WAIT",
            NOWAIT: "NOWAIT"
        }
    }
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return $q
    }));
    var _common_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6),
        $q = {
            when: function(val) {
                return new Promise((function(resolve, reject) {
                    return resolve(val)
                }))
            },
            reject: function(val) {
                return new Promise((function(resolve, reject) {
                    reject(val)
                }))
            },
            defer: function() {
                var deferred = {};
                return deferred.promise = new Promise((function(resolve, reject) {
                    deferred.resolve = resolve, deferred.reject = reject
                })), deferred
            },
            all: function(promises) {
                if (Object(_common_index__WEBPACK_IMPORTED_MODULE_0__.o)(promises)) return Promise.all(promises);
                if (Object(_common_index__WEBPACK_IMPORTED_MODULE_0__.u)(promises)) {
                    var chain = Object.keys(promises).map((function(key) {
                        return promises[key].then((function(val) {
                            return {
                                key: key,
                                val: val
                            }
                        }))
                    }));
                    return $q.all(chain).then((function(values) {
                        return values.reduce((function(acc, tuple) {
                            return acc[tuple.key] = tuple.val, acc
                        }), {})
                    }))
                }
            }
        }
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return $injector
    }));
    var _common_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6),
        globals = {},
        STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm,
        ARGUMENT_NAMES = /([^\s,]+)/g,
        $injector = {
            get: function(name) {
                return globals[name]
            },
            has: function(name) {
                return null != $injector.get(name)
            },
            invoke: function(fn, context, locals) {
                var all = Object(_common_index__WEBPACK_IMPORTED_MODULE_0__.h)({}, globals, locals || {}),
                    params = $injector.annotate(fn),
                    ensureExist = Object(_common_index__WEBPACK_IMPORTED_MODULE_0__.d)((function(key) {
                        return all.hasOwnProperty(key)
                    }), (function(key) {
                        return "DI can't find injectable: '" + key + "'"
                    })),
                    args = params.filter(ensureExist).map((function(x) {
                        return all[x]
                    }));
                return Object(_common_index__WEBPACK_IMPORTED_MODULE_0__.q)(fn) ? fn.apply(context, args) : fn.slice(-1)[0].apply(context, args)
            },
            annotate: function(fn) {
                if (!Object(_common_index__WEBPACK_IMPORTED_MODULE_0__.r)(fn)) throw new Error("Not an injectable function: " + fn);
                if (fn && fn.$inject) return fn.$inject;
                if (Object(_common_index__WEBPACK_IMPORTED_MODULE_0__.o)(fn)) return fn.slice(0, -1);
                var fnStr = fn.toString().replace(STRIP_COMMENTS, "");
                return fnStr.slice(fnStr.indexOf("(") + 1, fnStr.indexOf(")")).match(ARGUMENT_NAMES) || []
            }
        }
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return BrowserLocationConfig
    }));
    var _common_predicates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4),
        BrowserLocationConfig = function() {
            function BrowserLocationConfig(router, _isHtml5) {
                void 0 === _isHtml5 && (_isHtml5 = !1), this._isHtml5 = _isHtml5, this._baseHref = void 0, this._hashPrefix = ""
            }
            return BrowserLocationConfig.prototype.port = function() {
                return location.port ? Number(location.port) : "https" === this.protocol() ? 443 : 80
            }, BrowserLocationConfig.prototype.protocol = function() {
                return location.protocol.replace(/:/g, "")
            }, BrowserLocationConfig.prototype.host = function() {
                return location.hostname
            }, BrowserLocationConfig.prototype.html5Mode = function() {
                return this._isHtml5
            }, BrowserLocationConfig.prototype.hashPrefix = function(newprefix) {
                return Object(_common_predicates__WEBPACK_IMPORTED_MODULE_0__.c)(newprefix) ? this._hashPrefix = newprefix : this._hashPrefix
            }, BrowserLocationConfig.prototype.baseHref = function(href) {
                return Object(_common_predicates__WEBPACK_IMPORTED_MODULE_0__.c)(href) && (this._baseHref = href), Object(_common_predicates__WEBPACK_IMPORTED_MODULE_0__.m)(this._baseHref) && (this._baseHref = this.getBaseHref()), this._baseHref
            }, BrowserLocationConfig.prototype.getBaseHref = function() {
                var baseTag = document.getElementsByTagName("base")[0];
                return baseTag && baseTag.href ? baseTag.href.replace(/^([^/:]*:)?\/\/[^/]*/, "") : this._isHtml5 ? "/" : location.pathname || "/"
            }, BrowserLocationConfig.prototype.dispose = function() {}, BrowserLocationConfig
        }()
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    function isFunction(x) {
        return "function" == typeof x
    }
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return isFunction
    }))
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return of
    }));
    var _util_isScheduler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(51),
        _fromArray__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(54),
        _scheduled_scheduleArray__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(52);

    function of () {
        for (var args = [], _i = 0; _i < arguments.length; _i++) args[_i] = arguments[_i];
        var scheduler = args[args.length - 1];
        return Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_0__.a)(scheduler) ? (args.pop(), Object(_scheduled_scheduleArray__WEBPACK_IMPORTED_MODULE_2__.a)(args, scheduler)) : Object(_fromArray__WEBPACK_IMPORTED_MODULE_1__.a)(args)
    }
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return map
    }));
    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7),
        _Subscriber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(11);

    function map(project, thisArg) {
        return function(source) {
            if ("function" != typeof project) throw new TypeError("argument is not a function. Are you looking for `mapTo()`?");
            return source.lift(new MapOperator(project, thisArg))
        }
    }
    var MapOperator = function() {
            function MapOperator(project, thisArg) {
                this.project = project, this.thisArg = thisArg
            }
            return MapOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new MapSubscriber(subscriber, this.project, this.thisArg))
            }, MapOperator
        }(),
        MapSubscriber = function(_super) {
            function MapSubscriber(destination, project, thisArg) {
                var _this = _super.call(this, destination) || this;
                return _this.project = project, _this.count = 0, _this.thisArg = thisArg || _this, _this
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(MapSubscriber, _super), MapSubscriber.prototype._next = function(value) {
                var result;
                try {
                    result = this.project.call(this.thisArg, value, this.count++)
                } catch (err) {
                    return void this.destination.error(err)
                }
                this.destination.next(result)
            }, MapSubscriber
        }(_Subscriber__WEBPACK_IMPORTED_MODULE_1__.a)
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return from
    }));
    var Observable = __webpack_require__(12),
        subscribeTo = __webpack_require__(55),
        Subscription = __webpack_require__(15),
        symbol_observable = __webpack_require__(30);
    var scheduleArray = __webpack_require__(52),
        symbol_iterator = __webpack_require__(39);
    var isPromise = __webpack_require__(96),
        isArrayLike = __webpack_require__(95);

    function scheduled(input, scheduler) {
        if (null != input) {
            if (function(input) {
                    return input && "function" == typeof input[symbol_observable.a]
                }(input)) return function(input, scheduler) {
                return new Observable.a((function(subscriber) {
                    var sub = new Subscription.a;
                    return sub.add(scheduler.schedule((function() {
                        var observable = input[symbol_observable.a]();
                        sub.add(observable.subscribe({
                            next: function(value) {
                                sub.add(scheduler.schedule((function() {
                                    return subscriber.next(value)
                                })))
                            },
                            error: function(err) {
                                sub.add(scheduler.schedule((function() {
                                    return subscriber.error(err)
                                })))
                            },
                            complete: function() {
                                sub.add(scheduler.schedule((function() {
                                    return subscriber.complete()
                                })))
                            }
                        }))
                    }))), sub
                }))
            }(input, scheduler);
            if (Object(isPromise.a)(input)) return function(input, scheduler) {
                return new Observable.a((function(subscriber) {
                    var sub = new Subscription.a;
                    return sub.add(scheduler.schedule((function() {
                        return input.then((function(value) {
                            sub.add(scheduler.schedule((function() {
                                subscriber.next(value), sub.add(scheduler.schedule((function() {
                                    return subscriber.complete()
                                })))
                            })))
                        }), (function(err) {
                            sub.add(scheduler.schedule((function() {
                                return subscriber.error(err)
                            })))
                        }))
                    }))), sub
                }))
            }(input, scheduler);
            if (Object(isArrayLike.a)(input)) return Object(scheduleArray.a)(input, scheduler);
            if (function(input) {
                    return input && "function" == typeof input[symbol_iterator.a]
                }(input) || "string" == typeof input) return function(input, scheduler) {
                if (!input) throw new Error("Iterable cannot be null");
                return new Observable.a((function(subscriber) {
                    var iterator, sub = new Subscription.a;
                    return sub.add((function() {
                        iterator && "function" == typeof iterator.return && iterator.return()
                    })), sub.add(scheduler.schedule((function() {
                        iterator = input[symbol_iterator.a](), sub.add(scheduler.schedule((function() {
                            if (!subscriber.closed) {
                                var value, done;
                                try {
                                    var result = iterator.next();
                                    value = result.value, done = result.done
                                } catch (err) {
                                    return void subscriber.error(err)
                                }
                                done ? subscriber.complete() : (subscriber.next(value), this.schedule())
                            }
                        })))
                    }))), sub
                }))
            }(input, scheduler)
        }
        throw new TypeError((null !== input && typeof input || input) + " is not observable")
    }

    function from(input, scheduler) {
        return scheduler ? scheduled(input, scheduler) : input instanceof Observable.a ? input : new Observable.a(Object(subscribeTo.a)(input))
    }
}, function(module, exports) {
    var g;
    g = function() {
        return this
    }();
    try {
        g = g || new Function("return this")()
    } catch (e) {
        "object" == typeof window && (g = window)
    }
    module.exports = g
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return StateParams
    }));
    var _common_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2),
        StateParams = function() {
            function StateParams(params) {
                void 0 === params && (params = {}), Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.l)(this, params)
            }
            return StateParams.prototype.$inherit = function(newParams, $current, $to) {
                var parentParams, parents = Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.b)($current, $to),
                    inherited = {},
                    inheritList = [];
                for (var i in parents)
                    if (parents[i] && parents[i].params && (parentParams = Object.keys(parents[i].params)).length)
                        for (var j in parentParams) inheritList.indexOf(parentParams[j]) >= 0 || (inheritList.push(parentParams[j]), inherited[parentParams[j]] = this[parentParams[j]]);
                return Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.l)({}, inherited, newParams)
            }, StateParams
        }()
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return StateBuilder
    }));
    var _common_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2),
        _common_predicates__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4),
        _common_strings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(10),
        _common_hof__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(5),
        _resolve_resolvable__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(18),
        _common_coreservices__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(9);

    function nameBuilder(state) {
        return state.name
    }

    function selfBuilder(state) {
        return state.self.$$state = function() {
            return state
        }, state.self
    }

    function dataBuilder(state) {
        return state.parent && state.parent.data && (state.data = state.self.data = Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.t)(state.parent.data, state.data)), state.data
    }
    var getUrlBuilder = function($urlMatcherFactoryProvider, root) {
            return function(stateObject) {
                var stateDec = stateObject.self;
                if (stateDec && stateDec.url && stateDec.name && stateDec.name.match(/\.\*\*$/)) {
                    var newStateDec = {};
                    Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.g)(stateDec, newStateDec), newStateDec.url += "{remainder:any}", stateDec = newStateDec
                }
                var parent = stateObject.parent,
                    parsed = function(url) {
                        if (!Object(_common_predicates__WEBPACK_IMPORTED_MODULE_1__.l)(url)) return !1;
                        var root = "^" === url.charAt(0);
                        return {
                            val: root ? url.substring(1) : url,
                            root: root
                        }
                    }(stateDec.url),
                    url = parsed ? $urlMatcherFactoryProvider.compile(parsed.val, {
                        state: stateDec
                    }) : stateDec.url;
                if (!url) return null;
                if (!$urlMatcherFactoryProvider.isMatcher(url)) throw new Error("Invalid url '" + url + "' in state '" + stateObject + "'");
                return parsed && parsed.root ? url : (parent && parent.navigable || root()).url.append(url)
            }
        },
        getNavigableBuilder = function(isRoot) {
            return function(state) {
                return !isRoot(state) && state.url ? state : state.parent ? state.parent.navigable : null
            }
        };

    function pathBuilder(state) {
        return state.parent ? state.parent.path.concat(state) : [state]
    }

    function includesBuilder(state) {
        var includes = state.parent ? Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.l)({}, state.parent.includes) : {};
        return includes[state.name] = !0, includes
    }

    function resolvablesBuilder(state) {
        var resolveObj, resolvePolicies, getToken = function(p) {
                return p.provide || p.token
            },
            literal2Resolvable = Object(_common_hof__WEBPACK_IMPORTED_MODULE_3__.i)([
                [Object(_common_hof__WEBPACK_IMPORTED_MODULE_3__.k)("resolveFn"), function(p) {
                    return new _resolve_resolvable__WEBPACK_IMPORTED_MODULE_4__.a(getToken(p), p.resolveFn, p.deps, p.policy)
                }],
                [Object(_common_hof__WEBPACK_IMPORTED_MODULE_3__.k)("useFactory"), function(p) {
                    return new _resolve_resolvable__WEBPACK_IMPORTED_MODULE_4__.a(getToken(p), p.useFactory, p.deps || p.dependencies, p.policy)
                }],
                [Object(_common_hof__WEBPACK_IMPORTED_MODULE_3__.k)("useClass"), function(p) {
                    return new _resolve_resolvable__WEBPACK_IMPORTED_MODULE_4__.a(getToken(p), (function() {
                        return new p.useClass
                    }), [], p.policy)
                }],
                [Object(_common_hof__WEBPACK_IMPORTED_MODULE_3__.k)("useValue"), function(p) {
                    return new _resolve_resolvable__WEBPACK_IMPORTED_MODULE_4__.a(getToken(p), (function() {
                        return p.useValue
                    }), [], p.policy, p.useValue)
                }],
                [Object(_common_hof__WEBPACK_IMPORTED_MODULE_3__.k)("useExisting"), function(p) {
                    return new _resolve_resolvable__WEBPACK_IMPORTED_MODULE_4__.a(getToken(p), _common_common__WEBPACK_IMPORTED_MODULE_0__.r, [p.useExisting], p.policy)
                }]
            ]),
            tuple2Resolvable = Object(_common_hof__WEBPACK_IMPORTED_MODULE_3__.i)([
                [Object(_common_hof__WEBPACK_IMPORTED_MODULE_3__.j)(Object(_common_hof__WEBPACK_IMPORTED_MODULE_3__.k)("val"), _common_predicates__WEBPACK_IMPORTED_MODULE_1__.l), function(tuple) {
                    return new _resolve_resolvable__WEBPACK_IMPORTED_MODULE_4__.a(tuple.token, _common_common__WEBPACK_IMPORTED_MODULE_0__.r, [tuple.val], tuple.policy)
                }],
                [Object(_common_hof__WEBPACK_IMPORTED_MODULE_3__.j)(Object(_common_hof__WEBPACK_IMPORTED_MODULE_3__.k)("val"), _common_predicates__WEBPACK_IMPORTED_MODULE_1__.a), function(tuple) {
                    return new _resolve_resolvable__WEBPACK_IMPORTED_MODULE_4__.a(tuple.token, Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.G)(tuple.val), tuple.val.slice(0, -1), tuple.policy)
                }],
                [Object(_common_hof__WEBPACK_IMPORTED_MODULE_3__.j)(Object(_common_hof__WEBPACK_IMPORTED_MODULE_3__.k)("val"), _common_predicates__WEBPACK_IMPORTED_MODULE_1__.d), function(tuple) {
                    return new _resolve_resolvable__WEBPACK_IMPORTED_MODULE_4__.a(tuple.token, tuple.val, (fn = tuple.val, $injector = _common_coreservices__WEBPACK_IMPORTED_MODULE_5__.b.$injector, fn.$inject || $injector && $injector.annotate(fn, $injector.strictDi) || "deferred"), tuple.policy);
                    var fn, $injector
                }]
            ]),
            item2Resolvable = Object(_common_hof__WEBPACK_IMPORTED_MODULE_3__.i)([
                [Object(_common_hof__WEBPACK_IMPORTED_MODULE_3__.e)(_resolve_resolvable__WEBPACK_IMPORTED_MODULE_4__.a), function(r) {
                    return r
                }],
                [function(obj) {
                    return !(!obj.token || !obj.resolveFn)
                }, literal2Resolvable],
                [function(obj) {
                    return !(!obj.provide && !obj.token || !(obj.useValue || obj.useFactory || obj.useExisting || obj.useClass))
                }, literal2Resolvable],
                [function(obj) {
                    return !!(obj && obj.val && (Object(_common_predicates__WEBPACK_IMPORTED_MODULE_1__.l)(obj.val) || Object(_common_predicates__WEBPACK_IMPORTED_MODULE_1__.a)(obj.val) || Object(_common_predicates__WEBPACK_IMPORTED_MODULE_1__.d)(obj.val)))
                }, tuple2Resolvable],
                [Object(_common_hof__WEBPACK_IMPORTED_MODULE_3__.m)(!0), function(obj) {
                    throw new Error("Invalid resolve value: " + Object(_common_strings__WEBPACK_IMPORTED_MODULE_2__.k)(obj))
                }]
            ]),
            decl = state.resolve;
        return (Object(_common_predicates__WEBPACK_IMPORTED_MODULE_1__.a)(decl) ? decl : (resolveObj = decl, resolvePolicies = state.resolvePolicy || {}, Object.keys(resolveObj || {}).map((function(token) {
            return {
                token: token,
                val: resolveObj[token],
                deps: void 0,
                policy: resolvePolicies[token]
            }
        })))).map(item2Resolvable)
    }
    var StateBuilder = function() {
        function StateBuilder(matcher, urlMatcherFactory) {
            this.matcher = matcher;
            var paramFactory, self = this,
                root = function() {
                    return matcher.find("")
                },
                isRoot = function(state) {
                    return "" === state.name
                };
            this.builders = {
                name: [nameBuilder],
                self: [selfBuilder],
                parent: [function(state) {
                    return isRoot(state) ? null : matcher.find(self.parentName(state)) || root()
                }],
                data: [dataBuilder],
                url: [getUrlBuilder(urlMatcherFactory, root)],
                navigable: [getNavigableBuilder(isRoot)],
                params: [(paramFactory = urlMatcherFactory.paramFactory, function(state) {
                    var urlParams = state.url && state.url.parameters({
                            inherit: !1
                        }) || [],
                        nonUrlParams = Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.L)(Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.v)(Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.y)(state.params || {}, urlParams.map(Object(_common_hof__WEBPACK_IMPORTED_MODULE_3__.k)("id"))), (function(config, id) {
                            return paramFactory.fromConfig(id, null, state.self)
                        })));
                    return urlParams.concat(nonUrlParams).map((function(p) {
                        return [p.id, p]
                    })).reduce(_common_common__WEBPACK_IMPORTED_MODULE_0__.d, {})
                })],
                views: [],
                path: [pathBuilder],
                includes: [includesBuilder],
                resolvables: [resolvablesBuilder]
            }
        }
        return StateBuilder.prototype.builder = function(name, fn) {
            var builders = this.builders,
                array = builders[name] || [];
            return Object(_common_predicates__WEBPACK_IMPORTED_MODULE_1__.l)(name) && !Object(_common_predicates__WEBPACK_IMPORTED_MODULE_1__.c)(fn) ? array.length > 1 ? array : array[0] : Object(_common_predicates__WEBPACK_IMPORTED_MODULE_1__.l)(name) && Object(_common_predicates__WEBPACK_IMPORTED_MODULE_1__.d)(fn) ? (builders[name] = array, builders[name].push(fn), function() {
                return builders[name].splice(builders[name].indexOf(fn, 1)) && null
            }) : void 0
        }, StateBuilder.prototype.build = function(state) {
            var matcher = this.matcher,
                builders = this.builders,
                parent = this.parentName(state);
            if (parent && !matcher.find(parent, void 0, !1)) return null;
            for (var key in builders)
                if (builders.hasOwnProperty(key)) {
                    var chain = builders[key].reduce((function(parentFn, step) {
                        return function(_state) {
                            return step(_state, parentFn)
                        }
                    }), _common_common__WEBPACK_IMPORTED_MODULE_0__.x);
                    state[key] = chain(state)
                }
            return state
        }, StateBuilder.prototype.parentName = function(state) {
            var name = state.name || "",
                segments = name.split(".");
            if ("**" === segments.pop() && segments.pop(), segments.length) {
                if (state.parent) throw new Error("States that specify the 'parent:' property should not have a '.' in their name (" + name + ")");
                return segments.join(".")
            }
            return state.parent ? Object(_common_predicates__WEBPACK_IMPORTED_MODULE_1__.l)(state.parent) ? state.parent : state.parent.name : ""
        }, StateBuilder.prototype.name = function(state) {
            var name = state.name;
            if (-1 !== name.indexOf(".") || !state.parent) return name;
            var parentName = Object(_common_predicates__WEBPACK_IMPORTED_MODULE_1__.l)(state.parent) ? state.parent : state.parent.name;
            return parentName ? parentName + "." + name : name
        }, StateBuilder
    }()
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return StateMatcher
    }));
    var _common_predicates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4),
        _common_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2),
        _common_safeConsole__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(23),
        StateMatcher = function() {
            function StateMatcher(_states) {
                this._states = _states
            }
            return StateMatcher.prototype.isRelative = function(stateName) {
                return 0 === (stateName = stateName || "").indexOf(".") || 0 === stateName.indexOf("^")
            }, StateMatcher.prototype.find = function(stateOrName, base, matchGlob) {
                if (void 0 === matchGlob && (matchGlob = !0), stateOrName || "" === stateOrName) {
                    var isStr = Object(_common_predicates__WEBPACK_IMPORTED_MODULE_0__.l)(stateOrName),
                        name = isStr ? stateOrName : stateOrName.name;
                    this.isRelative(name) && (name = this.resolvePath(name, base));
                    var state = this._states[name];
                    if (state && (isStr || !(isStr || state !== stateOrName && state.self !== stateOrName))) return state;
                    if (isStr && matchGlob) {
                        var matches = Object(_common_common__WEBPACK_IMPORTED_MODULE_1__.L)(this._states).filter((function(_state) {
                            return _state.__stateObjectCache.nameGlob && _state.__stateObjectCache.nameGlob.matches(name)
                        }));
                        return matches.length > 1 && _common_safeConsole__WEBPACK_IMPORTED_MODULE_2__.a.error("stateMatcher.find: Found multiple matches for " + name + " using glob: ", matches.map((function(match) {
                            return match.name
                        }))), matches[0]
                    }
                }
            }, StateMatcher.prototype.resolvePath = function(name, base) {
                if (!base) throw new Error("No reference point given for path '" + name + "'");
                for (var baseState = this.find(base), splitName = name.split("."), pathLength = splitName.length, i = 0, current = baseState; i < pathLength; i++)
                    if ("" !== splitName[i] || 0 !== i) {
                        if ("^" !== splitName[i]) break;
                        if (!current.parent) throw new Error("Path '" + name + "' not valid for state '" + baseState.name + "'");
                        current = current.parent
                    } else current = baseState;
                var relName = splitName.slice(i).join(".");
                return current.name + (current.name && relName ? "." : "") + relName
            }, StateMatcher
        }()
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return StateQueueManager
    }));
    var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6),
        _stateObject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(37),
        StateQueueManager = function() {
            function StateQueueManager(router, states, builder, listeners) {
                this.router = router, this.states = states, this.builder = builder, this.listeners = listeners, this.queue = []
            }
            return StateQueueManager.prototype.dispose = function() {
                this.queue = []
            }, StateQueueManager.prototype.register = function(stateDecl) {
                var queue = this.queue,
                    state = _stateObject__WEBPACK_IMPORTED_MODULE_1__.a.create(stateDecl),
                    name = state.name;
                if (!Object(_common__WEBPACK_IMPORTED_MODULE_0__.v)(name)) throw new Error("State must have a valid name");
                if (this.states.hasOwnProperty(name) || Object(_common__WEBPACK_IMPORTED_MODULE_0__.m)(queue.map(Object(_common__WEBPACK_IMPORTED_MODULE_0__.E)("name")), name)) throw new Error("State '" + name + "' is already defined");
                return queue.push(state), this.flush(), state
            }, StateQueueManager.prototype.flush = function() {
                for (var _this = this, queue = this.queue, states = this.states, builder = this.builder, registered = [], orphans = [], previousQueueLength = {}, getState = function(name) {
                        return _this.states.hasOwnProperty(name) && _this.states[name]
                    }, notifyListeners = function() {
                        registered.length && _this.listeners.forEach((function(listener) {
                            return listener("registered", registered.map((function(s) {
                                return s.self
                            })))
                        }))
                    }; queue.length > 0;) {
                    var state = queue.shift(),
                        name_1 = state.name,
                        result = builder.build(state),
                        orphanIdx = orphans.indexOf(state);
                    if (result) {
                        var existingState = getState(name_1);
                        if (existingState && existingState.name === name_1) throw new Error("State '" + name_1 + "' is already defined");
                        var existingFutureState = getState(name_1 + ".**");
                        existingFutureState && this.router.stateRegistry.deregister(existingFutureState), states[name_1] = state, this.attachRoute(state), orphanIdx >= 0 && orphans.splice(orphanIdx, 1), registered.push(state)
                    } else {
                        var prev = previousQueueLength[name_1];
                        if (previousQueueLength[name_1] = queue.length, orphanIdx >= 0 && prev === queue.length) return queue.push(state), notifyListeners(), states;
                        orphanIdx < 0 && orphans.push(state), queue.push(state)
                    }
                }
                return notifyListeners(), states
            }, StateQueueManager.prototype.attachRoute = function(state) {
                if (!state.abstract && state.url) {
                    var rulesApi = this.router.urlService.rules;
                    rulesApi.rule(rulesApi.urlRuleFactory.create(state))
                }
            }, StateQueueManager
        }()
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return StateRegistry
    }));
    var _stateMatcher__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(68),
        _stateBuilder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(67),
        _stateQueueManager__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(69),
        _common_common__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(2),
        _common_hof__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(5),
        StateRegistry = function() {
            function StateRegistry(router) {
                this.router = router, this.states = {}, this.listeners = [], this.matcher = new _stateMatcher__WEBPACK_IMPORTED_MODULE_0__.a(this.states), this.builder = new _stateBuilder__WEBPACK_IMPORTED_MODULE_1__.a(this.matcher, router.urlMatcherFactory), this.stateQueue = new _stateQueueManager__WEBPACK_IMPORTED_MODULE_2__.a(router, this.states, this.builder, this.listeners), this._registerRoot()
            }
            return StateRegistry.prototype._registerRoot = function() {
                (this._root = this.stateQueue.register({
                    name: "",
                    url: "^",
                    views: null,
                    params: {
                        "#": {
                            value: null,
                            type: "hash",
                            dynamic: !0
                        }
                    },
                    abstract: !0
                })).navigable = null
            }, StateRegistry.prototype.dispose = function() {
                var _this = this;
                this.stateQueue.dispose(), this.listeners = [], this.get().forEach((function(state) {
                    return _this.get(state) && _this.deregister(state)
                }))
            }, StateRegistry.prototype.onStatesChanged = function(listener) {
                return this.listeners.push(listener),
                    function() {
                        Object(_common_common__WEBPACK_IMPORTED_MODULE_3__.C)(this.listeners)(listener)
                    }.bind(this)
            }, StateRegistry.prototype.root = function() {
                return this._root
            }, StateRegistry.prototype.register = function(stateDefinition) {
                return this.stateQueue.register(stateDefinition)
            }, StateRegistry.prototype._deregisterTree = function(state) {
                var _this = this,
                    all = this.get().map((function(s) {
                        return s.$$state()
                    })),
                    getChildren = function(states) {
                        var _children = all.filter((function(s) {
                            return -1 !== states.indexOf(s.parent)
                        }));
                        return 0 === _children.length ? _children : _children.concat(getChildren(_children))
                    },
                    children = getChildren([state]),
                    deregistered = [state].concat(children).reverse();
                return deregistered.forEach((function(_state) {
                    var rulesApi = _this.router.urlService.rules;
                    rulesApi.rules().filter(Object(_common_hof__WEBPACK_IMPORTED_MODULE_4__.l)("state", _state)).forEach((function(rule) {
                        return rulesApi.removeRule(rule)
                    })), delete _this.states[_state.name]
                })), deregistered
            }, StateRegistry.prototype.deregister = function(stateOrName) {
                var _state = this.get(stateOrName);
                if (!_state) throw new Error("Can't deregister state; not found: " + stateOrName);
                var deregisteredStates = this._deregisterTree(_state.$$state());
                return this.listeners.forEach((function(listener) {
                    return listener("deregistered", deregisteredStates.map((function(s) {
                        return s.self
                    })))
                })), deregisteredStates
            }, StateRegistry.prototype.get = function(stateOrName, base) {
                var _this = this;
                if (0 === arguments.length) return Object.keys(this.states).map((function(name) {
                    return _this.states[name].self
                }));
                var found = this.matcher.find(stateOrName, base);
                return found && found.self || null
            }, StateRegistry.prototype.decorator = function(property, builderFunction) {
                return this.builder.builder(property, builderFunction)
            }, StateRegistry
        }()
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return StateService
    }));
    var _common_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2),
        _common_predicates__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4),
        _common_queue__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(41),
        _common_coreservices__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(9),
        _path_pathUtils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(21),
        _path_pathNode__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(43),
        _transition_transitionService__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(47),
        _transition_rejectFactory__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(13),
        _targetState__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(25),
        _params_param__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(19),
        _common_glob__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(49),
        _resolve_resolveContext__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(26),
        _hooks_lazyLoad__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(89),
        _common_hof__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(5),
        StateService = function() {
            function StateService(router) {
                this.router = router, this.invalidCallbacks = [], this._defaultErrorHandler = function($error$) {
                    $error$ instanceof Error && $error$.stack ? (console.error($error$), console.error($error$.stack)) : $error$ instanceof _transition_rejectFactory__WEBPACK_IMPORTED_MODULE_7__.b ? (console.error($error$.toString()), $error$.detail && $error$.detail.stack && console.error($error$.detail.stack)) : console.error($error$)
                };
                var boundFns = Object.keys(StateService.prototype).filter(Object(_common_hof__WEBPACK_IMPORTED_MODULE_13__.f)(Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.s)(["current", "$current", "params", "transition"])));
                Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.h)(Object(_common_hof__WEBPACK_IMPORTED_MODULE_13__.m)(StateService.prototype), this, Object(_common_hof__WEBPACK_IMPORTED_MODULE_13__.m)(this), boundFns)
            }
            return Object.defineProperty(StateService.prototype, "transition", {
                get: function() {
                    return this.router.globals.transition
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(StateService.prototype, "params", {
                get: function() {
                    return this.router.globals.params
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(StateService.prototype, "current", {
                get: function() {
                    return this.router.globals.current
                },
                enumerable: !1,
                configurable: !0
            }), Object.defineProperty(StateService.prototype, "$current", {
                get: function() {
                    return this.router.globals.$current
                },
                enumerable: !1,
                configurable: !0
            }), StateService.prototype.dispose = function() {
                this.defaultErrorHandler(_common_common__WEBPACK_IMPORTED_MODULE_0__.x), this.invalidCallbacks = []
            }, StateService.prototype._handleInvalidTargetState = function(fromPath, toState) {
                var _this = this,
                    fromState = _path_pathUtils__WEBPACK_IMPORTED_MODULE_4__.a.makeTargetState(this.router.stateRegistry, fromPath),
                    globals = this.router.globals,
                    latestThing = function() {
                        return globals.transitionHistory.peekTail()
                    },
                    latest = latestThing(),
                    callbackQueue = new _common_queue__WEBPACK_IMPORTED_MODULE_2__.a(this.invalidCallbacks.slice()),
                    injector = new _resolve_resolveContext__WEBPACK_IMPORTED_MODULE_11__.b(fromPath).injector(),
                    checkForRedirect = function(result) {
                        if (result instanceof _targetState__WEBPACK_IMPORTED_MODULE_8__.a) {
                            var target = result;
                            return (target = _this.target(target.identifier(), target.params(), target.options())).valid() ? latestThing() !== latest ? _transition_rejectFactory__WEBPACK_IMPORTED_MODULE_7__.b.superseded().toPromise() : _this.transitionTo(target.identifier(), target.params(), target.options()) : _transition_rejectFactory__WEBPACK_IMPORTED_MODULE_7__.b.invalid(target.error()).toPromise()
                        }
                    };
                return function invokeNextCallback() {
                    var nextCallback = callbackQueue.dequeue();
                    return void 0 === nextCallback ? _transition_rejectFactory__WEBPACK_IMPORTED_MODULE_7__.b.invalid(toState.error()).toPromise() : _common_coreservices__WEBPACK_IMPORTED_MODULE_3__.b.$q.when(nextCallback(toState, fromState, injector)).then(checkForRedirect).then((function(result) {
                        return result || invokeNextCallback()
                    }))
                }()
            }, StateService.prototype.onInvalid = function(callback) {
                return this.invalidCallbacks.push(callback),
                    function() {
                        Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.C)(this.invalidCallbacks)(callback)
                    }.bind(this)
            }, StateService.prototype.reload = function(reloadState) {
                return this.transitionTo(this.current, this.params, {
                    reload: !Object(_common_predicates__WEBPACK_IMPORTED_MODULE_1__.c)(reloadState) || reloadState,
                    inherit: !1,
                    notify: !1
                })
            }, StateService.prototype.go = function(to, params, options) {
                var defautGoOpts = {
                        relative: this.$current,
                        inherit: !0
                    },
                    transOpts = Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.i)(options, defautGoOpts, _transition_transitionService__WEBPACK_IMPORTED_MODULE_6__.b);
                return this.transitionTo(to, params, transOpts)
            }, StateService.prototype.target = function(identifier, params, options) {
                if (void 0 === options && (options = {}), Object(_common_predicates__WEBPACK_IMPORTED_MODULE_1__.i)(options.reload) && !options.reload.name) throw new Error("Invalid reload state object");
                var reg = this.router.stateRegistry;
                if (options.reloadState = !0 === options.reload ? reg.root() : reg.matcher.find(options.reload, options.relative), options.reload && !options.reloadState) throw new Error("No such reload state '" + (Object(_common_predicates__WEBPACK_IMPORTED_MODULE_1__.l)(options.reload) ? options.reload : options.reload.name) + "'");
                return new _targetState__WEBPACK_IMPORTED_MODULE_8__.a(this.router.stateRegistry, identifier, params, options)
            }, StateService.prototype.getCurrentPath = function() {
                var _this = this,
                    latestSuccess = this.router.globals.successfulTransitions.peekTail();
                return latestSuccess ? latestSuccess.treeChanges().to : [new _path_pathNode__WEBPACK_IMPORTED_MODULE_5__.a(_this.router.stateRegistry.root())]
            }, StateService.prototype.transitionTo = function(to, toParams, options) {
                var _this = this;
                void 0 === toParams && (toParams = {}), void 0 === options && (options = {});
                var router = this.router,
                    globals = router.globals;
                options = Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.i)(options, _transition_transitionService__WEBPACK_IMPORTED_MODULE_6__.b);
                var getCurrent = function() {
                    return globals.transition
                };
                options = Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.l)(options, {
                    current: getCurrent
                });
                var ref = this.target(to, toParams, options),
                    currentPath = this.getCurrentPath();
                if (!ref.exists()) return this._handleInvalidTargetState(currentPath, ref);
                if (!ref.valid()) return Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.F)(ref.error());
                if (!1 === options.supercede && getCurrent()) return _transition_rejectFactory__WEBPACK_IMPORTED_MODULE_7__.b.ignored("Another transition is in progress and supercede has been set to false in TransitionOptions for the transition. So the transition was ignored in favour of the existing one in progress.").toPromise();
                var rejectedTransitionHandler = function(trans) {
                        return function(error) {
                            if (error instanceof _transition_rejectFactory__WEBPACK_IMPORTED_MODULE_7__.b) {
                                var isLatest = router.globals.lastStartedTransitionId <= trans.$id;
                                if (error.type === _transition_rejectFactory__WEBPACK_IMPORTED_MODULE_7__.a.IGNORED) return isLatest && router.urlRouter.update(), _common_coreservices__WEBPACK_IMPORTED_MODULE_3__.b.$q.when(globals.current);
                                var detail = error.detail;
                                if (error.type === _transition_rejectFactory__WEBPACK_IMPORTED_MODULE_7__.a.SUPERSEDED && error.redirected && detail instanceof _targetState__WEBPACK_IMPORTED_MODULE_8__.a) {
                                    var redirect = trans.redirect(detail);
                                    return redirect.run().catch(rejectedTransitionHandler(redirect))
                                }
                                if (error.type === _transition_rejectFactory__WEBPACK_IMPORTED_MODULE_7__.a.ABORTED) return isLatest && router.urlRouter.update(), _common_coreservices__WEBPACK_IMPORTED_MODULE_3__.b.$q.reject(error)
                            }
                            return _this.defaultErrorHandler()(error), _common_coreservices__WEBPACK_IMPORTED_MODULE_3__.b.$q.reject(error)
                        }
                    },
                    transition = this.router.transitionService.create(currentPath, ref),
                    transitionToPromise = transition.run().catch(rejectedTransitionHandler(transition));
                return Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.E)(transitionToPromise), Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.l)(transitionToPromise, {
                    transition: transition
                })
            }, StateService.prototype.is = function(stateOrName, params, options) {
                options = Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.i)(options, {
                    relative: this.$current
                });
                var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);
                if (Object(_common_predicates__WEBPACK_IMPORTED_MODULE_1__.c)(state)) {
                    if (this.$current !== state) return !1;
                    if (!params) return !0;
                    var schema = state.parameters({
                        inherit: !0,
                        matchingKeys: params
                    });
                    return _params_param__WEBPACK_IMPORTED_MODULE_9__.b.equals(schema, _params_param__WEBPACK_IMPORTED_MODULE_9__.b.values(schema, params), this.params)
                }
            }, StateService.prototype.includes = function(stateOrName, params, options) {
                options = Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.i)(options, {
                    relative: this.$current
                });
                var glob = Object(_common_predicates__WEBPACK_IMPORTED_MODULE_1__.l)(stateOrName) && _common_glob__WEBPACK_IMPORTED_MODULE_10__.a.fromString(stateOrName);
                if (glob) {
                    if (!glob.matches(this.$current.name)) return !1;
                    stateOrName = this.$current.name
                }
                var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative),
                    include = this.$current.includes;
                if (Object(_common_predicates__WEBPACK_IMPORTED_MODULE_1__.c)(state)) {
                    if (!Object(_common_predicates__WEBPACK_IMPORTED_MODULE_1__.c)(include[state.name])) return !1;
                    if (!params) return !0;
                    var schema = state.parameters({
                        inherit: !0,
                        matchingKeys: params
                    });
                    return _params_param__WEBPACK_IMPORTED_MODULE_9__.b.equals(schema, _params_param__WEBPACK_IMPORTED_MODULE_9__.b.values(schema, params), this.params)
                }
            }, StateService.prototype.href = function(stateOrName, params, options) {
                var defaultHrefOpts = {
                    lossy: !0,
                    inherit: !0,
                    absolute: !1,
                    relative: this.$current
                };
                options = Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.i)(options, defaultHrefOpts), params = params || {};
                var state = this.router.stateRegistry.matcher.find(stateOrName, options.relative);
                if (!Object(_common_predicates__WEBPACK_IMPORTED_MODULE_1__.c)(state)) return null;
                options.inherit && (params = this.params.$inherit(params, this.$current, state));
                var nav = state && options.lossy ? state.navigable : state;
                return nav && void 0 !== nav.url && null !== nav.url ? this.router.urlRouter.href(nav.url, params, {
                    absolute: options.absolute
                }) : null
            }, StateService.prototype.defaultErrorHandler = function(handler) {
                return this._defaultErrorHandler = handler || this._defaultErrorHandler
            }, StateService.prototype.get = function(stateOrName, base) {
                var reg = this.router.stateRegistry;
                return 0 === arguments.length ? reg.get() : reg.get(stateOrName, base || this.$current)
            }, StateService.prototype.lazyLoad = function(stateOrName, transition) {
                var state = this.get(stateOrName);
                if (!state || !state.lazyLoad) throw new Error("Can not lazy load " + stateOrName);
                var currentPath = this.getCurrentPath(),
                    target = _path_pathUtils__WEBPACK_IMPORTED_MODULE_4__.a.makeTargetState(this.router.stateRegistry, currentPath);
                return transition = transition || this.router.transitionService.create(currentPath, target), Object(_hooks_lazyLoad__WEBPACK_IMPORTED_MODULE_12__.a)(transition, state)
            }, StateService
        }()
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return HookBuilder
    }));
    var _common_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2),
        _common_predicates__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4),
        _interface__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(17),
        _transitionHook__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(20),
        HookBuilder = function() {
            function HookBuilder(transition) {
                this.transition = transition
            }
            return HookBuilder.prototype.buildHooksForPhase = function(phase) {
                var _this = this;
                return this.transition.router.transitionService._pluginapi._getEvents(phase).map((function(type) {
                    return _this.buildHooks(type)
                })).reduce(_common_common__WEBPACK_IMPORTED_MODULE_0__.K, []).filter(_common_common__WEBPACK_IMPORTED_MODULE_0__.r)
            }, HookBuilder.prototype.buildHooks = function(hookType) {
                var transition = this.transition,
                    treeChanges = transition.treeChanges(),
                    matchingHooks = this.getMatchingHooks(hookType, treeChanges, transition);
                if (!matchingHooks) return [];
                var baseHookOptions = {
                    transition: transition,
                    current: transition.options().current
                };
                return matchingHooks.map((function(hook) {
                    return hook.matches(treeChanges, transition)[hookType.criteriaMatchPath.name].map((function(node) {
                        var _options = Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.l)({
                                bind: hook.bind,
                                traceData: {
                                    hookType: hookType.name,
                                    context: node
                                }
                            }, baseHookOptions),
                            state = hookType.criteriaMatchPath.scope === _interface__WEBPACK_IMPORTED_MODULE_2__.b.STATE ? node.state.self : null,
                            transitionHook = new _transitionHook__WEBPACK_IMPORTED_MODULE_3__.a(transition, state, hook, _options);
                        return {
                            hook: hook,
                            node: node,
                            transitionHook: transitionHook
                        }
                    }))
                })).reduce(_common_common__WEBPACK_IMPORTED_MODULE_0__.K, []).sort(function(reverseDepthSort) {
                    void 0 === reverseDepthSort && (reverseDepthSort = !1);
                    return function(l, r) {
                        var factor = reverseDepthSort ? -1 : 1,
                            depthDelta = (l.node.state.path.length - r.node.state.path.length) * factor;
                        return 0 !== depthDelta ? depthDelta : r.hook.priority - l.hook.priority
                    }
                }(hookType.reverseSort)).map((function(tuple) {
                    return tuple.transitionHook
                }))
            }, HookBuilder.prototype.getMatchingHooks = function(hookType, treeChanges, transition) {
                var isCreate = hookType.hookPhase === _interface__WEBPACK_IMPORTED_MODULE_2__.a.CREATE,
                    $transitions = this.transition.router.transitionService;
                return (isCreate ? [$transitions] : [this.transition, $transitions]).map((function(reg) {
                    return reg.getHooks(hookType.name)
                })).filter(Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.f)(_common_predicates__WEBPACK_IMPORTED_MODULE_1__.a, "broken event named: " + hookType.name)).reduce(_common_common__WEBPACK_IMPORTED_MODULE_0__.K, []).filter((function(hook) {
                    return hook.matches(treeChanges, transition)
                }))
            }, HookBuilder
        }()
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return UIRouter
    }));
    var _url_urlMatcherFactory__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(74),
        _url_urlRouter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(75),
        _transition_transitionService__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(47),
        _view_view__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(76),
        _state_stateRegistry__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(70),
        _state_stateService__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(71),
        _globals__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(77),
        _common_common__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(2),
        _common_predicates__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(4),
        _url_urlService__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(78),
        _common_trace__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(14),
        _common__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(6),
        _routerInstance = 0,
        locationServiceStub = Object(_common__WEBPACK_IMPORTED_MODULE_11__.y)("LocationServices", ["url", "path", "search", "hash", "onChange"]),
        locationConfigStub = Object(_common__WEBPACK_IMPORTED_MODULE_11__.y)("LocationConfig", ["port", "protocol", "host", "baseHref", "html5Mode", "hashPrefix"]),
        UIRouter = function() {
            function UIRouter(locationService, locationConfig) {
                void 0 === locationService && (locationService = locationServiceStub), void 0 === locationConfig && (locationConfig = locationConfigStub), this.locationService = locationService, this.locationConfig = locationConfig, this.$id = _routerInstance++, this._disposed = !1, this._disposables = [], this.trace = _common_trace__WEBPACK_IMPORTED_MODULE_10__.a, this.viewService = new _view_view__WEBPACK_IMPORTED_MODULE_3__.a(this), this.globals = new _globals__WEBPACK_IMPORTED_MODULE_6__.a, this.transitionService = new _transition_transitionService__WEBPACK_IMPORTED_MODULE_2__.a(this), this.urlMatcherFactory = new _url_urlMatcherFactory__WEBPACK_IMPORTED_MODULE_0__.a(this), this.urlRouter = new _url_urlRouter__WEBPACK_IMPORTED_MODULE_1__.a(this), this.urlService = new _url_urlService__WEBPACK_IMPORTED_MODULE_9__.a(this), this.stateRegistry = new _state_stateRegistry__WEBPACK_IMPORTED_MODULE_4__.a(this), this.stateService = new _state_stateService__WEBPACK_IMPORTED_MODULE_5__.a(this), this._plugins = {}, this.viewService._pluginapi._rootViewContext(this.stateRegistry.root()), this.globals.$current = this.stateRegistry.root(), this.globals.current = this.globals.$current.self, this.disposable(this.globals), this.disposable(this.stateService), this.disposable(this.stateRegistry), this.disposable(this.transitionService), this.disposable(this.urlService), this.disposable(locationService), this.disposable(locationConfig)
            }
            return UIRouter.prototype.disposable = function(disposable) {
                this._disposables.push(disposable)
            }, UIRouter.prototype.dispose = function(disposable) {
                var _this = this;
                disposable && Object(_common_predicates__WEBPACK_IMPORTED_MODULE_8__.d)(disposable.dispose) ? disposable.dispose(this) : (this._disposed = !0, this._disposables.slice().forEach((function(d) {
                    try {
                        "function" == typeof d.dispose && d.dispose(_this), Object(_common_common__WEBPACK_IMPORTED_MODULE_7__.C)(_this._disposables, d)
                    } catch (ignored) {}
                })))
            }, UIRouter.prototype.plugin = function(plugin, options) {
                void 0 === options && (options = {});
                var pluginInstance = new plugin(this, options);
                if (!pluginInstance.name) throw new Error("Required property `name` missing on plugin: " + pluginInstance);
                return this._disposables.push(pluginInstance), this._plugins[pluginInstance.name] = pluginInstance
            }, UIRouter.prototype.getPlugin = function(pluginName) {
                return pluginName ? this._plugins[pluginName] : Object(_common_common__WEBPACK_IMPORTED_MODULE_7__.L)(this._plugins)
            }, UIRouter
        }()
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return UrlMatcherFactory
    }));
    var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6),
        _urlMatcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(29),
        _params__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(27),
        __assign = function() {
            return (__assign = Object.assign || function(t) {
                for (var s, i = 1, n = arguments.length; i < n; i++)
                    for (var p in s = arguments[i]) Object.prototype.hasOwnProperty.call(s, p) && (t[p] = s[p]);
                return t
            }).apply(this, arguments)
        },
        ParamFactory = function() {
            function ParamFactory(router) {
                this.router = router
            }
            return ParamFactory.prototype.fromConfig = function(id, type, state) {
                return new _params__WEBPACK_IMPORTED_MODULE_2__.Param(id, type, _params__WEBPACK_IMPORTED_MODULE_2__.DefType.CONFIG, this.router.urlService.config, state)
            }, ParamFactory.prototype.fromPath = function(id, type, state) {
                return new _params__WEBPACK_IMPORTED_MODULE_2__.Param(id, type, _params__WEBPACK_IMPORTED_MODULE_2__.DefType.PATH, this.router.urlService.config, state)
            }, ParamFactory.prototype.fromSearch = function(id, type, state) {
                return new _params__WEBPACK_IMPORTED_MODULE_2__.Param(id, type, _params__WEBPACK_IMPORTED_MODULE_2__.DefType.SEARCH, this.router.urlService.config, state)
            }, ParamFactory
        }(),
        UrlMatcherFactory = function() {
            function UrlMatcherFactory(router) {
                var _this = this;
                this.router = router, this.paramFactory = new ParamFactory(this.router), this.UrlMatcher = _urlMatcher__WEBPACK_IMPORTED_MODULE_1__.a, this.Param = _params__WEBPACK_IMPORTED_MODULE_2__.Param, this.caseInsensitive = function(value) {
                    return _this.router.urlService.config.caseInsensitive(value)
                }, this.defaultSquashPolicy = function(value) {
                    return _this.router.urlService.config.defaultSquashPolicy(value)
                }, this.strictMode = function(value) {
                    return _this.router.urlService.config.strictMode(value)
                }, this.type = function(name, definition, definitionFn) {
                    return _this.router.urlService.config.type(name, definition, definitionFn) || _this
                }
            }
            return UrlMatcherFactory.prototype.compile = function(pattern, config) {
                var urlConfig = this.router.urlService.config,
                    params = config && !config.state && config.params;
                config = params ? __assign({
                    state: {
                        params: params
                    }
                }, config) : config;
                var globalConfig = {
                    strict: urlConfig._isStrictMode,
                    caseInsensitive: urlConfig._isCaseInsensitive,
                    decodeParams: urlConfig._decodeParams
                };
                return new _urlMatcher__WEBPACK_IMPORTED_MODULE_1__.a(pattern, urlConfig.paramTypes, this.paramFactory, Object(_common__WEBPACK_IMPORTED_MODULE_0__.h)(globalConfig, config))
            }, UrlMatcherFactory.prototype.isMatcher = function(object) {
                if (!Object(_common__WEBPACK_IMPORTED_MODULE_0__.u)(object)) return !1;
                var result = !0;
                return Object(_common__WEBPACK_IMPORTED_MODULE_0__.k)(_urlMatcher__WEBPACK_IMPORTED_MODULE_1__.a.prototype, (function(val, name) {
                    Object(_common__WEBPACK_IMPORTED_MODULE_0__.q)(val) && (result = result && Object(_common__WEBPACK_IMPORTED_MODULE_0__.p)(object[name]) && Object(_common__WEBPACK_IMPORTED_MODULE_0__.q)(object[name]))
                })), result
            }, UrlMatcherFactory.prototype.$get = function() {
                var urlConfig = this.router.urlService.config;
                return urlConfig.paramTypes.enqueue = !1, urlConfig.paramTypes._flushTypeQueue(), this
            }, UrlMatcherFactory
        }()
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return UrlRouter
    }));
    var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6),
        _urlRule__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(45);
    var UrlRouter = function() {
        function UrlRouter(router) {
            var _this = this;
            this.router = router, this.sync = function(evt) {
                return _this.router.urlService.sync(evt)
            }, this.listen = function(enabled) {
                return _this.router.urlService.listen(enabled)
            }, this.deferIntercept = function(defer) {
                return _this.router.urlService.deferIntercept(defer)
            }, this.match = function(urlParts) {
                return _this.router.urlService.match(urlParts)
            }, this.initial = function(handler) {
                return _this.router.urlService.rules.initial(handler)
            }, this.otherwise = function(handler) {
                return _this.router.urlService.rules.otherwise(handler)
            }, this.removeRule = function(rule) {
                return _this.router.urlService.rules.removeRule(rule)
            }, this.rule = function(rule) {
                return _this.router.urlService.rules.rule(rule)
            }, this.rules = function() {
                return _this.router.urlService.rules.rules()
            }, this.sort = function(compareFn) {
                return _this.router.urlService.rules.sort(compareFn)
            }, this.when = function(matcher, handler, options) {
                return _this.router.urlService.rules.when(matcher, handler, options)
            }, this.urlRuleFactory = new _urlRule__WEBPACK_IMPORTED_MODULE_1__.b(router)
        }
        return UrlRouter.prototype.update = function(read) {
            var $url = this.router.locationService;
            read ? this.location = $url.url() : $url.url() !== this.location && $url.url(this.location, !0)
        }, UrlRouter.prototype.push = function(urlMatcher, params, options) {
            var replace = options && !!options.replace;
            this.router.urlService.url(urlMatcher.format(params || {}), replace)
        }, UrlRouter.prototype.href = function(urlMatcher, params, options) {
            var url = urlMatcher.format(params);
            if (null == url) return null;
            options = options || {
                absolute: !1
            };
            var cfg = this.router.urlService.config,
                isHtml5 = cfg.html5Mode();
            if (isHtml5 || null === url || (url = "#" + cfg.hashPrefix() + url), url = function(url, isHtml5, absolute, baseHref) {
                    return "/" === baseHref ? url : isHtml5 ? Object(_common__WEBPACK_IMPORTED_MODULE_0__.L)(baseHref) + url : absolute ? baseHref.slice(1) + url : url
                }(url, isHtml5, options.absolute, cfg.baseHref()), !options.absolute || !url) return url;
            var slash = !isHtml5 && url ? "/" : "",
                cfgPort = cfg.port(),
                port = 80 === cfgPort || 443 === cfgPort ? "" : ":" + cfgPort;
            return [cfg.protocol(), "://", cfg.host(), port, slash, url].join("")
        }, Object.defineProperty(UrlRouter.prototype, "interceptDeferred", {
            get: function() {
                return this.router.urlService.interceptDeferred
            },
            enumerable: !1,
            configurable: !0
        }), UrlRouter
    }()
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return ViewService
    }));
    var _common_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2),
        _common_hof__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(5),
        _common_predicates__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(4),
        _common_trace__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(14),
        ViewService = function() {
            function ViewService(router) {
                var _this = this;
                this.router = router, this._uiViews = [], this._viewConfigs = [], this._viewConfigFactories = {}, this._listeners = [], this._pluginapi = {
                    _rootViewContext: this._rootViewContext.bind(this),
                    _viewConfigFactory: this._viewConfigFactory.bind(this),
                    _registeredUIView: function(id) {
                        return Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.n)(_this._uiViews, (function(view) {
                            return _this.router.$id + "." + view.id === id
                        }))
                    },
                    _registeredUIViews: function() {
                        return _this._uiViews
                    },
                    _activeViewConfigs: function() {
                        return _this._viewConfigs
                    },
                    _onSync: function(listener) {
                        return _this._listeners.push(listener),
                            function() {
                                return Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.C)(_this._listeners, listener)
                            }
                    }
                }
            }
            return ViewService.normalizeUIViewTarget = function(context, rawViewName) {
                void 0 === rawViewName && (rawViewName = "");
                var viewAtContext = rawViewName.split("@"),
                    uiViewName = viewAtContext[0] || "$default",
                    uiViewContextAnchor = Object(_common_predicates__WEBPACK_IMPORTED_MODULE_2__.l)(viewAtContext[1]) ? viewAtContext[1] : "^",
                    relativeViewNameSugar = /^(\^(?:\.\^)*)\.(.*$)/.exec(uiViewName);
                relativeViewNameSugar && (uiViewContextAnchor = relativeViewNameSugar[1], uiViewName = relativeViewNameSugar[2]), "!" === uiViewName.charAt(0) && (uiViewName = uiViewName.substr(1), uiViewContextAnchor = "");
                if (/^(\^(?:\.\^)*)$/.exec(uiViewContextAnchor)) {
                    var anchorState = uiViewContextAnchor.split(".").reduce((function(anchor, x) {
                        return anchor.parent
                    }), context);
                    uiViewContextAnchor = anchorState.name
                } else "." === uiViewContextAnchor && (uiViewContextAnchor = context.name);
                return {
                    uiViewName: uiViewName,
                    uiViewContextAnchor: uiViewContextAnchor
                }
            }, ViewService.prototype._rootViewContext = function(context) {
                return this._rootContext = context || this._rootContext
            }, ViewService.prototype._viewConfigFactory = function(viewType, factory) {
                this._viewConfigFactories[viewType] = factory
            }, ViewService.prototype.createViewConfig = function(path, decl) {
                var cfgFactory = this._viewConfigFactories[decl.$type];
                if (!cfgFactory) throw new Error("ViewService: No view config factory registered for type " + decl.$type);
                var cfgs = cfgFactory(path, decl);
                return Object(_common_predicates__WEBPACK_IMPORTED_MODULE_2__.a)(cfgs) ? cfgs : [cfgs]
            }, ViewService.prototype.deactivateViewConfig = function(viewConfig) {
                _common_trace__WEBPACK_IMPORTED_MODULE_3__.a.traceViewServiceEvent("<- Removing", viewConfig), Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.C)(this._viewConfigs, viewConfig)
            }, ViewService.prototype.activateViewConfig = function(viewConfig) {
                _common_trace__WEBPACK_IMPORTED_MODULE_3__.a.traceViewServiceEvent("-> Registering", viewConfig), this._viewConfigs.push(viewConfig)
            }, ViewService.prototype.sync = function() {
                var _this = this,
                    uiViewsByFqn = this._uiViews.map((function(uiv) {
                        return [uiv.fqn, uiv]
                    })).reduce(_common_common__WEBPACK_IMPORTED_MODULE_0__.d, {});

                function viewConfigDepth(config) {
                    for (var context = config.viewDecl.$context, count = 0; ++count && context.parent;) context = context.parent;
                    return count
                }
                var depthCompare = Object(_common_hof__WEBPACK_IMPORTED_MODULE_1__.d)((function(depthFn, posNeg, left, right) {
                        return posNeg * (depthFn(left) - depthFn(right))
                    })),
                    uiViewTuples = this._uiViews.sort(depthCompare((function(uiView) {
                        var stateDepth = function(context) {
                            return context && context.parent ? stateDepth(context.parent) + 1 : 1
                        };
                        return 1e4 * uiView.fqn.split(".").length + stateDepth(uiView.creationContext)
                    }), 1)).map((function(uiView) {
                        var matchingConfigs = _this._viewConfigs.filter(ViewService.matches(uiViewsByFqn, uiView));
                        return matchingConfigs.length > 1 && matchingConfigs.sort(depthCompare(viewConfigDepth, -1)), {
                            uiView: uiView,
                            viewConfig: matchingConfigs[0]
                        }
                    })),
                    matchedViewConfigs = uiViewTuples.map((function(tuple) {
                        return tuple.viewConfig
                    })),
                    unmatchedConfigTuples = this._viewConfigs.filter((function(config) {
                        return !Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.s)(matchedViewConfigs, config)
                    })).map((function(viewConfig) {
                        return {
                            uiView: void 0,
                            viewConfig: viewConfig
                        }
                    }));
                uiViewTuples.forEach((function(tuple) {
                    -1 !== _this._uiViews.indexOf(tuple.uiView) && tuple.uiView.configUpdated(tuple.viewConfig)
                }));
                var allTuples = uiViewTuples.concat(unmatchedConfigTuples);
                this._listeners.forEach((function(cb) {
                    return cb(allTuples)
                })), _common_trace__WEBPACK_IMPORTED_MODULE_3__.a.traceViewSync(allTuples)
            }, ViewService.prototype.registerUIView = function(uiView) {
                _common_trace__WEBPACK_IMPORTED_MODULE_3__.a.traceViewServiceUIViewEvent("-> Registering", uiView);
                var uiViews = this._uiViews;
                return uiViews.filter((function(uiv) {
                        return uiv.fqn === uiView.fqn && uiv.$type === uiView.$type
                    })).length && _common_trace__WEBPACK_IMPORTED_MODULE_3__.a.traceViewServiceUIViewEvent("!!!! duplicate uiView named:", uiView), uiViews.push(uiView), this.sync(),
                    function() {
                        -1 !== uiViews.indexOf(uiView) ? (_common_trace__WEBPACK_IMPORTED_MODULE_3__.a.traceViewServiceUIViewEvent("<- Deregistering", uiView), Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.C)(uiViews)(uiView)) : _common_trace__WEBPACK_IMPORTED_MODULE_3__.a.traceViewServiceUIViewEvent("Tried removing non-registered uiView", uiView)
                    }
            }, ViewService.prototype.available = function() {
                return this._uiViews.map(Object(_common_hof__WEBPACK_IMPORTED_MODULE_1__.k)("fqn"))
            }, ViewService.prototype.active = function() {
                return this._uiViews.filter(Object(_common_hof__WEBPACK_IMPORTED_MODULE_1__.k)("$config")).map(Object(_common_hof__WEBPACK_IMPORTED_MODULE_1__.k)("name"))
            }, ViewService.matches = function(uiViewsByFqn, uiView) {
                return function(viewConfig) {
                    if (uiView.$type !== viewConfig.viewDecl.$type) return !1;
                    var vc = viewConfig.viewDecl,
                        vcSegments = vc.$uiViewName.split("."),
                        uivSegments = uiView.fqn.split(".");
                    if (!Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.k)(vcSegments, uivSegments.slice(0 - vcSegments.length))) return !1;
                    var negOffset = 1 - vcSegments.length || void 0,
                        fqnToFirstSegment = uivSegments.slice(0, negOffset).join("."),
                        uiViewContext = uiViewsByFqn[fqnToFirstSegment].creationContext;
                    return vc.$uiViewContextAnchor === (uiViewContext && uiViewContext.name)
                }
            }, ViewService
        }()
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return UIRouterGlobals
    }));
    var _params_stateParams__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(66),
        _common_queue__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(41),
        UIRouterGlobals = function() {
            function UIRouterGlobals() {
                this.params = new _params_stateParams__WEBPACK_IMPORTED_MODULE_0__.a, this.lastStartedTransitionId = -1, this.transitionHistory = new _common_queue__WEBPACK_IMPORTED_MODULE_1__.a([], 1), this.successfulTransitions = new _common_queue__WEBPACK_IMPORTED_MODULE_1__.a([], 1)
            }
            return UIRouterGlobals.prototype.dispose = function() {
                this.transitionHistory.clear(), this.successfulTransitions.clear(), this.transition = null
            }, UIRouterGlobals
        }()
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return UrlService
    }));
    var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6),
        _urlRules__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(79),
        _urlConfig__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(80),
        _state__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(36),
        UrlService = function() {
            function UrlService(router) {
                var _this = this;
                this.router = router, this.interceptDeferred = !1, this.rules = new _urlRules__WEBPACK_IMPORTED_MODULE_1__.a(this.router), this.config = new _urlConfig__WEBPACK_IMPORTED_MODULE_2__.a(this.router), this.url = function(newurl, replace, state) {
                    return _this.router.locationService.url(newurl, replace, state)
                }, this.path = function() {
                    return _this.router.locationService.path()
                }, this.search = function() {
                    return _this.router.locationService.search()
                }, this.hash = function() {
                    return _this.router.locationService.hash()
                }, this.onChange = function(callback) {
                    return _this.router.locationService.onChange(callback)
                }
            }
            return UrlService.prototype.dispose = function() {
                this.listen(!1), this.rules.dispose()
            }, UrlService.prototype.parts = function() {
                return {
                    path: this.path(),
                    search: this.search(),
                    hash: this.hash()
                }
            }, UrlService.prototype.sync = function(evt) {
                if (!evt || !evt.defaultPrevented) {
                    var _a = this.router,
                        urlService = _a.urlService,
                        stateService = _a.stateService,
                        url = {
                            path: urlService.path(),
                            search: urlService.search(),
                            hash: urlService.hash()
                        },
                        best = this.match(url);
                    Object(_common__WEBPACK_IMPORTED_MODULE_0__.C)([
                        [_common__WEBPACK_IMPORTED_MODULE_0__.v, function(newurl) {
                            return urlService.url(newurl, !0)
                        }],
                        [_state__WEBPACK_IMPORTED_MODULE_3__.TargetState.isDef, function(def) {
                            return stateService.go(def.state, def.params, def.options)
                        }],
                        [Object(_common__WEBPACK_IMPORTED_MODULE_0__.n)(_state__WEBPACK_IMPORTED_MODULE_3__.TargetState), function(target) {
                            return stateService.go(target.state(), target.params(), target.options())
                        }]
                    ])(best && best.rule.handler(best.match, url, this.router))
                }
            }, UrlService.prototype.listen = function(enabled) {
                var _this = this;
                if (!1 !== enabled) return this._stopListeningFn = this._stopListeningFn || this.router.urlService.onChange((function(evt) {
                    return _this.sync(evt)
                }));
                this._stopListeningFn && this._stopListeningFn(), delete this._stopListeningFn
            }, UrlService.prototype.deferIntercept = function(defer) {
                void 0 === defer && (defer = !0), this.interceptDeferred = defer
            }, UrlService.prototype.match = function(url) {
                var _this = this;
                url = Object(_common__WEBPACK_IMPORTED_MODULE_0__.h)({
                    path: "",
                    search: {},
                    hash: ""
                }, url);
                for (var best, rule, match, rules = this.rules.rules(), i = 0; i < rules.length && (!best || best.rule._group === rules[i]._group); i++) {
                    var current = (rule = rules[i], match = void 0, (match = rule.match(url, _this.router)) && {
                        match: match,
                        rule: rule,
                        weight: rule.matchPriority(match)
                    });
                    best = !best || current && current.weight > best.weight ? current : best
                }
                return best
            }, UrlService
        }()
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return UrlRules
    }));
    var defaultRuleSortFn, _state__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(36),
        _urlMatcher__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(29),
        _common__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(6),
        _urlRule__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(45);

    function getHandlerFn(handler) {
        if (!(Object(_common__WEBPACK_IMPORTED_MODULE_2__.q)(handler) || Object(_common__WEBPACK_IMPORTED_MODULE_2__.v)(handler) || Object(_common__WEBPACK_IMPORTED_MODULE_2__.n)(_state__WEBPACK_IMPORTED_MODULE_0__.TargetState)(handler) || _state__WEBPACK_IMPORTED_MODULE_0__.TargetState.isDef(handler))) throw new Error("'handler' must be a string, function, TargetState, or have a state: 'newtarget' property");
        return Object(_common__WEBPACK_IMPORTED_MODULE_2__.q)(handler) ? handler : Object(_common__WEBPACK_IMPORTED_MODULE_2__.R)(handler)
    }
    defaultRuleSortFn = function(a, b) {
        var cmp = function(a, b) {
            return (b.priority || 0) - (a.priority || 0)
        }(a, b);
        return 0 !== cmp || 0 !== (cmp = function(a, b) {
            var weights = {
                STATE: 4,
                URLMATCHER: 4,
                REGEXP: 3,
                RAW: 2,
                OTHER: 1
            };
            return (weights[a.type] || 0) - (weights[b.type] || 0)
        }(a, b)) || 0 !== (cmp = function(a, b) {
            return a.urlMatcher && b.urlMatcher ? _urlMatcher__WEBPACK_IMPORTED_MODULE_1__.a.compare(a.urlMatcher, b.urlMatcher) : 0
        }(a, b)) ? cmp : function(a, b) {
            var useMatchPriority = {
                STATE: !0,
                URLMATCHER: !0
            };
            return useMatchPriority[a.type] && useMatchPriority[b.type] ? 0 : (a.$id || 0) - (b.$id || 0)
        }(a, b)
    };
    var UrlRules = function() {
        function UrlRules(router) {
            this.router = router, this._sortFn = defaultRuleSortFn, this._rules = [], this._id = 0, this.urlRuleFactory = new _urlRule__WEBPACK_IMPORTED_MODULE_3__.b(router)
        }
        return UrlRules.prototype.dispose = function(router) {
            this._rules = [], delete this._otherwiseFn
        }, UrlRules.prototype.initial = function(handler) {
            var handlerFn = getHandlerFn(handler);
            this.rule(this.urlRuleFactory.create((function(urlParts, router) {
                return 0 === router.globals.transitionHistory.size() && !!/^\/?$/.exec(urlParts.path)
            }), handlerFn))
        }, UrlRules.prototype.otherwise = function(handler) {
            var handlerFn = getHandlerFn(handler);
            this._otherwiseFn = this.urlRuleFactory.create(Object(_common__WEBPACK_IMPORTED_MODULE_2__.R)(!0), handlerFn), this._sorted = !1
        }, UrlRules.prototype.removeRule = function(rule) {
            Object(_common__WEBPACK_IMPORTED_MODULE_2__.F)(this._rules, rule)
        }, UrlRules.prototype.rule = function(rule) {
            var _this = this;
            if (!_urlRule__WEBPACK_IMPORTED_MODULE_3__.b.isUrlRule(rule)) throw new Error("invalid rule");
            return rule.$id = this._id++, rule.priority = rule.priority || 0, this._rules.push(rule), this._sorted = !1,
                function() {
                    return _this.removeRule(rule)
                }
        }, UrlRules.prototype.rules = function() {
            return this.ensureSorted(), this._rules.concat(this._otherwiseFn ? [this._otherwiseFn] : [])
        }, UrlRules.prototype.sort = function(compareFn) {
            for (var sorted = this.stableSort(this._rules, this._sortFn = compareFn || this._sortFn), group = 0, i = 0; i < sorted.length; i++) sorted[i]._group = group, i < sorted.length - 1 && 0 !== this._sortFn(sorted[i], sorted[i + 1]) && group++;
            this._rules = sorted, this._sorted = !0
        }, UrlRules.prototype.ensureSorted = function() {
            this._sorted || this.sort()
        }, UrlRules.prototype.stableSort = function(arr, compareFn) {
            var arrOfWrapper = arr.map((function(elem, idx) {
                return {
                    elem: elem,
                    idx: idx
                }
            }));
            return arrOfWrapper.sort((function(wrapperA, wrapperB) {
                var cmpDiff = compareFn(wrapperA.elem, wrapperB.elem);
                return 0 === cmpDiff ? wrapperA.idx - wrapperB.idx : cmpDiff
            })), arrOfWrapper.map((function(wrapper) {
                return wrapper.elem
            }))
        }, UrlRules.prototype.when = function(matcher, handler, options) {
            var rule = this.urlRuleFactory.create(matcher, handler);
            return Object(_common__WEBPACK_IMPORTED_MODULE_2__.p)(options && options.priority) && (rule.priority = options.priority), this.rule(rule), rule
        }, UrlRules
    }()
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return UrlConfig
    }));
    var _params__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(27),
        _common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6),
        UrlConfig = function() {
            function UrlConfig(router) {
                var _this = this;
                this.router = router, this.paramTypes = new _params__WEBPACK_IMPORTED_MODULE_0__.ParamTypes, this._decodeParams = !0, this._isCaseInsensitive = !1, this._isStrictMode = !0, this._defaultSquashPolicy = !1, this.dispose = function() {
                    return _this.paramTypes.dispose()
                }, this.baseHref = function() {
                    return _this.router.locationConfig.baseHref()
                }, this.hashPrefix = function(newprefix) {
                    return _this.router.locationConfig.hashPrefix(newprefix)
                }, this.host = function() {
                    return _this.router.locationConfig.host()
                }, this.html5Mode = function() {
                    return _this.router.locationConfig.html5Mode()
                }, this.port = function() {
                    return _this.router.locationConfig.port()
                }, this.protocol = function() {
                    return _this.router.locationConfig.protocol()
                }
            }
            return UrlConfig.prototype.caseInsensitive = function(value) {
                return this._isCaseInsensitive = Object(_common__WEBPACK_IMPORTED_MODULE_1__.p)(value) ? value : this._isCaseInsensitive
            }, UrlConfig.prototype.defaultSquashPolicy = function(value) {
                if (Object(_common__WEBPACK_IMPORTED_MODULE_1__.p)(value) && !0 !== value && !1 !== value && !Object(_common__WEBPACK_IMPORTED_MODULE_1__.v)(value)) throw new Error("Invalid squash policy: " + value + ". Valid policies: false, true, arbitrary-string");
                return this._defaultSquashPolicy = Object(_common__WEBPACK_IMPORTED_MODULE_1__.p)(value) ? value : this._defaultSquashPolicy
            }, UrlConfig.prototype.strictMode = function(value) {
                return this._isStrictMode = Object(_common__WEBPACK_IMPORTED_MODULE_1__.p)(value) ? value : this._isStrictMode
            }, UrlConfig.prototype.type = function(name, definition, definitionFn) {
                var type = this.paramTypes.type(name, definition, definitionFn);
                return Object(_common__WEBPACK_IMPORTED_MODULE_1__.p)(definition) ? this : type
            }, UrlConfig
        }()
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return TransitionEventType
    }));
    var _transitionHook__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(20),
        TransitionEventType = function(name, hookPhase, hookOrder, criteriaMatchPath, reverseSort, getResultHandler, getErrorHandler, synchronous) {
            void 0 === reverseSort && (reverseSort = !1), void 0 === getResultHandler && (getResultHandler = _transitionHook__WEBPACK_IMPORTED_MODULE_0__.a.HANDLE_RESULT), void 0 === getErrorHandler && (getErrorHandler = _transitionHook__WEBPACK_IMPORTED_MODULE_0__.a.REJECT_ERROR), void 0 === synchronous && (synchronous = !1), this.name = name, this.hookPhase = hookPhase, this.hookOrder = hookOrder, this.criteriaMatchPath = criteriaMatchPath, this.reverseSort = reverseSort, this.getResultHandler = getResultHandler, this.getErrorHandler = getErrorHandler, this.synchronous = synchronous
        }
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return HashLocationService
    }));
    var extendStatics, _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(6),
        _baseLocationService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(35),
        __extends = (extendStatics = function(d, b) {
            return (extendStatics = Object.setPrototypeOf || {
                    __proto__: []
                }
                instanceof Array && function(d, b) {
                    d.__proto__ = b
                } || function(d, b) {
                    for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p])
                })(d, b)
        }, function(d, b) {
            function __() {
                this.constructor = d
            }
            extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __)
        }),
        HashLocationService = function(_super) {
            function HashLocationService(router) {
                var _this = _super.call(this, router, !1) || this;
                return _common__WEBPACK_IMPORTED_MODULE_0__.G.addEventListener("hashchange", _this._listener, !1), _this
            }
            return __extends(HashLocationService, _super), HashLocationService.prototype._get = function() {
                return Object(_common__WEBPACK_IMPORTED_MODULE_0__.O)(this._location.hash)
            }, HashLocationService.prototype._set = function(state, title, url, replace) {
                this._location.hash = url
            }, HashLocationService.prototype.dispose = function(router) {
                _super.prototype.dispose.call(this, router), _common__WEBPACK_IMPORTED_MODULE_0__.G.removeEventListener("hashchange", this._listener)
            }, HashLocationService
        }(_baseLocationService__WEBPACK_IMPORTED_MODULE_1__.a)
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return MemoryLocationService
    }));
    var extendStatics, _baseLocationService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(35),
        __extends = (extendStatics = function(d, b) {
            return (extendStatics = Object.setPrototypeOf || {
                    __proto__: []
                }
                instanceof Array && function(d, b) {
                    d.__proto__ = b
                } || function(d, b) {
                    for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p])
                })(d, b)
        }, function(d, b) {
            function __() {
                this.constructor = d
            }
            extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __)
        }),
        MemoryLocationService = function(_super) {
            function MemoryLocationService(router) {
                return _super.call(this, router, !0) || this
            }
            return __extends(MemoryLocationService, _super), MemoryLocationService.prototype._get = function() {
                return this._url
            }, MemoryLocationService.prototype._set = function(state, title, url, replace) {
                this._url = url
            }, MemoryLocationService
        }(_baseLocationService__WEBPACK_IMPORTED_MODULE_0__.a)
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return PushStateLocationService
    }));
    var extendStatics, _baseLocationService__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(35),
        _common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(6),
        __extends = (extendStatics = function(d, b) {
            return (extendStatics = Object.setPrototypeOf || {
                    __proto__: []
                }
                instanceof Array && function(d, b) {
                    d.__proto__ = b
                } || function(d, b) {
                    for (var p in b) b.hasOwnProperty(p) && (d[p] = b[p])
                })(d, b)
        }, function(d, b) {
            function __() {
                this.constructor = d
            }
            extendStatics(d, b), d.prototype = null === b ? Object.create(b) : (__.prototype = b.prototype, new __)
        }),
        PushStateLocationService = function(_super) {
            function PushStateLocationService(router) {
                var _this = _super.call(this, router, !0) || this;
                return _this._config = router.urlService.config, _common__WEBPACK_IMPORTED_MODULE_1__.G.addEventListener("popstate", _this._listener, !1), _this
            }
            return __extends(PushStateLocationService, _super), PushStateLocationService.prototype._getBasePrefix = function() {
                return Object(_common__WEBPACK_IMPORTED_MODULE_1__.L)(this._config.baseHref())
            }, PushStateLocationService.prototype._get = function() {
                var _a = this._location,
                    pathname = _a.pathname,
                    hash = _a.hash,
                    search = _a.search;
                search = Object(_common__WEBPACK_IMPORTED_MODULE_1__.K)(search)[1], hash = Object(_common__WEBPACK_IMPORTED_MODULE_1__.J)(hash)[1];
                var basePrefix = this._getBasePrefix(),
                    exactBaseHrefMatch = pathname === this._config.baseHref(),
                    startsWithBase = pathname.substr(0, basePrefix.length) === basePrefix;
                return (pathname = exactBaseHrefMatch ? "/" : startsWithBase ? pathname.substring(basePrefix.length) : pathname) + (search ? "?" + search : "") + (hash ? "#" + hash : "")
            }, PushStateLocationService.prototype._set = function(state, title, url, replace) {
                var basePrefix = this._getBasePrefix(),
                    slash = url && "/" !== url[0] ? "/" : "",
                    fullUrl = "" === url || "/" === url ? this._config.baseHref() : basePrefix + slash + url;
                replace ? this._history.replaceState(state, title, fullUrl) : this._history.pushState(state, title, fullUrl)
            }, PushStateLocationService.prototype.dispose = function(router) {
                _super.prototype.dispose.call(this, router), _common__WEBPACK_IMPORTED_MODULE_1__.G.removeEventListener("popstate", this._listener)
            }, PushStateLocationService
        }(_baseLocationService__WEBPACK_IMPORTED_MODULE_0__.a)
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return MemoryLocationConfig
    }));
    var _common_predicates__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4),
        _common_common__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(2),
        MemoryLocationConfig = function() {
            var _this = this;
            this.dispose = _common_common__WEBPACK_IMPORTED_MODULE_1__.x, this._baseHref = "", this._port = 80, this._protocol = "http", this._host = "localhost", this._hashPrefix = "", this.port = function() {
                return _this._port
            }, this.protocol = function() {
                return _this._protocol
            }, this.host = function() {
                return _this._host
            }, this.baseHref = function() {
                return _this._baseHref
            }, this.html5Mode = function() {
                return !1
            }, this.hashPrefix = function(newval) {
                return Object(_common_predicates__WEBPACK_IMPORTED_MODULE_0__.c)(newval) ? _this._hashPrefix = newval : _this._hashPrefix
            }
        }
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return StateProvider
    }));
    var _uirouter_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1),
        StateProvider = function() {
            function StateProvider(stateRegistry, stateService) {
                this.stateRegistry = stateRegistry, this.stateService = stateService, Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.createProxyFunctions)(Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.val)(StateProvider.prototype), this, Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.val)(this))
            }
            return StateProvider.prototype.decorator = function(name, func) {
                return this.stateRegistry.decorator(name, func) || this
            }, StateProvider.prototype.state = function(name, definition) {
                return Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.isObject)(name) ? definition = name : definition.name = name, this.stateRegistry.register(definition), this
            }, StateProvider.prototype.onInvalid = function(callback) {
                return this.stateService.onInvalid(callback)
            }, StateProvider
        }()
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return UrlRouterProvider
    }));
    var _uirouter_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1),
        UrlRouterProvider = function() {
            function UrlRouterProvider(router) {
                this.router = router
            }
            return UrlRouterProvider.injectableHandler = function(router, handler) {
                return function(match) {
                    return _uirouter_core__WEBPACK_IMPORTED_MODULE_0__.services.$injector.invoke(handler, null, {
                        $match: match,
                        $stateParams: router.globals.params
                    })
                }
            }, UrlRouterProvider.prototype.$get = function() {
                var urlService = this.router.urlService;
                return this.router.urlRouter.update(!0), urlService.interceptDeferred || urlService.listen(), this.router.urlRouter
            }, UrlRouterProvider.prototype.rule = function(ruleFn) {
                var _this = this;
                if (!Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.isFunction)(ruleFn)) throw new Error("'rule' must be a function");
                var rule = new _uirouter_core__WEBPACK_IMPORTED_MODULE_0__.BaseUrlRule((function() {
                    return ruleFn(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.services.$injector, _this.router.locationService)
                }), _uirouter_core__WEBPACK_IMPORTED_MODULE_0__.identity);
                return this.router.urlService.rules.rule(rule), this
            }, UrlRouterProvider.prototype.otherwise = function(rule) {
                var _this = this,
                    urlRules = this.router.urlService.rules;
                if (Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.isString)(rule)) urlRules.otherwise(rule);
                else {
                    if (!Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.isFunction)(rule)) throw new Error("'rule' must be a string or function");
                    urlRules.otherwise((function() {
                        return rule(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.services.$injector, _this.router.locationService)
                    }))
                }
                return this
            }, UrlRouterProvider.prototype.when = function(what, handler) {
                return (Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.isArray)(handler) || Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.isFunction)(handler)) && (handler = UrlRouterProvider.injectableHandler(this.router, handler)), this.router.urlService.rules.when(what, handler), this
            }, UrlRouterProvider.prototype.deferIntercept = function(defer) {
                this.router.urlService.deferIntercept(defer)
            }, UrlRouterProvider
        }()
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return getLocals
    }));
    var angular = __webpack_require__(16),
        lib_esm = __webpack_require__(1),
        views = __webpack_require__(46),
        templateFactory_TemplateFactory = function() {
            function TemplateFactory() {
                var _this = this;
                this._useHttp = angular.a.version.minor < 3, this.$get = ["$http", "$templateCache", "$injector", function($http, $templateCache, $injector) {
                    return _this.$templateRequest = $injector.has && $injector.has("$templateRequest") && $injector.get("$templateRequest"), _this.$http = $http, _this.$templateCache = $templateCache, _this
                }]
            }
            return TemplateFactory.prototype.useHttpService = function(value) {
                this._useHttp = value
            }, TemplateFactory.prototype.fromConfig = function(config, params, context) {
                var asTemplate = function(result) {
                        return lib_esm.services.$q.when(result).then((function(str) {
                            return {
                                template: str
                            }
                        }))
                    },
                    asComponent = function(result) {
                        return lib_esm.services.$q.when(result).then((function(str) {
                            return {
                                component: str
                            }
                        }))
                    };
                return Object(lib_esm.isDefined)(config.template) ? asTemplate(this.fromString(config.template, params)) : Object(lib_esm.isDefined)(config.templateUrl) ? asTemplate(this.fromUrl(config.templateUrl, params)) : Object(lib_esm.isDefined)(config.templateProvider) ? asTemplate(this.fromProvider(config.templateProvider, params, context)) : Object(lib_esm.isDefined)(config.component) ? asComponent(config.component) : Object(lib_esm.isDefined)(config.componentProvider) ? asComponent(this.fromComponentProvider(config.componentProvider, params, context)) : asTemplate("<ui-view></ui-view>")
            }, TemplateFactory.prototype.fromString = function(template, params) {
                return Object(lib_esm.isFunction)(template) ? template(params) : template
            }, TemplateFactory.prototype.fromUrl = function(url, params) {
                return Object(lib_esm.isFunction)(url) && (url = url(params)), null == url ? null : this._useHttp ? this.$http.get(url, {
                    cache: this.$templateCache,
                    headers: {
                        Accept: "text/html"
                    }
                }).then((function(response) {
                    return response.data
                })) : this.$templateRequest(url)
            }, TemplateFactory.prototype.fromProvider = function(provider, params, context) {
                var deps = lib_esm.services.$injector.annotate(provider),
                    providerFn = Object(lib_esm.isArray)(provider) ? Object(lib_esm.tail)(provider) : provider;
                return new lib_esm.Resolvable("", providerFn, deps).get(context)
            }, TemplateFactory.prototype.fromComponentProvider = function(provider, params, context) {
                var deps = lib_esm.services.$injector.annotate(provider),
                    providerFn = Object(lib_esm.isArray)(provider) ? Object(lib_esm.tail)(provider) : provider;
                return new lib_esm.Resolvable("", providerFn, deps).get(context)
            }, TemplateFactory.prototype.makeComponentTemplate = function(uiView, context, component, bindings) {
                bindings = bindings || {};
                var prefix = angular.a.version.minor >= 3 ? "::" : "",
                    kebob = function(camelCase) {
                        var kebobed = Object(lib_esm.kebobString)(camelCase);
                        return /^(x|data)-/.exec(kebobed) ? "x-" + kebobed : kebobed
                    },
                    attrs = function(name) {
                        var cmpDefs = lib_esm.services.$injector.get(name + "Directive");
                        if (!cmpDefs || !cmpDefs.length) throw new Error("Unable to find component named '" + name + "'");
                        return cmpDefs.map(getBindings).reduce(lib_esm.unnestR, [])
                    }(component).map((function(input) {
                        var name = input.name,
                            type = input.type,
                            attrName = kebob(name);
                        if (uiView.attr(attrName) && !bindings[name]) return attrName + "='" + uiView.attr(attrName) + "'";
                        var resolveName = bindings[name] || name;
                        if ("@" === type) return attrName + "='{{" + prefix + "$resolve." + resolveName + "}}'";
                        if ("&" === type) {
                            var res = context.getResolvable(resolveName),
                                fn = res && res.data,
                                args = fn && lib_esm.services.$injector.annotate(fn) || [];
                            return attrName + "='$resolve." + resolveName + (Object(lib_esm.isArray)(fn) ? "[" + (fn.length - 1) + "]" : "") + "(" + args.join(",") + ")'"
                        }
                        return attrName + "='" + prefix + "$resolve." + resolveName + "'"
                    })).join(" "),
                    kebobName = kebob(component);
                return "<" + kebobName + " " + attrs + "></" + kebobName + ">"
            }, TemplateFactory
        }();
    var getBindings = function(def) {
            return Object(lib_esm.isObject)(def.bindToController) ? scopeBindings(def.bindToController) : scopeBindings(def.scope)
        },
        scopeBindings = function(bindingsObj) {
            return Object.keys(bindingsObj || {}).map((function(key) {
                return [key, /^([=<@&])[?]?(.*)/.exec(bindingsObj[key])]
            })).filter((function(tuple) {
                return Object(lib_esm.isDefined)(tuple) && Object(lib_esm.isArray)(tuple[1])
            })).map((function(tuple) {
                return {
                    name: tuple[1][2] || tuple[0],
                    type: tuple[1][1]
                }
            }))
        },
        stateProvider = __webpack_require__(86),
        getStateHookBuilder = function(hookName) {
            return function(stateObject) {
                var hook = stateObject[hookName],
                    pathname = "onExit" === hookName ? "from" : "to";
                return hook ? function(trans, state) {
                    var subContext = new lib_esm.ResolveContext(trans.treeChanges(pathname)).subContext(state.$$state()),
                        locals = Object(lib_esm.extend)(getLocals(subContext), {
                            $state$: state,
                            $transition$: trans
                        });
                    return lib_esm.services.$injector.invoke(hook, this, locals)
                } : void 0
            }
        },
        locationServices_Ng1LocationServices = function() {
            function Ng1LocationServices($locationProvider) {
                this._urlListeners = [], this.$locationProvider = $locationProvider;
                var _lp = Object(lib_esm.val)($locationProvider);
                Object(lib_esm.createProxyFunctions)(_lp, this, _lp, ["hashPrefix"])
            }
            return Ng1LocationServices.monkeyPatchPathParameterType = function(router) {
                var pathType = router.urlMatcherFactory.type("path");
                pathType.encode = function(x) {
                    return null != x ? x.toString().replace(/(~|\/)/g, (function(m) {
                        return {
                            "~": "~~",
                            "/": "~2F"
                        }[m]
                    })) : x
                }, pathType.decode = function(x) {
                    return null != x ? x.toString().replace(/(~~|~2F)/g, (function(m) {
                        return {
                            "~~": "~",
                            "~2F": "/"
                        }[m]
                    })) : x
                }
            }, Ng1LocationServices.prototype.dispose = function() {}, Ng1LocationServices.prototype.onChange = function(callback) {
                var _this = this;
                return this._urlListeners.push(callback),
                    function() {
                        return Object(lib_esm.removeFrom)(_this._urlListeners)(callback)
                    }
            }, Ng1LocationServices.prototype.html5Mode = function() {
                var html5Mode = this.$locationProvider.html5Mode();
                return (html5Mode = Object(lib_esm.isObject)(html5Mode) ? html5Mode.enabled : html5Mode) && this.$sniffer.history
            }, Ng1LocationServices.prototype.baseHref = function() {
                return this._baseHref || (this._baseHref = this.$browser.baseHref() || this.$window.location.pathname)
            }, Ng1LocationServices.prototype.url = function(newUrl, replace, state) {
                return void 0 === replace && (replace = !1), Object(lib_esm.isDefined)(newUrl) && this.$location.url(newUrl), replace && this.$location.replace(), state && this.$location.state(state), this.$location.url()
            }, Ng1LocationServices.prototype._runtimeServices = function($rootScope, $location, $sniffer, $browser, $window) {
                var _this = this;
                this.$location = $location, this.$sniffer = $sniffer, this.$browser = $browser, this.$window = $window, $rootScope.$on("$locationChangeSuccess", (function(evt) {
                    return _this._urlListeners.forEach((function(fn) {
                        return fn(evt)
                    }))
                }));
                var _loc = Object(lib_esm.val)($location);
                Object(lib_esm.createProxyFunctions)(_loc, this, _loc, ["replace", "path", "search", "hash"]), Object(lib_esm.createProxyFunctions)(_loc, this, _loc, ["port", "protocol", "host"])
            }, Ng1LocationServices
        }(),
        urlRouterProvider = __webpack_require__(87);
    angular.a.module("ui.router.angular1", []);
    var mod_init = angular.a.module("ui.router.init", ["ng"]),
        mod_util = angular.a.module("ui.router.util", ["ui.router.init"]),
        mod_rtr = angular.a.module("ui.router.router", ["ui.router.util"]),
        mod_state = angular.a.module("ui.router.state", ["ui.router.router", "ui.router.util", "ui.router.angular1"]),
        mod_main = angular.a.module("ui.router", ["ui.router.init", "ui.router.state", "ui.router.angular1"]),
        router = (angular.a.module("ui.router.compat", ["ui.router"]), null);

    function $uiRouterProvider($locationProvider) {
        (router = this.router = new lib_esm.UIRouter).stateProvider = new stateProvider.a(router.stateRegistry, router.stateService), router.stateRegistry.decorator("views", views.c), router.stateRegistry.decorator("onExit", getStateHookBuilder("onExit")), router.stateRegistry.decorator("onRetain", getStateHookBuilder("onRetain")), router.stateRegistry.decorator("onEnter", getStateHookBuilder("onEnter")), router.viewService._pluginapi._viewConfigFactory("ng1", Object(views.b)()), router.urlService.config._decodeParams = !1;
        var ng1LocationService = router.locationService = router.locationConfig = new locationServices_Ng1LocationServices($locationProvider);

        function $get($location, $browser, $window, $sniffer, $rootScope, $http, $templateCache) {
            return ng1LocationService._runtimeServices($rootScope, $location, $sniffer, $browser, $window), delete router.router, delete router.$get, router
        }
        return locationServices_Ng1LocationServices.monkeyPatchPathParameterType(router), router.router = router, router.$get = $get, $get.$inject = ["$location", "$browser", "$window", "$sniffer", "$rootScope", "$http", "$templateCache"], router
    }
    $uiRouterProvider.$inject = ["$locationProvider"];
    var getProviderFor = function(serviceName) {
        return ["$uiRouterProvider", function($urp) {
            var service = $urp.router[serviceName];
            return service.$get = function() {
                return service
            }, service
        }]
    };

    function runBlock($injector, $q, $uiRouter) {
        if (lib_esm.services.$injector = $injector, lib_esm.services.$q = $q, !Object.prototype.hasOwnProperty.call($injector, "strictDi")) try {
            $injector.invoke((function(checkStrictDi) {}))
        } catch (error) {
            $injector.strictDi = !!/strict mode/.exec(error && error.toString())
        }
        $uiRouter.stateRegistry.get().map((function(x) {
            return x.$$state().resolvables
        })).reduce(lib_esm.unnestR, []).filter((function(x) {
            return "deferred" === x.deps
        })).forEach((function(resolvable) {
            return resolvable.deps = $injector.annotate(resolvable.resolveFn, $injector.strictDi)
        }))
    }
    runBlock.$inject = ["$injector", "$q", "$uiRouter"];

    function watchDigests($rootScope) {
        $rootScope.$watch((function() {
            lib_esm.trace.approximateDigests++
        }))
    }
    watchDigests.$inject = ["$rootScope"], mod_init.provider("$uiRouter", $uiRouterProvider), mod_rtr.provider("$urlRouter", ["$uiRouterProvider", function(uiRouter) {
        return uiRouter.urlRouterProvider = new urlRouterProvider.a(uiRouter)
    }]), mod_util.provider("$urlService", getProviderFor("urlService")), mod_util.provider("$urlMatcherFactory", ["$uiRouterProvider", function() {
        return router.urlMatcherFactory
    }]), mod_util.provider("$templateFactory", (function() {
        return new templateFactory_TemplateFactory
    })), mod_state.provider("$stateRegistry", getProviderFor("stateRegistry")), mod_state.provider("$uiRouterGlobals", getProviderFor("globals")), mod_state.provider("$transitions", getProviderFor("transitionService")), mod_state.provider("$state", ["$uiRouterProvider", function() {
        return Object(lib_esm.extend)(router.stateProvider, {
            $get: function() {
                return router.stateService
            }
        })
    }]), mod_state.factory("$stateParams", ["$uiRouter", function($uiRouter) {
        return $uiRouter.globals.params
    }]), mod_main.factory("$view", (function() {
        return router.viewService
    })), mod_main.service("$trace", (function() {
        return lib_esm.trace
    })), mod_main.run(watchDigests), mod_util.run(["$urlMatcherFactory", function($urlMatcherFactory) {}]), mod_state.run(["$state", function($state) {}]), mod_rtr.run(["$urlRouter", function($urlRouter) {}]), mod_init.run(runBlock);
    var getLocals = function(ctx) {
        return ctx.getTokens().filter(lib_esm.isString).map((function(key) {
            var resolvable = ctx.getResolvable(key);
            return [key, "NOWAIT" === ctx.getPolicy(resolvable).async ? resolvable.promise : resolvable.data]
        })).reduce(lib_esm.applyPairs, {})
    }
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "b", (function() {
        return registerLazyLoadHook
    })), __webpack_require__.d(__webpack_exports__, "a", (function() {
        return lazyLoadState
    }));
    var _common_coreservices__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(9),
        lazyLoadHook = function(transition) {
            var router = transition.router;
            var promises = transition.entering().filter((function(state) {
                return !!state.$$state().lazyLoad
            })).map((function(state) {
                return lazyLoadState(transition, state)
            }));
            return _common_coreservices__WEBPACK_IMPORTED_MODULE_0__.b.$q.all(promises).then((function() {
                if ("url" !== transition.originalTransition().options().source) {
                    var orig = transition.targetState();
                    return router.stateService.target(orig.identifier(), orig.params(), orig.options())
                }
                var $url = router.urlService,
                    result = $url.match($url.parts()),
                    rule = result && result.rule;
                if (rule && "STATE" === rule.type) {
                    var state = rule.state,
                        params = result.match;
                    return router.stateService.target(state, params, transition.options())
                }
                router.urlService.sync()
            }))
        },
        registerLazyLoadHook = function(transitionService) {
            return transitionService.onBefore({
                entering: function(state) {
                    return !!state.lazyLoad
                }
            }, lazyLoadHook)
        };

    function lazyLoadState(transition, state) {
        var lazyLoadFn = state.$$state().lazyLoad,
            promise = lazyLoadFn._promise;
        if (!promise) {
            promise = lazyLoadFn._promise = _common_coreservices__WEBPACK_IMPORTED_MODULE_0__.b.$q.when(lazyLoadFn(transition, state)).then((function(result) {
                result && Array.isArray(result.states) && result.states.forEach((function(_state) {
                    return transition.router.stateRegistry.register(_state)
                }));
                return result
            })).then((function(result) {
                return delete state.lazyLoad, delete state.$$state().lazyLoad, delete lazyLoadFn._promise, result
            }), (function(err) {
                return delete lazyLoadFn._promise, _common_coreservices__WEBPACK_IMPORTED_MODULE_0__.b.$q.reject(err)
            }))
        }
        return promise
    }
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return isArray
    }));
    var isArray = function() {
        return Array.isArray || function(x) {
            return x && "number" == typeof x.length
        }
    }()
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    function isObject(x) {
        return null !== x && "object" == typeof x
    }
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return isObject
    }))
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return SubjectSubscription
    }));
    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7),
        SubjectSubscription = function(_super) {
            function SubjectSubscription(subject, subscriber) {
                var _this = _super.call(this) || this;
                return _this.subject = subject, _this.subscriber = subscriber, _this.closed = !1, _this
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(SubjectSubscription, _super), SubjectSubscription.prototype.unsubscribe = function() {
                if (!this.closed) {
                    this.closed = !0;
                    var subject = this.subject,
                        observers = subject.observers;
                    if (this.subject = null, observers && 0 !== observers.length && !subject.isStopped && !subject.closed) {
                        var subscriberIndex = observers.indexOf(this.subscriber); - 1 !== subscriberIndex && observers.splice(subscriberIndex, 1)
                    }
                }
            }, SubjectSubscription
        }(__webpack_require__(15).a)
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return subscribeToArray
    }));
    var subscribeToArray = function(array) {
        return function(subscriber) {
            for (var i = 0, len = array.length; i < len && !subscriber.closed; i++) subscriber.next(array[i]);
            subscriber.complete()
        }
    }
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return empty
    }));
    var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12),
        EMPTY = new _Observable__WEBPACK_IMPORTED_MODULE_0__.a((function(subscriber) {
            return subscriber.complete()
        }));

    function empty(scheduler) {
        return scheduler ? function(scheduler) {
            return new _Observable__WEBPACK_IMPORTED_MODULE_0__.a((function(subscriber) {
                return scheduler.schedule((function() {
                    return subscriber.complete()
                }))
            }))
        }(scheduler) : EMPTY
    }
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return isArrayLike
    }));
    var isArrayLike = function(x) {
        return x && "number" == typeof x.length && "function" != typeof x
    }
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";

    function isPromise(value) {
        return !!value && "function" != typeof value.subscribe && "function" == typeof value.then
    }
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return isPromise
    }))
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return mergeAll
    }));
    var _mergeMap__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(258),
        _util_identity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(53);

    function mergeAll(concurrent) {
        return void 0 === concurrent && (concurrent = Number.POSITIVE_INFINITY), Object(_mergeMap__WEBPACK_IMPORTED_MODULE_0__.a)(_util_identity__WEBPACK_IMPORTED_MODULE_1__.a, concurrent)
    }
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return ui_router_rx_UIRouterRx
    }));
    __webpack_require__(271);
    var ReplaySubject = __webpack_require__(102),
        mergeMap = __webpack_require__(258),
        tslib_es6 = __webpack_require__(7),
        Subscriber = __webpack_require__(11);

    function filter(predicate, thisArg) {
        return function(source) {
            return source.lift(new FilterOperator(predicate, thisArg))
        }
    }
    var FilterOperator = function() {
            function FilterOperator(predicate, thisArg) {
                this.predicate = predicate, this.thisArg = thisArg
            }
            return FilterOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new filter_FilterSubscriber(subscriber, this.predicate, this.thisArg))
            }, FilterOperator
        }(),
        filter_FilterSubscriber = function(_super) {
            function FilterSubscriber(destination, predicate, thisArg) {
                var _this = _super.call(this, destination) || this;
                return _this.predicate = predicate, _this.thisArg = thisArg, _this.count = 0, _this
            }
            return tslib_es6.a(FilterSubscriber, _super), FilterSubscriber.prototype._next = function(value) {
                var result;
                try {
                    result = this.predicate.call(this.thisArg, value, this.count++)
                } catch (err) {
                    return void this.destination.error(err)
                }
                result && this.destination.next(value)
            }, FilterSubscriber
        }(Subscriber.a),
        map = __webpack_require__(63),
        ui_router_rx_UIRouterRx = function() {
            function UIRouterRx(router) {
                this.name = "@uirouter/rx", this.deregisterFns = [];
                var start$ = new ReplaySubject.a(1),
                    success$ = start$.pipe(Object(mergeMap.a)((function(t) {
                        return t.promise.then((function() {
                            return t
                        }), (function() {
                            return null
                        }))
                    })), filter((function(t) {
                        return !!t
                    }))),
                    params$ = success$.pipe(Object(map.a)((function(transition) {
                        return transition.params()
                    }))),
                    states$ = new ReplaySubject.a(1);

                function onStatesChangedEvent(event, states) {
                    var changeEvent = {
                        currentStates: router.stateRegistry.get(),
                        registered: [],
                        deregistered: []
                    };
                    event && (changeEvent[event] = states), states$.next(changeEvent)
                }
                this.deregisterFns.push(router.transitionService.onStart({}, (function(transition) {
                    return start$.next(transition)
                }))), this.deregisterFns.push(router.stateRegistry.onStatesChanged(onStatesChangedEvent)), onStatesChangedEvent(null, null), Object.assign(router.globals, {
                    start$: start$,
                    success$: success$,
                    params$: params$,
                    states$: states$
                })
            }
            return UIRouterRx.prototype.dispose = function() {
                this.deregisterFns.forEach((function(deregisterFn) {
                    return deregisterFn()
                })), this.deregisterFns = []
            }, UIRouterRx
        }();
    __webpack_require__(12), __webpack_require__(62);
    __webpack_require__(94);
    Subscriber.a;
    Subscriber.a;
    Subscriber.a;
    __webpack_require__(53)
}, , , function(module, exports, __webpack_require__) {
    "use strict";
    (function(global) {
        module.exports = function() {
            if ("object" == typeof globalThis) return globalThis;
            var g;
            try {
                g = this || new Function("return this")()
            } catch (e) {
                if ("object" == typeof window) return window;
                if ("object" == typeof self) return self;
                if (void 0 !== global) return global
            }
            return g
        }()
    }).call(this, __webpack_require__(65))
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return ReplaySubject_ReplaySubject
    }));
    var NotificationKind, tslib_es6 = __webpack_require__(7),
        Subject = __webpack_require__(32),
        Subscription = __webpack_require__(15),
        QueueAction_QueueAction = function(_super) {
            function QueueAction(scheduler, work) {
                var _this = _super.call(this, scheduler, work) || this;
                return _this.scheduler = scheduler, _this.work = work, _this
            }
            return tslib_es6.a(QueueAction, _super), QueueAction.prototype.schedule = function(state, delay) {
                return void 0 === delay && (delay = 0), delay > 0 ? _super.prototype.schedule.call(this, state, delay) : (this.delay = delay, this.state = state, this.scheduler.flush(this), this)
            }, QueueAction.prototype.execute = function(state, delay) {
                return delay > 0 || this.closed ? _super.prototype.execute.call(this, state, delay) : this._execute(state, delay)
            }, QueueAction.prototype.requestAsyncId = function(scheduler, id, delay) {
                return void 0 === delay && (delay = 0), null !== delay && delay > 0 || null === delay && this.delay > 0 ? _super.prototype.requestAsyncId.call(this, scheduler, id, delay) : scheduler.flush(this)
            }, QueueAction
        }(function(_super) {
            function AsyncAction(scheduler, work) {
                var _this = _super.call(this, scheduler, work) || this;
                return _this.scheduler = scheduler, _this.work = work, _this.pending = !1, _this
            }
            return tslib_es6.a(AsyncAction, _super), AsyncAction.prototype.schedule = function(state, delay) {
                if (void 0 === delay && (delay = 0), this.closed) return this;
                this.state = state;
                var id = this.id,
                    scheduler = this.scheduler;
                return null != id && (this.id = this.recycleAsyncId(scheduler, id, delay)), this.pending = !0, this.delay = delay, this.id = this.id || this.requestAsyncId(scheduler, this.id, delay), this
            }, AsyncAction.prototype.requestAsyncId = function(scheduler, id, delay) {
                return void 0 === delay && (delay = 0), setInterval(scheduler.flush.bind(scheduler, this), delay)
            }, AsyncAction.prototype.recycleAsyncId = function(scheduler, id, delay) {
                if (void 0 === delay && (delay = 0), null !== delay && this.delay === delay && !1 === this.pending) return id;
                clearInterval(id)
            }, AsyncAction.prototype.execute = function(state, delay) {
                if (this.closed) return new Error("executing a cancelled action");
                this.pending = !1;
                var error = this._execute(state, delay);
                if (error) return error;
                !1 === this.pending && null != this.id && (this.id = this.recycleAsyncId(this.scheduler, this.id, null))
            }, AsyncAction.prototype._execute = function(state, delay) {
                var errored = !1,
                    errorValue = void 0;
                try {
                    this.work(state)
                } catch (e) {
                    errored = !0, errorValue = !!e && e || new Error(e)
                }
                if (errored) return this.unsubscribe(), errorValue
            }, AsyncAction.prototype._unsubscribe = function() {
                var id = this.id,
                    scheduler = this.scheduler,
                    actions = scheduler.actions,
                    index = actions.indexOf(this);
                this.work = null, this.state = null, this.pending = !1, this.scheduler = null, -1 !== index && actions.splice(index, 1), null != id && (this.id = this.recycleAsyncId(scheduler, id, null)), this.delay = null
            }, AsyncAction
        }(function(_super) {
            function Action(scheduler, work) {
                return _super.call(this) || this
            }
            return tslib_es6.a(Action, _super), Action.prototype.schedule = function(state, delay) {
                return void 0 === delay && (delay = 0), this
            }, Action
        }(Subscription.a))),
        Scheduler = function() {
            function Scheduler(SchedulerAction, now) {
                void 0 === now && (now = Scheduler.now), this.SchedulerAction = SchedulerAction, this.now = now
            }
            return Scheduler.prototype.schedule = function(work, delay, state) {
                return void 0 === delay && (delay = 0), new this.SchedulerAction(this, work).schedule(state, delay)
            }, Scheduler.now = function() {
                return Date.now()
            }, Scheduler
        }(),
        queue = new(function(_super) {
            function QueueScheduler() {
                return null !== _super && _super.apply(this, arguments) || this
            }
            return tslib_es6.a(QueueScheduler, _super), QueueScheduler
        }(function(_super) {
            function AsyncScheduler(SchedulerAction, now) {
                void 0 === now && (now = Scheduler.now);
                var _this = _super.call(this, SchedulerAction, (function() {
                    return AsyncScheduler.delegate && AsyncScheduler.delegate !== _this ? AsyncScheduler.delegate.now() : now()
                })) || this;
                return _this.actions = [], _this.active = !1, _this.scheduled = void 0, _this
            }
            return tslib_es6.a(AsyncScheduler, _super), AsyncScheduler.prototype.schedule = function(work, delay, state) {
                return void 0 === delay && (delay = 0), AsyncScheduler.delegate && AsyncScheduler.delegate !== this ? AsyncScheduler.delegate.schedule(work, delay, state) : _super.prototype.schedule.call(this, work, delay, state)
            }, AsyncScheduler.prototype.flush = function(action) {
                var actions = this.actions;
                if (this.active) actions.push(action);
                else {
                    var error;
                    this.active = !0;
                    do {
                        if (error = action.execute(action.state, action.delay)) break
                    } while (action = actions.shift());
                    if (this.active = !1, error) {
                        for (; action = actions.shift();) action.unsubscribe();
                        throw error
                    }
                }
            }, AsyncScheduler
        }(Scheduler)))(QueueAction_QueueAction),
        Subscriber = __webpack_require__(11),
        empty = __webpack_require__(94),
        of = __webpack_require__(62),
        Observable = __webpack_require__(12);

    function dispatch(_a) {
        var error = _a.error;
        _a.subscriber.error(error)
    }
    NotificationKind || (NotificationKind = {});
    var Notification_Notification = function() {
        function Notification(kind, value, error) {
            this.kind = kind, this.value = value, this.error = error, this.hasValue = "N" === kind
        }
        return Notification.prototype.observe = function(observer) {
            switch (this.kind) {
                case "N":
                    return observer.next && observer.next(this.value);
                case "E":
                    return observer.error && observer.error(this.error);
                case "C":
                    return observer.complete && observer.complete()
            }
        }, Notification.prototype.do = function(next, error, complete) {
            switch (this.kind) {
                case "N":
                    return next && next(this.value);
                case "E":
                    return error && error(this.error);
                case "C":
                    return complete && complete()
            }
        }, Notification.prototype.accept = function(nextOrObserver, error, complete) {
            return nextOrObserver && "function" == typeof nextOrObserver.next ? this.observe(nextOrObserver) : this.do(nextOrObserver, error, complete)
        }, Notification.prototype.toObservable = function() {
            var error, scheduler;
            switch (this.kind) {
                case "N":
                    return Object( of .a)(this.value);
                case "E":
                    return error = this.error, scheduler ? new Observable.a((function(subscriber) {
                        return scheduler.schedule(dispatch, 0, {
                            error: error,
                            subscriber: subscriber
                        })
                    })) : new Observable.a((function(subscriber) {
                        return subscriber.error(error)
                    }));
                case "C":
                    return Object(empty.a)()
            }
            throw new Error("unexpected notification kind value")
        }, Notification.createNext = function(value) {
            return void 0 !== value ? new Notification("N", value) : Notification.undefinedValueNotification
        }, Notification.createError = function(err) {
            return new Notification("E", void 0, err)
        }, Notification.createComplete = function() {
            return Notification.completeNotification
        }, Notification.completeNotification = new Notification("C"), Notification.undefinedValueNotification = new Notification("N", void 0), Notification
    }();
    var observeOn_ObserveOnSubscriber = function(_super) {
            function ObserveOnSubscriber(destination, scheduler, delay) {
                void 0 === delay && (delay = 0);
                var _this = _super.call(this, destination) || this;
                return _this.scheduler = scheduler, _this.delay = delay, _this
            }
            return tslib_es6.a(ObserveOnSubscriber, _super), ObserveOnSubscriber.dispatch = function(arg) {
                var notification = arg.notification,
                    destination = arg.destination;
                notification.observe(destination), this.unsubscribe()
            }, ObserveOnSubscriber.prototype.scheduleMessage = function(notification) {
                this.destination.add(this.scheduler.schedule(ObserveOnSubscriber.dispatch, this.delay, new ObserveOnMessage(notification, this.destination)))
            }, ObserveOnSubscriber.prototype._next = function(value) {
                this.scheduleMessage(Notification_Notification.createNext(value))
            }, ObserveOnSubscriber.prototype._error = function(err) {
                this.scheduleMessage(Notification_Notification.createError(err)), this.unsubscribe()
            }, ObserveOnSubscriber.prototype._complete = function() {
                this.scheduleMessage(Notification_Notification.createComplete()), this.unsubscribe()
            }, ObserveOnSubscriber
        }(Subscriber.a),
        ObserveOnMessage = function() {
            return function(notification, destination) {
                this.notification = notification, this.destination = destination
            }
        }(),
        ObjectUnsubscribedError = __webpack_require__(31),
        SubjectSubscription = __webpack_require__(92),
        ReplaySubject_ReplaySubject = function(_super) {
            function ReplaySubject(bufferSize, windowTime, scheduler) {
                void 0 === bufferSize && (bufferSize = Number.POSITIVE_INFINITY), void 0 === windowTime && (windowTime = Number.POSITIVE_INFINITY);
                var _this = _super.call(this) || this;
                return _this.scheduler = scheduler, _this._events = [], _this._infiniteTimeWindow = !1, _this._bufferSize = bufferSize < 1 ? 1 : bufferSize, _this._windowTime = windowTime < 1 ? 1 : windowTime, windowTime === Number.POSITIVE_INFINITY ? (_this._infiniteTimeWindow = !0, _this.next = _this.nextInfiniteTimeWindow) : _this.next = _this.nextTimeWindow, _this
            }
            return tslib_es6.a(ReplaySubject, _super), ReplaySubject.prototype.nextInfiniteTimeWindow = function(value) {
                if (!this.isStopped) {
                    var _events = this._events;
                    _events.push(value), _events.length > this._bufferSize && _events.shift()
                }
                _super.prototype.next.call(this, value)
            }, ReplaySubject.prototype.nextTimeWindow = function(value) {
                this.isStopped || (this._events.push(new ReplayEvent(this._getNow(), value)), this._trimBufferThenGetEvents()), _super.prototype.next.call(this, value)
            }, ReplaySubject.prototype._subscribe = function(subscriber) {
                var subscription, _infiniteTimeWindow = this._infiniteTimeWindow,
                    _events = _infiniteTimeWindow ? this._events : this._trimBufferThenGetEvents(),
                    scheduler = this.scheduler,
                    len = _events.length;
                if (this.closed) throw new ObjectUnsubscribedError.a;
                if (this.isStopped || this.hasError ? subscription = Subscription.a.EMPTY : (this.observers.push(subscriber), subscription = new SubjectSubscription.a(this, subscriber)), scheduler && subscriber.add(subscriber = new observeOn_ObserveOnSubscriber(subscriber, scheduler)), _infiniteTimeWindow)
                    for (var i = 0; i < len && !subscriber.closed; i++) subscriber.next(_events[i]);
                else
                    for (i = 0; i < len && !subscriber.closed; i++) subscriber.next(_events[i].value);
                return this.hasError ? subscriber.error(this.thrownError) : this.isStopped && subscriber.complete(), subscription
            }, ReplaySubject.prototype._getNow = function() {
                return (this.scheduler || queue).now()
            }, ReplaySubject.prototype._trimBufferThenGetEvents = function() {
                for (var now = this._getNow(), _bufferSize = this._bufferSize, _windowTime = this._windowTime, _events = this._events, eventsCount = _events.length, spliceCount = 0; spliceCount < eventsCount && !(now - _events[spliceCount].time < _windowTime);) spliceCount++;
                return eventsCount > _bufferSize && (spliceCount = Math.max(spliceCount, eventsCount - _bufferSize)), spliceCount > 0 && _events.splice(0, spliceCount), _events
            }, ReplaySubject
        }(Subject.a),
        ReplayEvent = function() {
            return function(time, value) {
                this.time = time, this.value = value
            }
        }()
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return switchMap
    }));
    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7),
        _map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(63),
        _observable_from__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(64),
        _innerSubscribe__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(40);

    function switchMap(project, resultSelector) {
        return "function" == typeof resultSelector ? function(source) {
            return source.pipe(switchMap((function(a, i) {
                return Object(_observable_from__WEBPACK_IMPORTED_MODULE_2__.a)(project(a, i)).pipe(Object(_map__WEBPACK_IMPORTED_MODULE_1__.a)((function(b, ii) {
                    return resultSelector(a, b, i, ii)
                })))
            })))
        } : function(source) {
            return source.lift(new SwitchMapOperator(project))
        }
    }
    var SwitchMapOperator = function() {
            function SwitchMapOperator(project) {
                this.project = project
            }
            return SwitchMapOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new SwitchMapSubscriber(subscriber, this.project))
            }, SwitchMapOperator
        }(),
        SwitchMapSubscriber = function(_super) {
            function SwitchMapSubscriber(destination, project) {
                var _this = _super.call(this, destination) || this;
                return _this.project = project, _this.index = 0, _this
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(SwitchMapSubscriber, _super), SwitchMapSubscriber.prototype._next = function(value) {
                var result, index = this.index++;
                try {
                    result = this.project(value, index)
                } catch (error) {
                    return void this.destination.error(error)
                }
                this._innerSub(result)
            }, SwitchMapSubscriber.prototype._innerSub = function(result) {
                var innerSubscription = this.innerSubscription;
                innerSubscription && innerSubscription.unsubscribe();
                var innerSubscriber = new _innerSubscribe__WEBPACK_IMPORTED_MODULE_3__.a(this),
                    destination = this.destination;
                destination.add(innerSubscriber), this.innerSubscription = Object(_innerSubscribe__WEBPACK_IMPORTED_MODULE_3__.c)(result, innerSubscriber), this.innerSubscription !== innerSubscriber && destination.add(this.innerSubscription)
            }, SwitchMapSubscriber.prototype._complete = function() {
                var innerSubscription = this.innerSubscription;
                innerSubscription && !innerSubscription.closed || _super.prototype._complete.call(this), this.unsubscribe()
            }, SwitchMapSubscriber.prototype._unsubscribe = function() {
                this.innerSubscription = void 0
            }, SwitchMapSubscriber.prototype.notifyComplete = function() {
                this.innerSubscription = void 0, this.isStopped && _super.prototype._complete.call(this)
            }, SwitchMapSubscriber.prototype.notifyNext = function(innerValue) {
                this.destination.next(innerValue)
            }, SwitchMapSubscriber
        }(_innerSubscribe__WEBPACK_IMPORTED_MODULE_3__.b)
}, function(module, exports) {
    module.exports = function(module) {
        return module.webpackPolyfill || (module.deprecate = function() {}, module.paths = [], module.children || (module.children = []), Object.defineProperty(module, "loaded", {
            enumerable: !0,
            get: function() {
                return module.l
            }
        }), Object.defineProperty(module, "id", {
            enumerable: !0,
            get: function() {
                return module.i
            }
        }), module.webpackPolyfill = 1), module
    }
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("af", {
            months: "Januarie_Februarie_Maart_April_Mei_Junie_Julie_Augustus_September_Oktober_November_Desember".split("_"),
            monthsShort: "Jan_Feb_Mrt_Apr_Mei_Jun_Jul_Aug_Sep_Okt_Nov_Des".split("_"),
            weekdays: "Sondag_Maandag_Dinsdag_Woensdag_Donderdag_Vrydag_Saterdag".split("_"),
            weekdaysShort: "Son_Maa_Din_Woe_Don_Vry_Sat".split("_"),
            weekdaysMin: "So_Ma_Di_Wo_Do_Vr_Sa".split("_"),
            meridiemParse: /vm|nm/i,
            isPM: function(input) {
                return /^nm$/i.test(input)
            },
            meridiem: function(hours, minutes, isLower) {
                return hours < 12 ? isLower ? "vm" : "VM" : isLower ? "nm" : "NM"
            },
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd, D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[Vandag om] LT",
                nextDay: "[Môre om] LT",
                nextWeek: "dddd [om] LT",
                lastDay: "[Gister om] LT",
                lastWeek: "[Laas] dddd [om] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "oor %s",
                past: "%s gelede",
                s: "'n paar sekondes",
                ss: "%d sekondes",
                m: "'n minuut",
                mm: "%d minute",
                h: "'n uur",
                hh: "%d ure",
                d: "'n dag",
                dd: "%d dae",
                M: "'n maand",
                MM: "%d maande",
                y: "'n jaar",
                yy: "%d jaar"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
            ordinal: function(number) {
                return number + (1 === number || 8 === number || number >= 20 ? "ste" : "de")
            },
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        var symbolMap = {
                1: "١",
                2: "٢",
                3: "٣",
                4: "٤",
                5: "٥",
                6: "٦",
                7: "٧",
                8: "٨",
                9: "٩",
                0: "٠"
            },
            numberMap = {
                "١": "1",
                "٢": "2",
                "٣": "3",
                "٤": "4",
                "٥": "5",
                "٦": "6",
                "٧": "7",
                "٨": "8",
                "٩": "9",
                "٠": "0"
            },
            pluralForm = function(n) {
                return 0 === n ? 0 : 1 === n ? 1 : 2 === n ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5
            },
            plurals = {
                s: ["أقل من ثانية", "ثانية واحدة", ["ثانيتان", "ثانيتين"], "%d ثوان", "%d ثانية", "%d ثانية"],
                m: ["أقل من دقيقة", "دقيقة واحدة", ["دقيقتان", "دقيقتين"], "%d دقائق", "%d دقيقة", "%d دقيقة"],
                h: ["أقل من ساعة", "ساعة واحدة", ["ساعتان", "ساعتين"], "%d ساعات", "%d ساعة", "%d ساعة"],
                d: ["أقل من يوم", "يوم واحد", ["يومان", "يومين"], "%d أيام", "%d يومًا", "%d يوم"],
                M: ["أقل من شهر", "شهر واحد", ["شهران", "شهرين"], "%d أشهر", "%d شهرا", "%d شهر"],
                y: ["أقل من عام", "عام واحد", ["عامان", "عامين"], "%d أعوام", "%d عامًا", "%d عام"]
            },
            pluralize = function(u) {
                return function(number, withoutSuffix, string, isFuture) {
                    var f = pluralForm(number),
                        str = plurals[u][pluralForm(number)];
                    return 2 === f && (str = str[withoutSuffix ? 0 : 1]), str.replace(/%d/i, number)
                }
            },
            months = ["يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر"];
        moment.defineLocale("ar", {
            months: months,
            monthsShort: months,
            weekdays: "الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"),
            weekdaysShort: "أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت".split("_"),
            weekdaysMin: "ح_ن_ث_ر_خ_ج_س".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "D/‏M/‏YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd D MMMM YYYY HH:mm"
            },
            meridiemParse: /ص|م/,
            isPM: function(input) {
                return "م" === input
            },
            meridiem: function(hour, minute, isLower) {
                return hour < 12 ? "ص" : "م"
            },
            calendar: {
                sameDay: "[اليوم عند الساعة] LT",
                nextDay: "[غدًا عند الساعة] LT",
                nextWeek: "dddd [عند الساعة] LT",
                lastDay: "[أمس عند الساعة] LT",
                lastWeek: "dddd [عند الساعة] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "بعد %s",
                past: "منذ %s",
                s: pluralize("s"),
                ss: pluralize("s"),
                m: pluralize("m"),
                mm: pluralize("m"),
                h: pluralize("h"),
                hh: pluralize("h"),
                d: pluralize("d"),
                dd: pluralize("d"),
                M: pluralize("M"),
                MM: pluralize("M"),
                y: pluralize("y"),
                yy: pluralize("y")
            },
            preparse: function(string) {
                return string.replace(/[١٢٣٤٥٦٧٨٩٠]/g, (function(match) {
                    return numberMap[match]
                })).replace(/،/g, ",")
            },
            postformat: function(string) {
                return string.replace(/\d/g, (function(match) {
                    return symbolMap[match]
                })).replace(/,/g, "،")
            },
            week: {
                dow: 6,
                doy: 12
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        var pluralForm = function(n) {
                return 0 === n ? 0 : 1 === n ? 1 : 2 === n ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5
            },
            plurals = {
                s: ["أقل من ثانية", "ثانية واحدة", ["ثانيتان", "ثانيتين"], "%d ثوان", "%d ثانية", "%d ثانية"],
                m: ["أقل من دقيقة", "دقيقة واحدة", ["دقيقتان", "دقيقتين"], "%d دقائق", "%d دقيقة", "%d دقيقة"],
                h: ["أقل من ساعة", "ساعة واحدة", ["ساعتان", "ساعتين"], "%d ساعات", "%d ساعة", "%d ساعة"],
                d: ["أقل من يوم", "يوم واحد", ["يومان", "يومين"], "%d أيام", "%d يومًا", "%d يوم"],
                M: ["أقل من شهر", "شهر واحد", ["شهران", "شهرين"], "%d أشهر", "%d شهرا", "%d شهر"],
                y: ["أقل من عام", "عام واحد", ["عامان", "عامين"], "%d أعوام", "%d عامًا", "%d عام"]
            },
            pluralize = function(u) {
                return function(number, withoutSuffix, string, isFuture) {
                    var f = pluralForm(number),
                        str = plurals[u][pluralForm(number)];
                    return 2 === f && (str = str[withoutSuffix ? 0 : 1]), str.replace(/%d/i, number)
                }
            },
            months = ["جانفي", "فيفري", "مارس", "أفريل", "ماي", "جوان", "جويلية", "أوت", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر"];
        moment.defineLocale("ar-dz", {
            months: months,
            monthsShort: months,
            weekdays: "الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"),
            weekdaysShort: "أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت".split("_"),
            weekdaysMin: "ح_ن_ث_ر_خ_ج_س".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "D/‏M/‏YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd D MMMM YYYY HH:mm"
            },
            meridiemParse: /ص|م/,
            isPM: function(input) {
                return "م" === input
            },
            meridiem: function(hour, minute, isLower) {
                return hour < 12 ? "ص" : "م"
            },
            calendar: {
                sameDay: "[اليوم عند الساعة] LT",
                nextDay: "[غدًا عند الساعة] LT",
                nextWeek: "dddd [عند الساعة] LT",
                lastDay: "[أمس عند الساعة] LT",
                lastWeek: "dddd [عند الساعة] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "بعد %s",
                past: "منذ %s",
                s: pluralize("s"),
                ss: pluralize("s"),
                m: pluralize("m"),
                mm: pluralize("m"),
                h: pluralize("h"),
                hh: pluralize("h"),
                d: pluralize("d"),
                dd: pluralize("d"),
                M: pluralize("M"),
                MM: pluralize("M"),
                y: pluralize("y"),
                yy: pluralize("y")
            },
            postformat: function(string) {
                return string.replace(/,/g, "،")
            },
            week: {
                dow: 0,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("ar-kw", {
            months: "يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر".split("_"),
            monthsShort: "يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر".split("_"),
            weekdays: "الأحد_الإتنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"),
            weekdaysShort: "احد_اتنين_ثلاثاء_اربعاء_خميس_جمعة_سبت".split("_"),
            weekdaysMin: "ح_ن_ث_ر_خ_ج_س".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[اليوم على الساعة] LT",
                nextDay: "[غدا على الساعة] LT",
                nextWeek: "dddd [على الساعة] LT",
                lastDay: "[أمس على الساعة] LT",
                lastWeek: "dddd [على الساعة] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "في %s",
                past: "منذ %s",
                s: "ثوان",
                ss: "%d ثانية",
                m: "دقيقة",
                mm: "%d دقائق",
                h: "ساعة",
                hh: "%d ساعات",
                d: "يوم",
                dd: "%d أيام",
                M: "شهر",
                MM: "%d أشهر",
                y: "سنة",
                yy: "%d سنوات"
            },
            week: {
                dow: 0,
                doy: 12
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        var symbolMap = {
                1: "1",
                2: "2",
                3: "3",
                4: "4",
                5: "5",
                6: "6",
                7: "7",
                8: "8",
                9: "9",
                0: "0"
            },
            pluralForm = function(n) {
                return 0 === n ? 0 : 1 === n ? 1 : 2 === n ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5
            },
            plurals = {
                s: ["أقل من ثانية", "ثانية واحدة", ["ثانيتان", "ثانيتين"], "%d ثوان", "%d ثانية", "%d ثانية"],
                m: ["أقل من دقيقة", "دقيقة واحدة", ["دقيقتان", "دقيقتين"], "%d دقائق", "%d دقيقة", "%d دقيقة"],
                h: ["أقل من ساعة", "ساعة واحدة", ["ساعتان", "ساعتين"], "%d ساعات", "%d ساعة", "%d ساعة"],
                d: ["أقل من يوم", "يوم واحد", ["يومان", "يومين"], "%d أيام", "%d يومًا", "%d يوم"],
                M: ["أقل من شهر", "شهر واحد", ["شهران", "شهرين"], "%d أشهر", "%d شهرا", "%d شهر"],
                y: ["أقل من عام", "عام واحد", ["عامان", "عامين"], "%d أعوام", "%d عامًا", "%d عام"]
            },
            pluralize = function(u) {
                return function(number, withoutSuffix, string, isFuture) {
                    var f = pluralForm(number),
                        str = plurals[u][pluralForm(number)];
                    return 2 === f && (str = str[withoutSuffix ? 0 : 1]), str.replace(/%d/i, number)
                }
            },
            months = ["يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو", "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر"];
        moment.defineLocale("ar-ly", {
            months: months,
            monthsShort: months,
            weekdays: "الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"),
            weekdaysShort: "أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت".split("_"),
            weekdaysMin: "ح_ن_ث_ر_خ_ج_س".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "D/‏M/‏YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd D MMMM YYYY HH:mm"
            },
            meridiemParse: /ص|م/,
            isPM: function(input) {
                return "م" === input
            },
            meridiem: function(hour, minute, isLower) {
                return hour < 12 ? "ص" : "م"
            },
            calendar: {
                sameDay: "[اليوم عند الساعة] LT",
                nextDay: "[غدًا عند الساعة] LT",
                nextWeek: "dddd [عند الساعة] LT",
                lastDay: "[أمس عند الساعة] LT",
                lastWeek: "dddd [عند الساعة] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "بعد %s",
                past: "منذ %s",
                s: pluralize("s"),
                ss: pluralize("s"),
                m: pluralize("m"),
                mm: pluralize("m"),
                h: pluralize("h"),
                hh: pluralize("h"),
                d: pluralize("d"),
                dd: pluralize("d"),
                M: pluralize("M"),
                MM: pluralize("M"),
                y: pluralize("y"),
                yy: pluralize("y")
            },
            preparse: function(string) {
                return string.replace(/،/g, ",")
            },
            postformat: function(string) {
                return string.replace(/\d/g, (function(match) {
                    return symbolMap[match]
                })).replace(/,/g, "،")
            },
            week: {
                dow: 6,
                doy: 12
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("ar-ma", {
            months: "يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر".split("_"),
            monthsShort: "يناير_فبراير_مارس_أبريل_ماي_يونيو_يوليوز_غشت_شتنبر_أكتوبر_نونبر_دجنبر".split("_"),
            weekdays: "الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"),
            weekdaysShort: "احد_اثنين_ثلاثاء_اربعاء_خميس_جمعة_سبت".split("_"),
            weekdaysMin: "ح_ن_ث_ر_خ_ج_س".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[اليوم على الساعة] LT",
                nextDay: "[غدا على الساعة] LT",
                nextWeek: "dddd [على الساعة] LT",
                lastDay: "[أمس على الساعة] LT",
                lastWeek: "dddd [على الساعة] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "في %s",
                past: "منذ %s",
                s: "ثوان",
                ss: "%d ثانية",
                m: "دقيقة",
                mm: "%d دقائق",
                h: "ساعة",
                hh: "%d ساعات",
                d: "يوم",
                dd: "%d أيام",
                M: "شهر",
                MM: "%d أشهر",
                y: "سنة",
                yy: "%d سنوات"
            },
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        var symbolMap = {
                1: "١",
                2: "٢",
                3: "٣",
                4: "٤",
                5: "٥",
                6: "٦",
                7: "٧",
                8: "٨",
                9: "٩",
                0: "٠"
            },
            numberMap = {
                "١": "1",
                "٢": "2",
                "٣": "3",
                "٤": "4",
                "٥": "5",
                "٦": "6",
                "٧": "7",
                "٨": "8",
                "٩": "9",
                "٠": "0"
            };
        moment.defineLocale("ar-sa", {
            months: "يناير_فبراير_مارس_أبريل_مايو_يونيو_يوليو_أغسطس_سبتمبر_أكتوبر_نوفمبر_ديسمبر".split("_"),
            monthsShort: "يناير_فبراير_مارس_أبريل_مايو_يونيو_يوليو_أغسطس_سبتمبر_أكتوبر_نوفمبر_ديسمبر".split("_"),
            weekdays: "الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"),
            weekdaysShort: "أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت".split("_"),
            weekdaysMin: "ح_ن_ث_ر_خ_ج_س".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd D MMMM YYYY HH:mm"
            },
            meridiemParse: /ص|م/,
            isPM: function(input) {
                return "م" === input
            },
            meridiem: function(hour, minute, isLower) {
                return hour < 12 ? "ص" : "م"
            },
            calendar: {
                sameDay: "[اليوم على الساعة] LT",
                nextDay: "[غدا على الساعة] LT",
                nextWeek: "dddd [على الساعة] LT",
                lastDay: "[أمس على الساعة] LT",
                lastWeek: "dddd [على الساعة] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "في %s",
                past: "منذ %s",
                s: "ثوان",
                ss: "%d ثانية",
                m: "دقيقة",
                mm: "%d دقائق",
                h: "ساعة",
                hh: "%d ساعات",
                d: "يوم",
                dd: "%d أيام",
                M: "شهر",
                MM: "%d أشهر",
                y: "سنة",
                yy: "%d سنوات"
            },
            preparse: function(string) {
                return string.replace(/[١٢٣٤٥٦٧٨٩٠]/g, (function(match) {
                    return numberMap[match]
                })).replace(/،/g, ",")
            },
            postformat: function(string) {
                return string.replace(/\d/g, (function(match) {
                    return symbolMap[match]
                })).replace(/,/g, "،")
            },
            week: {
                dow: 0,
                doy: 6
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("ar-tn", {
            months: "جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر".split("_"),
            monthsShort: "جانفي_فيفري_مارس_أفريل_ماي_جوان_جويلية_أوت_سبتمبر_أكتوبر_نوفمبر_ديسمبر".split("_"),
            weekdays: "الأحد_الإثنين_الثلاثاء_الأربعاء_الخميس_الجمعة_السبت".split("_"),
            weekdaysShort: "أحد_إثنين_ثلاثاء_أربعاء_خميس_جمعة_سبت".split("_"),
            weekdaysMin: "ح_ن_ث_ر_خ_ج_س".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[اليوم على الساعة] LT",
                nextDay: "[غدا على الساعة] LT",
                nextWeek: "dddd [على الساعة] LT",
                lastDay: "[أمس على الساعة] LT",
                lastWeek: "dddd [على الساعة] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "في %s",
                past: "منذ %s",
                s: "ثوان",
                ss: "%d ثانية",
                m: "دقيقة",
                mm: "%d دقائق",
                h: "ساعة",
                hh: "%d ساعات",
                d: "يوم",
                dd: "%d أيام",
                M: "شهر",
                MM: "%d أشهر",
                y: "سنة",
                yy: "%d سنوات"
            },
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        var suffixes = {
            1: "-inci",
            5: "-inci",
            8: "-inci",
            70: "-inci",
            80: "-inci",
            2: "-nci",
            7: "-nci",
            20: "-nci",
            50: "-nci",
            3: "-üncü",
            4: "-üncü",
            100: "-üncü",
            6: "-ncı",
            9: "-uncu",
            10: "-uncu",
            30: "-uncu",
            60: "-ıncı",
            90: "-ıncı"
        };
        moment.defineLocale("az", {
            months: "yanvar_fevral_mart_aprel_may_iyun_iyul_avqust_sentyabr_oktyabr_noyabr_dekabr".split("_"),
            monthsShort: "yan_fev_mar_apr_may_iyn_iyl_avq_sen_okt_noy_dek".split("_"),
            weekdays: "Bazar_Bazar ertəsi_Çərşənbə axşamı_Çərşənbə_Cümə axşamı_Cümə_Şənbə".split("_"),
            weekdaysShort: "Baz_BzE_ÇAx_Çər_CAx_Cüm_Şən".split("_"),
            weekdaysMin: "Bz_BE_ÇA_Çə_CA_Cü_Şə".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd, D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[bugün saat] LT",
                nextDay: "[sabah saat] LT",
                nextWeek: "[gələn həftə] dddd [saat] LT",
                lastDay: "[dünən] LT",
                lastWeek: "[keçən həftə] dddd [saat] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s sonra",
                past: "%s əvvəl",
                s: "bir neçə saniyə",
                ss: "%d saniyə",
                m: "bir dəqiqə",
                mm: "%d dəqiqə",
                h: "bir saat",
                hh: "%d saat",
                d: "bir gün",
                dd: "%d gün",
                M: "bir ay",
                MM: "%d ay",
                y: "bir il",
                yy: "%d il"
            },
            meridiemParse: /gecə|səhər|gündüz|axşam/,
            isPM: function(input) {
                return /^(gündüz|axşam)$/.test(input)
            },
            meridiem: function(hour, minute, isLower) {
                return hour < 4 ? "gecə" : hour < 12 ? "səhər" : hour < 17 ? "gündüz" : "axşam"
            },
            dayOfMonthOrdinalParse: /\d{1,2}-(ıncı|inci|nci|üncü|ncı|uncu)/,
            ordinal: function(number) {
                if (0 === number) return number + "-ıncı";
                var a = number % 10,
                    b = number % 100 - a,
                    c = number >= 100 ? 100 : null;
                return number + (suffixes[a] || suffixes[b] || suffixes[c])
            },
            week: {
                dow: 1,
                doy: 7
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";

        function plural(word, num) {
            var forms = word.split("_");
            return num % 10 == 1 && num % 100 != 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]
        }

        function relativeTimeWithPlural(number, withoutSuffix, key) {
            return "m" === key ? withoutSuffix ? "хвіліна" : "хвіліну" : "h" === key ? withoutSuffix ? "гадзіна" : "гадзіну" : number + " " + plural({
                ss: withoutSuffix ? "секунда_секунды_секунд" : "секунду_секунды_секунд",
                mm: withoutSuffix ? "хвіліна_хвіліны_хвілін" : "хвіліну_хвіліны_хвілін",
                hh: withoutSuffix ? "гадзіна_гадзіны_гадзін" : "гадзіну_гадзіны_гадзін",
                dd: "дзень_дні_дзён",
                MM: "месяц_месяцы_месяцаў",
                yy: "год_гады_гадоў"
            }[key], +number)
        }
        moment.defineLocale("be", {
            months: {
                format: "студзеня_лютага_сакавіка_красавіка_траўня_чэрвеня_ліпеня_жніўня_верасня_кастрычніка_лістапада_снежня".split("_"),
                standalone: "студзень_люты_сакавік_красавік_травень_чэрвень_ліпень_жнівень_верасень_кастрычнік_лістапад_снежань".split("_")
            },
            monthsShort: "студ_лют_сак_крас_трав_чэрв_ліп_жнів_вер_каст_ліст_снеж".split("_"),
            weekdays: {
                format: "нядзелю_панядзелак_аўторак_сераду_чацвер_пятніцу_суботу".split("_"),
                standalone: "нядзеля_панядзелак_аўторак_серада_чацвер_пятніца_субота".split("_"),
                isFormat: /\[ ?[Ууў] ?(?:мінулую|наступную)? ?\] ?dddd/
            },
            weekdaysShort: "нд_пн_ат_ср_чц_пт_сб".split("_"),
            weekdaysMin: "нд_пн_ат_ср_чц_пт_сб".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D MMMM YYYY г.",
                LLL: "D MMMM YYYY г., HH:mm",
                LLLL: "dddd, D MMMM YYYY г., HH:mm"
            },
            calendar: {
                sameDay: "[Сёння ў] LT",
                nextDay: "[Заўтра ў] LT",
                lastDay: "[Учора ў] LT",
                nextWeek: function() {
                    return "[У] dddd [ў] LT"
                },
                lastWeek: function() {
                    switch (this.day()) {
                        case 0:
                        case 3:
                        case 5:
                        case 6:
                            return "[У мінулую] dddd [ў] LT";
                        case 1:
                        case 2:
                        case 4:
                            return "[У мінулы] dddd [ў] LT"
                    }
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "праз %s",
                past: "%s таму",
                s: "некалькі секунд",
                m: relativeTimeWithPlural,
                mm: relativeTimeWithPlural,
                h: relativeTimeWithPlural,
                hh: relativeTimeWithPlural,
                d: "дзень",
                dd: relativeTimeWithPlural,
                M: "месяц",
                MM: relativeTimeWithPlural,
                y: "год",
                yy: relativeTimeWithPlural
            },
            meridiemParse: /ночы|раніцы|дня|вечара/,
            isPM: function(input) {
                return /^(дня|вечара)$/.test(input)
            },
            meridiem: function(hour, minute, isLower) {
                return hour < 4 ? "ночы" : hour < 12 ? "раніцы" : hour < 17 ? "дня" : "вечара"
            },
            dayOfMonthOrdinalParse: /\d{1,2}-(і|ы|га)/,
            ordinal: function(number, period) {
                switch (period) {
                    case "M":
                    case "d":
                    case "DDD":
                    case "w":
                    case "W":
                        return number % 10 != 2 && number % 10 != 3 || number % 100 == 12 || number % 100 == 13 ? number + "-ы" : number + "-і";
                    case "D":
                        return number + "-га";
                    default:
                        return number
                }
            },
            week: {
                dow: 1,
                doy: 7
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("bg", {
            months: "януари_февруари_март_април_май_юни_юли_август_септември_октомври_ноември_декември".split("_"),
            monthsShort: "яну_фев_мар_апр_май_юни_юли_авг_сеп_окт_ное_дек".split("_"),
            weekdays: "неделя_понеделник_вторник_сряда_четвъртък_петък_събота".split("_"),
            weekdaysShort: "нед_пон_вто_сря_чет_пет_съб".split("_"),
            weekdaysMin: "нд_пн_вт_ср_чт_пт_сб".split("_"),
            longDateFormat: {
                LT: "H:mm",
                LTS: "H:mm:ss",
                L: "D.MM.YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY H:mm",
                LLLL: "dddd, D MMMM YYYY H:mm"
            },
            calendar: {
                sameDay: "[Днес в] LT",
                nextDay: "[Утре в] LT",
                nextWeek: "dddd [в] LT",
                lastDay: "[Вчера в] LT",
                lastWeek: function() {
                    switch (this.day()) {
                        case 0:
                        case 3:
                        case 6:
                            return "[Миналата] dddd [в] LT";
                        case 1:
                        case 2:
                        case 4:
                        case 5:
                            return "[Миналия] dddd [в] LT"
                    }
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "след %s",
                past: "преди %s",
                s: "няколко секунди",
                ss: "%d секунди",
                m: "минута",
                mm: "%d минути",
                h: "час",
                hh: "%d часа",
                d: "ден",
                dd: "%d дена",
                w: "седмица",
                ww: "%d седмици",
                M: "месец",
                MM: "%d месеца",
                y: "година",
                yy: "%d години"
            },
            dayOfMonthOrdinalParse: /\d{1,2}-(ев|ен|ти|ви|ри|ми)/,
            ordinal: function(number) {
                var lastDigit = number % 10,
                    last2Digits = number % 100;
                return 0 === number ? number + "-ев" : 0 === last2Digits ? number + "-ен" : last2Digits > 10 && last2Digits < 20 ? number + "-ти" : 1 === lastDigit ? number + "-ви" : 2 === lastDigit ? number + "-ри" : 7 === lastDigit || 8 === lastDigit ? number + "-ми" : number + "-ти"
            },
            week: {
                dow: 1,
                doy: 7
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("bm", {
            months: "Zanwuyekalo_Fewuruyekalo_Marisikalo_Awirilikalo_Mɛkalo_Zuwɛnkalo_Zuluyekalo_Utikalo_Sɛtanburukalo_ɔkutɔburukalo_Nowanburukalo_Desanburukalo".split("_"),
            monthsShort: "Zan_Few_Mar_Awi_Mɛ_Zuw_Zul_Uti_Sɛt_ɔku_Now_Des".split("_"),
            weekdays: "Kari_Ntɛnɛn_Tarata_Araba_Alamisa_Juma_Sibiri".split("_"),
            weekdaysShort: "Kar_Ntɛ_Tar_Ara_Ala_Jum_Sib".split("_"),
            weekdaysMin: "Ka_Nt_Ta_Ar_Al_Ju_Si".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "MMMM [tile] D [san] YYYY",
                LLL: "MMMM [tile] D [san] YYYY [lɛrɛ] HH:mm",
                LLLL: "dddd MMMM [tile] D [san] YYYY [lɛrɛ] HH:mm"
            },
            calendar: {
                sameDay: "[Bi lɛrɛ] LT",
                nextDay: "[Sini lɛrɛ] LT",
                nextWeek: "dddd [don lɛrɛ] LT",
                lastDay: "[Kunu lɛrɛ] LT",
                lastWeek: "dddd [tɛmɛnen lɛrɛ] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s kɔnɔ",
                past: "a bɛ %s bɔ",
                s: "sanga dama dama",
                ss: "sekondi %d",
                m: "miniti kelen",
                mm: "miniti %d",
                h: "lɛrɛ kelen",
                hh: "lɛrɛ %d",
                d: "tile kelen",
                dd: "tile %d",
                M: "kalo kelen",
                MM: "kalo %d",
                y: "san kelen",
                yy: "san %d"
            },
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        var symbolMap = {
                1: "১",
                2: "২",
                3: "৩",
                4: "৪",
                5: "৫",
                6: "৬",
                7: "৭",
                8: "৮",
                9: "৯",
                0: "০"
            },
            numberMap = {
                "১": "1",
                "২": "2",
                "৩": "3",
                "৪": "4",
                "৫": "5",
                "৬": "6",
                "৭": "7",
                "৮": "8",
                "৯": "9",
                "০": "0"
            };
        moment.defineLocale("bn", {
            months: "জানুয়ারি_ফেব্রুয়ারি_মার্চ_এপ্রিল_মে_জুন_জুলাই_আগস্ট_সেপ্টেম্বর_অক্টোবর_নভেম্বর_ডিসেম্বর".split("_"),
            monthsShort: "জানু_ফেব্রু_মার্চ_এপ্রিল_মে_জুন_জুলাই_আগস্ট_সেপ্ট_অক্টো_নভে_ডিসে".split("_"),
            weekdays: "রবিবার_সোমবার_মঙ্গলবার_বুধবার_বৃহস্পতিবার_শুক্রবার_শনিবার".split("_"),
            weekdaysShort: "রবি_সোম_মঙ্গল_বুধ_বৃহস্পতি_শুক্র_শনি".split("_"),
            weekdaysMin: "রবি_সোম_মঙ্গল_বুধ_বৃহ_শুক্র_শনি".split("_"),
            longDateFormat: {
                LT: "A h:mm সময়",
                LTS: "A h:mm:ss সময়",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY, A h:mm সময়",
                LLLL: "dddd, D MMMM YYYY, A h:mm সময়"
            },
            calendar: {
                sameDay: "[আজ] LT",
                nextDay: "[আগামীকাল] LT",
                nextWeek: "dddd, LT",
                lastDay: "[গতকাল] LT",
                lastWeek: "[গত] dddd, LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s পরে",
                past: "%s আগে",
                s: "কয়েক সেকেন্ড",
                ss: "%d সেকেন্ড",
                m: "এক মিনিট",
                mm: "%d মিনিট",
                h: "এক ঘন্টা",
                hh: "%d ঘন্টা",
                d: "এক দিন",
                dd: "%d দিন",
                M: "এক মাস",
                MM: "%d মাস",
                y: "এক বছর",
                yy: "%d বছর"
            },
            preparse: function(string) {
                return string.replace(/[১২৩৪৫৬৭৮৯০]/g, (function(match) {
                    return numberMap[match]
                }))
            },
            postformat: function(string) {
                return string.replace(/\d/g, (function(match) {
                    return symbolMap[match]
                }))
            },
            meridiemParse: /রাত|সকাল|দুপুর|বিকাল|রাত/,
            meridiemHour: function(hour, meridiem) {
                return 12 === hour && (hour = 0), "রাত" === meridiem && hour >= 4 || "দুপুর" === meridiem && hour < 5 || "বিকাল" === meridiem ? hour + 12 : hour
            },
            meridiem: function(hour, minute, isLower) {
                return hour < 4 ? "রাত" : hour < 10 ? "সকাল" : hour < 17 ? "দুপুর" : hour < 20 ? "বিকাল" : "রাত"
            },
            week: {
                dow: 0,
                doy: 6
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        var symbolMap = {
                1: "১",
                2: "২",
                3: "৩",
                4: "৪",
                5: "৫",
                6: "৬",
                7: "৭",
                8: "৮",
                9: "৯",
                0: "০"
            },
            numberMap = {
                "১": "1",
                "২": "2",
                "৩": "3",
                "৪": "4",
                "৫": "5",
                "৬": "6",
                "৭": "7",
                "৮": "8",
                "৯": "9",
                "০": "0"
            };
        moment.defineLocale("bn-bd", {
            months: "জানুয়ারি_ফেব্রুয়ারি_মার্চ_এপ্রিল_মে_জুন_জুলাই_আগস্ট_সেপ্টেম্বর_অক্টোবর_নভেম্বর_ডিসেম্বর".split("_"),
            monthsShort: "জানু_ফেব্রু_মার্চ_এপ্রিল_মে_জুন_জুলাই_আগস্ট_সেপ্ট_অক্টো_নভে_ডিসে".split("_"),
            weekdays: "রবিবার_সোমবার_মঙ্গলবার_বুধবার_বৃহস্পতিবার_শুক্রবার_শনিবার".split("_"),
            weekdaysShort: "রবি_সোম_মঙ্গল_বুধ_বৃহস্পতি_শুক্র_শনি".split("_"),
            weekdaysMin: "রবি_সোম_মঙ্গল_বুধ_বৃহ_শুক্র_শনি".split("_"),
            longDateFormat: {
                LT: "A h:mm সময়",
                LTS: "A h:mm:ss সময়",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY, A h:mm সময়",
                LLLL: "dddd, D MMMM YYYY, A h:mm সময়"
            },
            calendar: {
                sameDay: "[আজ] LT",
                nextDay: "[আগামীকাল] LT",
                nextWeek: "dddd, LT",
                lastDay: "[গতকাল] LT",
                lastWeek: "[গত] dddd, LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s পরে",
                past: "%s আগে",
                s: "কয়েক সেকেন্ড",
                ss: "%d সেকেন্ড",
                m: "এক মিনিট",
                mm: "%d মিনিট",
                h: "এক ঘন্টা",
                hh: "%d ঘন্টা",
                d: "এক দিন",
                dd: "%d দিন",
                M: "এক মাস",
                MM: "%d মাস",
                y: "এক বছর",
                yy: "%d বছর"
            },
            preparse: function(string) {
                return string.replace(/[১২৩৪৫৬৭৮৯০]/g, (function(match) {
                    return numberMap[match]
                }))
            },
            postformat: function(string) {
                return string.replace(/\d/g, (function(match) {
                    return symbolMap[match]
                }))
            },
            meridiemParse: /রাত|ভোর|সকাল|দুপুর|বিকাল|সন্ধ্যা|রাত/,
            meridiemHour: function(hour, meridiem) {
                return 12 === hour && (hour = 0), "রাত" === meridiem ? hour < 4 ? hour : hour + 12 : "ভোর" === meridiem || "সকাল" === meridiem ? hour : "দুপুর" === meridiem ? hour >= 3 ? hour : hour + 12 : "বিকাল" === meridiem || "সন্ধ্যা" === meridiem ? hour + 12 : void 0
            },
            meridiem: function(hour, minute, isLower) {
                return hour < 4 ? "রাত" : hour < 6 ? "ভোর" : hour < 12 ? "সকাল" : hour < 15 ? "দুপুর" : hour < 18 ? "বিকাল" : hour < 20 ? "সন্ধ্যা" : "রাত"
            },
            week: {
                dow: 0,
                doy: 6
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        var symbolMap = {
                1: "༡",
                2: "༢",
                3: "༣",
                4: "༤",
                5: "༥",
                6: "༦",
                7: "༧",
                8: "༨",
                9: "༩",
                0: "༠"
            },
            numberMap = {
                "༡": "1",
                "༢": "2",
                "༣": "3",
                "༤": "4",
                "༥": "5",
                "༦": "6",
                "༧": "7",
                "༨": "8",
                "༩": "9",
                "༠": "0"
            };
        moment.defineLocale("bo", {
            months: "ཟླ་བ་དང་པོ_ཟླ་བ་གཉིས་པ_ཟླ་བ་གསུམ་པ_ཟླ་བ་བཞི་པ_ཟླ་བ་ལྔ་པ_ཟླ་བ་དྲུག་པ_ཟླ་བ་བདུན་པ_ཟླ་བ་བརྒྱད་པ_ཟླ་བ་དགུ་པ_ཟླ་བ་བཅུ་པ_ཟླ་བ་བཅུ་གཅིག་པ_ཟླ་བ་བཅུ་གཉིས་པ".split("_"),
            monthsShort: "ཟླ་1_ཟླ་2_ཟླ་3_ཟླ་4_ཟླ་5_ཟླ་6_ཟླ་7_ཟླ་8_ཟླ་9_ཟླ་10_ཟླ་11_ཟླ་12".split("_"),
            monthsShortRegex: /^(ཟླ་\d{1,2})/,
            monthsParseExact: !0,
            weekdays: "གཟའ་ཉི་མ་_གཟའ་ཟླ་བ་_གཟའ་མིག་དམར་_གཟའ་ལྷག་པ་_གཟའ་ཕུར་བུ_གཟའ་པ་སངས་_གཟའ་སྤེན་པ་".split("_"),
            weekdaysShort: "ཉི་མ་_ཟླ་བ་_མིག་དམར་_ལྷག་པ་_ཕུར་བུ_པ་སངས་_སྤེན་པ་".split("_"),
            weekdaysMin: "ཉི_ཟླ_མིག_ལྷག_ཕུར_སངས_སྤེན".split("_"),
            longDateFormat: {
                LT: "A h:mm",
                LTS: "A h:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY, A h:mm",
                LLLL: "dddd, D MMMM YYYY, A h:mm"
            },
            calendar: {
                sameDay: "[དི་རིང] LT",
                nextDay: "[སང་ཉིན] LT",
                nextWeek: "[བདུན་ཕྲག་རྗེས་མ], LT",
                lastDay: "[ཁ་སང] LT",
                lastWeek: "[བདུན་ཕྲག་མཐའ་མ] dddd, LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s ལ་",
                past: "%s སྔན་ལ",
                s: "ལམ་སང",
                ss: "%d སྐར་ཆ།",
                m: "སྐར་མ་གཅིག",
                mm: "%d སྐར་མ",
                h: "ཆུ་ཚོད་གཅིག",
                hh: "%d ཆུ་ཚོད",
                d: "ཉིན་གཅིག",
                dd: "%d ཉིན་",
                M: "ཟླ་བ་གཅིག",
                MM: "%d ཟླ་བ",
                y: "ལོ་གཅིག",
                yy: "%d ལོ"
            },
            preparse: function(string) {
                return string.replace(/[༡༢༣༤༥༦༧༨༩༠]/g, (function(match) {
                    return numberMap[match]
                }))
            },
            postformat: function(string) {
                return string.replace(/\d/g, (function(match) {
                    return symbolMap[match]
                }))
            },
            meridiemParse: /མཚན་མོ|ཞོགས་ཀས|ཉིན་གུང|དགོང་དག|མཚན་མོ/,
            meridiemHour: function(hour, meridiem) {
                return 12 === hour && (hour = 0), "མཚན་མོ" === meridiem && hour >= 4 || "ཉིན་གུང" === meridiem && hour < 5 || "དགོང་དག" === meridiem ? hour + 12 : hour
            },
            meridiem: function(hour, minute, isLower) {
                return hour < 4 ? "མཚན་མོ" : hour < 10 ? "ཞོགས་ཀས" : hour < 17 ? "ཉིན་གུང" : hour < 20 ? "དགོང་དག" : "མཚན་མོ"
            },
            week: {
                dow: 0,
                doy: 6
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";

        function relativeTimeWithMutation(number, withoutSuffix, key) {
            return number + " " + mutation({
                mm: "munutenn",
                MM: "miz",
                dd: "devezh"
            }[key], number)
        }

        function specialMutationForYears(number) {
            switch (lastNumber(number)) {
                case 1:
                case 3:
                case 4:
                case 5:
                case 9:
                    return number + " bloaz";
                default:
                    return number + " vloaz"
            }
        }

        function lastNumber(number) {
            return number > 9 ? lastNumber(number % 10) : number
        }

        function mutation(text, number) {
            return 2 === number ? softMutation(text) : text
        }

        function softMutation(text) {
            var mutationTable = {
                m: "v",
                b: "v",
                d: "z"
            };
            return void 0 === mutationTable[text.charAt(0)] ? text : mutationTable[text.charAt(0)] + text.substring(1)
        }
        var monthsParse = [/^gen/i, /^c[ʼ\']hwe/i, /^meu/i, /^ebr/i, /^mae/i, /^(mez|eve)/i, /^gou/i, /^eos/i, /^gwe/i, /^her/i, /^du/i, /^ker/i],
            monthsRegex = /^(genver|c[ʼ\']hwevrer|meurzh|ebrel|mae|mezheven|gouere|eost|gwengolo|here|du|kerzu|gen|c[ʼ\']hwe|meu|ebr|mae|eve|gou|eos|gwe|her|du|ker)/i,
            monthsStrictRegex = /^(genver|c[ʼ\']hwevrer|meurzh|ebrel|mae|mezheven|gouere|eost|gwengolo|here|du|kerzu)/i,
            monthsShortStrictRegex = /^(gen|c[ʼ\']hwe|meu|ebr|mae|eve|gou|eos|gwe|her|du|ker)/i,
            fullWeekdaysParse = [/^sul/i, /^lun/i, /^meurzh/i, /^merc[ʼ\']her/i, /^yaou/i, /^gwener/i, /^sadorn/i],
            shortWeekdaysParse = [/^Sul/i, /^Lun/i, /^Meu/i, /^Mer/i, /^Yao/i, /^Gwe/i, /^Sad/i],
            minWeekdaysParse = [/^Su/i, /^Lu/i, /^Me([^r]|$)/i, /^Mer/i, /^Ya/i, /^Gw/i, /^Sa/i];
        moment.defineLocale("br", {
            months: "Genver_Cʼhwevrer_Meurzh_Ebrel_Mae_Mezheven_Gouere_Eost_Gwengolo_Here_Du_Kerzu".split("_"),
            monthsShort: "Gen_Cʼhwe_Meu_Ebr_Mae_Eve_Gou_Eos_Gwe_Her_Du_Ker".split("_"),
            weekdays: "Sul_Lun_Meurzh_Mercʼher_Yaou_Gwener_Sadorn".split("_"),
            weekdaysShort: "Sul_Lun_Meu_Mer_Yao_Gwe_Sad".split("_"),
            weekdaysMin: "Su_Lu_Me_Mer_Ya_Gw_Sa".split("_"),
            weekdaysParse: minWeekdaysParse,
            fullWeekdaysParse: fullWeekdaysParse,
            shortWeekdaysParse: shortWeekdaysParse,
            minWeekdaysParse: minWeekdaysParse,
            monthsRegex: monthsRegex,
            monthsShortRegex: monthsRegex,
            monthsStrictRegex: monthsStrictRegex,
            monthsShortStrictRegex: monthsShortStrictRegex,
            monthsParse: monthsParse,
            longMonthsParse: monthsParse,
            shortMonthsParse: monthsParse,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D [a viz] MMMM YYYY",
                LLL: "D [a viz] MMMM YYYY HH:mm",
                LLLL: "dddd, D [a viz] MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[Hiziv da] LT",
                nextDay: "[Warcʼhoazh da] LT",
                nextWeek: "dddd [da] LT",
                lastDay: "[Decʼh da] LT",
                lastWeek: "dddd [paset da] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "a-benn %s",
                past: "%s ʼzo",
                s: "un nebeud segondennoù",
                ss: "%d eilenn",
                m: "ur vunutenn",
                mm: relativeTimeWithMutation,
                h: "un eur",
                hh: "%d eur",
                d: "un devezh",
                dd: relativeTimeWithMutation,
                M: "ur miz",
                MM: relativeTimeWithMutation,
                y: "ur bloaz",
                yy: specialMutationForYears
            },
            dayOfMonthOrdinalParse: /\d{1,2}(añ|vet)/,
            ordinal: function(number) {
                return number + (1 === number ? "añ" : "vet")
            },
            week: {
                dow: 1,
                doy: 4
            },
            meridiemParse: /a.m.|g.m./,
            isPM: function(token) {
                return "g.m." === token
            },
            meridiem: function(hour, minute, isLower) {
                return hour < 12 ? "a.m." : "g.m."
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";

        function translate(number, withoutSuffix, key) {
            var result = number + " ";
            switch (key) {
                case "ss":
                    return result += 1 === number ? "sekunda" : 2 === number || 3 === number || 4 === number ? "sekunde" : "sekundi";
                case "m":
                    return withoutSuffix ? "jedna minuta" : "jedne minute";
                case "mm":
                    return result += 1 === number ? "minuta" : 2 === number || 3 === number || 4 === number ? "minute" : "minuta";
                case "h":
                    return withoutSuffix ? "jedan sat" : "jednog sata";
                case "hh":
                    return result += 1 === number ? "sat" : 2 === number || 3 === number || 4 === number ? "sata" : "sati";
                case "dd":
                    return result += 1 === number ? "dan" : "dana";
                case "MM":
                    return result += 1 === number ? "mjesec" : 2 === number || 3 === number || 4 === number ? "mjeseca" : "mjeseci";
                case "yy":
                    return result += 1 === number ? "godina" : 2 === number || 3 === number || 4 === number ? "godine" : "godina"
            }
        }
        moment.defineLocale("bs", {
            months: "januar_februar_mart_april_maj_juni_juli_august_septembar_oktobar_novembar_decembar".split("_"),
            monthsShort: "jan._feb._mar._apr._maj._jun._jul._aug._sep._okt._nov._dec.".split("_"),
            monthsParseExact: !0,
            weekdays: "nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota".split("_"),
            weekdaysShort: "ned._pon._uto._sri._čet._pet._sub.".split("_"),
            weekdaysMin: "ne_po_ut_sr_če_pe_su".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "H:mm",
                LTS: "H:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D. MMMM YYYY",
                LLL: "D. MMMM YYYY H:mm",
                LLLL: "dddd, D. MMMM YYYY H:mm"
            },
            calendar: {
                sameDay: "[danas u] LT",
                nextDay: "[sutra u] LT",
                nextWeek: function() {
                    switch (this.day()) {
                        case 0:
                            return "[u] [nedjelju] [u] LT";
                        case 3:
                            return "[u] [srijedu] [u] LT";
                        case 6:
                            return "[u] [subotu] [u] LT";
                        case 1:
                        case 2:
                        case 4:
                        case 5:
                            return "[u] dddd [u] LT"
                    }
                },
                lastDay: "[jučer u] LT",
                lastWeek: function() {
                    switch (this.day()) {
                        case 0:
                        case 3:
                            return "[prošlu] dddd [u] LT";
                        case 6:
                            return "[prošle] [subote] [u] LT";
                        case 1:
                        case 2:
                        case 4:
                        case 5:
                            return "[prošli] dddd [u] LT"
                    }
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "za %s",
                past: "prije %s",
                s: "par sekundi",
                ss: translate,
                m: translate,
                mm: translate,
                h: translate,
                hh: translate,
                d: "dan",
                dd: translate,
                M: "mjesec",
                MM: translate,
                y: "godinu",
                yy: translate
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {
                dow: 1,
                doy: 7
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("ca", {
            months: {
                standalone: "gener_febrer_març_abril_maig_juny_juliol_agost_setembre_octubre_novembre_desembre".split("_"),
                format: "de gener_de febrer_de març_d'abril_de maig_de juny_de juliol_d'agost_de setembre_d'octubre_de novembre_de desembre".split("_"),
                isFormat: /D[oD]?(\s)+MMMM/
            },
            monthsShort: "gen._febr._març_abr._maig_juny_jul._ag._set._oct._nov._des.".split("_"),
            monthsParseExact: !0,
            weekdays: "diumenge_dilluns_dimarts_dimecres_dijous_divendres_dissabte".split("_"),
            weekdaysShort: "dg._dl._dt._dc._dj._dv._ds.".split("_"),
            weekdaysMin: "dg_dl_dt_dc_dj_dv_ds".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "H:mm",
                LTS: "H:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM [de] YYYY",
                ll: "D MMM YYYY",
                LLL: "D MMMM [de] YYYY [a les] H:mm",
                lll: "D MMM YYYY, H:mm",
                LLLL: "dddd D MMMM [de] YYYY [a les] H:mm",
                llll: "ddd D MMM YYYY, H:mm"
            },
            calendar: {
                sameDay: function() {
                    return "[avui a " + (1 !== this.hours() ? "les" : "la") + "] LT"
                },
                nextDay: function() {
                    return "[demà a " + (1 !== this.hours() ? "les" : "la") + "] LT"
                },
                nextWeek: function() {
                    return "dddd [a " + (1 !== this.hours() ? "les" : "la") + "] LT"
                },
                lastDay: function() {
                    return "[ahir a " + (1 !== this.hours() ? "les" : "la") + "] LT"
                },
                lastWeek: function() {
                    return "[el] dddd [passat a " + (1 !== this.hours() ? "les" : "la") + "] LT"
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "d'aquí %s",
                past: "fa %s",
                s: "uns segons",
                ss: "%d segons",
                m: "un minut",
                mm: "%d minuts",
                h: "una hora",
                hh: "%d hores",
                d: "un dia",
                dd: "%d dies",
                M: "un mes",
                MM: "%d mesos",
                y: "un any",
                yy: "%d anys"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(r|n|t|è|a)/,
            ordinal: function(number, period) {
                var output = 1 === number ? "r" : 2 === number ? "n" : 3 === number ? "r" : 4 === number ? "t" : "è";
                return "w" !== period && "W" !== period || (output = "a"), number + output
            },
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        var months = "leden_únor_březen_duben_květen_červen_červenec_srpen_září_říjen_listopad_prosinec".split("_"),
            monthsShort = "led_úno_bře_dub_kvě_čvn_čvc_srp_zář_říj_lis_pro".split("_"),
            monthsParse = [/^led/i, /^úno/i, /^bře/i, /^dub/i, /^kvě/i, /^(čvn|červen$|června)/i, /^(čvc|červenec|července)/i, /^srp/i, /^zář/i, /^říj/i, /^lis/i, /^pro/i],
            monthsRegex = /^(leden|únor|březen|duben|květen|červenec|července|červen|června|srpen|září|říjen|listopad|prosinec|led|úno|bře|dub|kvě|čvn|čvc|srp|zář|říj|lis|pro)/i;

        function plural(n) {
            return n > 1 && n < 5 && 1 != ~~(n / 10)
        }

        function translate(number, withoutSuffix, key, isFuture) {
            var result = number + " ";
            switch (key) {
                case "s":
                    return withoutSuffix || isFuture ? "pár sekund" : "pár sekundami";
                case "ss":
                    return withoutSuffix || isFuture ? result + (plural(number) ? "sekundy" : "sekund") : result + "sekundami";
                case "m":
                    return withoutSuffix ? "minuta" : isFuture ? "minutu" : "minutou";
                case "mm":
                    return withoutSuffix || isFuture ? result + (plural(number) ? "minuty" : "minut") : result + "minutami";
                case "h":
                    return withoutSuffix ? "hodina" : isFuture ? "hodinu" : "hodinou";
                case "hh":
                    return withoutSuffix || isFuture ? result + (plural(number) ? "hodiny" : "hodin") : result + "hodinami";
                case "d":
                    return withoutSuffix || isFuture ? "den" : "dnem";
                case "dd":
                    return withoutSuffix || isFuture ? result + (plural(number) ? "dny" : "dní") : result + "dny";
                case "M":
                    return withoutSuffix || isFuture ? "měsíc" : "měsícem";
                case "MM":
                    return withoutSuffix || isFuture ? result + (plural(number) ? "měsíce" : "měsíců") : result + "měsíci";
                case "y":
                    return withoutSuffix || isFuture ? "rok" : "rokem";
                case "yy":
                    return withoutSuffix || isFuture ? result + (plural(number) ? "roky" : "let") : result + "lety"
            }
        }
        moment.defineLocale("cs", {
            months: months,
            monthsShort: monthsShort,
            monthsRegex: monthsRegex,
            monthsShortRegex: monthsRegex,
            monthsStrictRegex: /^(leden|ledna|února|únor|březen|března|duben|dubna|květen|května|červenec|července|červen|června|srpen|srpna|září|říjen|října|listopadu|listopad|prosinec|prosince)/i,
            monthsShortStrictRegex: /^(led|úno|bře|dub|kvě|čvn|čvc|srp|zář|říj|lis|pro)/i,
            monthsParse: monthsParse,
            longMonthsParse: monthsParse,
            shortMonthsParse: monthsParse,
            weekdays: "neděle_pondělí_úterý_středa_čtvrtek_pátek_sobota".split("_"),
            weekdaysShort: "ne_po_út_st_čt_pá_so".split("_"),
            weekdaysMin: "ne_po_út_st_čt_pá_so".split("_"),
            longDateFormat: {
                LT: "H:mm",
                LTS: "H:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D. MMMM YYYY",
                LLL: "D. MMMM YYYY H:mm",
                LLLL: "dddd D. MMMM YYYY H:mm",
                l: "D. M. YYYY"
            },
            calendar: {
                sameDay: "[dnes v] LT",
                nextDay: "[zítra v] LT",
                nextWeek: function() {
                    switch (this.day()) {
                        case 0:
                            return "[v neděli v] LT";
                        case 1:
                        case 2:
                            return "[v] dddd [v] LT";
                        case 3:
                            return "[ve středu v] LT";
                        case 4:
                            return "[ve čtvrtek v] LT";
                        case 5:
                            return "[v pátek v] LT";
                        case 6:
                            return "[v sobotu v] LT"
                    }
                },
                lastDay: "[včera v] LT",
                lastWeek: function() {
                    switch (this.day()) {
                        case 0:
                            return "[minulou neděli v] LT";
                        case 1:
                        case 2:
                            return "[minulé] dddd [v] LT";
                        case 3:
                            return "[minulou středu v] LT";
                        case 4:
                        case 5:
                            return "[minulý] dddd [v] LT";
                        case 6:
                            return "[minulou sobotu v] LT"
                    }
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "za %s",
                past: "před %s",
                s: translate,
                ss: translate,
                m: translate,
                mm: translate,
                h: translate,
                hh: translate,
                d: translate,
                dd: translate,
                M: translate,
                MM: translate,
                y: translate,
                yy: translate
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("cv", {
            months: "кӑрлач_нарӑс_пуш_ака_май_ҫӗртме_утӑ_ҫурла_авӑн_юпа_чӳк_раштав".split("_"),
            monthsShort: "кӑр_нар_пуш_ака_май_ҫӗр_утӑ_ҫур_авн_юпа_чӳк_раш".split("_"),
            weekdays: "вырсарникун_тунтикун_ытларикун_юнкун_кӗҫнерникун_эрнекун_шӑматкун".split("_"),
            weekdaysShort: "выр_тун_ытл_юн_кӗҫ_эрн_шӑм".split("_"),
            weekdaysMin: "вр_тн_ыт_юн_кҫ_эр_шм".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD-MM-YYYY",
                LL: "YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ]",
                LLL: "YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ], HH:mm",
                LLLL: "dddd, YYYY [ҫулхи] MMMM [уйӑхӗн] D[-мӗшӗ], HH:mm"
            },
            calendar: {
                sameDay: "[Паян] LT [сехетре]",
                nextDay: "[Ыран] LT [сехетре]",
                lastDay: "[Ӗнер] LT [сехетре]",
                nextWeek: "[Ҫитес] dddd LT [сехетре]",
                lastWeek: "[Иртнӗ] dddd LT [сехетре]",
                sameElse: "L"
            },
            relativeTime: {
                future: function(output) {
                    return output + (/сехет$/i.exec(output) ? "рен" : /ҫул$/i.exec(output) ? "тан" : "ран")
                },
                past: "%s каялла",
                s: "пӗр-ик ҫеккунт",
                ss: "%d ҫеккунт",
                m: "пӗр минут",
                mm: "%d минут",
                h: "пӗр сехет",
                hh: "%d сехет",
                d: "пӗр кун",
                dd: "%d кун",
                M: "пӗр уйӑх",
                MM: "%d уйӑх",
                y: "пӗр ҫул",
                yy: "%d ҫул"
            },
            dayOfMonthOrdinalParse: /\d{1,2}-мӗш/,
            ordinal: "%d-мӗш",
            week: {
                dow: 1,
                doy: 7
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("cy", {
            months: "Ionawr_Chwefror_Mawrth_Ebrill_Mai_Mehefin_Gorffennaf_Awst_Medi_Hydref_Tachwedd_Rhagfyr".split("_"),
            monthsShort: "Ion_Chwe_Maw_Ebr_Mai_Meh_Gor_Aws_Med_Hyd_Tach_Rhag".split("_"),
            weekdays: "Dydd Sul_Dydd Llun_Dydd Mawrth_Dydd Mercher_Dydd Iau_Dydd Gwener_Dydd Sadwrn".split("_"),
            weekdaysShort: "Sul_Llun_Maw_Mer_Iau_Gwe_Sad".split("_"),
            weekdaysMin: "Su_Ll_Ma_Me_Ia_Gw_Sa".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd, D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[Heddiw am] LT",
                nextDay: "[Yfory am] LT",
                nextWeek: "dddd [am] LT",
                lastDay: "[Ddoe am] LT",
                lastWeek: "dddd [diwethaf am] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "mewn %s",
                past: "%s yn ôl",
                s: "ychydig eiliadau",
                ss: "%d eiliad",
                m: "munud",
                mm: "%d munud",
                h: "awr",
                hh: "%d awr",
                d: "diwrnod",
                dd: "%d diwrnod",
                M: "mis",
                MM: "%d mis",
                y: "blwyddyn",
                yy: "%d flynedd"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(fed|ain|af|il|ydd|ed|eg)/,
            ordinal: function(number) {
                var output = "";
                return number > 20 ? output = 40 === number || 50 === number || 60 === number || 80 === number || 100 === number ? "fed" : "ain" : number > 0 && (output = ["", "af", "il", "ydd", "ydd", "ed", "ed", "ed", "fed", "fed", "fed", "eg", "fed", "eg", "eg", "fed", "eg", "eg", "fed", "eg", "fed"][number]), number + output
            },
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("da", {
            months: "januar_februar_marts_april_maj_juni_juli_august_september_oktober_november_december".split("_"),
            monthsShort: "jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec".split("_"),
            weekdays: "søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag".split("_"),
            weekdaysShort: "søn_man_tir_ons_tor_fre_lør".split("_"),
            weekdaysMin: "sø_ma_ti_on_to_fr_lø".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D. MMMM YYYY",
                LLL: "D. MMMM YYYY HH:mm",
                LLLL: "dddd [d.] D. MMMM YYYY [kl.] HH:mm"
            },
            calendar: {
                sameDay: "[i dag kl.] LT",
                nextDay: "[i morgen kl.] LT",
                nextWeek: "på dddd [kl.] LT",
                lastDay: "[i går kl.] LT",
                lastWeek: "[i] dddd[s kl.] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "om %s",
                past: "%s siden",
                s: "få sekunder",
                ss: "%d sekunder",
                m: "et minut",
                mm: "%d minutter",
                h: "en time",
                hh: "%d timer",
                d: "en dag",
                dd: "%d dage",
                M: "en måned",
                MM: "%d måneder",
                y: "et år",
                yy: "%d år"
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";

        function processRelativeTime(number, withoutSuffix, key, isFuture) {
            var format = {
                m: ["eine Minute", "einer Minute"],
                h: ["eine Stunde", "einer Stunde"],
                d: ["ein Tag", "einem Tag"],
                dd: [number + " Tage", number + " Tagen"],
                w: ["eine Woche", "einer Woche"],
                M: ["ein Monat", "einem Monat"],
                MM: [number + " Monate", number + " Monaten"],
                y: ["ein Jahr", "einem Jahr"],
                yy: [number + " Jahre", number + " Jahren"]
            };
            return withoutSuffix ? format[key][0] : format[key][1]
        }
        moment.defineLocale("de", {
            months: "Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),
            monthsShort: "Jan._Feb._März_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.".split("_"),
            monthsParseExact: !0,
            weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"),
            weekdaysShort: "So._Mo._Di._Mi._Do._Fr._Sa.".split("_"),
            weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D. MMMM YYYY",
                LLL: "D. MMMM YYYY HH:mm",
                LLLL: "dddd, D. MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[heute um] LT [Uhr]",
                sameElse: "L",
                nextDay: "[morgen um] LT [Uhr]",
                nextWeek: "dddd [um] LT [Uhr]",
                lastDay: "[gestern um] LT [Uhr]",
                lastWeek: "[letzten] dddd [um] LT [Uhr]"
            },
            relativeTime: {
                future: "in %s",
                past: "vor %s",
                s: "ein paar Sekunden",
                ss: "%d Sekunden",
                m: processRelativeTime,
                mm: "%d Minuten",
                h: processRelativeTime,
                hh: "%d Stunden",
                d: processRelativeTime,
                dd: processRelativeTime,
                w: processRelativeTime,
                ww: "%d Wochen",
                M: processRelativeTime,
                MM: processRelativeTime,
                y: processRelativeTime,
                yy: processRelativeTime
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";

        function processRelativeTime(number, withoutSuffix, key, isFuture) {
            var format = {
                m: ["eine Minute", "einer Minute"],
                h: ["eine Stunde", "einer Stunde"],
                d: ["ein Tag", "einem Tag"],
                dd: [number + " Tage", number + " Tagen"],
                w: ["eine Woche", "einer Woche"],
                M: ["ein Monat", "einem Monat"],
                MM: [number + " Monate", number + " Monaten"],
                y: ["ein Jahr", "einem Jahr"],
                yy: [number + " Jahre", number + " Jahren"]
            };
            return withoutSuffix ? format[key][0] : format[key][1]
        }
        moment.defineLocale("de-at", {
            months: "Jänner_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),
            monthsShort: "Jän._Feb._März_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.".split("_"),
            monthsParseExact: !0,
            weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"),
            weekdaysShort: "So._Mo._Di._Mi._Do._Fr._Sa.".split("_"),
            weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D. MMMM YYYY",
                LLL: "D. MMMM YYYY HH:mm",
                LLLL: "dddd, D. MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[heute um] LT [Uhr]",
                sameElse: "L",
                nextDay: "[morgen um] LT [Uhr]",
                nextWeek: "dddd [um] LT [Uhr]",
                lastDay: "[gestern um] LT [Uhr]",
                lastWeek: "[letzten] dddd [um] LT [Uhr]"
            },
            relativeTime: {
                future: "in %s",
                past: "vor %s",
                s: "ein paar Sekunden",
                ss: "%d Sekunden",
                m: processRelativeTime,
                mm: "%d Minuten",
                h: processRelativeTime,
                hh: "%d Stunden",
                d: processRelativeTime,
                dd: processRelativeTime,
                w: processRelativeTime,
                ww: "%d Wochen",
                M: processRelativeTime,
                MM: processRelativeTime,
                y: processRelativeTime,
                yy: processRelativeTime
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";

        function processRelativeTime(number, withoutSuffix, key, isFuture) {
            var format = {
                m: ["eine Minute", "einer Minute"],
                h: ["eine Stunde", "einer Stunde"],
                d: ["ein Tag", "einem Tag"],
                dd: [number + " Tage", number + " Tagen"],
                w: ["eine Woche", "einer Woche"],
                M: ["ein Monat", "einem Monat"],
                MM: [number + " Monate", number + " Monaten"],
                y: ["ein Jahr", "einem Jahr"],
                yy: [number + " Jahre", number + " Jahren"]
            };
            return withoutSuffix ? format[key][0] : format[key][1]
        }
        moment.defineLocale("de-ch", {
            months: "Januar_Februar_März_April_Mai_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),
            monthsShort: "Jan._Feb._März_Apr._Mai_Juni_Juli_Aug._Sep._Okt._Nov._Dez.".split("_"),
            monthsParseExact: !0,
            weekdays: "Sonntag_Montag_Dienstag_Mittwoch_Donnerstag_Freitag_Samstag".split("_"),
            weekdaysShort: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"),
            weekdaysMin: "So_Mo_Di_Mi_Do_Fr_Sa".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D. MMMM YYYY",
                LLL: "D. MMMM YYYY HH:mm",
                LLLL: "dddd, D. MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[heute um] LT [Uhr]",
                sameElse: "L",
                nextDay: "[morgen um] LT [Uhr]",
                nextWeek: "dddd [um] LT [Uhr]",
                lastDay: "[gestern um] LT [Uhr]",
                lastWeek: "[letzten] dddd [um] LT [Uhr]"
            },
            relativeTime: {
                future: "in %s",
                past: "vor %s",
                s: "ein paar Sekunden",
                ss: "%d Sekunden",
                m: processRelativeTime,
                mm: "%d Minuten",
                h: processRelativeTime,
                hh: "%d Stunden",
                d: processRelativeTime,
                dd: processRelativeTime,
                w: processRelativeTime,
                ww: "%d Wochen",
                M: processRelativeTime,
                MM: processRelativeTime,
                y: processRelativeTime,
                yy: processRelativeTime
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        var months = ["ޖެނުއަރީ", "ފެބްރުއަރީ", "މާރިޗު", "އޭޕްރީލު", "މޭ", "ޖޫން", "ޖުލައި", "އޯގަސްޓު", "ސެޕްޓެމްބަރު", "އޮކްޓޯބަރު", "ނޮވެމްބަރު", "ޑިސެމްބަރު"],
            weekdays = ["އާދިއްތަ", "ހޯމަ", "އަންގާރަ", "ބުދަ", "ބުރާސްފަތި", "ހުކުރު", "ހޮނިހިރު"];
        moment.defineLocale("dv", {
            months: months,
            monthsShort: months,
            weekdays: weekdays,
            weekdaysShort: weekdays,
            weekdaysMin: "އާދި_ހޯމަ_އަން_ބުދަ_ބުރާ_ހުކު_ހޮނި".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "D/M/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd D MMMM YYYY HH:mm"
            },
            meridiemParse: /މކ|މފ/,
            isPM: function(input) {
                return "މފ" === input
            },
            meridiem: function(hour, minute, isLower) {
                return hour < 12 ? "މކ" : "މފ"
            },
            calendar: {
                sameDay: "[މިއަދު] LT",
                nextDay: "[މާދަމާ] LT",
                nextWeek: "dddd LT",
                lastDay: "[އިއްޔެ] LT",
                lastWeek: "[ފާއިތުވި] dddd LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "ތެރޭގައި %s",
                past: "ކުރިން %s",
                s: "ސިކުންތުކޮޅެއް",
                ss: "d% ސިކުންތު",
                m: "މިނިޓެއް",
                mm: "މިނިޓު %d",
                h: "ގަޑިއިރެއް",
                hh: "ގަޑިއިރު %d",
                d: "ދުވަހެއް",
                dd: "ދުވަސް %d",
                M: "މަހެއް",
                MM: "މަސް %d",
                y: "އަހަރެއް",
                yy: "އަހަރު %d"
            },
            preparse: function(string) {
                return string.replace(/،/g, ",")
            },
            postformat: function(string) {
                return string.replace(/,/g, "،")
            },
            week: {
                dow: 7,
                doy: 12
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";

        function isFunction(input) {
            return "undefined" != typeof Function && input instanceof Function || "[object Function]" === Object.prototype.toString.call(input)
        }
        moment.defineLocale("el", {
            monthsNominativeEl: "Ιανουάριος_Φεβρουάριος_Μάρτιος_Απρίλιος_Μάιος_Ιούνιος_Ιούλιος_Αύγουστος_Σεπτέμβριος_Οκτώβριος_Νοέμβριος_Δεκέμβριος".split("_"),
            monthsGenitiveEl: "Ιανουαρίου_Φεβρουαρίου_Μαρτίου_Απριλίου_Μαΐου_Ιουνίου_Ιουλίου_Αυγούστου_Σεπτεμβρίου_Οκτωβρίου_Νοεμβρίου_Δεκεμβρίου".split("_"),
            months: function(momentToFormat, format) {
                return momentToFormat ? "string" == typeof format && /D/.test(format.substring(0, format.indexOf("MMMM"))) ? this._monthsGenitiveEl[momentToFormat.month()] : this._monthsNominativeEl[momentToFormat.month()] : this._monthsNominativeEl
            },
            monthsShort: "Ιαν_Φεβ_Μαρ_Απρ_Μαϊ_Ιουν_Ιουλ_Αυγ_Σεπ_Οκτ_Νοε_Δεκ".split("_"),
            weekdays: "Κυριακή_Δευτέρα_Τρίτη_Τετάρτη_Πέμπτη_Παρασκευή_Σάββατο".split("_"),
            weekdaysShort: "Κυρ_Δευ_Τρι_Τετ_Πεμ_Παρ_Σαβ".split("_"),
            weekdaysMin: "Κυ_Δε_Τρ_Τε_Πε_Πα_Σα".split("_"),
            meridiem: function(hours, minutes, isLower) {
                return hours > 11 ? isLower ? "μμ" : "ΜΜ" : isLower ? "πμ" : "ΠΜ"
            },
            isPM: function(input) {
                return "μ" === (input + "").toLowerCase()[0]
            },
            meridiemParse: /[ΠΜ]\.?Μ?\.?/i,
            longDateFormat: {
                LT: "h:mm A",
                LTS: "h:mm:ss A",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY h:mm A",
                LLLL: "dddd, D MMMM YYYY h:mm A"
            },
            calendarEl: {
                sameDay: "[Σήμερα {}] LT",
                nextDay: "[Αύριο {}] LT",
                nextWeek: "dddd [{}] LT",
                lastDay: "[Χθες {}] LT",
                lastWeek: function() {
                    switch (this.day()) {
                        case 6:
                            return "[το προηγούμενο] dddd [{}] LT";
                        default:
                            return "[την προηγούμενη] dddd [{}] LT"
                    }
                },
                sameElse: "L"
            },
            calendar: function(key, mom) {
                var output = this._calendarEl[key],
                    hours = mom && mom.hours();
                return isFunction(output) && (output = output.apply(mom)), output.replace("{}", hours % 12 == 1 ? "στη" : "στις")
            },
            relativeTime: {
                future: "σε %s",
                past: "%s πριν",
                s: "λίγα δευτερόλεπτα",
                ss: "%d δευτερόλεπτα",
                m: "ένα λεπτό",
                mm: "%d λεπτά",
                h: "μία ώρα",
                hh: "%d ώρες",
                d: "μία μέρα",
                dd: "%d μέρες",
                M: "ένας μήνας",
                MM: "%d μήνες",
                y: "ένας χρόνος",
                yy: "%d χρόνια"
            },
            dayOfMonthOrdinalParse: /\d{1,2}η/,
            ordinal: "%dη",
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("en-au", {
            months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
            monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
            weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
            weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
            weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
            longDateFormat: {
                LT: "h:mm A",
                LTS: "h:mm:ss A",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY h:mm A",
                LLLL: "dddd, D MMMM YYYY h:mm A"
            },
            calendar: {
                sameDay: "[Today at] LT",
                nextDay: "[Tomorrow at] LT",
                nextWeek: "dddd [at] LT",
                lastDay: "[Yesterday at] LT",
                lastWeek: "[Last] dddd [at] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "in %s",
                past: "%s ago",
                s: "a few seconds",
                ss: "%d seconds",
                m: "a minute",
                mm: "%d minutes",
                h: "an hour",
                hh: "%d hours",
                d: "a day",
                dd: "%d days",
                M: "a month",
                MM: "%d months",
                y: "a year",
                yy: "%d years"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
            ordinal: function(number) {
                var b = number % 10;
                return number + (1 == ~~(number % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th")
            },
            week: {
                dow: 0,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("en-ca", {
            months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
            monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
            weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
            weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
            weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
            longDateFormat: {
                LT: "h:mm A",
                LTS: "h:mm:ss A",
                L: "YYYY-MM-DD",
                LL: "MMMM D, YYYY",
                LLL: "MMMM D, YYYY h:mm A",
                LLLL: "dddd, MMMM D, YYYY h:mm A"
            },
            calendar: {
                sameDay: "[Today at] LT",
                nextDay: "[Tomorrow at] LT",
                nextWeek: "dddd [at] LT",
                lastDay: "[Yesterday at] LT",
                lastWeek: "[Last] dddd [at] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "in %s",
                past: "%s ago",
                s: "a few seconds",
                ss: "%d seconds",
                m: "a minute",
                mm: "%d minutes",
                h: "an hour",
                hh: "%d hours",
                d: "a day",
                dd: "%d days",
                M: "a month",
                MM: "%d months",
                y: "a year",
                yy: "%d years"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
            ordinal: function(number) {
                var b = number % 10;
                return number + (1 == ~~(number % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th")
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("en-gb", {
            months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
            monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
            weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
            weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
            weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd, D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[Today at] LT",
                nextDay: "[Tomorrow at] LT",
                nextWeek: "dddd [at] LT",
                lastDay: "[Yesterday at] LT",
                lastWeek: "[Last] dddd [at] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "in %s",
                past: "%s ago",
                s: "a few seconds",
                ss: "%d seconds",
                m: "a minute",
                mm: "%d minutes",
                h: "an hour",
                hh: "%d hours",
                d: "a day",
                dd: "%d days",
                M: "a month",
                MM: "%d months",
                y: "a year",
                yy: "%d years"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
            ordinal: function(number) {
                var b = number % 10;
                return number + (1 == ~~(number % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th")
            },
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("en-ie", {
            months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
            monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
            weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
            weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
            weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[Today at] LT",
                nextDay: "[Tomorrow at] LT",
                nextWeek: "dddd [at] LT",
                lastDay: "[Yesterday at] LT",
                lastWeek: "[Last] dddd [at] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "in %s",
                past: "%s ago",
                s: "a few seconds",
                ss: "%d seconds",
                m: "a minute",
                mm: "%d minutes",
                h: "an hour",
                hh: "%d hours",
                d: "a day",
                dd: "%d days",
                M: "a month",
                MM: "%d months",
                y: "a year",
                yy: "%d years"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
            ordinal: function(number) {
                var b = number % 10;
                return number + (1 == ~~(number % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th")
            },
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("en-il", {
            months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
            monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
            weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
            weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
            weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd, D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[Today at] LT",
                nextDay: "[Tomorrow at] LT",
                nextWeek: "dddd [at] LT",
                lastDay: "[Yesterday at] LT",
                lastWeek: "[Last] dddd [at] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "in %s",
                past: "%s ago",
                s: "a few seconds",
                ss: "%d seconds",
                m: "a minute",
                mm: "%d minutes",
                h: "an hour",
                hh: "%d hours",
                d: "a day",
                dd: "%d days",
                M: "a month",
                MM: "%d months",
                y: "a year",
                yy: "%d years"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
            ordinal: function(number) {
                var b = number % 10;
                return number + (1 == ~~(number % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th")
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("en-in", {
            months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
            monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
            weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
            weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
            weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
            longDateFormat: {
                LT: "h:mm A",
                LTS: "h:mm:ss A",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY h:mm A",
                LLLL: "dddd, D MMMM YYYY h:mm A"
            },
            calendar: {
                sameDay: "[Today at] LT",
                nextDay: "[Tomorrow at] LT",
                nextWeek: "dddd [at] LT",
                lastDay: "[Yesterday at] LT",
                lastWeek: "[Last] dddd [at] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "in %s",
                past: "%s ago",
                s: "a few seconds",
                ss: "%d seconds",
                m: "a minute",
                mm: "%d minutes",
                h: "an hour",
                hh: "%d hours",
                d: "a day",
                dd: "%d days",
                M: "a month",
                MM: "%d months",
                y: "a year",
                yy: "%d years"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
            ordinal: function(number) {
                var b = number % 10;
                return number + (1 == ~~(number % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th")
            },
            week: {
                dow: 0,
                doy: 6
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("en-nz", {
            months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
            monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
            weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
            weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
            weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
            longDateFormat: {
                LT: "h:mm A",
                LTS: "h:mm:ss A",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY h:mm A",
                LLLL: "dddd, D MMMM YYYY h:mm A"
            },
            calendar: {
                sameDay: "[Today at] LT",
                nextDay: "[Tomorrow at] LT",
                nextWeek: "dddd [at] LT",
                lastDay: "[Yesterday at] LT",
                lastWeek: "[Last] dddd [at] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "in %s",
                past: "%s ago",
                s: "a few seconds",
                ss: "%d seconds",
                m: "a minute",
                mm: "%d minutes",
                h: "an hour",
                hh: "%d hours",
                d: "a day",
                dd: "%d days",
                M: "a month",
                MM: "%d months",
                y: "a year",
                yy: "%d years"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
            ordinal: function(number) {
                var b = number % 10;
                return number + (1 == ~~(number % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th")
            },
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("en-sg", {
            months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
            monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
            weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
            weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
            weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd, D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[Today at] LT",
                nextDay: "[Tomorrow at] LT",
                nextWeek: "dddd [at] LT",
                lastDay: "[Yesterday at] LT",
                lastWeek: "[Last] dddd [at] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "in %s",
                past: "%s ago",
                s: "a few seconds",
                ss: "%d seconds",
                m: "a minute",
                mm: "%d minutes",
                h: "an hour",
                hh: "%d hours",
                d: "a day",
                dd: "%d days",
                M: "a month",
                MM: "%d months",
                y: "a year",
                yy: "%d years"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
            ordinal: function(number) {
                var b = number % 10;
                return number + (1 == ~~(number % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th")
            },
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("eo", {
            months: "januaro_februaro_marto_aprilo_majo_junio_julio_aŭgusto_septembro_oktobro_novembro_decembro".split("_"),
            monthsShort: "jan_feb_mart_apr_maj_jun_jul_aŭg_sept_okt_nov_dec".split("_"),
            weekdays: "dimanĉo_lundo_mardo_merkredo_ĵaŭdo_vendredo_sabato".split("_"),
            weekdaysShort: "dim_lun_mard_merk_ĵaŭ_ven_sab".split("_"),
            weekdaysMin: "di_lu_ma_me_ĵa_ve_sa".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "YYYY-MM-DD",
                LL: "[la] D[-an de] MMMM, YYYY",
                LLL: "[la] D[-an de] MMMM, YYYY HH:mm",
                LLLL: "dddd[n], [la] D[-an de] MMMM, YYYY HH:mm",
                llll: "ddd, [la] D[-an de] MMM, YYYY HH:mm"
            },
            meridiemParse: /[ap]\.t\.m/i,
            isPM: function(input) {
                return "p" === input.charAt(0).toLowerCase()
            },
            meridiem: function(hours, minutes, isLower) {
                return hours > 11 ? isLower ? "p.t.m." : "P.T.M." : isLower ? "a.t.m." : "A.T.M."
            },
            calendar: {
                sameDay: "[Hodiaŭ je] LT",
                nextDay: "[Morgaŭ je] LT",
                nextWeek: "dddd[n je] LT",
                lastDay: "[Hieraŭ je] LT",
                lastWeek: "[pasintan] dddd[n je] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "post %s",
                past: "antaŭ %s",
                s: "kelkaj sekundoj",
                ss: "%d sekundoj",
                m: "unu minuto",
                mm: "%d minutoj",
                h: "unu horo",
                hh: "%d horoj",
                d: "unu tago",
                dd: "%d tagoj",
                M: "unu monato",
                MM: "%d monatoj",
                y: "unu jaro",
                yy: "%d jaroj"
            },
            dayOfMonthOrdinalParse: /\d{1,2}a/,
            ordinal: "%da",
            week: {
                dow: 1,
                doy: 7
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        var monthsShortDot = "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"),
            monthsShort = "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"),
            monthsParse = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i],
            monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
        moment.defineLocale("es", {
            months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"),
            monthsShort: function(m, format) {
                return m ? /-MMM-/.test(format) ? monthsShort[m.month()] : monthsShortDot[m.month()] : monthsShortDot
            },
            monthsRegex: monthsRegex,
            monthsShortRegex: monthsRegex,
            monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
            monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
            monthsParse: monthsParse,
            longMonthsParse: monthsParse,
            shortMonthsParse: monthsParse,
            weekdays: "domingo_lunes_martes_miércoles_jueves_viernes_sábado".split("_"),
            weekdaysShort: "dom._lun._mar._mié._jue._vie._sáb.".split("_"),
            weekdaysMin: "do_lu_ma_mi_ju_vi_sá".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "H:mm",
                LTS: "H:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D [de] MMMM [de] YYYY",
                LLL: "D [de] MMMM [de] YYYY H:mm",
                LLLL: "dddd, D [de] MMMM [de] YYYY H:mm"
            },
            calendar: {
                sameDay: function() {
                    return "[hoy a la" + (1 !== this.hours() ? "s" : "") + "] LT"
                },
                nextDay: function() {
                    return "[mañana a la" + (1 !== this.hours() ? "s" : "") + "] LT"
                },
                nextWeek: function() {
                    return "dddd [a la" + (1 !== this.hours() ? "s" : "") + "] LT"
                },
                lastDay: function() {
                    return "[ayer a la" + (1 !== this.hours() ? "s" : "") + "] LT"
                },
                lastWeek: function() {
                    return "[el] dddd [pasado a la" + (1 !== this.hours() ? "s" : "") + "] LT"
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "en %s",
                past: "hace %s",
                s: "unos segundos",
                ss: "%d segundos",
                m: "un minuto",
                mm: "%d minutos",
                h: "una hora",
                hh: "%d horas",
                d: "un día",
                dd: "%d días",
                w: "una semana",
                ww: "%d semanas",
                M: "un mes",
                MM: "%d meses",
                y: "un año",
                yy: "%d años"
            },
            dayOfMonthOrdinalParse: /\d{1,2}º/,
            ordinal: "%dº",
            week: {
                dow: 1,
                doy: 4
            },
            invalidDate: "Fecha inválida"
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        var monthsShortDot = "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"),
            monthsShort = "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"),
            monthsParse = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i],
            monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
        moment.defineLocale("es-do", {
            months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"),
            monthsShort: function(m, format) {
                return m ? /-MMM-/.test(format) ? monthsShort[m.month()] : monthsShortDot[m.month()] : monthsShortDot
            },
            monthsRegex: monthsRegex,
            monthsShortRegex: monthsRegex,
            monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
            monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
            monthsParse: monthsParse,
            longMonthsParse: monthsParse,
            shortMonthsParse: monthsParse,
            weekdays: "domingo_lunes_martes_miércoles_jueves_viernes_sábado".split("_"),
            weekdaysShort: "dom._lun._mar._mié._jue._vie._sáb.".split("_"),
            weekdaysMin: "do_lu_ma_mi_ju_vi_sá".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "h:mm A",
                LTS: "h:mm:ss A",
                L: "DD/MM/YYYY",
                LL: "D [de] MMMM [de] YYYY",
                LLL: "D [de] MMMM [de] YYYY h:mm A",
                LLLL: "dddd, D [de] MMMM [de] YYYY h:mm A"
            },
            calendar: {
                sameDay: function() {
                    return "[hoy a la" + (1 !== this.hours() ? "s" : "") + "] LT"
                },
                nextDay: function() {
                    return "[mañana a la" + (1 !== this.hours() ? "s" : "") + "] LT"
                },
                nextWeek: function() {
                    return "dddd [a la" + (1 !== this.hours() ? "s" : "") + "] LT"
                },
                lastDay: function() {
                    return "[ayer a la" + (1 !== this.hours() ? "s" : "") + "] LT"
                },
                lastWeek: function() {
                    return "[el] dddd [pasado a la" + (1 !== this.hours() ? "s" : "") + "] LT"
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "en %s",
                past: "hace %s",
                s: "unos segundos",
                ss: "%d segundos",
                m: "un minuto",
                mm: "%d minutos",
                h: "una hora",
                hh: "%d horas",
                d: "un día",
                dd: "%d días",
                w: "una semana",
                ww: "%d semanas",
                M: "un mes",
                MM: "%d meses",
                y: "un año",
                yy: "%d años"
            },
            dayOfMonthOrdinalParse: /\d{1,2}º/,
            ordinal: "%dº",
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        var monthsShortDot = "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"),
            monthsShort = "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"),
            monthsParse = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i],
            monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
        moment.defineLocale("es-mx", {
            months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"),
            monthsShort: function(m, format) {
                return m ? /-MMM-/.test(format) ? monthsShort[m.month()] : monthsShortDot[m.month()] : monthsShortDot
            },
            monthsRegex: monthsRegex,
            monthsShortRegex: monthsRegex,
            monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
            monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
            monthsParse: monthsParse,
            longMonthsParse: monthsParse,
            shortMonthsParse: monthsParse,
            weekdays: "domingo_lunes_martes_miércoles_jueves_viernes_sábado".split("_"),
            weekdaysShort: "dom._lun._mar._mié._jue._vie._sáb.".split("_"),
            weekdaysMin: "do_lu_ma_mi_ju_vi_sá".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "H:mm",
                LTS: "H:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D [de] MMMM [de] YYYY",
                LLL: "D [de] MMMM [de] YYYY H:mm",
                LLLL: "dddd, D [de] MMMM [de] YYYY H:mm"
            },
            calendar: {
                sameDay: function() {
                    return "[hoy a la" + (1 !== this.hours() ? "s" : "") + "] LT"
                },
                nextDay: function() {
                    return "[mañana a la" + (1 !== this.hours() ? "s" : "") + "] LT"
                },
                nextWeek: function() {
                    return "dddd [a la" + (1 !== this.hours() ? "s" : "") + "] LT"
                },
                lastDay: function() {
                    return "[ayer a la" + (1 !== this.hours() ? "s" : "") + "] LT"
                },
                lastWeek: function() {
                    return "[el] dddd [pasado a la" + (1 !== this.hours() ? "s" : "") + "] LT"
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "en %s",
                past: "hace %s",
                s: "unos segundos",
                ss: "%d segundos",
                m: "un minuto",
                mm: "%d minutos",
                h: "una hora",
                hh: "%d horas",
                d: "un día",
                dd: "%d días",
                w: "una semana",
                ww: "%d semanas",
                M: "un mes",
                MM: "%d meses",
                y: "un año",
                yy: "%d años"
            },
            dayOfMonthOrdinalParse: /\d{1,2}º/,
            ordinal: "%dº",
            week: {
                dow: 0,
                doy: 4
            },
            invalidDate: "Fecha inválida"
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        var monthsShortDot = "ene._feb._mar._abr._may._jun._jul._ago._sep._oct._nov._dic.".split("_"),
            monthsShort = "ene_feb_mar_abr_may_jun_jul_ago_sep_oct_nov_dic".split("_"),
            monthsParse = [/^ene/i, /^feb/i, /^mar/i, /^abr/i, /^may/i, /^jun/i, /^jul/i, /^ago/i, /^sep/i, /^oct/i, /^nov/i, /^dic/i],
            monthsRegex = /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre|ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i;
        moment.defineLocale("es-us", {
            months: "enero_febrero_marzo_abril_mayo_junio_julio_agosto_septiembre_octubre_noviembre_diciembre".split("_"),
            monthsShort: function(m, format) {
                return m ? /-MMM-/.test(format) ? monthsShort[m.month()] : monthsShortDot[m.month()] : monthsShortDot
            },
            monthsRegex: monthsRegex,
            monthsShortRegex: monthsRegex,
            monthsStrictRegex: /^(enero|febrero|marzo|abril|mayo|junio|julio|agosto|septiembre|octubre|noviembre|diciembre)/i,
            monthsShortStrictRegex: /^(ene\.?|feb\.?|mar\.?|abr\.?|may\.?|jun\.?|jul\.?|ago\.?|sep\.?|oct\.?|nov\.?|dic\.?)/i,
            monthsParse: monthsParse,
            longMonthsParse: monthsParse,
            shortMonthsParse: monthsParse,
            weekdays: "domingo_lunes_martes_miércoles_jueves_viernes_sábado".split("_"),
            weekdaysShort: "dom._lun._mar._mié._jue._vie._sáb.".split("_"),
            weekdaysMin: "do_lu_ma_mi_ju_vi_sá".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "h:mm A",
                LTS: "h:mm:ss A",
                L: "MM/DD/YYYY",
                LL: "D [de] MMMM [de] YYYY",
                LLL: "D [de] MMMM [de] YYYY h:mm A",
                LLLL: "dddd, D [de] MMMM [de] YYYY h:mm A"
            },
            calendar: {
                sameDay: function() {
                    return "[hoy a la" + (1 !== this.hours() ? "s" : "") + "] LT"
                },
                nextDay: function() {
                    return "[mañana a la" + (1 !== this.hours() ? "s" : "") + "] LT"
                },
                nextWeek: function() {
                    return "dddd [a la" + (1 !== this.hours() ? "s" : "") + "] LT"
                },
                lastDay: function() {
                    return "[ayer a la" + (1 !== this.hours() ? "s" : "") + "] LT"
                },
                lastWeek: function() {
                    return "[el] dddd [pasado a la" + (1 !== this.hours() ? "s" : "") + "] LT"
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "en %s",
                past: "hace %s",
                s: "unos segundos",
                ss: "%d segundos",
                m: "un minuto",
                mm: "%d minutos",
                h: "una hora",
                hh: "%d horas",
                d: "un día",
                dd: "%d días",
                w: "una semana",
                ww: "%d semanas",
                M: "un mes",
                MM: "%d meses",
                y: "un año",
                yy: "%d años"
            },
            dayOfMonthOrdinalParse: /\d{1,2}º/,
            ordinal: "%dº",
            week: {
                dow: 0,
                doy: 6
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";

        function processRelativeTime(number, withoutSuffix, key, isFuture) {
            var format = {
                s: ["mõne sekundi", "mõni sekund", "paar sekundit"],
                ss: [number + "sekundi", number + "sekundit"],
                m: ["ühe minuti", "üks minut"],
                mm: [number + " minuti", number + " minutit"],
                h: ["ühe tunni", "tund aega", "üks tund"],
                hh: [number + " tunni", number + " tundi"],
                d: ["ühe päeva", "üks päev"],
                M: ["kuu aja", "kuu aega", "üks kuu"],
                MM: [number + " kuu", number + " kuud"],
                y: ["ühe aasta", "aasta", "üks aasta"],
                yy: [number + " aasta", number + " aastat"]
            };
            return withoutSuffix ? format[key][2] ? format[key][2] : format[key][1] : isFuture ? format[key][0] : format[key][1]
        }
        moment.defineLocale("et", {
            months: "jaanuar_veebruar_märts_aprill_mai_juuni_juuli_august_september_oktoober_november_detsember".split("_"),
            monthsShort: "jaan_veebr_märts_apr_mai_juuni_juuli_aug_sept_okt_nov_dets".split("_"),
            weekdays: "pühapäev_esmaspäev_teisipäev_kolmapäev_neljapäev_reede_laupäev".split("_"),
            weekdaysShort: "P_E_T_K_N_R_L".split("_"),
            weekdaysMin: "P_E_T_K_N_R_L".split("_"),
            longDateFormat: {
                LT: "H:mm",
                LTS: "H:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D. MMMM YYYY",
                LLL: "D. MMMM YYYY H:mm",
                LLLL: "dddd, D. MMMM YYYY H:mm"
            },
            calendar: {
                sameDay: "[Täna,] LT",
                nextDay: "[Homme,] LT",
                nextWeek: "[Järgmine] dddd LT",
                lastDay: "[Eile,] LT",
                lastWeek: "[Eelmine] dddd LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s pärast",
                past: "%s tagasi",
                s: processRelativeTime,
                ss: processRelativeTime,
                m: processRelativeTime,
                mm: processRelativeTime,
                h: processRelativeTime,
                hh: processRelativeTime,
                d: processRelativeTime,
                dd: "%d päeva",
                M: processRelativeTime,
                MM: processRelativeTime,
                y: processRelativeTime,
                yy: processRelativeTime
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("eu", {
            months: "urtarrila_otsaila_martxoa_apirila_maiatza_ekaina_uztaila_abuztua_iraila_urria_azaroa_abendua".split("_"),
            monthsShort: "urt._ots._mar._api._mai._eka._uzt._abu._ira._urr._aza._abe.".split("_"),
            monthsParseExact: !0,
            weekdays: "igandea_astelehena_asteartea_asteazkena_osteguna_ostirala_larunbata".split("_"),
            weekdaysShort: "ig._al._ar._az._og._ol._lr.".split("_"),
            weekdaysMin: "ig_al_ar_az_og_ol_lr".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "YYYY-MM-DD",
                LL: "YYYY[ko] MMMM[ren] D[a]",
                LLL: "YYYY[ko] MMMM[ren] D[a] HH:mm",
                LLLL: "dddd, YYYY[ko] MMMM[ren] D[a] HH:mm",
                l: "YYYY-M-D",
                ll: "YYYY[ko] MMM D[a]",
                lll: "YYYY[ko] MMM D[a] HH:mm",
                llll: "ddd, YYYY[ko] MMM D[a] HH:mm"
            },
            calendar: {
                sameDay: "[gaur] LT[etan]",
                nextDay: "[bihar] LT[etan]",
                nextWeek: "dddd LT[etan]",
                lastDay: "[atzo] LT[etan]",
                lastWeek: "[aurreko] dddd LT[etan]",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s barru",
                past: "duela %s",
                s: "segundo batzuk",
                ss: "%d segundo",
                m: "minutu bat",
                mm: "%d minutu",
                h: "ordu bat",
                hh: "%d ordu",
                d: "egun bat",
                dd: "%d egun",
                M: "hilabete bat",
                MM: "%d hilabete",
                y: "urte bat",
                yy: "%d urte"
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {
                dow: 1,
                doy: 7
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        var symbolMap = {
                1: "۱",
                2: "۲",
                3: "۳",
                4: "۴",
                5: "۵",
                6: "۶",
                7: "۷",
                8: "۸",
                9: "۹",
                0: "۰"
            },
            numberMap = {
                "۱": "1",
                "۲": "2",
                "۳": "3",
                "۴": "4",
                "۵": "5",
                "۶": "6",
                "۷": "7",
                "۸": "8",
                "۹": "9",
                "۰": "0"
            };
        moment.defineLocale("fa", {
            months: "ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر".split("_"),
            monthsShort: "ژانویه_فوریه_مارس_آوریل_مه_ژوئن_ژوئیه_اوت_سپتامبر_اکتبر_نوامبر_دسامبر".split("_"),
            weekdays: "یک‌شنبه_دوشنبه_سه‌شنبه_چهارشنبه_پنج‌شنبه_جمعه_شنبه".split("_"),
            weekdaysShort: "یک‌شنبه_دوشنبه_سه‌شنبه_چهارشنبه_پنج‌شنبه_جمعه_شنبه".split("_"),
            weekdaysMin: "ی_د_س_چ_پ_ج_ش".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd, D MMMM YYYY HH:mm"
            },
            meridiemParse: /قبل از ظهر|بعد از ظهر/,
            isPM: function(input) {
                return /بعد از ظهر/.test(input)
            },
            meridiem: function(hour, minute, isLower) {
                return hour < 12 ? "قبل از ظهر" : "بعد از ظهر"
            },
            calendar: {
                sameDay: "[امروز ساعت] LT",
                nextDay: "[فردا ساعت] LT",
                nextWeek: "dddd [ساعت] LT",
                lastDay: "[دیروز ساعت] LT",
                lastWeek: "dddd [پیش] [ساعت] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "در %s",
                past: "%s پیش",
                s: "چند ثانیه",
                ss: "%d ثانیه",
                m: "یک دقیقه",
                mm: "%d دقیقه",
                h: "یک ساعت",
                hh: "%d ساعت",
                d: "یک روز",
                dd: "%d روز",
                M: "یک ماه",
                MM: "%d ماه",
                y: "یک سال",
                yy: "%d سال"
            },
            preparse: function(string) {
                return string.replace(/[۰-۹]/g, (function(match) {
                    return numberMap[match]
                })).replace(/،/g, ",")
            },
            postformat: function(string) {
                return string.replace(/\d/g, (function(match) {
                    return symbolMap[match]
                })).replace(/,/g, "،")
            },
            dayOfMonthOrdinalParse: /\d{1,2}م/,
            ordinal: "%dم",
            week: {
                dow: 6,
                doy: 12
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        var numbersPast = "nolla yksi kaksi kolme neljä viisi kuusi seitsemän kahdeksan yhdeksän".split(" "),
            numbersFuture = ["nolla", "yhden", "kahden", "kolmen", "neljän", "viiden", "kuuden", numbersPast[7], numbersPast[8], numbersPast[9]];

        function translate(number, withoutSuffix, key, isFuture) {
            var result = "";
            switch (key) {
                case "s":
                    return isFuture ? "muutaman sekunnin" : "muutama sekunti";
                case "ss":
                    result = isFuture ? "sekunnin" : "sekuntia";
                    break;
                case "m":
                    return isFuture ? "minuutin" : "minuutti";
                case "mm":
                    result = isFuture ? "minuutin" : "minuuttia";
                    break;
                case "h":
                    return isFuture ? "tunnin" : "tunti";
                case "hh":
                    result = isFuture ? "tunnin" : "tuntia";
                    break;
                case "d":
                    return isFuture ? "päivän" : "päivä";
                case "dd":
                    result = isFuture ? "päivän" : "päivää";
                    break;
                case "M":
                    return isFuture ? "kuukauden" : "kuukausi";
                case "MM":
                    result = isFuture ? "kuukauden" : "kuukautta";
                    break;
                case "y":
                    return isFuture ? "vuoden" : "vuosi";
                case "yy":
                    result = isFuture ? "vuoden" : "vuotta"
            }
            return result = verbalNumber(number, isFuture) + " " + result
        }

        function verbalNumber(number, isFuture) {
            return number < 10 ? isFuture ? numbersFuture[number] : numbersPast[number] : number
        }
        moment.defineLocale("fi", {
            months: "tammikuu_helmikuu_maaliskuu_huhtikuu_toukokuu_kesäkuu_heinäkuu_elokuu_syyskuu_lokakuu_marraskuu_joulukuu".split("_"),
            monthsShort: "tammi_helmi_maalis_huhti_touko_kesä_heinä_elo_syys_loka_marras_joulu".split("_"),
            weekdays: "sunnuntai_maanantai_tiistai_keskiviikko_torstai_perjantai_lauantai".split("_"),
            weekdaysShort: "su_ma_ti_ke_to_pe_la".split("_"),
            weekdaysMin: "su_ma_ti_ke_to_pe_la".split("_"),
            longDateFormat: {
                LT: "HH.mm",
                LTS: "HH.mm.ss",
                L: "DD.MM.YYYY",
                LL: "Do MMMM[ta] YYYY",
                LLL: "Do MMMM[ta] YYYY, [klo] HH.mm",
                LLLL: "dddd, Do MMMM[ta] YYYY, [klo] HH.mm",
                l: "D.M.YYYY",
                ll: "Do MMM YYYY",
                lll: "Do MMM YYYY, [klo] HH.mm",
                llll: "ddd, Do MMM YYYY, [klo] HH.mm"
            },
            calendar: {
                sameDay: "[tänään] [klo] LT",
                nextDay: "[huomenna] [klo] LT",
                nextWeek: "dddd [klo] LT",
                lastDay: "[eilen] [klo] LT",
                lastWeek: "[viime] dddd[na] [klo] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s päästä",
                past: "%s sitten",
                s: translate,
                ss: translate,
                m: translate,
                mm: translate,
                h: translate,
                hh: translate,
                d: translate,
                dd: translate,
                M: translate,
                MM: translate,
                y: translate,
                yy: translate
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("fil", {
            months: "Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre".split("_"),
            monthsShort: "Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis".split("_"),
            weekdays: "Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado".split("_"),
            weekdaysShort: "Lin_Lun_Mar_Miy_Huw_Biy_Sab".split("_"),
            weekdaysMin: "Li_Lu_Ma_Mi_Hu_Bi_Sab".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "MM/D/YYYY",
                LL: "MMMM D, YYYY",
                LLL: "MMMM D, YYYY HH:mm",
                LLLL: "dddd, MMMM DD, YYYY HH:mm"
            },
            calendar: {
                sameDay: "LT [ngayong araw]",
                nextDay: "[Bukas ng] LT",
                nextWeek: "LT [sa susunod na] dddd",
                lastDay: "LT [kahapon]",
                lastWeek: "LT [noong nakaraang] dddd",
                sameElse: "L"
            },
            relativeTime: {
                future: "sa loob ng %s",
                past: "%s ang nakalipas",
                s: "ilang segundo",
                ss: "%d segundo",
                m: "isang minuto",
                mm: "%d minuto",
                h: "isang oras",
                hh: "%d oras",
                d: "isang araw",
                dd: "%d araw",
                M: "isang buwan",
                MM: "%d buwan",
                y: "isang taon",
                yy: "%d taon"
            },
            dayOfMonthOrdinalParse: /\d{1,2}/,
            ordinal: function(number) {
                return number
            },
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("fo", {
            months: "januar_februar_mars_apríl_mai_juni_juli_august_september_oktober_november_desember".split("_"),
            monthsShort: "jan_feb_mar_apr_mai_jun_jul_aug_sep_okt_nov_des".split("_"),
            weekdays: "sunnudagur_mánadagur_týsdagur_mikudagur_hósdagur_fríggjadagur_leygardagur".split("_"),
            weekdaysShort: "sun_mán_týs_mik_hós_frí_ley".split("_"),
            weekdaysMin: "su_má_tý_mi_hó_fr_le".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd D. MMMM, YYYY HH:mm"
            },
            calendar: {
                sameDay: "[Í dag kl.] LT",
                nextDay: "[Í morgin kl.] LT",
                nextWeek: "dddd [kl.] LT",
                lastDay: "[Í gjár kl.] LT",
                lastWeek: "[síðstu] dddd [kl] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "um %s",
                past: "%s síðani",
                s: "fá sekund",
                ss: "%d sekundir",
                m: "ein minuttur",
                mm: "%d minuttir",
                h: "ein tími",
                hh: "%d tímar",
                d: "ein dagur",
                dd: "%d dagar",
                M: "ein mánaður",
                MM: "%d mánaðir",
                y: "eitt ár",
                yy: "%d ár"
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        var monthsStrictRegex = /^(janvier|février|mars|avril|mai|juin|juillet|août|septembre|octobre|novembre|décembre)/i,
            monthsShortStrictRegex = /(janv\.?|févr\.?|mars|avr\.?|mai|juin|juil\.?|août|sept\.?|oct\.?|nov\.?|déc\.?)/i,
            monthsRegex = /(janv\.?|févr\.?|mars|avr\.?|mai|juin|juil\.?|août|sept\.?|oct\.?|nov\.?|déc\.?|janvier|février|mars|avril|mai|juin|juillet|août|septembre|octobre|novembre|décembre)/i,
            monthsParse = [/^janv/i, /^févr/i, /^mars/i, /^avr/i, /^mai/i, /^juin/i, /^juil/i, /^août/i, /^sept/i, /^oct/i, /^nov/i, /^déc/i];
        moment.defineLocale("fr", {
            months: "janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre".split("_"),
            monthsShort: "janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.".split("_"),
            monthsRegex: monthsRegex,
            monthsShortRegex: monthsRegex,
            monthsStrictRegex: monthsStrictRegex,
            monthsShortStrictRegex: monthsShortStrictRegex,
            monthsParse: monthsParse,
            longMonthsParse: monthsParse,
            shortMonthsParse: monthsParse,
            weekdays: "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"),
            weekdaysShort: "dim._lun._mar._mer._jeu._ven._sam.".split("_"),
            weekdaysMin: "di_lu_ma_me_je_ve_sa".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[Aujourd’hui à] LT",
                nextDay: "[Demain à] LT",
                nextWeek: "dddd [à] LT",
                lastDay: "[Hier à] LT",
                lastWeek: "dddd [dernier à] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "dans %s",
                past: "il y a %s",
                s: "quelques secondes",
                ss: "%d secondes",
                m: "une minute",
                mm: "%d minutes",
                h: "une heure",
                hh: "%d heures",
                d: "un jour",
                dd: "%d jours",
                w: "une semaine",
                ww: "%d semaines",
                M: "un mois",
                MM: "%d mois",
                y: "un an",
                yy: "%d ans"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(er|)/,
            ordinal: function(number, period) {
                switch (period) {
                    case "D":
                        return number + (1 === number ? "er" : "");
                    default:
                    case "M":
                    case "Q":
                    case "DDD":
                    case "d":
                        return number + (1 === number ? "er" : "e");
                    case "w":
                    case "W":
                        return number + (1 === number ? "re" : "e")
                }
            },
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("fr-ca", {
            months: "janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre".split("_"),
            monthsShort: "janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.".split("_"),
            monthsParseExact: !0,
            weekdays: "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"),
            weekdaysShort: "dim._lun._mar._mer._jeu._ven._sam.".split("_"),
            weekdaysMin: "di_lu_ma_me_je_ve_sa".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "YYYY-MM-DD",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[Aujourd’hui à] LT",
                nextDay: "[Demain à] LT",
                nextWeek: "dddd [à] LT",
                lastDay: "[Hier à] LT",
                lastWeek: "dddd [dernier à] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "dans %s",
                past: "il y a %s",
                s: "quelques secondes",
                ss: "%d secondes",
                m: "une minute",
                mm: "%d minutes",
                h: "une heure",
                hh: "%d heures",
                d: "un jour",
                dd: "%d jours",
                M: "un mois",
                MM: "%d mois",
                y: "un an",
                yy: "%d ans"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
            ordinal: function(number, period) {
                switch (period) {
                    default:
                        case "M":
                        case "Q":
                        case "D":
                        case "DDD":
                        case "d":
                        return number + (1 === number ? "er" : "e");
                    case "w":
                            case "W":
                            return number + (1 === number ? "re" : "e")
                }
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("fr-ch", {
            months: "janvier_février_mars_avril_mai_juin_juillet_août_septembre_octobre_novembre_décembre".split("_"),
            monthsShort: "janv._févr._mars_avr._mai_juin_juil._août_sept._oct._nov._déc.".split("_"),
            monthsParseExact: !0,
            weekdays: "dimanche_lundi_mardi_mercredi_jeudi_vendredi_samedi".split("_"),
            weekdaysShort: "dim._lun._mar._mer._jeu._ven._sam.".split("_"),
            weekdaysMin: "di_lu_ma_me_je_ve_sa".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[Aujourd’hui à] LT",
                nextDay: "[Demain à] LT",
                nextWeek: "dddd [à] LT",
                lastDay: "[Hier à] LT",
                lastWeek: "dddd [dernier à] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "dans %s",
                past: "il y a %s",
                s: "quelques secondes",
                ss: "%d secondes",
                m: "une minute",
                mm: "%d minutes",
                h: "une heure",
                hh: "%d heures",
                d: "un jour",
                dd: "%d jours",
                M: "un mois",
                MM: "%d mois",
                y: "un an",
                yy: "%d ans"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(er|e)/,
            ordinal: function(number, period) {
                switch (period) {
                    default:
                        case "M":
                        case "Q":
                        case "D":
                        case "DDD":
                        case "d":
                        return number + (1 === number ? "er" : "e");
                    case "w":
                            case "W":
                            return number + (1 === number ? "re" : "e")
                }
            },
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        var monthsShortWithDots = "jan._feb._mrt._apr._mai_jun._jul._aug._sep._okt._nov._des.".split("_"),
            monthsShortWithoutDots = "jan_feb_mrt_apr_mai_jun_jul_aug_sep_okt_nov_des".split("_");
        moment.defineLocale("fy", {
            months: "jannewaris_febrewaris_maart_april_maaie_juny_july_augustus_septimber_oktober_novimber_desimber".split("_"),
            monthsShort: function(m, format) {
                return m ? /-MMM-/.test(format) ? monthsShortWithoutDots[m.month()] : monthsShortWithDots[m.month()] : monthsShortWithDots
            },
            monthsParseExact: !0,
            weekdays: "snein_moandei_tiisdei_woansdei_tongersdei_freed_sneon".split("_"),
            weekdaysShort: "si._mo._ti._wo._to._fr._so.".split("_"),
            weekdaysMin: "Si_Mo_Ti_Wo_To_Fr_So".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD-MM-YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[hjoed om] LT",
                nextDay: "[moarn om] LT",
                nextWeek: "dddd [om] LT",
                lastDay: "[juster om] LT",
                lastWeek: "[ôfrûne] dddd [om] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "oer %s",
                past: "%s lyn",
                s: "in pear sekonden",
                ss: "%d sekonden",
                m: "ien minút",
                mm: "%d minuten",
                h: "ien oere",
                hh: "%d oeren",
                d: "ien dei",
                dd: "%d dagen",
                M: "ien moanne",
                MM: "%d moannen",
                y: "ien jier",
                yy: "%d jierren"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
            ordinal: function(number) {
                return number + (1 === number || 8 === number || number >= 20 ? "ste" : "de")
            },
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        var months = ["Eanáir", "Feabhra", "Márta", "Aibreán", "Bealtaine", "Meitheamh", "Iúil", "Lúnasa", "Meán Fómhair", "Deireadh Fómhair", "Samhain", "Nollaig"],
            monthsShort = ["Ean", "Feabh", "Márt", "Aib", "Beal", "Meith", "Iúil", "Lún", "M.F.", "D.F.", "Samh", "Noll"],
            weekdays = ["Dé Domhnaigh", "Dé Luain", "Dé Máirt", "Dé Céadaoin", "Déardaoin", "Dé hAoine", "Dé Sathairn"],
            weekdaysShort = ["Domh", "Luan", "Máirt", "Céad", "Déar", "Aoine", "Sath"],
            weekdaysMin = ["Do", "Lu", "Má", "Cé", "Dé", "A", "Sa"];
        moment.defineLocale("ga", {
            months: months,
            monthsShort: monthsShort,
            monthsParseExact: !0,
            weekdays: weekdays,
            weekdaysShort: weekdaysShort,
            weekdaysMin: weekdaysMin,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd, D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[Inniu ag] LT",
                nextDay: "[Amárach ag] LT",
                nextWeek: "dddd [ag] LT",
                lastDay: "[Inné ag] LT",
                lastWeek: "dddd [seo caite] [ag] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "i %s",
                past: "%s ó shin",
                s: "cúpla soicind",
                ss: "%d soicind",
                m: "nóiméad",
                mm: "%d nóiméad",
                h: "uair an chloig",
                hh: "%d uair an chloig",
                d: "lá",
                dd: "%d lá",
                M: "mí",
                MM: "%d míonna",
                y: "bliain",
                yy: "%d bliain"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/,
            ordinal: function(number) {
                return number + (1 === number ? "d" : number % 10 == 2 ? "na" : "mh")
            },
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        var months = ["Am Faoilleach", "An Gearran", "Am Màrt", "An Giblean", "An Cèitean", "An t-Ògmhios", "An t-Iuchar", "An Lùnastal", "An t-Sultain", "An Dàmhair", "An t-Samhain", "An Dùbhlachd"],
            monthsShort = ["Faoi", "Gear", "Màrt", "Gibl", "Cèit", "Ògmh", "Iuch", "Lùn", "Sult", "Dàmh", "Samh", "Dùbh"],
            weekdays = ["Didòmhnaich", "Diluain", "Dimàirt", "Diciadain", "Diardaoin", "Dihaoine", "Disathairne"],
            weekdaysShort = ["Did", "Dil", "Dim", "Dic", "Dia", "Dih", "Dis"],
            weekdaysMin = ["Dò", "Lu", "Mà", "Ci", "Ar", "Ha", "Sa"];
        moment.defineLocale("gd", {
            months: months,
            monthsShort: monthsShort,
            monthsParseExact: !0,
            weekdays: weekdays,
            weekdaysShort: weekdaysShort,
            weekdaysMin: weekdaysMin,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd, D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[An-diugh aig] LT",
                nextDay: "[A-màireach aig] LT",
                nextWeek: "dddd [aig] LT",
                lastDay: "[An-dè aig] LT",
                lastWeek: "dddd [seo chaidh] [aig] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "ann an %s",
                past: "bho chionn %s",
                s: "beagan diogan",
                ss: "%d diogan",
                m: "mionaid",
                mm: "%d mionaidean",
                h: "uair",
                hh: "%d uairean",
                d: "latha",
                dd: "%d latha",
                M: "mìos",
                MM: "%d mìosan",
                y: "bliadhna",
                yy: "%d bliadhna"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(d|na|mh)/,
            ordinal: function(number) {
                return number + (1 === number ? "d" : number % 10 == 2 ? "na" : "mh")
            },
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("gl", {
            months: "xaneiro_febreiro_marzo_abril_maio_xuño_xullo_agosto_setembro_outubro_novembro_decembro".split("_"),
            monthsShort: "xan._feb._mar._abr._mai._xuñ._xul._ago._set._out._nov._dec.".split("_"),
            monthsParseExact: !0,
            weekdays: "domingo_luns_martes_mércores_xoves_venres_sábado".split("_"),
            weekdaysShort: "dom._lun._mar._mér._xov._ven._sáb.".split("_"),
            weekdaysMin: "do_lu_ma_mé_xo_ve_sá".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "H:mm",
                LTS: "H:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D [de] MMMM [de] YYYY",
                LLL: "D [de] MMMM [de] YYYY H:mm",
                LLLL: "dddd, D [de] MMMM [de] YYYY H:mm"
            },
            calendar: {
                sameDay: function() {
                    return "[hoxe " + (1 !== this.hours() ? "ás" : "á") + "] LT"
                },
                nextDay: function() {
                    return "[mañá " + (1 !== this.hours() ? "ás" : "á") + "] LT"
                },
                nextWeek: function() {
                    return "dddd [" + (1 !== this.hours() ? "ás" : "a") + "] LT"
                },
                lastDay: function() {
                    return "[onte " + (1 !== this.hours() ? "á" : "a") + "] LT"
                },
                lastWeek: function() {
                    return "[o] dddd [pasado " + (1 !== this.hours() ? "ás" : "a") + "] LT"
                },
                sameElse: "L"
            },
            relativeTime: {
                future: function(str) {
                    return 0 === str.indexOf("un") ? "n" + str : "en " + str
                },
                past: "hai %s",
                s: "uns segundos",
                ss: "%d segundos",
                m: "un minuto",
                mm: "%d minutos",
                h: "unha hora",
                hh: "%d horas",
                d: "un día",
                dd: "%d días",
                M: "un mes",
                MM: "%d meses",
                y: "un ano",
                yy: "%d anos"
            },
            dayOfMonthOrdinalParse: /\d{1,2}º/,
            ordinal: "%dº",
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";

        function processRelativeTime(number, withoutSuffix, key, isFuture) {
            var format = {
                s: ["थोडया सॅकंडांनी", "थोडे सॅकंड"],
                ss: [number + " सॅकंडांनी", number + " सॅकंड"],
                m: ["एका मिणटान", "एक मिनूट"],
                mm: [number + " मिणटांनी", number + " मिणटां"],
                h: ["एका वरान", "एक वर"],
                hh: [number + " वरांनी", number + " वरां"],
                d: ["एका दिसान", "एक दीस"],
                dd: [number + " दिसांनी", number + " दीस"],
                M: ["एका म्हयन्यान", "एक म्हयनो"],
                MM: [number + " म्हयन्यानी", number + " म्हयने"],
                y: ["एका वर्सान", "एक वर्स"],
                yy: [number + " वर्सांनी", number + " वर्सां"]
            };
            return isFuture ? format[key][0] : format[key][1]
        }
        moment.defineLocale("gom-deva", {
            months: {
                standalone: "जानेवारी_फेब्रुवारी_मार्च_एप्रील_मे_जून_जुलय_ऑगस्ट_सप्टेंबर_ऑक्टोबर_नोव्हेंबर_डिसेंबर".split("_"),
                format: "जानेवारीच्या_फेब्रुवारीच्या_मार्चाच्या_एप्रीलाच्या_मेयाच्या_जूनाच्या_जुलयाच्या_ऑगस्टाच्या_सप्टेंबराच्या_ऑक्टोबराच्या_नोव्हेंबराच्या_डिसेंबराच्या".split("_"),
                isFormat: /MMMM(\s)+D[oD]?/
            },
            monthsShort: "जाने._फेब्रु._मार्च_एप्री._मे_जून_जुल._ऑग._सप्टें._ऑक्टो._नोव्हें._डिसें.".split("_"),
            monthsParseExact: !0,
            weekdays: "आयतार_सोमार_मंगळार_बुधवार_बिरेस्तार_सुक्रार_शेनवार".split("_"),
            weekdaysShort: "आयत._सोम._मंगळ._बुध._ब्रेस्त._सुक्र._शेन.".split("_"),
            weekdaysMin: "आ_सो_मं_बु_ब्रे_सु_शे".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "A h:mm [वाजतां]",
                LTS: "A h:mm:ss [वाजतां]",
                L: "DD-MM-YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY A h:mm [वाजतां]",
                LLLL: "dddd, MMMM Do, YYYY, A h:mm [वाजतां]",
                llll: "ddd, D MMM YYYY, A h:mm [वाजतां]"
            },
            calendar: {
                sameDay: "[आयज] LT",
                nextDay: "[फाल्यां] LT",
                nextWeek: "[फुडलो] dddd[,] LT",
                lastDay: "[काल] LT",
                lastWeek: "[फाटलो] dddd[,] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s",
                past: "%s आदीं",
                s: processRelativeTime,
                ss: processRelativeTime,
                m: processRelativeTime,
                mm: processRelativeTime,
                h: processRelativeTime,
                hh: processRelativeTime,
                d: processRelativeTime,
                dd: processRelativeTime,
                M: processRelativeTime,
                MM: processRelativeTime,
                y: processRelativeTime,
                yy: processRelativeTime
            },
            dayOfMonthOrdinalParse: /\d{1,2}(वेर)/,
            ordinal: function(number, period) {
                switch (period) {
                    case "D":
                        return number + "वेर";
                    default:
                    case "M":
                    case "Q":
                    case "DDD":
                    case "d":
                    case "w":
                    case "W":
                        return number
                }
            },
            week: {
                dow: 0,
                doy: 3
            },
            meridiemParse: /राती|सकाळीं|दनपारां|सांजे/,
            meridiemHour: function(hour, meridiem) {
                return 12 === hour && (hour = 0), "राती" === meridiem ? hour < 4 ? hour : hour + 12 : "सकाळीं" === meridiem ? hour : "दनपारां" === meridiem ? hour > 12 ? hour : hour + 12 : "सांजे" === meridiem ? hour + 12 : void 0
            },
            meridiem: function(hour, minute, isLower) {
                return hour < 4 ? "राती" : hour < 12 ? "सकाळीं" : hour < 16 ? "दनपारां" : hour < 20 ? "सांजे" : "राती"
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";

        function processRelativeTime(number, withoutSuffix, key, isFuture) {
            var format = {
                s: ["thoddea sekondamni", "thodde sekond"],
                ss: [number + " sekondamni", number + " sekond"],
                m: ["eka mintan", "ek minut"],
                mm: [number + " mintamni", number + " mintam"],
                h: ["eka voran", "ek vor"],
                hh: [number + " voramni", number + " voram"],
                d: ["eka disan", "ek dis"],
                dd: [number + " disamni", number + " dis"],
                M: ["eka mhoinean", "ek mhoino"],
                MM: [number + " mhoineamni", number + " mhoine"],
                y: ["eka vorsan", "ek voros"],
                yy: [number + " vorsamni", number + " vorsam"]
            };
            return isFuture ? format[key][0] : format[key][1]
        }
        moment.defineLocale("gom-latn", {
            months: {
                standalone: "Janer_Febrer_Mars_Abril_Mai_Jun_Julai_Agost_Setembr_Otubr_Novembr_Dezembr".split("_"),
                format: "Janerachea_Febrerachea_Marsachea_Abrilachea_Maiachea_Junachea_Julaiachea_Agostachea_Setembrachea_Otubrachea_Novembrachea_Dezembrachea".split("_"),
                isFormat: /MMMM(\s)+D[oD]?/
            },
            monthsShort: "Jan._Feb._Mars_Abr._Mai_Jun_Jul._Ago._Set._Otu._Nov._Dez.".split("_"),
            monthsParseExact: !0,
            weekdays: "Aitar_Somar_Mongllar_Budhvar_Birestar_Sukrar_Son'var".split("_"),
            weekdaysShort: "Ait._Som._Mon._Bud._Bre._Suk._Son.".split("_"),
            weekdaysMin: "Ai_Sm_Mo_Bu_Br_Su_Sn".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "A h:mm [vazta]",
                LTS: "A h:mm:ss [vazta]",
                L: "DD-MM-YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY A h:mm [vazta]",
                LLLL: "dddd, MMMM Do, YYYY, A h:mm [vazta]",
                llll: "ddd, D MMM YYYY, A h:mm [vazta]"
            },
            calendar: {
                sameDay: "[Aiz] LT",
                nextDay: "[Faleam] LT",
                nextWeek: "[Fuddlo] dddd[,] LT",
                lastDay: "[Kal] LT",
                lastWeek: "[Fattlo] dddd[,] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s",
                past: "%s adim",
                s: processRelativeTime,
                ss: processRelativeTime,
                m: processRelativeTime,
                mm: processRelativeTime,
                h: processRelativeTime,
                hh: processRelativeTime,
                d: processRelativeTime,
                dd: processRelativeTime,
                M: processRelativeTime,
                MM: processRelativeTime,
                y: processRelativeTime,
                yy: processRelativeTime
            },
            dayOfMonthOrdinalParse: /\d{1,2}(er)/,
            ordinal: function(number, period) {
                switch (period) {
                    case "D":
                        return number + "er";
                    default:
                    case "M":
                    case "Q":
                    case "DDD":
                    case "d":
                    case "w":
                    case "W":
                        return number
                }
            },
            week: {
                dow: 0,
                doy: 3
            },
            meridiemParse: /rati|sokallim|donparam|sanje/,
            meridiemHour: function(hour, meridiem) {
                return 12 === hour && (hour = 0), "rati" === meridiem ? hour < 4 ? hour : hour + 12 : "sokallim" === meridiem ? hour : "donparam" === meridiem ? hour > 12 ? hour : hour + 12 : "sanje" === meridiem ? hour + 12 : void 0
            },
            meridiem: function(hour, minute, isLower) {
                return hour < 4 ? "rati" : hour < 12 ? "sokallim" : hour < 16 ? "donparam" : hour < 20 ? "sanje" : "rati"
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        var symbolMap = {
                1: "૧",
                2: "૨",
                3: "૩",
                4: "૪",
                5: "૫",
                6: "૬",
                7: "૭",
                8: "૮",
                9: "૯",
                0: "૦"
            },
            numberMap = {
                "૧": "1",
                "૨": "2",
                "૩": "3",
                "૪": "4",
                "૫": "5",
                "૬": "6",
                "૭": "7",
                "૮": "8",
                "૯": "9",
                "૦": "0"
            };
        moment.defineLocale("gu", {
            months: "જાન્યુઆરી_ફેબ્રુઆરી_માર્ચ_એપ્રિલ_મે_જૂન_જુલાઈ_ઑગસ્ટ_સપ્ટેમ્બર_ઑક્ટ્બર_નવેમ્બર_ડિસેમ્બર".split("_"),
            monthsShort: "જાન્યુ._ફેબ્રુ._માર્ચ_એપ્રિ._મે_જૂન_જુલા._ઑગ._સપ્ટે._ઑક્ટ્._નવે._ડિસે.".split("_"),
            monthsParseExact: !0,
            weekdays: "રવિવાર_સોમવાર_મંગળવાર_બુધ્વાર_ગુરુવાર_શુક્રવાર_શનિવાર".split("_"),
            weekdaysShort: "રવિ_સોમ_મંગળ_બુધ્_ગુરુ_શુક્ર_શનિ".split("_"),
            weekdaysMin: "ર_સો_મં_બુ_ગુ_શુ_શ".split("_"),
            longDateFormat: {
                LT: "A h:mm વાગ્યે",
                LTS: "A h:mm:ss વાગ્યે",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY, A h:mm વાગ્યે",
                LLLL: "dddd, D MMMM YYYY, A h:mm વાગ્યે"
            },
            calendar: {
                sameDay: "[આજ] LT",
                nextDay: "[કાલે] LT",
                nextWeek: "dddd, LT",
                lastDay: "[ગઇકાલે] LT",
                lastWeek: "[પાછલા] dddd, LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s મા",
                past: "%s પહેલા",
                s: "અમુક પળો",
                ss: "%d સેકંડ",
                m: "એક મિનિટ",
                mm: "%d મિનિટ",
                h: "એક કલાક",
                hh: "%d કલાક",
                d: "એક દિવસ",
                dd: "%d દિવસ",
                M: "એક મહિનો",
                MM: "%d મહિનો",
                y: "એક વર્ષ",
                yy: "%d વર્ષ"
            },
            preparse: function(string) {
                return string.replace(/[૧૨૩૪૫૬૭૮૯૦]/g, (function(match) {
                    return numberMap[match]
                }))
            },
            postformat: function(string) {
                return string.replace(/\d/g, (function(match) {
                    return symbolMap[match]
                }))
            },
            meridiemParse: /રાત|બપોર|સવાર|સાંજ/,
            meridiemHour: function(hour, meridiem) {
                return 12 === hour && (hour = 0), "રાત" === meridiem ? hour < 4 ? hour : hour + 12 : "સવાર" === meridiem ? hour : "બપોર" === meridiem ? hour >= 10 ? hour : hour + 12 : "સાંજ" === meridiem ? hour + 12 : void 0
            },
            meridiem: function(hour, minute, isLower) {
                return hour < 4 ? "રાત" : hour < 10 ? "સવાર" : hour < 17 ? "બપોર" : hour < 20 ? "સાંજ" : "રાત"
            },
            week: {
                dow: 0,
                doy: 6
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("he", {
            months: "ינואר_פברואר_מרץ_אפריל_מאי_יוני_יולי_אוגוסט_ספטמבר_אוקטובר_נובמבר_דצמבר".split("_"),
            monthsShort: "ינו׳_פבר׳_מרץ_אפר׳_מאי_יוני_יולי_אוג׳_ספט׳_אוק׳_נוב׳_דצמ׳".split("_"),
            weekdays: "ראשון_שני_שלישי_רביעי_חמישי_שישי_שבת".split("_"),
            weekdaysShort: "א׳_ב׳_ג׳_ד׳_ה׳_ו׳_ש׳".split("_"),
            weekdaysMin: "א_ב_ג_ד_ה_ו_ש".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D [ב]MMMM YYYY",
                LLL: "D [ב]MMMM YYYY HH:mm",
                LLLL: "dddd, D [ב]MMMM YYYY HH:mm",
                l: "D/M/YYYY",
                ll: "D MMM YYYY",
                lll: "D MMM YYYY HH:mm",
                llll: "ddd, D MMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[היום ב־]LT",
                nextDay: "[מחר ב־]LT",
                nextWeek: "dddd [בשעה] LT",
                lastDay: "[אתמול ב־]LT",
                lastWeek: "[ביום] dddd [האחרון בשעה] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "בעוד %s",
                past: "לפני %s",
                s: "מספר שניות",
                ss: "%d שניות",
                m: "דקה",
                mm: "%d דקות",
                h: "שעה",
                hh: function(number) {
                    return 2 === number ? "שעתיים" : number + " שעות"
                },
                d: "יום",
                dd: function(number) {
                    return 2 === number ? "יומיים" : number + " ימים"
                },
                M: "חודש",
                MM: function(number) {
                    return 2 === number ? "חודשיים" : number + " חודשים"
                },
                y: "שנה",
                yy: function(number) {
                    return 2 === number ? "שנתיים" : number % 10 == 0 && 10 !== number ? number + " שנה" : number + " שנים"
                }
            },
            meridiemParse: /אחה"צ|לפנה"צ|אחרי הצהריים|לפני הצהריים|לפנות בוקר|בבוקר|בערב/i,
            isPM: function(input) {
                return /^(אחה"צ|אחרי הצהריים|בערב)$/.test(input)
            },
            meridiem: function(hour, minute, isLower) {
                return hour < 5 ? "לפנות בוקר" : hour < 10 ? "בבוקר" : hour < 12 ? isLower ? 'לפנה"צ' : "לפני הצהריים" : hour < 18 ? isLower ? 'אחה"צ' : "אחרי הצהריים" : "בערב"
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        var symbolMap = {
                1: "१",
                2: "२",
                3: "३",
                4: "४",
                5: "५",
                6: "६",
                7: "७",
                8: "८",
                9: "९",
                0: "०"
            },
            numberMap = {
                "१": "1",
                "२": "2",
                "३": "3",
                "४": "4",
                "५": "5",
                "६": "6",
                "७": "7",
                "८": "8",
                "९": "9",
                "०": "0"
            },
            monthsParse = [/^जन/i, /^फ़र|फर/i, /^मार्च/i, /^अप्रै/i, /^मई/i, /^जून/i, /^जुल/i, /^अग/i, /^सितं|सित/i, /^अक्टू/i, /^नव|नवं/i, /^दिसं|दिस/i],
            shortMonthsParse = [/^जन/i, /^फ़र/i, /^मार्च/i, /^अप्रै/i, /^मई/i, /^जून/i, /^जुल/i, /^अग/i, /^सित/i, /^अक्टू/i, /^नव/i, /^दिस/i];
        moment.defineLocale("hi", {
            months: {
                format: "जनवरी_फ़रवरी_मार्च_अप्रैल_मई_जून_जुलाई_अगस्त_सितम्बर_अक्टूबर_नवम्बर_दिसम्बर".split("_"),
                standalone: "जनवरी_फरवरी_मार्च_अप्रैल_मई_जून_जुलाई_अगस्त_सितंबर_अक्टूबर_नवंबर_दिसंबर".split("_")
            },
            monthsShort: "जन._फ़र._मार्च_अप्रै._मई_जून_जुल._अग._सित._अक्टू._नव._दिस.".split("_"),
            weekdays: "रविवार_सोमवार_मंगलवार_बुधवार_गुरूवार_शुक्रवार_शनिवार".split("_"),
            weekdaysShort: "रवि_सोम_मंगल_बुध_गुरू_शुक्र_शनि".split("_"),
            weekdaysMin: "र_सो_मं_बु_गु_शु_श".split("_"),
            longDateFormat: {
                LT: "A h:mm बजे",
                LTS: "A h:mm:ss बजे",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY, A h:mm बजे",
                LLLL: "dddd, D MMMM YYYY, A h:mm बजे"
            },
            monthsParse: monthsParse,
            longMonthsParse: monthsParse,
            shortMonthsParse: shortMonthsParse,
            monthsRegex: /^(जनवरी|जन\.?|फ़रवरी|फरवरी|फ़र\.?|मार्च?|अप्रैल|अप्रै\.?|मई?|जून?|जुलाई|जुल\.?|अगस्त|अग\.?|सितम्बर|सितंबर|सित\.?|अक्टूबर|अक्टू\.?|नवम्बर|नवंबर|नव\.?|दिसम्बर|दिसंबर|दिस\.?)/i,
            monthsShortRegex: /^(जनवरी|जन\.?|फ़रवरी|फरवरी|फ़र\.?|मार्च?|अप्रैल|अप्रै\.?|मई?|जून?|जुलाई|जुल\.?|अगस्त|अग\.?|सितम्बर|सितंबर|सित\.?|अक्टूबर|अक्टू\.?|नवम्बर|नवंबर|नव\.?|दिसम्बर|दिसंबर|दिस\.?)/i,
            monthsStrictRegex: /^(जनवरी?|फ़रवरी|फरवरी?|मार्च?|अप्रैल?|मई?|जून?|जुलाई?|अगस्त?|सितम्बर|सितंबर|सित?\.?|अक्टूबर|अक्टू\.?|नवम्बर|नवंबर?|दिसम्बर|दिसंबर?)/i,
            monthsShortStrictRegex: /^(जन\.?|फ़र\.?|मार्च?|अप्रै\.?|मई?|जून?|जुल\.?|अग\.?|सित\.?|अक्टू\.?|नव\.?|दिस\.?)/i,
            calendar: {
                sameDay: "[आज] LT",
                nextDay: "[कल] LT",
                nextWeek: "dddd, LT",
                lastDay: "[कल] LT",
                lastWeek: "[पिछले] dddd, LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s में",
                past: "%s पहले",
                s: "कुछ ही क्षण",
                ss: "%d सेकंड",
                m: "एक मिनट",
                mm: "%d मिनट",
                h: "एक घंटा",
                hh: "%d घंटे",
                d: "एक दिन",
                dd: "%d दिन",
                M: "एक महीने",
                MM: "%d महीने",
                y: "एक वर्ष",
                yy: "%d वर्ष"
            },
            preparse: function(string) {
                return string.replace(/[१२३४५६७८९०]/g, (function(match) {
                    return numberMap[match]
                }))
            },
            postformat: function(string) {
                return string.replace(/\d/g, (function(match) {
                    return symbolMap[match]
                }))
            },
            meridiemParse: /रात|सुबह|दोपहर|शाम/,
            meridiemHour: function(hour, meridiem) {
                return 12 === hour && (hour = 0), "रात" === meridiem ? hour < 4 ? hour : hour + 12 : "सुबह" === meridiem ? hour : "दोपहर" === meridiem ? hour >= 10 ? hour : hour + 12 : "शाम" === meridiem ? hour + 12 : void 0
            },
            meridiem: function(hour, minute, isLower) {
                return hour < 4 ? "रात" : hour < 10 ? "सुबह" : hour < 17 ? "दोपहर" : hour < 20 ? "शाम" : "रात"
            },
            week: {
                dow: 0,
                doy: 6
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";

        function translate(number, withoutSuffix, key) {
            var result = number + " ";
            switch (key) {
                case "ss":
                    return result += 1 === number ? "sekunda" : 2 === number || 3 === number || 4 === number ? "sekunde" : "sekundi";
                case "m":
                    return withoutSuffix ? "jedna minuta" : "jedne minute";
                case "mm":
                    return result += 1 === number ? "minuta" : 2 === number || 3 === number || 4 === number ? "minute" : "minuta";
                case "h":
                    return withoutSuffix ? "jedan sat" : "jednog sata";
                case "hh":
                    return result += 1 === number ? "sat" : 2 === number || 3 === number || 4 === number ? "sata" : "sati";
                case "dd":
                    return result += 1 === number ? "dan" : "dana";
                case "MM":
                    return result += 1 === number ? "mjesec" : 2 === number || 3 === number || 4 === number ? "mjeseca" : "mjeseci";
                case "yy":
                    return result += 1 === number ? "godina" : 2 === number || 3 === number || 4 === number ? "godine" : "godina"
            }
        }
        moment.defineLocale("hr", {
            months: {
                format: "siječnja_veljače_ožujka_travnja_svibnja_lipnja_srpnja_kolovoza_rujna_listopada_studenoga_prosinca".split("_"),
                standalone: "siječanj_veljača_ožujak_travanj_svibanj_lipanj_srpanj_kolovoz_rujan_listopad_studeni_prosinac".split("_")
            },
            monthsShort: "sij._velj._ožu._tra._svi._lip._srp._kol._ruj._lis._stu._pro.".split("_"),
            monthsParseExact: !0,
            weekdays: "nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota".split("_"),
            weekdaysShort: "ned._pon._uto._sri._čet._pet._sub.".split("_"),
            weekdaysMin: "ne_po_ut_sr_če_pe_su".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "H:mm",
                LTS: "H:mm:ss",
                L: "DD.MM.YYYY",
                LL: "Do MMMM YYYY",
                LLL: "Do MMMM YYYY H:mm",
                LLLL: "dddd, Do MMMM YYYY H:mm"
            },
            calendar: {
                sameDay: "[danas u] LT",
                nextDay: "[sutra u] LT",
                nextWeek: function() {
                    switch (this.day()) {
                        case 0:
                            return "[u] [nedjelju] [u] LT";
                        case 3:
                            return "[u] [srijedu] [u] LT";
                        case 6:
                            return "[u] [subotu] [u] LT";
                        case 1:
                        case 2:
                        case 4:
                        case 5:
                            return "[u] dddd [u] LT"
                    }
                },
                lastDay: "[jučer u] LT",
                lastWeek: function() {
                    switch (this.day()) {
                        case 0:
                            return "[prošlu] [nedjelju] [u] LT";
                        case 3:
                            return "[prošlu] [srijedu] [u] LT";
                        case 6:
                            return "[prošle] [subote] [u] LT";
                        case 1:
                        case 2:
                        case 4:
                        case 5:
                            return "[prošli] dddd [u] LT"
                    }
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "za %s",
                past: "prije %s",
                s: "par sekundi",
                ss: translate,
                m: translate,
                mm: translate,
                h: translate,
                hh: translate,
                d: "dan",
                dd: translate,
                M: "mjesec",
                MM: translate,
                y: "godinu",
                yy: translate
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {
                dow: 1,
                doy: 7
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        var weekEndings = "vasárnap hétfőn kedden szerdán csütörtökön pénteken szombaton".split(" ");

        function translate(number, withoutSuffix, key, isFuture) {
            var num = number;
            switch (key) {
                case "s":
                    return isFuture || withoutSuffix ? "néhány másodperc" : "néhány másodperce";
                case "ss":
                    return num + (isFuture || withoutSuffix) ? " másodperc" : " másodperce";
                case "m":
                    return "egy" + (isFuture || withoutSuffix ? " perc" : " perce");
                case "mm":
                    return num + (isFuture || withoutSuffix ? " perc" : " perce");
                case "h":
                    return "egy" + (isFuture || withoutSuffix ? " óra" : " órája");
                case "hh":
                    return num + (isFuture || withoutSuffix ? " óra" : " órája");
                case "d":
                    return "egy" + (isFuture || withoutSuffix ? " nap" : " napja");
                case "dd":
                    return num + (isFuture || withoutSuffix ? " nap" : " napja");
                case "M":
                    return "egy" + (isFuture || withoutSuffix ? " hónap" : " hónapja");
                case "MM":
                    return num + (isFuture || withoutSuffix ? " hónap" : " hónapja");
                case "y":
                    return "egy" + (isFuture || withoutSuffix ? " év" : " éve");
                case "yy":
                    return num + (isFuture || withoutSuffix ? " év" : " éve")
            }
            return ""
        }

        function week(isFuture) {
            return (isFuture ? "" : "[múlt] ") + "[" + weekEndings[this.day()] + "] LT[-kor]"
        }
        moment.defineLocale("hu", {
            months: "január_február_március_április_május_június_július_augusztus_szeptember_október_november_december".split("_"),
            monthsShort: "jan._feb._márc._ápr._máj._jún._júl._aug._szept._okt._nov._dec.".split("_"),
            monthsParseExact: !0,
            weekdays: "vasárnap_hétfő_kedd_szerda_csütörtök_péntek_szombat".split("_"),
            weekdaysShort: "vas_hét_kedd_sze_csüt_pén_szo".split("_"),
            weekdaysMin: "v_h_k_sze_cs_p_szo".split("_"),
            longDateFormat: {
                LT: "H:mm",
                LTS: "H:mm:ss",
                L: "YYYY.MM.DD.",
                LL: "YYYY. MMMM D.",
                LLL: "YYYY. MMMM D. H:mm",
                LLLL: "YYYY. MMMM D., dddd H:mm"
            },
            meridiemParse: /de|du/i,
            isPM: function(input) {
                return "u" === input.charAt(1).toLowerCase()
            },
            meridiem: function(hours, minutes, isLower) {
                return hours < 12 ? !0 === isLower ? "de" : "DE" : !0 === isLower ? "du" : "DU"
            },
            calendar: {
                sameDay: "[ma] LT[-kor]",
                nextDay: "[holnap] LT[-kor]",
                nextWeek: function() {
                    return week.call(this, !0)
                },
                lastDay: "[tegnap] LT[-kor]",
                lastWeek: function() {
                    return week.call(this, !1)
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "%s múlva",
                past: "%s",
                s: translate,
                ss: translate,
                m: translate,
                mm: translate,
                h: translate,
                hh: translate,
                d: translate,
                dd: translate,
                M: translate,
                MM: translate,
                y: translate,
                yy: translate
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("hy-am", {
            months: {
                format: "հունվարի_փետրվարի_մարտի_ապրիլի_մայիսի_հունիսի_հուլիսի_օգոստոսի_սեպտեմբերի_հոկտեմբերի_նոյեմբերի_դեկտեմբերի".split("_"),
                standalone: "հունվար_փետրվար_մարտ_ապրիլ_մայիս_հունիս_հուլիս_օգոստոս_սեպտեմբեր_հոկտեմբեր_նոյեմբեր_դեկտեմբեր".split("_")
            },
            monthsShort: "հնվ_փտր_մրտ_ապր_մյս_հնս_հլս_օգս_սպտ_հկտ_նմբ_դկտ".split("_"),
            weekdays: "կիրակի_երկուշաբթի_երեքշաբթի_չորեքշաբթի_հինգշաբթի_ուրբաթ_շաբաթ".split("_"),
            weekdaysShort: "կրկ_երկ_երք_չրք_հնգ_ուրբ_շբթ".split("_"),
            weekdaysMin: "կրկ_երկ_երք_չրք_հնգ_ուրբ_շբթ".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D MMMM YYYY թ.",
                LLL: "D MMMM YYYY թ., HH:mm",
                LLLL: "dddd, D MMMM YYYY թ., HH:mm"
            },
            calendar: {
                sameDay: "[այսօր] LT",
                nextDay: "[վաղը] LT",
                lastDay: "[երեկ] LT",
                nextWeek: function() {
                    return "dddd [օրը ժամը] LT"
                },
                lastWeek: function() {
                    return "[անցած] dddd [օրը ժամը] LT"
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "%s հետո",
                past: "%s առաջ",
                s: "մի քանի վայրկյան",
                ss: "%d վայրկյան",
                m: "րոպե",
                mm: "%d րոպե",
                h: "ժամ",
                hh: "%d ժամ",
                d: "օր",
                dd: "%d օր",
                M: "ամիս",
                MM: "%d ամիս",
                y: "տարի",
                yy: "%d տարի"
            },
            meridiemParse: /գիշերվա|առավոտվա|ցերեկվա|երեկոյան/,
            isPM: function(input) {
                return /^(ցերեկվա|երեկոյան)$/.test(input)
            },
            meridiem: function(hour) {
                return hour < 4 ? "գիշերվա" : hour < 12 ? "առավոտվա" : hour < 17 ? "ցերեկվա" : "երեկոյան"
            },
            dayOfMonthOrdinalParse: /\d{1,2}|\d{1,2}-(ին|րդ)/,
            ordinal: function(number, period) {
                switch (period) {
                    case "DDD":
                    case "w":
                    case "W":
                    case "DDDo":
                        return 1 === number ? number + "-ին" : number + "-րդ";
                    default:
                        return number
                }
            },
            week: {
                dow: 1,
                doy: 7
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("id", {
            months: "Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_November_Desember".split("_"),
            monthsShort: "Jan_Feb_Mar_Apr_Mei_Jun_Jul_Agt_Sep_Okt_Nov_Des".split("_"),
            weekdays: "Minggu_Senin_Selasa_Rabu_Kamis_Jumat_Sabtu".split("_"),
            weekdaysShort: "Min_Sen_Sel_Rab_Kam_Jum_Sab".split("_"),
            weekdaysMin: "Mg_Sn_Sl_Rb_Km_Jm_Sb".split("_"),
            longDateFormat: {
                LT: "HH.mm",
                LTS: "HH.mm.ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY [pukul] HH.mm",
                LLLL: "dddd, D MMMM YYYY [pukul] HH.mm"
            },
            meridiemParse: /pagi|siang|sore|malam/,
            meridiemHour: function(hour, meridiem) {
                return 12 === hour && (hour = 0), "pagi" === meridiem ? hour : "siang" === meridiem ? hour >= 11 ? hour : hour + 12 : "sore" === meridiem || "malam" === meridiem ? hour + 12 : void 0
            },
            meridiem: function(hours, minutes, isLower) {
                return hours < 11 ? "pagi" : hours < 15 ? "siang" : hours < 19 ? "sore" : "malam"
            },
            calendar: {
                sameDay: "[Hari ini pukul] LT",
                nextDay: "[Besok pukul] LT",
                nextWeek: "dddd [pukul] LT",
                lastDay: "[Kemarin pukul] LT",
                lastWeek: "dddd [lalu pukul] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "dalam %s",
                past: "%s yang lalu",
                s: "beberapa detik",
                ss: "%d detik",
                m: "semenit",
                mm: "%d menit",
                h: "sejam",
                hh: "%d jam",
                d: "sehari",
                dd: "%d hari",
                M: "sebulan",
                MM: "%d bulan",
                y: "setahun",
                yy: "%d tahun"
            },
            week: {
                dow: 0,
                doy: 6
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";

        function plural(n) {
            return n % 100 == 11 || n % 10 != 1
        }

        function translate(number, withoutSuffix, key, isFuture) {
            var result = number + " ";
            switch (key) {
                case "s":
                    return withoutSuffix || isFuture ? "nokkrar sekúndur" : "nokkrum sekúndum";
                case "ss":
                    return plural(number) ? result + (withoutSuffix || isFuture ? "sekúndur" : "sekúndum") : result + "sekúnda";
                case "m":
                    return withoutSuffix ? "mínúta" : "mínútu";
                case "mm":
                    return plural(number) ? result + (withoutSuffix || isFuture ? "mínútur" : "mínútum") : withoutSuffix ? result + "mínúta" : result + "mínútu";
                case "hh":
                    return plural(number) ? result + (withoutSuffix || isFuture ? "klukkustundir" : "klukkustundum") : result + "klukkustund";
                case "d":
                    return withoutSuffix ? "dagur" : isFuture ? "dag" : "degi";
                case "dd":
                    return plural(number) ? withoutSuffix ? result + "dagar" : result + (isFuture ? "daga" : "dögum") : withoutSuffix ? result + "dagur" : result + (isFuture ? "dag" : "degi");
                case "M":
                    return withoutSuffix ? "mánuður" : isFuture ? "mánuð" : "mánuði";
                case "MM":
                    return plural(number) ? withoutSuffix ? result + "mánuðir" : result + (isFuture ? "mánuði" : "mánuðum") : withoutSuffix ? result + "mánuður" : result + (isFuture ? "mánuð" : "mánuði");
                case "y":
                    return withoutSuffix || isFuture ? "ár" : "ári";
                case "yy":
                    return plural(number) ? result + (withoutSuffix || isFuture ? "ár" : "árum") : result + (withoutSuffix || isFuture ? "ár" : "ári")
            }
        }
        moment.defineLocale("is", {
            months: "janúar_febrúar_mars_apríl_maí_júní_júlí_ágúst_september_október_nóvember_desember".split("_"),
            monthsShort: "jan_feb_mar_apr_maí_jún_júl_ágú_sep_okt_nóv_des".split("_"),
            weekdays: "sunnudagur_mánudagur_þriðjudagur_miðvikudagur_fimmtudagur_föstudagur_laugardagur".split("_"),
            weekdaysShort: "sun_mán_þri_mið_fim_fös_lau".split("_"),
            weekdaysMin: "Su_Má_Þr_Mi_Fi_Fö_La".split("_"),
            longDateFormat: {
                LT: "H:mm",
                LTS: "H:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D. MMMM YYYY",
                LLL: "D. MMMM YYYY [kl.] H:mm",
                LLLL: "dddd, D. MMMM YYYY [kl.] H:mm"
            },
            calendar: {
                sameDay: "[í dag kl.] LT",
                nextDay: "[á morgun kl.] LT",
                nextWeek: "dddd [kl.] LT",
                lastDay: "[í gær kl.] LT",
                lastWeek: "[síðasta] dddd [kl.] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "eftir %s",
                past: "fyrir %s síðan",
                s: translate,
                ss: translate,
                m: translate,
                mm: translate,
                h: "klukkustund",
                hh: translate,
                d: translate,
                dd: translate,
                M: translate,
                MM: translate,
                y: translate,
                yy: translate
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("it", {
            months: "gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre".split("_"),
            monthsShort: "gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic".split("_"),
            weekdays: "domenica_lunedì_martedì_mercoledì_giovedì_venerdì_sabato".split("_"),
            weekdaysShort: "dom_lun_mar_mer_gio_ven_sab".split("_"),
            weekdaysMin: "do_lu_ma_me_gi_ve_sa".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: function() {
                    return "[Oggi a" + (this.hours() > 1 ? "lle " : 0 === this.hours() ? " " : "ll'") + "]LT"
                },
                nextDay: function() {
                    return "[Domani a" + (this.hours() > 1 ? "lle " : 0 === this.hours() ? " " : "ll'") + "]LT"
                },
                nextWeek: function() {
                    return "dddd [a" + (this.hours() > 1 ? "lle " : 0 === this.hours() ? " " : "ll'") + "]LT"
                },
                lastDay: function() {
                    return "[Ieri a" + (this.hours() > 1 ? "lle " : 0 === this.hours() ? " " : "ll'") + "]LT"
                },
                lastWeek: function() {
                    switch (this.day()) {
                        case 0:
                            return "[La scorsa] dddd [a" + (this.hours() > 1 ? "lle " : 0 === this.hours() ? " " : "ll'") + "]LT";
                        default:
                            return "[Lo scorso] dddd [a" + (this.hours() > 1 ? "lle " : 0 === this.hours() ? " " : "ll'") + "]LT"
                    }
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "tra %s",
                past: "%s fa",
                s: "alcuni secondi",
                ss: "%d secondi",
                m: "un minuto",
                mm: "%d minuti",
                h: "un'ora",
                hh: "%d ore",
                d: "un giorno",
                dd: "%d giorni",
                w: "una settimana",
                ww: "%d settimane",
                M: "un mese",
                MM: "%d mesi",
                y: "un anno",
                yy: "%d anni"
            },
            dayOfMonthOrdinalParse: /\d{1,2}º/,
            ordinal: "%dº",
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("it-ch", {
            months: "gennaio_febbraio_marzo_aprile_maggio_giugno_luglio_agosto_settembre_ottobre_novembre_dicembre".split("_"),
            monthsShort: "gen_feb_mar_apr_mag_giu_lug_ago_set_ott_nov_dic".split("_"),
            weekdays: "domenica_lunedì_martedì_mercoledì_giovedì_venerdì_sabato".split("_"),
            weekdaysShort: "dom_lun_mar_mer_gio_ven_sab".split("_"),
            weekdaysMin: "do_lu_ma_me_gi_ve_sa".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[Oggi alle] LT",
                nextDay: "[Domani alle] LT",
                nextWeek: "dddd [alle] LT",
                lastDay: "[Ieri alle] LT",
                lastWeek: function() {
                    switch (this.day()) {
                        case 0:
                            return "[la scorsa] dddd [alle] LT";
                        default:
                            return "[lo scorso] dddd [alle] LT"
                    }
                },
                sameElse: "L"
            },
            relativeTime: {
                future: function(s) {
                    return (/^[0-9].+$/.test(s) ? "tra" : "in") + " " + s
                },
                past: "%s fa",
                s: "alcuni secondi",
                ss: "%d secondi",
                m: "un minuto",
                mm: "%d minuti",
                h: "un'ora",
                hh: "%d ore",
                d: "un giorno",
                dd: "%d giorni",
                M: "un mese",
                MM: "%d mesi",
                y: "un anno",
                yy: "%d anni"
            },
            dayOfMonthOrdinalParse: /\d{1,2}º/,
            ordinal: "%dº",
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("ja", {
            eras: [{
                since: "2019-05-01",
                offset: 1,
                name: "令和",
                narrow: "㋿",
                abbr: "R"
            }, {
                since: "1989-01-08",
                until: "2019-04-30",
                offset: 1,
                name: "平成",
                narrow: "㍻",
                abbr: "H"
            }, {
                since: "1926-12-25",
                until: "1989-01-07",
                offset: 1,
                name: "昭和",
                narrow: "㍼",
                abbr: "S"
            }, {
                since: "1912-07-30",
                until: "1926-12-24",
                offset: 1,
                name: "大正",
                narrow: "㍽",
                abbr: "T"
            }, {
                since: "1873-01-01",
                until: "1912-07-29",
                offset: 6,
                name: "明治",
                narrow: "㍾",
                abbr: "M"
            }, {
                since: "0001-01-01",
                until: "1873-12-31",
                offset: 1,
                name: "西暦",
                narrow: "AD",
                abbr: "AD"
            }, {
                since: "0000-12-31",
                until: -1 / 0,
                offset: 1,
                name: "紀元前",
                narrow: "BC",
                abbr: "BC"
            }],
            eraYearOrdinalRegex: /(元|\d+)年/,
            eraYearOrdinalParse: function(input, match) {
                return "元" === match[1] ? 1 : parseInt(match[1] || input, 10)
            },
            months: "1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"),
            monthsShort: "1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"),
            weekdays: "日曜日_月曜日_火曜日_水曜日_木曜日_金曜日_土曜日".split("_"),
            weekdaysShort: "日_月_火_水_木_金_土".split("_"),
            weekdaysMin: "日_月_火_水_木_金_土".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "YYYY/MM/DD",
                LL: "YYYY年M月D日",
                LLL: "YYYY年M月D日 HH:mm",
                LLLL: "YYYY年M月D日 dddd HH:mm",
                l: "YYYY/MM/DD",
                ll: "YYYY年M月D日",
                lll: "YYYY年M月D日 HH:mm",
                llll: "YYYY年M月D日(ddd) HH:mm"
            },
            meridiemParse: /午前|午後/i,
            isPM: function(input) {
                return "午後" === input
            },
            meridiem: function(hour, minute, isLower) {
                return hour < 12 ? "午前" : "午後"
            },
            calendar: {
                sameDay: "[今日] LT",
                nextDay: "[明日] LT",
                nextWeek: function(now) {
                    return now.week() !== this.week() ? "[来週]dddd LT" : "dddd LT"
                },
                lastDay: "[昨日] LT",
                lastWeek: function(now) {
                    return this.week() !== now.week() ? "[先週]dddd LT" : "dddd LT"
                },
                sameElse: "L"
            },
            dayOfMonthOrdinalParse: /\d{1,2}日/,
            ordinal: function(number, period) {
                switch (period) {
                    case "y":
                        return 1 === number ? "元年" : number + "年";
                    case "d":
                    case "D":
                    case "DDD":
                        return number + "日";
                    default:
                        return number
                }
            },
            relativeTime: {
                future: "%s後",
                past: "%s前",
                s: "数秒",
                ss: "%d秒",
                m: "1分",
                mm: "%d分",
                h: "1時間",
                hh: "%d時間",
                d: "1日",
                dd: "%d日",
                M: "1ヶ月",
                MM: "%dヶ月",
                y: "1年",
                yy: "%d年"
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("jv", {
            months: "Januari_Februari_Maret_April_Mei_Juni_Juli_Agustus_September_Oktober_Nopember_Desember".split("_"),
            monthsShort: "Jan_Feb_Mar_Apr_Mei_Jun_Jul_Ags_Sep_Okt_Nop_Des".split("_"),
            weekdays: "Minggu_Senen_Seloso_Rebu_Kemis_Jemuwah_Septu".split("_"),
            weekdaysShort: "Min_Sen_Sel_Reb_Kem_Jem_Sep".split("_"),
            weekdaysMin: "Mg_Sn_Sl_Rb_Km_Jm_Sp".split("_"),
            longDateFormat: {
                LT: "HH.mm",
                LTS: "HH.mm.ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY [pukul] HH.mm",
                LLLL: "dddd, D MMMM YYYY [pukul] HH.mm"
            },
            meridiemParse: /enjing|siyang|sonten|ndalu/,
            meridiemHour: function(hour, meridiem) {
                return 12 === hour && (hour = 0), "enjing" === meridiem ? hour : "siyang" === meridiem ? hour >= 11 ? hour : hour + 12 : "sonten" === meridiem || "ndalu" === meridiem ? hour + 12 : void 0
            },
            meridiem: function(hours, minutes, isLower) {
                return hours < 11 ? "enjing" : hours < 15 ? "siyang" : hours < 19 ? "sonten" : "ndalu"
            },
            calendar: {
                sameDay: "[Dinten puniko pukul] LT",
                nextDay: "[Mbenjang pukul] LT",
                nextWeek: "dddd [pukul] LT",
                lastDay: "[Kala wingi pukul] LT",
                lastWeek: "dddd [kepengker pukul] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "wonten ing %s",
                past: "%s ingkang kepengker",
                s: "sawetawis detik",
                ss: "%d detik",
                m: "setunggal menit",
                mm: "%d menit",
                h: "setunggal jam",
                hh: "%d jam",
                d: "sedinten",
                dd: "%d dinten",
                M: "sewulan",
                MM: "%d wulan",
                y: "setaun",
                yy: "%d taun"
            },
            week: {
                dow: 1,
                doy: 7
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("ka", {
            months: "იანვარი_თებერვალი_მარტი_აპრილი_მაისი_ივნისი_ივლისი_აგვისტო_სექტემბერი_ოქტომბერი_ნოემბერი_დეკემბერი".split("_"),
            monthsShort: "იან_თებ_მარ_აპრ_მაი_ივნ_ივლ_აგვ_სექ_ოქტ_ნოე_დეკ".split("_"),
            weekdays: {
                standalone: "კვირა_ორშაბათი_სამშაბათი_ოთხშაბათი_ხუთშაბათი_პარასკევი_შაბათი".split("_"),
                format: "კვირას_ორშაბათს_სამშაბათს_ოთხშაბათს_ხუთშაბათს_პარასკევს_შაბათს".split("_"),
                isFormat: /(წინა|შემდეგ)/
            },
            weekdaysShort: "კვი_ორშ_სამ_ოთხ_ხუთ_პარ_შაბ".split("_"),
            weekdaysMin: "კვ_ორ_სა_ოთ_ხუ_პა_შა".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd, D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[დღეს] LT[-ზე]",
                nextDay: "[ხვალ] LT[-ზე]",
                lastDay: "[გუშინ] LT[-ზე]",
                nextWeek: "[შემდეგ] dddd LT[-ზე]",
                lastWeek: "[წინა] dddd LT-ზე",
                sameElse: "L"
            },
            relativeTime: {
                future: function(s) {
                    return s.replace(/(წამ|წუთ|საათ|წელ|დღ|თვ)(ი|ე)/, (function($0, $1, $2) {
                        return "ი" === $2 ? $1 + "ში" : $1 + $2 + "ში"
                    }))
                },
                past: function(s) {
                    return /(წამი|წუთი|საათი|დღე|თვე)/.test(s) ? s.replace(/(ი|ე)$/, "ის წინ") : /წელი/.test(s) ? s.replace(/წელი$/, "წლის წინ") : s
                },
                s: "რამდენიმე წამი",
                ss: "%d წამი",
                m: "წუთი",
                mm: "%d წუთი",
                h: "საათი",
                hh: "%d საათი",
                d: "დღე",
                dd: "%d დღე",
                M: "თვე",
                MM: "%d თვე",
                y: "წელი",
                yy: "%d წელი"
            },
            dayOfMonthOrdinalParse: /0|1-ლი|მე-\d{1,2}|\d{1,2}-ე/,
            ordinal: function(number) {
                return 0 === number ? number : 1 === number ? number + "-ლი" : number < 20 || number <= 100 && number % 20 == 0 || number % 100 == 0 ? "მე-" + number : number + "-ე"
            },
            week: {
                dow: 1,
                doy: 7
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        var suffixes = {
            0: "-ші",
            1: "-ші",
            2: "-ші",
            3: "-ші",
            4: "-ші",
            5: "-ші",
            6: "-шы",
            7: "-ші",
            8: "-ші",
            9: "-шы",
            10: "-шы",
            20: "-шы",
            30: "-шы",
            40: "-шы",
            50: "-ші",
            60: "-шы",
            70: "-ші",
            80: "-ші",
            90: "-шы",
            100: "-ші"
        };
        moment.defineLocale("kk", {
            months: "қаңтар_ақпан_наурыз_сәуір_мамыр_маусым_шілде_тамыз_қыркүйек_қазан_қараша_желтоқсан".split("_"),
            monthsShort: "қаң_ақп_нау_сәу_мам_мау_шіл_там_қыр_қаз_қар_жел".split("_"),
            weekdays: "жексенбі_дүйсенбі_сейсенбі_сәрсенбі_бейсенбі_жұма_сенбі".split("_"),
            weekdaysShort: "жек_дүй_сей_сәр_бей_жұм_сен".split("_"),
            weekdaysMin: "жк_дй_сй_ср_бй_жм_сн".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd, D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[Бүгін сағат] LT",
                nextDay: "[Ертең сағат] LT",
                nextWeek: "dddd [сағат] LT",
                lastDay: "[Кеше сағат] LT",
                lastWeek: "[Өткен аптаның] dddd [сағат] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s ішінде",
                past: "%s бұрын",
                s: "бірнеше секунд",
                ss: "%d секунд",
                m: "бір минут",
                mm: "%d минут",
                h: "бір сағат",
                hh: "%d сағат",
                d: "бір күн",
                dd: "%d күн",
                M: "бір ай",
                MM: "%d ай",
                y: "бір жыл",
                yy: "%d жыл"
            },
            dayOfMonthOrdinalParse: /\d{1,2}-(ші|шы)/,
            ordinal: function(number) {
                var a = number % 10,
                    b = number >= 100 ? 100 : null;
                return number + (suffixes[number] || suffixes[a] || suffixes[b])
            },
            week: {
                dow: 1,
                doy: 7
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        var symbolMap = {
                1: "១",
                2: "២",
                3: "៣",
                4: "៤",
                5: "៥",
                6: "៦",
                7: "៧",
                8: "៨",
                9: "៩",
                0: "០"
            },
            numberMap = {
                "១": "1",
                "២": "2",
                "៣": "3",
                "៤": "4",
                "៥": "5",
                "៦": "6",
                "៧": "7",
                "៨": "8",
                "៩": "9",
                "០": "0"
            };
        moment.defineLocale("km", {
            months: "មករា_កុម្ភៈ_មីនា_មេសា_ឧសភា_មិថុនា_កក្កដា_សីហា_កញ្ញា_តុលា_វិច្ឆិកា_ធ្នូ".split("_"),
            monthsShort: "មករា_កុម្ភៈ_មីនា_មេសា_ឧសភា_មិថុនា_កក្កដា_សីហា_កញ្ញា_តុលា_វិច្ឆិកា_ធ្នូ".split("_"),
            weekdays: "អាទិត្យ_ច័ន្ទ_អង្គារ_ពុធ_ព្រហស្បតិ៍_សុក្រ_សៅរ៍".split("_"),
            weekdaysShort: "អា_ច_អ_ព_ព្រ_សុ_ស".split("_"),
            weekdaysMin: "អា_ច_អ_ព_ព្រ_សុ_ស".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd, D MMMM YYYY HH:mm"
            },
            meridiemParse: /ព្រឹក|ល្ងាច/,
            isPM: function(input) {
                return "ល្ងាច" === input
            },
            meridiem: function(hour, minute, isLower) {
                return hour < 12 ? "ព្រឹក" : "ល្ងាច"
            },
            calendar: {
                sameDay: "[ថ្ងៃនេះ ម៉ោង] LT",
                nextDay: "[ស្អែក ម៉ោង] LT",
                nextWeek: "dddd [ម៉ោង] LT",
                lastDay: "[ម្សិលមិញ ម៉ោង] LT",
                lastWeek: "dddd [សប្តាហ៍មុន] [ម៉ោង] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%sទៀត",
                past: "%sមុន",
                s: "ប៉ុន្មានវិនាទី",
                ss: "%d វិនាទី",
                m: "មួយនាទី",
                mm: "%d នាទី",
                h: "មួយម៉ោង",
                hh: "%d ម៉ោង",
                d: "មួយថ្ងៃ",
                dd: "%d ថ្ងៃ",
                M: "មួយខែ",
                MM: "%d ខែ",
                y: "មួយឆ្នាំ",
                yy: "%d ឆ្នាំ"
            },
            dayOfMonthOrdinalParse: /ទី\d{1,2}/,
            ordinal: "ទី%d",
            preparse: function(string) {
                return string.replace(/[១២៣៤៥៦៧៨៩០]/g, (function(match) {
                    return numberMap[match]
                }))
            },
            postformat: function(string) {
                return string.replace(/\d/g, (function(match) {
                    return symbolMap[match]
                }))
            },
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        var symbolMap = {
                1: "೧",
                2: "೨",
                3: "೩",
                4: "೪",
                5: "೫",
                6: "೬",
                7: "೭",
                8: "೮",
                9: "೯",
                0: "೦"
            },
            numberMap = {
                "೧": "1",
                "೨": "2",
                "೩": "3",
                "೪": "4",
                "೫": "5",
                "೬": "6",
                "೭": "7",
                "೮": "8",
                "೯": "9",
                "೦": "0"
            };
        moment.defineLocale("kn", {
            months: "ಜನವರಿ_ಫೆಬ್ರವರಿ_ಮಾರ್ಚ್_ಏಪ್ರಿಲ್_ಮೇ_ಜೂನ್_ಜುಲೈ_ಆಗಸ್ಟ್_ಸೆಪ್ಟೆಂಬರ್_ಅಕ್ಟೋಬರ್_ನವೆಂಬರ್_ಡಿಸೆಂಬರ್".split("_"),
            monthsShort: "ಜನ_ಫೆಬ್ರ_ಮಾರ್ಚ್_ಏಪ್ರಿಲ್_ಮೇ_ಜೂನ್_ಜುಲೈ_ಆಗಸ್ಟ್_ಸೆಪ್ಟೆಂ_ಅಕ್ಟೋ_ನವೆಂ_ಡಿಸೆಂ".split("_"),
            monthsParseExact: !0,
            weekdays: "ಭಾನುವಾರ_ಸೋಮವಾರ_ಮಂಗಳವಾರ_ಬುಧವಾರ_ಗುರುವಾರ_ಶುಕ್ರವಾರ_ಶನಿವಾರ".split("_"),
            weekdaysShort: "ಭಾನು_ಸೋಮ_ಮಂಗಳ_ಬುಧ_ಗುರು_ಶುಕ್ರ_ಶನಿ".split("_"),
            weekdaysMin: "ಭಾ_ಸೋ_ಮಂ_ಬು_ಗು_ಶು_ಶ".split("_"),
            longDateFormat: {
                LT: "A h:mm",
                LTS: "A h:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY, A h:mm",
                LLLL: "dddd, D MMMM YYYY, A h:mm"
            },
            calendar: {
                sameDay: "[ಇಂದು] LT",
                nextDay: "[ನಾಳೆ] LT",
                nextWeek: "dddd, LT",
                lastDay: "[ನಿನ್ನೆ] LT",
                lastWeek: "[ಕೊನೆಯ] dddd, LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s ನಂತರ",
                past: "%s ಹಿಂದೆ",
                s: "ಕೆಲವು ಕ್ಷಣಗಳು",
                ss: "%d ಸೆಕೆಂಡುಗಳು",
                m: "ಒಂದು ನಿಮಿಷ",
                mm: "%d ನಿಮಿಷ",
                h: "ಒಂದು ಗಂಟೆ",
                hh: "%d ಗಂಟೆ",
                d: "ಒಂದು ದಿನ",
                dd: "%d ದಿನ",
                M: "ಒಂದು ತಿಂಗಳು",
                MM: "%d ತಿಂಗಳು",
                y: "ಒಂದು ವರ್ಷ",
                yy: "%d ವರ್ಷ"
            },
            preparse: function(string) {
                return string.replace(/[೧೨೩೪೫೬೭೮೯೦]/g, (function(match) {
                    return numberMap[match]
                }))
            },
            postformat: function(string) {
                return string.replace(/\d/g, (function(match) {
                    return symbolMap[match]
                }))
            },
            meridiemParse: /ರಾತ್ರಿ|ಬೆಳಿಗ್ಗೆ|ಮಧ್ಯಾಹ್ನ|ಸಂಜೆ/,
            meridiemHour: function(hour, meridiem) {
                return 12 === hour && (hour = 0), "ರಾತ್ರಿ" === meridiem ? hour < 4 ? hour : hour + 12 : "ಬೆಳಿಗ್ಗೆ" === meridiem ? hour : "ಮಧ್ಯಾಹ್ನ" === meridiem ? hour >= 10 ? hour : hour + 12 : "ಸಂಜೆ" === meridiem ? hour + 12 : void 0
            },
            meridiem: function(hour, minute, isLower) {
                return hour < 4 ? "ರಾತ್ರಿ" : hour < 10 ? "ಬೆಳಿಗ್ಗೆ" : hour < 17 ? "ಮಧ್ಯಾಹ್ನ" : hour < 20 ? "ಸಂಜೆ" : "ರಾತ್ರಿ"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(ನೇ)/,
            ordinal: function(number) {
                return number + "ನೇ"
            },
            week: {
                dow: 0,
                doy: 6
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("ko", {
            months: "1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월".split("_"),
            monthsShort: "1월_2월_3월_4월_5월_6월_7월_8월_9월_10월_11월_12월".split("_"),
            weekdays: "일요일_월요일_화요일_수요일_목요일_금요일_토요일".split("_"),
            weekdaysShort: "일_월_화_수_목_금_토".split("_"),
            weekdaysMin: "일_월_화_수_목_금_토".split("_"),
            longDateFormat: {
                LT: "A h:mm",
                LTS: "A h:mm:ss",
                L: "YYYY.MM.DD.",
                LL: "YYYY년 MMMM D일",
                LLL: "YYYY년 MMMM D일 A h:mm",
                LLLL: "YYYY년 MMMM D일 dddd A h:mm",
                l: "YYYY.MM.DD.",
                ll: "YYYY년 MMMM D일",
                lll: "YYYY년 MMMM D일 A h:mm",
                llll: "YYYY년 MMMM D일 dddd A h:mm"
            },
            calendar: {
                sameDay: "오늘 LT",
                nextDay: "내일 LT",
                nextWeek: "dddd LT",
                lastDay: "어제 LT",
                lastWeek: "지난주 dddd LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s 후",
                past: "%s 전",
                s: "몇 초",
                ss: "%d초",
                m: "1분",
                mm: "%d분",
                h: "한 시간",
                hh: "%d시간",
                d: "하루",
                dd: "%d일",
                M: "한 달",
                MM: "%d달",
                y: "일 년",
                yy: "%d년"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(일|월|주)/,
            ordinal: function(number, period) {
                switch (period) {
                    case "d":
                    case "D":
                    case "DDD":
                        return number + "일";
                    case "M":
                        return number + "월";
                    case "w":
                    case "W":
                        return number + "주";
                    default:
                        return number
                }
            },
            meridiemParse: /오전|오후/,
            isPM: function(token) {
                return "오후" === token
            },
            meridiem: function(hour, minute, isUpper) {
                return hour < 12 ? "오전" : "오후"
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        var symbolMap = {
                1: "١",
                2: "٢",
                3: "٣",
                4: "٤",
                5: "٥",
                6: "٦",
                7: "٧",
                8: "٨",
                9: "٩",
                0: "٠"
            },
            numberMap = {
                "١": "1",
                "٢": "2",
                "٣": "3",
                "٤": "4",
                "٥": "5",
                "٦": "6",
                "٧": "7",
                "٨": "8",
                "٩": "9",
                "٠": "0"
            },
            months = ["کانونی دووەم", "شوبات", "ئازار", "نیسان", "ئایار", "حوزەیران", "تەمموز", "ئاب", "ئەیلوول", "تشرینی یەكەم", "تشرینی دووەم", "كانونی یەکەم"];
        moment.defineLocale("ku", {
            months: months,
            monthsShort: months,
            weekdays: "یه‌كشه‌ممه‌_دووشه‌ممه‌_سێشه‌ممه‌_چوارشه‌ممه‌_پێنجشه‌ممه‌_هه‌ینی_شه‌ممه‌".split("_"),
            weekdaysShort: "یه‌كشه‌م_دووشه‌م_سێشه‌م_چوارشه‌م_پێنجشه‌م_هه‌ینی_شه‌ممه‌".split("_"),
            weekdaysMin: "ی_د_س_چ_پ_ه_ش".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd, D MMMM YYYY HH:mm"
            },
            meridiemParse: /ئێواره‌|به‌یانی/,
            isPM: function(input) {
                return /ئێواره‌/.test(input)
            },
            meridiem: function(hour, minute, isLower) {
                return hour < 12 ? "به‌یانی" : "ئێواره‌"
            },
            calendar: {
                sameDay: "[ئه‌مرۆ كاتژمێر] LT",
                nextDay: "[به‌یانی كاتژمێر] LT",
                nextWeek: "dddd [كاتژمێر] LT",
                lastDay: "[دوێنێ كاتژمێر] LT",
                lastWeek: "dddd [كاتژمێر] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "له‌ %s",
                past: "%s",
                s: "چه‌ند چركه‌یه‌ك",
                ss: "چركه‌ %d",
                m: "یه‌ك خوله‌ك",
                mm: "%d خوله‌ك",
                h: "یه‌ك كاتژمێر",
                hh: "%d كاتژمێر",
                d: "یه‌ك ڕۆژ",
                dd: "%d ڕۆژ",
                M: "یه‌ك مانگ",
                MM: "%d مانگ",
                y: "یه‌ك ساڵ",
                yy: "%d ساڵ"
            },
            preparse: function(string) {
                return string.replace(/[١٢٣٤٥٦٧٨٩٠]/g, (function(match) {
                    return numberMap[match]
                })).replace(/،/g, ",")
            },
            postformat: function(string) {
                return string.replace(/\d/g, (function(match) {
                    return symbolMap[match]
                })).replace(/,/g, "،")
            },
            week: {
                dow: 6,
                doy: 12
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        var suffixes = {
            0: "-чү",
            1: "-чи",
            2: "-чи",
            3: "-чү",
            4: "-чү",
            5: "-чи",
            6: "-чы",
            7: "-чи",
            8: "-чи",
            9: "-чу",
            10: "-чу",
            20: "-чы",
            30: "-чу",
            40: "-чы",
            50: "-чү",
            60: "-чы",
            70: "-чи",
            80: "-чи",
            90: "-чу",
            100: "-чү"
        };
        moment.defineLocale("ky", {
            months: "январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь".split("_"),
            monthsShort: "янв_фев_март_апр_май_июнь_июль_авг_сен_окт_ноя_дек".split("_"),
            weekdays: "Жекшемби_Дүйшөмбү_Шейшемби_Шаршемби_Бейшемби_Жума_Ишемби".split("_"),
            weekdaysShort: "Жек_Дүй_Шей_Шар_Бей_Жум_Ише".split("_"),
            weekdaysMin: "Жк_Дй_Шй_Шр_Бй_Жм_Иш".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd, D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[Бүгүн саат] LT",
                nextDay: "[Эртең саат] LT",
                nextWeek: "dddd [саат] LT",
                lastDay: "[Кечээ саат] LT",
                lastWeek: "[Өткөн аптанын] dddd [күнү] [саат] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s ичинде",
                past: "%s мурун",
                s: "бирнече секунд",
                ss: "%d секунд",
                m: "бир мүнөт",
                mm: "%d мүнөт",
                h: "бир саат",
                hh: "%d саат",
                d: "бир күн",
                dd: "%d күн",
                M: "бир ай",
                MM: "%d ай",
                y: "бир жыл",
                yy: "%d жыл"
            },
            dayOfMonthOrdinalParse: /\d{1,2}-(чи|чы|чү|чу)/,
            ordinal: function(number) {
                var a = number % 10,
                    b = number >= 100 ? 100 : null;
                return number + (suffixes[number] || suffixes[a] || suffixes[b])
            },
            week: {
                dow: 1,
                doy: 7
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";

        function processRelativeTime(number, withoutSuffix, key, isFuture) {
            var format = {
                m: ["eng Minutt", "enger Minutt"],
                h: ["eng Stonn", "enger Stonn"],
                d: ["een Dag", "engem Dag"],
                M: ["ee Mount", "engem Mount"],
                y: ["ee Joer", "engem Joer"]
            };
            return withoutSuffix ? format[key][0] : format[key][1]
        }

        function processFutureTime(string) {
            return eifelerRegelAppliesToNumber(string.substr(0, string.indexOf(" "))) ? "a " + string : "an " + string
        }

        function processPastTime(string) {
            return eifelerRegelAppliesToNumber(string.substr(0, string.indexOf(" "))) ? "viru " + string : "virun " + string
        }

        function eifelerRegelAppliesToNumber(number) {
            if (number = parseInt(number, 10), isNaN(number)) return !1;
            if (number < 0) return !0;
            if (number < 10) return 4 <= number && number <= 7;
            if (number < 100) {
                var lastDigit = number % 10;
                return eifelerRegelAppliesToNumber(0 === lastDigit ? number / 10 : lastDigit)
            }
            if (number < 1e4) {
                for (; number >= 10;) number /= 10;
                return eifelerRegelAppliesToNumber(number)
            }
            return eifelerRegelAppliesToNumber(number /= 1e3)
        }
        moment.defineLocale("lb", {
            months: "Januar_Februar_Mäerz_Abrëll_Mee_Juni_Juli_August_September_Oktober_November_Dezember".split("_"),
            monthsShort: "Jan._Febr._Mrz._Abr._Mee_Jun._Jul._Aug._Sept._Okt._Nov._Dez.".split("_"),
            monthsParseExact: !0,
            weekdays: "Sonndeg_Méindeg_Dënschdeg_Mëttwoch_Donneschdeg_Freideg_Samschdeg".split("_"),
            weekdaysShort: "So._Mé._Dë._Më._Do._Fr._Sa.".split("_"),
            weekdaysMin: "So_Mé_Dë_Më_Do_Fr_Sa".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "H:mm [Auer]",
                LTS: "H:mm:ss [Auer]",
                L: "DD.MM.YYYY",
                LL: "D. MMMM YYYY",
                LLL: "D. MMMM YYYY H:mm [Auer]",
                LLLL: "dddd, D. MMMM YYYY H:mm [Auer]"
            },
            calendar: {
                sameDay: "[Haut um] LT",
                sameElse: "L",
                nextDay: "[Muer um] LT",
                nextWeek: "dddd [um] LT",
                lastDay: "[Gëschter um] LT",
                lastWeek: function() {
                    switch (this.day()) {
                        case 2:
                        case 4:
                            return "[Leschten] dddd [um] LT";
                        default:
                            return "[Leschte] dddd [um] LT"
                    }
                }
            },
            relativeTime: {
                future: processFutureTime,
                past: processPastTime,
                s: "e puer Sekonnen",
                ss: "%d Sekonnen",
                m: processRelativeTime,
                mm: "%d Minutten",
                h: processRelativeTime,
                hh: "%d Stonnen",
                d: processRelativeTime,
                dd: "%d Deeg",
                M: processRelativeTime,
                MM: "%d Méint",
                y: processRelativeTime,
                yy: "%d Joer"
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("lo", {
            months: "ມັງກອນ_ກຸມພາ_ມີນາ_ເມສາ_ພຶດສະພາ_ມິຖຸນາ_ກໍລະກົດ_ສິງຫາ_ກັນຍາ_ຕຸລາ_ພະຈິກ_ທັນວາ".split("_"),
            monthsShort: "ມັງກອນ_ກຸມພາ_ມີນາ_ເມສາ_ພຶດສະພາ_ມິຖຸນາ_ກໍລະກົດ_ສິງຫາ_ກັນຍາ_ຕຸລາ_ພະຈິກ_ທັນວາ".split("_"),
            weekdays: "ອາທິດ_ຈັນ_ອັງຄານ_ພຸດ_ພະຫັດ_ສຸກ_ເສົາ".split("_"),
            weekdaysShort: "ທິດ_ຈັນ_ອັງຄານ_ພຸດ_ພະຫັດ_ສຸກ_ເສົາ".split("_"),
            weekdaysMin: "ທ_ຈ_ອຄ_ພ_ພຫ_ສກ_ສ".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "ວັນdddd D MMMM YYYY HH:mm"
            },
            meridiemParse: /ຕອນເຊົ້າ|ຕອນແລງ/,
            isPM: function(input) {
                return "ຕອນແລງ" === input
            },
            meridiem: function(hour, minute, isLower) {
                return hour < 12 ? "ຕອນເຊົ້າ" : "ຕອນແລງ"
            },
            calendar: {
                sameDay: "[ມື້ນີ້ເວລາ] LT",
                nextDay: "[ມື້ອື່ນເວລາ] LT",
                nextWeek: "[ວັນ]dddd[ໜ້າເວລາ] LT",
                lastDay: "[ມື້ວານນີ້ເວລາ] LT",
                lastWeek: "[ວັນ]dddd[ແລ້ວນີ້ເວລາ] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "ອີກ %s",
                past: "%sຜ່ານມາ",
                s: "ບໍ່ເທົ່າໃດວິນາທີ",
                ss: "%d ວິນາທີ",
                m: "1 ນາທີ",
                mm: "%d ນາທີ",
                h: "1 ຊົ່ວໂມງ",
                hh: "%d ຊົ່ວໂມງ",
                d: "1 ມື້",
                dd: "%d ມື້",
                M: "1 ເດືອນ",
                MM: "%d ເດືອນ",
                y: "1 ປີ",
                yy: "%d ປີ"
            },
            dayOfMonthOrdinalParse: /(ທີ່)\d{1,2}/,
            ordinal: function(number) {
                return "ທີ່" + number
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        var units = {
            ss: "sekundė_sekundžių_sekundes",
            m: "minutė_minutės_minutę",
            mm: "minutės_minučių_minutes",
            h: "valanda_valandos_valandą",
            hh: "valandos_valandų_valandas",
            d: "diena_dienos_dieną",
            dd: "dienos_dienų_dienas",
            M: "mėnuo_mėnesio_mėnesį",
            MM: "mėnesiai_mėnesių_mėnesius",
            y: "metai_metų_metus",
            yy: "metai_metų_metus"
        };

        function translateSeconds(number, withoutSuffix, key, isFuture) {
            return withoutSuffix ? "kelios sekundės" : isFuture ? "kelių sekundžių" : "kelias sekundes"
        }

        function translateSingular(number, withoutSuffix, key, isFuture) {
            return withoutSuffix ? forms(key)[0] : isFuture ? forms(key)[1] : forms(key)[2]
        }

        function special(number) {
            return number % 10 == 0 || number > 10 && number < 20
        }

        function forms(key) {
            return units[key].split("_")
        }

        function translate(number, withoutSuffix, key, isFuture) {
            var result = number + " ";
            return 1 === number ? result + translateSingular(number, withoutSuffix, key[0], isFuture) : withoutSuffix ? result + (special(number) ? forms(key)[1] : forms(key)[0]) : isFuture ? result + forms(key)[1] : result + (special(number) ? forms(key)[1] : forms(key)[2])
        }
        moment.defineLocale("lt", {
            months: {
                format: "sausio_vasario_kovo_balandžio_gegužės_birželio_liepos_rugpjūčio_rugsėjo_spalio_lapkričio_gruodžio".split("_"),
                standalone: "sausis_vasaris_kovas_balandis_gegužė_birželis_liepa_rugpjūtis_rugsėjis_spalis_lapkritis_gruodis".split("_"),
                isFormat: /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?|MMMM?(\[[^\[\]]*\]|\s)+D[oD]?/
            },
            monthsShort: "sau_vas_kov_bal_geg_bir_lie_rgp_rgs_spa_lap_grd".split("_"),
            weekdays: {
                format: "sekmadienį_pirmadienį_antradienį_trečiadienį_ketvirtadienį_penktadienį_šeštadienį".split("_"),
                standalone: "sekmadienis_pirmadienis_antradienis_trečiadienis_ketvirtadienis_penktadienis_šeštadienis".split("_"),
                isFormat: /dddd HH:mm/
            },
            weekdaysShort: "Sek_Pir_Ant_Tre_Ket_Pen_Šeš".split("_"),
            weekdaysMin: "S_P_A_T_K_Pn_Š".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "YYYY-MM-DD",
                LL: "YYYY [m.] MMMM D [d.]",
                LLL: "YYYY [m.] MMMM D [d.], HH:mm [val.]",
                LLLL: "YYYY [m.] MMMM D [d.], dddd, HH:mm [val.]",
                l: "YYYY-MM-DD",
                ll: "YYYY [m.] MMMM D [d.]",
                lll: "YYYY [m.] MMMM D [d.], HH:mm [val.]",
                llll: "YYYY [m.] MMMM D [d.], ddd, HH:mm [val.]"
            },
            calendar: {
                sameDay: "[Šiandien] LT",
                nextDay: "[Rytoj] LT",
                nextWeek: "dddd LT",
                lastDay: "[Vakar] LT",
                lastWeek: "[Praėjusį] dddd LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "po %s",
                past: "prieš %s",
                s: translateSeconds,
                ss: translate,
                m: translateSingular,
                mm: translate,
                h: translateSingular,
                hh: translate,
                d: translateSingular,
                dd: translate,
                M: translateSingular,
                MM: translate,
                y: translateSingular,
                yy: translate
            },
            dayOfMonthOrdinalParse: /\d{1,2}-oji/,
            ordinal: function(number) {
                return number + "-oji"
            },
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        var units = {
            ss: "sekundes_sekundēm_sekunde_sekundes".split("_"),
            m: "minūtes_minūtēm_minūte_minūtes".split("_"),
            mm: "minūtes_minūtēm_minūte_minūtes".split("_"),
            h: "stundas_stundām_stunda_stundas".split("_"),
            hh: "stundas_stundām_stunda_stundas".split("_"),
            d: "dienas_dienām_diena_dienas".split("_"),
            dd: "dienas_dienām_diena_dienas".split("_"),
            M: "mēneša_mēnešiem_mēnesis_mēneši".split("_"),
            MM: "mēneša_mēnešiem_mēnesis_mēneši".split("_"),
            y: "gada_gadiem_gads_gadi".split("_"),
            yy: "gada_gadiem_gads_gadi".split("_")
        };

        function format(forms, number, withoutSuffix) {
            return withoutSuffix ? number % 10 == 1 && number % 100 != 11 ? forms[2] : forms[3] : number % 10 == 1 && number % 100 != 11 ? forms[0] : forms[1]
        }

        function relativeTimeWithPlural(number, withoutSuffix, key) {
            return number + " " + format(units[key], number, withoutSuffix)
        }

        function relativeTimeWithSingular(number, withoutSuffix, key) {
            return format(units[key], number, withoutSuffix)
        }

        function relativeSeconds(number, withoutSuffix) {
            return withoutSuffix ? "dažas sekundes" : "dažām sekundēm"
        }
        moment.defineLocale("lv", {
            months: "janvāris_februāris_marts_aprīlis_maijs_jūnijs_jūlijs_augusts_septembris_oktobris_novembris_decembris".split("_"),
            monthsShort: "jan_feb_mar_apr_mai_jūn_jūl_aug_sep_okt_nov_dec".split("_"),
            weekdays: "svētdiena_pirmdiena_otrdiena_trešdiena_ceturtdiena_piektdiena_sestdiena".split("_"),
            weekdaysShort: "Sv_P_O_T_C_Pk_S".split("_"),
            weekdaysMin: "Sv_P_O_T_C_Pk_S".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD.MM.YYYY.",
                LL: "YYYY. [gada] D. MMMM",
                LLL: "YYYY. [gada] D. MMMM, HH:mm",
                LLLL: "YYYY. [gada] D. MMMM, dddd, HH:mm"
            },
            calendar: {
                sameDay: "[Šodien pulksten] LT",
                nextDay: "[Rīt pulksten] LT",
                nextWeek: "dddd [pulksten] LT",
                lastDay: "[Vakar pulksten] LT",
                lastWeek: "[Pagājušā] dddd [pulksten] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "pēc %s",
                past: "pirms %s",
                s: relativeSeconds,
                ss: relativeTimeWithPlural,
                m: relativeTimeWithSingular,
                mm: relativeTimeWithPlural,
                h: relativeTimeWithSingular,
                hh: relativeTimeWithPlural,
                d: relativeTimeWithSingular,
                dd: relativeTimeWithPlural,
                M: relativeTimeWithSingular,
                MM: relativeTimeWithPlural,
                y: relativeTimeWithSingular,
                yy: relativeTimeWithPlural
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        var translator = {
            words: {
                ss: ["sekund", "sekunda", "sekundi"],
                m: ["jedan minut", "jednog minuta"],
                mm: ["minut", "minuta", "minuta"],
                h: ["jedan sat", "jednog sata"],
                hh: ["sat", "sata", "sati"],
                dd: ["dan", "dana", "dana"],
                MM: ["mjesec", "mjeseca", "mjeseci"],
                yy: ["godina", "godine", "godina"]
            },
            correctGrammaticalCase: function(number, wordKey) {
                return 1 === number ? wordKey[0] : number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]
            },
            translate: function(number, withoutSuffix, key) {
                var wordKey = translator.words[key];
                return 1 === key.length ? withoutSuffix ? wordKey[0] : wordKey[1] : number + " " + translator.correctGrammaticalCase(number, wordKey)
            }
        };
        moment.defineLocale("me", {
            months: "januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar".split("_"),
            monthsShort: "jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.".split("_"),
            monthsParseExact: !0,
            weekdays: "nedjelja_ponedjeljak_utorak_srijeda_četvrtak_petak_subota".split("_"),
            weekdaysShort: "ned._pon._uto._sri._čet._pet._sub.".split("_"),
            weekdaysMin: "ne_po_ut_sr_če_pe_su".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "H:mm",
                LTS: "H:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D. MMMM YYYY",
                LLL: "D. MMMM YYYY H:mm",
                LLLL: "dddd, D. MMMM YYYY H:mm"
            },
            calendar: {
                sameDay: "[danas u] LT",
                nextDay: "[sjutra u] LT",
                nextWeek: function() {
                    switch (this.day()) {
                        case 0:
                            return "[u] [nedjelju] [u] LT";
                        case 3:
                            return "[u] [srijedu] [u] LT";
                        case 6:
                            return "[u] [subotu] [u] LT";
                        case 1:
                        case 2:
                        case 4:
                        case 5:
                            return "[u] dddd [u] LT"
                    }
                },
                lastDay: "[juče u] LT",
                lastWeek: function() {
                    return ["[prošle] [nedjelje] [u] LT", "[prošlog] [ponedjeljka] [u] LT", "[prošlog] [utorka] [u] LT", "[prošle] [srijede] [u] LT", "[prošlog] [četvrtka] [u] LT", "[prošlog] [petka] [u] LT", "[prošle] [subote] [u] LT"][this.day()]
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "za %s",
                past: "prije %s",
                s: "nekoliko sekundi",
                ss: translator.translate,
                m: translator.translate,
                mm: translator.translate,
                h: translator.translate,
                hh: translator.translate,
                d: "dan",
                dd: translator.translate,
                M: "mjesec",
                MM: translator.translate,
                y: "godinu",
                yy: translator.translate
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {
                dow: 1,
                doy: 7
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("mi", {
            months: "Kohi-tāte_Hui-tanguru_Poutū-te-rangi_Paenga-whāwhā_Haratua_Pipiri_Hōngoingoi_Here-turi-kōkā_Mahuru_Whiringa-ā-nuku_Whiringa-ā-rangi_Hakihea".split("_"),
            monthsShort: "Kohi_Hui_Pou_Pae_Hara_Pipi_Hōngoi_Here_Mahu_Whi-nu_Whi-ra_Haki".split("_"),
            monthsRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
            monthsStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
            monthsShortRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,3}/i,
            monthsShortStrictRegex: /(?:['a-z\u0101\u014D\u016B]+\-?){1,2}/i,
            weekdays: "Rātapu_Mane_Tūrei_Wenerei_Tāite_Paraire_Hātarei".split("_"),
            weekdaysShort: "Ta_Ma_Tū_We_Tāi_Pa_Hā".split("_"),
            weekdaysMin: "Ta_Ma_Tū_We_Tāi_Pa_Hā".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY [i] HH:mm",
                LLLL: "dddd, D MMMM YYYY [i] HH:mm"
            },
            calendar: {
                sameDay: "[i teie mahana, i] LT",
                nextDay: "[apopo i] LT",
                nextWeek: "dddd [i] LT",
                lastDay: "[inanahi i] LT",
                lastWeek: "dddd [whakamutunga i] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "i roto i %s",
                past: "%s i mua",
                s: "te hēkona ruarua",
                ss: "%d hēkona",
                m: "he meneti",
                mm: "%d meneti",
                h: "te haora",
                hh: "%d haora",
                d: "he ra",
                dd: "%d ra",
                M: "he marama",
                MM: "%d marama",
                y: "he tau",
                yy: "%d tau"
            },
            dayOfMonthOrdinalParse: /\d{1,2}º/,
            ordinal: "%dº",
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("mk", {
            months: "јануари_февруари_март_април_мај_јуни_јули_август_септември_октомври_ноември_декември".split("_"),
            monthsShort: "јан_фев_мар_апр_мај_јун_јул_авг_сеп_окт_ное_дек".split("_"),
            weekdays: "недела_понеделник_вторник_среда_четврток_петок_сабота".split("_"),
            weekdaysShort: "нед_пон_вто_сре_чет_пет_саб".split("_"),
            weekdaysMin: "нe_пo_вт_ср_че_пе_сa".split("_"),
            longDateFormat: {
                LT: "H:mm",
                LTS: "H:mm:ss",
                L: "D.MM.YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY H:mm",
                LLLL: "dddd, D MMMM YYYY H:mm"
            },
            calendar: {
                sameDay: "[Денес во] LT",
                nextDay: "[Утре во] LT",
                nextWeek: "[Во] dddd [во] LT",
                lastDay: "[Вчера во] LT",
                lastWeek: function() {
                    switch (this.day()) {
                        case 0:
                        case 3:
                        case 6:
                            return "[Изминатата] dddd [во] LT";
                        case 1:
                        case 2:
                        case 4:
                        case 5:
                            return "[Изминатиот] dddd [во] LT"
                    }
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "за %s",
                past: "пред %s",
                s: "неколку секунди",
                ss: "%d секунди",
                m: "една минута",
                mm: "%d минути",
                h: "еден час",
                hh: "%d часа",
                d: "еден ден",
                dd: "%d дена",
                M: "еден месец",
                MM: "%d месеци",
                y: "една година",
                yy: "%d години"
            },
            dayOfMonthOrdinalParse: /\d{1,2}-(ев|ен|ти|ви|ри|ми)/,
            ordinal: function(number) {
                var lastDigit = number % 10,
                    last2Digits = number % 100;
                return 0 === number ? number + "-ев" : 0 === last2Digits ? number + "-ен" : last2Digits > 10 && last2Digits < 20 ? number + "-ти" : 1 === lastDigit ? number + "-ви" : 2 === lastDigit ? number + "-ри" : 7 === lastDigit || 8 === lastDigit ? number + "-ми" : number + "-ти"
            },
            week: {
                dow: 1,
                doy: 7
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("ml", {
            months: "ജനുവരി_ഫെബ്രുവരി_മാർച്ച്_ഏപ്രിൽ_മേയ്_ജൂൺ_ജൂലൈ_ഓഗസ്റ്റ്_സെപ്റ്റംബർ_ഒക്ടോബർ_നവംബർ_ഡിസംബർ".split("_"),
            monthsShort: "ജനു._ഫെബ്രു._മാർ._ഏപ്രി._മേയ്_ജൂൺ_ജൂലൈ._ഓഗ._സെപ്റ്റ._ഒക്ടോ._നവം._ഡിസം.".split("_"),
            monthsParseExact: !0,
            weekdays: "ഞായറാഴ്ച_തിങ്കളാഴ്ച_ചൊവ്വാഴ്ച_ബുധനാഴ്ച_വ്യാഴാഴ്ച_വെള്ളിയാഴ്ച_ശനിയാഴ്ച".split("_"),
            weekdaysShort: "ഞായർ_തിങ്കൾ_ചൊവ്വ_ബുധൻ_വ്യാഴം_വെള്ളി_ശനി".split("_"),
            weekdaysMin: "ഞാ_തി_ചൊ_ബു_വ്യാ_വെ_ശ".split("_"),
            longDateFormat: {
                LT: "A h:mm -നു",
                LTS: "A h:mm:ss -നു",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY, A h:mm -നു",
                LLLL: "dddd, D MMMM YYYY, A h:mm -നു"
            },
            calendar: {
                sameDay: "[ഇന്ന്] LT",
                nextDay: "[നാളെ] LT",
                nextWeek: "dddd, LT",
                lastDay: "[ഇന്നലെ] LT",
                lastWeek: "[കഴിഞ്ഞ] dddd, LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s കഴിഞ്ഞ്",
                past: "%s മുൻപ്",
                s: "അൽപ നിമിഷങ്ങൾ",
                ss: "%d സെക്കൻഡ്",
                m: "ഒരു മിനിറ്റ്",
                mm: "%d മിനിറ്റ്",
                h: "ഒരു മണിക്കൂർ",
                hh: "%d മണിക്കൂർ",
                d: "ഒരു ദിവസം",
                dd: "%d ദിവസം",
                M: "ഒരു മാസം",
                MM: "%d മാസം",
                y: "ഒരു വർഷം",
                yy: "%d വർഷം"
            },
            meridiemParse: /രാത്രി|രാവിലെ|ഉച്ച കഴിഞ്ഞ്|വൈകുന്നേരം|രാത്രി/i,
            meridiemHour: function(hour, meridiem) {
                return 12 === hour && (hour = 0), "രാത്രി" === meridiem && hour >= 4 || "ഉച്ച കഴിഞ്ഞ്" === meridiem || "വൈകുന്നേരം" === meridiem ? hour + 12 : hour
            },
            meridiem: function(hour, minute, isLower) {
                return hour < 4 ? "രാത്രി" : hour < 12 ? "രാവിലെ" : hour < 17 ? "ഉച്ച കഴിഞ്ഞ്" : hour < 20 ? "വൈകുന്നേരം" : "രാത്രി"
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";

        function translate(number, withoutSuffix, key, isFuture) {
            switch (key) {
                case "s":
                    return withoutSuffix ? "хэдхэн секунд" : "хэдхэн секундын";
                case "ss":
                    return number + (withoutSuffix ? " секунд" : " секундын");
                case "m":
                case "mm":
                    return number + (withoutSuffix ? " минут" : " минутын");
                case "h":
                case "hh":
                    return number + (withoutSuffix ? " цаг" : " цагийн");
                case "d":
                case "dd":
                    return number + (withoutSuffix ? " өдөр" : " өдрийн");
                case "M":
                case "MM":
                    return number + (withoutSuffix ? " сар" : " сарын");
                case "y":
                case "yy":
                    return number + (withoutSuffix ? " жил" : " жилийн");
                default:
                    return number
            }
        }
        moment.defineLocale("mn", {
            months: "Нэгдүгээр сар_Хоёрдугаар сар_Гуравдугаар сар_Дөрөвдүгээр сар_Тавдугаар сар_Зургадугаар сар_Долдугаар сар_Наймдугаар сар_Есдүгээр сар_Аравдугаар сар_Арван нэгдүгээр сар_Арван хоёрдугаар сар".split("_"),
            monthsShort: "1 сар_2 сар_3 сар_4 сар_5 сар_6 сар_7 сар_8 сар_9 сар_10 сар_11 сар_12 сар".split("_"),
            monthsParseExact: !0,
            weekdays: "Ням_Даваа_Мягмар_Лхагва_Пүрэв_Баасан_Бямба".split("_"),
            weekdaysShort: "Ням_Дав_Мяг_Лха_Пүр_Баа_Бям".split("_"),
            weekdaysMin: "Ня_Да_Мя_Лх_Пү_Ба_Бя".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "YYYY-MM-DD",
                LL: "YYYY оны MMMMын D",
                LLL: "YYYY оны MMMMын D HH:mm",
                LLLL: "dddd, YYYY оны MMMMын D HH:mm"
            },
            meridiemParse: /ҮӨ|ҮХ/i,
            isPM: function(input) {
                return "ҮХ" === input
            },
            meridiem: function(hour, minute, isLower) {
                return hour < 12 ? "ҮӨ" : "ҮХ"
            },
            calendar: {
                sameDay: "[Өнөөдөр] LT",
                nextDay: "[Маргааш] LT",
                nextWeek: "[Ирэх] dddd LT",
                lastDay: "[Өчигдөр] LT",
                lastWeek: "[Өнгөрсөн] dddd LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s дараа",
                past: "%s өмнө",
                s: translate,
                ss: translate,
                m: translate,
                mm: translate,
                h: translate,
                hh: translate,
                d: translate,
                dd: translate,
                M: translate,
                MM: translate,
                y: translate,
                yy: translate
            },
            dayOfMonthOrdinalParse: /\d{1,2} өдөр/,
            ordinal: function(number, period) {
                switch (period) {
                    case "d":
                    case "D":
                    case "DDD":
                        return number + " өдөр";
                    default:
                        return number
                }
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        var symbolMap = {
                1: "१",
                2: "२",
                3: "३",
                4: "४",
                5: "५",
                6: "६",
                7: "७",
                8: "८",
                9: "९",
                0: "०"
            },
            numberMap = {
                "१": "1",
                "२": "2",
                "३": "3",
                "४": "4",
                "५": "5",
                "६": "6",
                "७": "7",
                "८": "8",
                "९": "9",
                "०": "0"
            };

        function relativeTimeMr(number, withoutSuffix, string, isFuture) {
            var output = "";
            if (withoutSuffix) switch (string) {
                case "s":
                    output = "काही सेकंद";
                    break;
                case "ss":
                    output = "%d सेकंद";
                    break;
                case "m":
                    output = "एक मिनिट";
                    break;
                case "mm":
                    output = "%d मिनिटे";
                    break;
                case "h":
                    output = "एक तास";
                    break;
                case "hh":
                    output = "%d तास";
                    break;
                case "d":
                    output = "एक दिवस";
                    break;
                case "dd":
                    output = "%d दिवस";
                    break;
                case "M":
                    output = "एक महिना";
                    break;
                case "MM":
                    output = "%d महिने";
                    break;
                case "y":
                    output = "एक वर्ष";
                    break;
                case "yy":
                    output = "%d वर्षे"
            } else switch (string) {
                case "s":
                    output = "काही सेकंदां";
                    break;
                case "ss":
                    output = "%d सेकंदां";
                    break;
                case "m":
                    output = "एका मिनिटा";
                    break;
                case "mm":
                    output = "%d मिनिटां";
                    break;
                case "h":
                    output = "एका तासा";
                    break;
                case "hh":
                    output = "%d तासां";
                    break;
                case "d":
                    output = "एका दिवसा";
                    break;
                case "dd":
                    output = "%d दिवसां";
                    break;
                case "M":
                    output = "एका महिन्या";
                    break;
                case "MM":
                    output = "%d महिन्यां";
                    break;
                case "y":
                    output = "एका वर्षा";
                    break;
                case "yy":
                    output = "%d वर्षां"
            }
            return output.replace(/%d/i, number)
        }
        moment.defineLocale("mr", {
            months: "जानेवारी_फेब्रुवारी_मार्च_एप्रिल_मे_जून_जुलै_ऑगस्ट_सप्टेंबर_ऑक्टोबर_नोव्हेंबर_डिसेंबर".split("_"),
            monthsShort: "जाने._फेब्रु._मार्च._एप्रि._मे._जून._जुलै._ऑग._सप्टें._ऑक्टो._नोव्हें._डिसें.".split("_"),
            monthsParseExact: !0,
            weekdays: "रविवार_सोमवार_मंगळवार_बुधवार_गुरूवार_शुक्रवार_शनिवार".split("_"),
            weekdaysShort: "रवि_सोम_मंगळ_बुध_गुरू_शुक्र_शनि".split("_"),
            weekdaysMin: "र_सो_मं_बु_गु_शु_श".split("_"),
            longDateFormat: {
                LT: "A h:mm वाजता",
                LTS: "A h:mm:ss वाजता",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY, A h:mm वाजता",
                LLLL: "dddd, D MMMM YYYY, A h:mm वाजता"
            },
            calendar: {
                sameDay: "[आज] LT",
                nextDay: "[उद्या] LT",
                nextWeek: "dddd, LT",
                lastDay: "[काल] LT",
                lastWeek: "[मागील] dddd, LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%sमध्ये",
                past: "%sपूर्वी",
                s: relativeTimeMr,
                ss: relativeTimeMr,
                m: relativeTimeMr,
                mm: relativeTimeMr,
                h: relativeTimeMr,
                hh: relativeTimeMr,
                d: relativeTimeMr,
                dd: relativeTimeMr,
                M: relativeTimeMr,
                MM: relativeTimeMr,
                y: relativeTimeMr,
                yy: relativeTimeMr
            },
            preparse: function(string) {
                return string.replace(/[१२३४५६७८९०]/g, (function(match) {
                    return numberMap[match]
                }))
            },
            postformat: function(string) {
                return string.replace(/\d/g, (function(match) {
                    return symbolMap[match]
                }))
            },
            meridiemParse: /पहाटे|सकाळी|दुपारी|सायंकाळी|रात्री/,
            meridiemHour: function(hour, meridiem) {
                return 12 === hour && (hour = 0), "पहाटे" === meridiem || "सकाळी" === meridiem ? hour : "दुपारी" === meridiem || "सायंकाळी" === meridiem || "रात्री" === meridiem ? hour >= 12 ? hour : hour + 12 : void 0
            },
            meridiem: function(hour, minute, isLower) {
                return hour >= 0 && hour < 6 ? "पहाटे" : hour < 12 ? "सकाळी" : hour < 17 ? "दुपारी" : hour < 20 ? "सायंकाळी" : "रात्री"
            },
            week: {
                dow: 0,
                doy: 6
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("ms", {
            months: "Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember".split("_"),
            monthsShort: "Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis".split("_"),
            weekdays: "Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu".split("_"),
            weekdaysShort: "Ahd_Isn_Sel_Rab_Kha_Jum_Sab".split("_"),
            weekdaysMin: "Ah_Is_Sl_Rb_Km_Jm_Sb".split("_"),
            longDateFormat: {
                LT: "HH.mm",
                LTS: "HH.mm.ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY [pukul] HH.mm",
                LLLL: "dddd, D MMMM YYYY [pukul] HH.mm"
            },
            meridiemParse: /pagi|tengahari|petang|malam/,
            meridiemHour: function(hour, meridiem) {
                return 12 === hour && (hour = 0), "pagi" === meridiem ? hour : "tengahari" === meridiem ? hour >= 11 ? hour : hour + 12 : "petang" === meridiem || "malam" === meridiem ? hour + 12 : void 0
            },
            meridiem: function(hours, minutes, isLower) {
                return hours < 11 ? "pagi" : hours < 15 ? "tengahari" : hours < 19 ? "petang" : "malam"
            },
            calendar: {
                sameDay: "[Hari ini pukul] LT",
                nextDay: "[Esok pukul] LT",
                nextWeek: "dddd [pukul] LT",
                lastDay: "[Kelmarin pukul] LT",
                lastWeek: "dddd [lepas pukul] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "dalam %s",
                past: "%s yang lepas",
                s: "beberapa saat",
                ss: "%d saat",
                m: "seminit",
                mm: "%d minit",
                h: "sejam",
                hh: "%d jam",
                d: "sehari",
                dd: "%d hari",
                M: "sebulan",
                MM: "%d bulan",
                y: "setahun",
                yy: "%d tahun"
            },
            week: {
                dow: 1,
                doy: 7
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("ms-my", {
            months: "Januari_Februari_Mac_April_Mei_Jun_Julai_Ogos_September_Oktober_November_Disember".split("_"),
            monthsShort: "Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ogs_Sep_Okt_Nov_Dis".split("_"),
            weekdays: "Ahad_Isnin_Selasa_Rabu_Khamis_Jumaat_Sabtu".split("_"),
            weekdaysShort: "Ahd_Isn_Sel_Rab_Kha_Jum_Sab".split("_"),
            weekdaysMin: "Ah_Is_Sl_Rb_Km_Jm_Sb".split("_"),
            longDateFormat: {
                LT: "HH.mm",
                LTS: "HH.mm.ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY [pukul] HH.mm",
                LLLL: "dddd, D MMMM YYYY [pukul] HH.mm"
            },
            meridiemParse: /pagi|tengahari|petang|malam/,
            meridiemHour: function(hour, meridiem) {
                return 12 === hour && (hour = 0), "pagi" === meridiem ? hour : "tengahari" === meridiem ? hour >= 11 ? hour : hour + 12 : "petang" === meridiem || "malam" === meridiem ? hour + 12 : void 0
            },
            meridiem: function(hours, minutes, isLower) {
                return hours < 11 ? "pagi" : hours < 15 ? "tengahari" : hours < 19 ? "petang" : "malam"
            },
            calendar: {
                sameDay: "[Hari ini pukul] LT",
                nextDay: "[Esok pukul] LT",
                nextWeek: "dddd [pukul] LT",
                lastDay: "[Kelmarin pukul] LT",
                lastWeek: "dddd [lepas pukul] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "dalam %s",
                past: "%s yang lepas",
                s: "beberapa saat",
                ss: "%d saat",
                m: "seminit",
                mm: "%d minit",
                h: "sejam",
                hh: "%d jam",
                d: "sehari",
                dd: "%d hari",
                M: "sebulan",
                MM: "%d bulan",
                y: "setahun",
                yy: "%d tahun"
            },
            week: {
                dow: 1,
                doy: 7
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("mt", {
            months: "Jannar_Frar_Marzu_April_Mejju_Ġunju_Lulju_Awwissu_Settembru_Ottubru_Novembru_Diċembru".split("_"),
            monthsShort: "Jan_Fra_Mar_Apr_Mej_Ġun_Lul_Aww_Set_Ott_Nov_Diċ".split("_"),
            weekdays: "Il-Ħadd_It-Tnejn_It-Tlieta_L-Erbgħa_Il-Ħamis_Il-Ġimgħa_Is-Sibt".split("_"),
            weekdaysShort: "Ħad_Tne_Tli_Erb_Ħam_Ġim_Sib".split("_"),
            weekdaysMin: "Ħa_Tn_Tl_Er_Ħa_Ġi_Si".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd, D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[Illum fil-]LT",
                nextDay: "[Għada fil-]LT",
                nextWeek: "dddd [fil-]LT",
                lastDay: "[Il-bieraħ fil-]LT",
                lastWeek: "dddd [li għadda] [fil-]LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "f’ %s",
                past: "%s ilu",
                s: "ftit sekondi",
                ss: "%d sekondi",
                m: "minuta",
                mm: "%d minuti",
                h: "siegħa",
                hh: "%d siegħat",
                d: "ġurnata",
                dd: "%d ġranet",
                M: "xahar",
                MM: "%d xhur",
                y: "sena",
                yy: "%d sni"
            },
            dayOfMonthOrdinalParse: /\d{1,2}º/,
            ordinal: "%dº",
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        var symbolMap = {
                1: "၁",
                2: "၂",
                3: "၃",
                4: "၄",
                5: "၅",
                6: "၆",
                7: "၇",
                8: "၈",
                9: "၉",
                0: "၀"
            },
            numberMap = {
                "၁": "1",
                "၂": "2",
                "၃": "3",
                "၄": "4",
                "၅": "5",
                "၆": "6",
                "၇": "7",
                "၈": "8",
                "၉": "9",
                "၀": "0"
            };
        moment.defineLocale("my", {
            months: "ဇန်နဝါရီ_ဖေဖော်ဝါရီ_မတ်_ဧပြီ_မေ_ဇွန်_ဇူလိုင်_သြဂုတ်_စက်တင်ဘာ_အောက်တိုဘာ_နိုဝင်ဘာ_ဒီဇင်ဘာ".split("_"),
            monthsShort: "ဇန်_ဖေ_မတ်_ပြီ_မေ_ဇွန်_လိုင်_သြ_စက်_အောက်_နို_ဒီ".split("_"),
            weekdays: "တနင်္ဂနွေ_တနင်္လာ_အင်္ဂါ_ဗုဒ္ဓဟူး_ကြာသပတေး_သောကြာ_စနေ".split("_"),
            weekdaysShort: "နွေ_လာ_ဂါ_ဟူး_ကြာ_သော_နေ".split("_"),
            weekdaysMin: "နွေ_လာ_ဂါ_ဟူး_ကြာ_သော_နေ".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[ယနေ.] LT [မှာ]",
                nextDay: "[မနက်ဖြန်] LT [မှာ]",
                nextWeek: "dddd LT [မှာ]",
                lastDay: "[မနေ.က] LT [မှာ]",
                lastWeek: "[ပြီးခဲ့သော] dddd LT [မှာ]",
                sameElse: "L"
            },
            relativeTime: {
                future: "လာမည့် %s မှာ",
                past: "လွန်ခဲ့သော %s က",
                s: "စက္ကန်.အနည်းငယ်",
                ss: "%d စက္ကန့်",
                m: "တစ်မိနစ်",
                mm: "%d မိနစ်",
                h: "တစ်နာရီ",
                hh: "%d နာရီ",
                d: "တစ်ရက်",
                dd: "%d ရက်",
                M: "တစ်လ",
                MM: "%d လ",
                y: "တစ်နှစ်",
                yy: "%d နှစ်"
            },
            preparse: function(string) {
                return string.replace(/[၁၂၃၄၅၆၇၈၉၀]/g, (function(match) {
                    return numberMap[match]
                }))
            },
            postformat: function(string) {
                return string.replace(/\d/g, (function(match) {
                    return symbolMap[match]
                }))
            },
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("nb", {
            months: "januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember".split("_"),
            monthsShort: "jan._feb._mars_apr._mai_juni_juli_aug._sep._okt._nov._des.".split("_"),
            monthsParseExact: !0,
            weekdays: "søndag_mandag_tirsdag_onsdag_torsdag_fredag_lørdag".split("_"),
            weekdaysShort: "sø._ma._ti._on._to._fr._lø.".split("_"),
            weekdaysMin: "sø_ma_ti_on_to_fr_lø".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D. MMMM YYYY",
                LLL: "D. MMMM YYYY [kl.] HH:mm",
                LLLL: "dddd D. MMMM YYYY [kl.] HH:mm"
            },
            calendar: {
                sameDay: "[i dag kl.] LT",
                nextDay: "[i morgen kl.] LT",
                nextWeek: "dddd [kl.] LT",
                lastDay: "[i går kl.] LT",
                lastWeek: "[forrige] dddd [kl.] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "om %s",
                past: "%s siden",
                s: "noen sekunder",
                ss: "%d sekunder",
                m: "ett minutt",
                mm: "%d minutter",
                h: "en time",
                hh: "%d timer",
                d: "en dag",
                dd: "%d dager",
                w: "en uke",
                ww: "%d uker",
                M: "en måned",
                MM: "%d måneder",
                y: "ett år",
                yy: "%d år"
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        var symbolMap = {
                1: "१",
                2: "२",
                3: "३",
                4: "४",
                5: "५",
                6: "६",
                7: "७",
                8: "८",
                9: "९",
                0: "०"
            },
            numberMap = {
                "१": "1",
                "२": "2",
                "३": "3",
                "४": "4",
                "५": "5",
                "६": "6",
                "७": "7",
                "८": "8",
                "९": "9",
                "०": "0"
            };
        moment.defineLocale("ne", {
            months: "जनवरी_फेब्रुवरी_मार्च_अप्रिल_मई_जुन_जुलाई_अगष्ट_सेप्टेम्बर_अक्टोबर_नोभेम्बर_डिसेम्बर".split("_"),
            monthsShort: "जन._फेब्रु._मार्च_अप्रि._मई_जुन_जुलाई._अग._सेप्ट._अक्टो._नोभे._डिसे.".split("_"),
            monthsParseExact: !0,
            weekdays: "आइतबार_सोमबार_मङ्गलबार_बुधबार_बिहिबार_शुक्रबार_शनिबार".split("_"),
            weekdaysShort: "आइत._सोम._मङ्गल._बुध._बिहि._शुक्र._शनि.".split("_"),
            weekdaysMin: "आ._सो._मं._बु._बि._शु._श.".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "Aको h:mm बजे",
                LTS: "Aको h:mm:ss बजे",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY, Aको h:mm बजे",
                LLLL: "dddd, D MMMM YYYY, Aको h:mm बजे"
            },
            preparse: function(string) {
                return string.replace(/[१२३४५६७८९०]/g, (function(match) {
                    return numberMap[match]
                }))
            },
            postformat: function(string) {
                return string.replace(/\d/g, (function(match) {
                    return symbolMap[match]
                }))
            },
            meridiemParse: /राति|बिहान|दिउँसो|साँझ/,
            meridiemHour: function(hour, meridiem) {
                return 12 === hour && (hour = 0), "राति" === meridiem ? hour < 4 ? hour : hour + 12 : "बिहान" === meridiem ? hour : "दिउँसो" === meridiem ? hour >= 10 ? hour : hour + 12 : "साँझ" === meridiem ? hour + 12 : void 0
            },
            meridiem: function(hour, minute, isLower) {
                return hour < 3 ? "राति" : hour < 12 ? "बिहान" : hour < 16 ? "दिउँसो" : hour < 20 ? "साँझ" : "राति"
            },
            calendar: {
                sameDay: "[आज] LT",
                nextDay: "[भोलि] LT",
                nextWeek: "[आउँदो] dddd[,] LT",
                lastDay: "[हिजो] LT",
                lastWeek: "[गएको] dddd[,] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%sमा",
                past: "%s अगाडि",
                s: "केही क्षण",
                ss: "%d सेकेण्ड",
                m: "एक मिनेट",
                mm: "%d मिनेट",
                h: "एक घण्टा",
                hh: "%d घण्टा",
                d: "एक दिन",
                dd: "%d दिन",
                M: "एक महिना",
                MM: "%d महिना",
                y: "एक बर्ष",
                yy: "%d बर्ष"
            },
            week: {
                dow: 0,
                doy: 6
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        var monthsShortWithDots = "jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.".split("_"),
            monthsShortWithoutDots = "jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec".split("_"),
            monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i],
            monthsRegex = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;
        moment.defineLocale("nl", {
            months: "januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december".split("_"),
            monthsShort: function(m, format) {
                return m ? /-MMM-/.test(format) ? monthsShortWithoutDots[m.month()] : monthsShortWithDots[m.month()] : monthsShortWithDots
            },
            monthsRegex: monthsRegex,
            monthsShortRegex: monthsRegex,
            monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,
            monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,
            monthsParse: monthsParse,
            longMonthsParse: monthsParse,
            shortMonthsParse: monthsParse,
            weekdays: "zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag".split("_"),
            weekdaysShort: "zo._ma._di._wo._do._vr._za.".split("_"),
            weekdaysMin: "zo_ma_di_wo_do_vr_za".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD-MM-YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[vandaag om] LT",
                nextDay: "[morgen om] LT",
                nextWeek: "dddd [om] LT",
                lastDay: "[gisteren om] LT",
                lastWeek: "[afgelopen] dddd [om] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "over %s",
                past: "%s geleden",
                s: "een paar seconden",
                ss: "%d seconden",
                m: "één minuut",
                mm: "%d minuten",
                h: "één uur",
                hh: "%d uur",
                d: "één dag",
                dd: "%d dagen",
                w: "één week",
                ww: "%d weken",
                M: "één maand",
                MM: "%d maanden",
                y: "één jaar",
                yy: "%d jaar"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
            ordinal: function(number) {
                return number + (1 === number || 8 === number || number >= 20 ? "ste" : "de")
            },
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        var monthsShortWithDots = "jan._feb._mrt._apr._mei_jun._jul._aug._sep._okt._nov._dec.".split("_"),
            monthsShortWithoutDots = "jan_feb_mrt_apr_mei_jun_jul_aug_sep_okt_nov_dec".split("_"),
            monthsParse = [/^jan/i, /^feb/i, /^maart|mrt.?$/i, /^apr/i, /^mei$/i, /^jun[i.]?$/i, /^jul[i.]?$/i, /^aug/i, /^sep/i, /^okt/i, /^nov/i, /^dec/i],
            monthsRegex = /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december|jan\.?|feb\.?|mrt\.?|apr\.?|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i;
        moment.defineLocale("nl-be", {
            months: "januari_februari_maart_april_mei_juni_juli_augustus_september_oktober_november_december".split("_"),
            monthsShort: function(m, format) {
                return m ? /-MMM-/.test(format) ? monthsShortWithoutDots[m.month()] : monthsShortWithDots[m.month()] : monthsShortWithDots
            },
            monthsRegex: monthsRegex,
            monthsShortRegex: monthsRegex,
            monthsStrictRegex: /^(januari|februari|maart|april|mei|ju[nl]i|augustus|september|oktober|november|december)/i,
            monthsShortStrictRegex: /^(jan\.?|feb\.?|mrt\.?|apr\.?|mei|ju[nl]\.?|aug\.?|sep\.?|okt\.?|nov\.?|dec\.?)/i,
            monthsParse: monthsParse,
            longMonthsParse: monthsParse,
            shortMonthsParse: monthsParse,
            weekdays: "zondag_maandag_dinsdag_woensdag_donderdag_vrijdag_zaterdag".split("_"),
            weekdaysShort: "zo._ma._di._wo._do._vr._za.".split("_"),
            weekdaysMin: "zo_ma_di_wo_do_vr_za".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[vandaag om] LT",
                nextDay: "[morgen om] LT",
                nextWeek: "dddd [om] LT",
                lastDay: "[gisteren om] LT",
                lastWeek: "[afgelopen] dddd [om] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "over %s",
                past: "%s geleden",
                s: "een paar seconden",
                ss: "%d seconden",
                m: "één minuut",
                mm: "%d minuten",
                h: "één uur",
                hh: "%d uur",
                d: "één dag",
                dd: "%d dagen",
                M: "één maand",
                MM: "%d maanden",
                y: "één jaar",
                yy: "%d jaar"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(ste|de)/,
            ordinal: function(number) {
                return number + (1 === number || 8 === number || number >= 20 ? "ste" : "de")
            },
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("nn", {
            months: "januar_februar_mars_april_mai_juni_juli_august_september_oktober_november_desember".split("_"),
            monthsShort: "jan._feb._mars_apr._mai_juni_juli_aug._sep._okt._nov._des.".split("_"),
            monthsParseExact: !0,
            weekdays: "sundag_måndag_tysdag_onsdag_torsdag_fredag_laurdag".split("_"),
            weekdaysShort: "su._må._ty._on._to._fr._lau.".split("_"),
            weekdaysMin: "su_må_ty_on_to_fr_la".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D. MMMM YYYY",
                LLL: "D. MMMM YYYY [kl.] H:mm",
                LLLL: "dddd D. MMMM YYYY [kl.] HH:mm"
            },
            calendar: {
                sameDay: "[I dag klokka] LT",
                nextDay: "[I morgon klokka] LT",
                nextWeek: "dddd [klokka] LT",
                lastDay: "[I går klokka] LT",
                lastWeek: "[Føregåande] dddd [klokka] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "om %s",
                past: "%s sidan",
                s: "nokre sekund",
                ss: "%d sekund",
                m: "eit minutt",
                mm: "%d minutt",
                h: "ein time",
                hh: "%d timar",
                d: "ein dag",
                dd: "%d dagar",
                w: "ei veke",
                ww: "%d veker",
                M: "ein månad",
                MM: "%d månader",
                y: "eit år",
                yy: "%d år"
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("oc-lnc", {
            months: {
                standalone: "genièr_febrièr_març_abril_mai_junh_julhet_agost_setembre_octòbre_novembre_decembre".split("_"),
                format: "de genièr_de febrièr_de març_d'abril_de mai_de junh_de julhet_d'agost_de setembre_d'octòbre_de novembre_de decembre".split("_"),
                isFormat: /D[oD]?(\s)+MMMM/
            },
            monthsShort: "gen._febr._març_abr._mai_junh_julh._ago._set._oct._nov._dec.".split("_"),
            monthsParseExact: !0,
            weekdays: "dimenge_diluns_dimars_dimècres_dijòus_divendres_dissabte".split("_"),
            weekdaysShort: "dg._dl._dm._dc._dj._dv._ds.".split("_"),
            weekdaysMin: "dg_dl_dm_dc_dj_dv_ds".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "H:mm",
                LTS: "H:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM [de] YYYY",
                ll: "D MMM YYYY",
                LLL: "D MMMM [de] YYYY [a] H:mm",
                lll: "D MMM YYYY, H:mm",
                LLLL: "dddd D MMMM [de] YYYY [a] H:mm",
                llll: "ddd D MMM YYYY, H:mm"
            },
            calendar: {
                sameDay: "[uèi a] LT",
                nextDay: "[deman a] LT",
                nextWeek: "dddd [a] LT",
                lastDay: "[ièr a] LT",
                lastWeek: "dddd [passat a] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "d'aquí %s",
                past: "fa %s",
                s: "unas segondas",
                ss: "%d segondas",
                m: "una minuta",
                mm: "%d minutas",
                h: "una ora",
                hh: "%d oras",
                d: "un jorn",
                dd: "%d jorns",
                M: "un mes",
                MM: "%d meses",
                y: "un an",
                yy: "%d ans"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(r|n|t|è|a)/,
            ordinal: function(number, period) {
                var output = 1 === number ? "r" : 2 === number ? "n" : 3 === number ? "r" : 4 === number ? "t" : "è";
                return "w" !== period && "W" !== period || (output = "a"), number + output
            },
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        var symbolMap = {
                1: "੧",
                2: "੨",
                3: "੩",
                4: "੪",
                5: "੫",
                6: "੬",
                7: "੭",
                8: "੮",
                9: "੯",
                0: "੦"
            },
            numberMap = {
                "੧": "1",
                "੨": "2",
                "੩": "3",
                "੪": "4",
                "੫": "5",
                "੬": "6",
                "੭": "7",
                "੮": "8",
                "੯": "9",
                "੦": "0"
            };
        moment.defineLocale("pa-in", {
            months: "ਜਨਵਰੀ_ਫ਼ਰਵਰੀ_ਮਾਰਚ_ਅਪ੍ਰੈਲ_ਮਈ_ਜੂਨ_ਜੁਲਾਈ_ਅਗਸਤ_ਸਤੰਬਰ_ਅਕਤੂਬਰ_ਨਵੰਬਰ_ਦਸੰਬਰ".split("_"),
            monthsShort: "ਜਨਵਰੀ_ਫ਼ਰਵਰੀ_ਮਾਰਚ_ਅਪ੍ਰੈਲ_ਮਈ_ਜੂਨ_ਜੁਲਾਈ_ਅਗਸਤ_ਸਤੰਬਰ_ਅਕਤੂਬਰ_ਨਵੰਬਰ_ਦਸੰਬਰ".split("_"),
            weekdays: "ਐਤਵਾਰ_ਸੋਮਵਾਰ_ਮੰਗਲਵਾਰ_ਬੁਧਵਾਰ_ਵੀਰਵਾਰ_ਸ਼ੁੱਕਰਵਾਰ_ਸ਼ਨੀਚਰਵਾਰ".split("_"),
            weekdaysShort: "ਐਤ_ਸੋਮ_ਮੰਗਲ_ਬੁਧ_ਵੀਰ_ਸ਼ੁਕਰ_ਸ਼ਨੀ".split("_"),
            weekdaysMin: "ਐਤ_ਸੋਮ_ਮੰਗਲ_ਬੁਧ_ਵੀਰ_ਸ਼ੁਕਰ_ਸ਼ਨੀ".split("_"),
            longDateFormat: {
                LT: "A h:mm ਵਜੇ",
                LTS: "A h:mm:ss ਵਜੇ",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY, A h:mm ਵਜੇ",
                LLLL: "dddd, D MMMM YYYY, A h:mm ਵਜੇ"
            },
            calendar: {
                sameDay: "[ਅਜ] LT",
                nextDay: "[ਕਲ] LT",
                nextWeek: "[ਅਗਲਾ] dddd, LT",
                lastDay: "[ਕਲ] LT",
                lastWeek: "[ਪਿਛਲੇ] dddd, LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s ਵਿੱਚ",
                past: "%s ਪਿਛਲੇ",
                s: "ਕੁਝ ਸਕਿੰਟ",
                ss: "%d ਸਕਿੰਟ",
                m: "ਇਕ ਮਿੰਟ",
                mm: "%d ਮਿੰਟ",
                h: "ਇੱਕ ਘੰਟਾ",
                hh: "%d ਘੰਟੇ",
                d: "ਇੱਕ ਦਿਨ",
                dd: "%d ਦਿਨ",
                M: "ਇੱਕ ਮਹੀਨਾ",
                MM: "%d ਮਹੀਨੇ",
                y: "ਇੱਕ ਸਾਲ",
                yy: "%d ਸਾਲ"
            },
            preparse: function(string) {
                return string.replace(/[੧੨੩੪੫੬੭੮੯੦]/g, (function(match) {
                    return numberMap[match]
                }))
            },
            postformat: function(string) {
                return string.replace(/\d/g, (function(match) {
                    return symbolMap[match]
                }))
            },
            meridiemParse: /ਰਾਤ|ਸਵੇਰ|ਦੁਪਹਿਰ|ਸ਼ਾਮ/,
            meridiemHour: function(hour, meridiem) {
                return 12 === hour && (hour = 0), "ਰਾਤ" === meridiem ? hour < 4 ? hour : hour + 12 : "ਸਵੇਰ" === meridiem ? hour : "ਦੁਪਹਿਰ" === meridiem ? hour >= 10 ? hour : hour + 12 : "ਸ਼ਾਮ" === meridiem ? hour + 12 : void 0
            },
            meridiem: function(hour, minute, isLower) {
                return hour < 4 ? "ਰਾਤ" : hour < 10 ? "ਸਵੇਰ" : hour < 17 ? "ਦੁਪਹਿਰ" : hour < 20 ? "ਸ਼ਾਮ" : "ਰਾਤ"
            },
            week: {
                dow: 0,
                doy: 6
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        var monthsNominative = "styczeń_luty_marzec_kwiecień_maj_czerwiec_lipiec_sierpień_wrzesień_październik_listopad_grudzień".split("_"),
            monthsSubjective = "stycznia_lutego_marca_kwietnia_maja_czerwca_lipca_sierpnia_września_października_listopada_grudnia".split("_"),
            monthsParse = [/^sty/i, /^lut/i, /^mar/i, /^kwi/i, /^maj/i, /^cze/i, /^lip/i, /^sie/i, /^wrz/i, /^paź/i, /^lis/i, /^gru/i];

        function plural(n) {
            return n % 10 < 5 && n % 10 > 1 && ~~(n / 10) % 10 != 1
        }

        function translate(number, withoutSuffix, key) {
            var result = number + " ";
            switch (key) {
                case "ss":
                    return result + (plural(number) ? "sekundy" : "sekund");
                case "m":
                    return withoutSuffix ? "minuta" : "minutę";
                case "mm":
                    return result + (plural(number) ? "minuty" : "minut");
                case "h":
                    return withoutSuffix ? "godzina" : "godzinę";
                case "hh":
                    return result + (plural(number) ? "godziny" : "godzin");
                case "ww":
                    return result + (plural(number) ? "tygodnie" : "tygodni");
                case "MM":
                    return result + (plural(number) ? "miesiące" : "miesięcy");
                case "yy":
                    return result + (plural(number) ? "lata" : "lat")
            }
        }
        moment.defineLocale("pl", {
            months: function(momentToFormat, format) {
                return momentToFormat ? /D MMMM/.test(format) ? monthsSubjective[momentToFormat.month()] : monthsNominative[momentToFormat.month()] : monthsNominative
            },
            monthsShort: "sty_lut_mar_kwi_maj_cze_lip_sie_wrz_paź_lis_gru".split("_"),
            monthsParse: monthsParse,
            longMonthsParse: monthsParse,
            shortMonthsParse: monthsParse,
            weekdays: "niedziela_poniedziałek_wtorek_środa_czwartek_piątek_sobota".split("_"),
            weekdaysShort: "ndz_pon_wt_śr_czw_pt_sob".split("_"),
            weekdaysMin: "Nd_Pn_Wt_Śr_Cz_Pt_So".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd, D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[Dziś o] LT",
                nextDay: "[Jutro o] LT",
                nextWeek: function() {
                    switch (this.day()) {
                        case 0:
                            return "[W niedzielę o] LT";
                        case 2:
                            return "[We wtorek o] LT";
                        case 3:
                            return "[W środę o] LT";
                        case 6:
                            return "[W sobotę o] LT";
                        default:
                            return "[W] dddd [o] LT"
                    }
                },
                lastDay: "[Wczoraj o] LT",
                lastWeek: function() {
                    switch (this.day()) {
                        case 0:
                            return "[W zeszłą niedzielę o] LT";
                        case 3:
                            return "[W zeszłą środę o] LT";
                        case 6:
                            return "[W zeszłą sobotę o] LT";
                        default:
                            return "[W zeszły] dddd [o] LT"
                    }
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "za %s",
                past: "%s temu",
                s: "kilka sekund",
                ss: translate,
                m: translate,
                mm: translate,
                h: translate,
                hh: translate,
                d: "1 dzień",
                dd: "%d dni",
                w: "tydzień",
                ww: translate,
                M: "miesiąc",
                MM: translate,
                y: "rok",
                yy: translate
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("pt", {
            months: "janeiro_fevereiro_março_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro".split("_"),
            monthsShort: "jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez".split("_"),
            weekdays: "Domingo_Segunda-feira_Terça-feira_Quarta-feira_Quinta-feira_Sexta-feira_Sábado".split("_"),
            weekdaysShort: "Dom_Seg_Ter_Qua_Qui_Sex_Sáb".split("_"),
            weekdaysMin: "Do_2ª_3ª_4ª_5ª_6ª_Sá".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D [de] MMMM [de] YYYY",
                LLL: "D [de] MMMM [de] YYYY HH:mm",
                LLLL: "dddd, D [de] MMMM [de] YYYY HH:mm"
            },
            calendar: {
                sameDay: "[Hoje às] LT",
                nextDay: "[Amanhã às] LT",
                nextWeek: "dddd [às] LT",
                lastDay: "[Ontem às] LT",
                lastWeek: function() {
                    return 0 === this.day() || 6 === this.day() ? "[Último] dddd [às] LT" : "[Última] dddd [às] LT"
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "em %s",
                past: "há %s",
                s: "segundos",
                ss: "%d segundos",
                m: "um minuto",
                mm: "%d minutos",
                h: "uma hora",
                hh: "%d horas",
                d: "um dia",
                dd: "%d dias",
                w: "uma semana",
                ww: "%d semanas",
                M: "um mês",
                MM: "%d meses",
                y: "um ano",
                yy: "%d anos"
            },
            dayOfMonthOrdinalParse: /\d{1,2}º/,
            ordinal: "%dº",
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("pt-br", {
            months: "janeiro_fevereiro_março_abril_maio_junho_julho_agosto_setembro_outubro_novembro_dezembro".split("_"),
            monthsShort: "jan_fev_mar_abr_mai_jun_jul_ago_set_out_nov_dez".split("_"),
            weekdays: "domingo_segunda-feira_terça-feira_quarta-feira_quinta-feira_sexta-feira_sábado".split("_"),
            weekdaysShort: "dom_seg_ter_qua_qui_sex_sáb".split("_"),
            weekdaysMin: "do_2ª_3ª_4ª_5ª_6ª_sá".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D [de] MMMM [de] YYYY",
                LLL: "D [de] MMMM [de] YYYY [às] HH:mm",
                LLLL: "dddd, D [de] MMMM [de] YYYY [às] HH:mm"
            },
            calendar: {
                sameDay: "[Hoje às] LT",
                nextDay: "[Amanhã às] LT",
                nextWeek: "dddd [às] LT",
                lastDay: "[Ontem às] LT",
                lastWeek: function() {
                    return 0 === this.day() || 6 === this.day() ? "[Último] dddd [às] LT" : "[Última] dddd [às] LT"
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "em %s",
                past: "há %s",
                s: "poucos segundos",
                ss: "%d segundos",
                m: "um minuto",
                mm: "%d minutos",
                h: "uma hora",
                hh: "%d horas",
                d: "um dia",
                dd: "%d dias",
                M: "um mês",
                MM: "%d meses",
                y: "um ano",
                yy: "%d anos"
            },
            dayOfMonthOrdinalParse: /\d{1,2}º/,
            ordinal: "%dº",
            invalidDate: "Data inválida"
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";

        function relativeTimeWithPlural(number, withoutSuffix, key) {
            var separator = " ";
            return (number % 100 >= 20 || number >= 100 && number % 100 == 0) && (separator = " de "), number + separator + {
                ss: "secunde",
                mm: "minute",
                hh: "ore",
                dd: "zile",
                ww: "săptămâni",
                MM: "luni",
                yy: "ani"
            }[key]
        }
        moment.defineLocale("ro", {
            months: "ianuarie_februarie_martie_aprilie_mai_iunie_iulie_august_septembrie_octombrie_noiembrie_decembrie".split("_"),
            monthsShort: "ian._feb._mart._apr._mai_iun._iul._aug._sept._oct._nov._dec.".split("_"),
            monthsParseExact: !0,
            weekdays: "duminică_luni_marți_miercuri_joi_vineri_sâmbătă".split("_"),
            weekdaysShort: "Dum_Lun_Mar_Mie_Joi_Vin_Sâm".split("_"),
            weekdaysMin: "Du_Lu_Ma_Mi_Jo_Vi_Sâ".split("_"),
            longDateFormat: {
                LT: "H:mm",
                LTS: "H:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY H:mm",
                LLLL: "dddd, D MMMM YYYY H:mm"
            },
            calendar: {
                sameDay: "[azi la] LT",
                nextDay: "[mâine la] LT",
                nextWeek: "dddd [la] LT",
                lastDay: "[ieri la] LT",
                lastWeek: "[fosta] dddd [la] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "peste %s",
                past: "%s în urmă",
                s: "câteva secunde",
                ss: relativeTimeWithPlural,
                m: "un minut",
                mm: relativeTimeWithPlural,
                h: "o oră",
                hh: relativeTimeWithPlural,
                d: "o zi",
                dd: relativeTimeWithPlural,
                w: "o săptămână",
                ww: relativeTimeWithPlural,
                M: "o lună",
                MM: relativeTimeWithPlural,
                y: "un an",
                yy: relativeTimeWithPlural
            },
            week: {
                dow: 1,
                doy: 7
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";

        function plural(word, num) {
            var forms = word.split("_");
            return num % 10 == 1 && num % 100 != 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]
        }

        function relativeTimeWithPlural(number, withoutSuffix, key) {
            return "m" === key ? withoutSuffix ? "минута" : "минуту" : number + " " + plural({
                ss: withoutSuffix ? "секунда_секунды_секунд" : "секунду_секунды_секунд",
                mm: withoutSuffix ? "минута_минуты_минут" : "минуту_минуты_минут",
                hh: "час_часа_часов",
                dd: "день_дня_дней",
                ww: "неделя_недели_недель",
                MM: "месяц_месяца_месяцев",
                yy: "год_года_лет"
            }[key], +number)
        }
        var monthsParse = [/^янв/i, /^фев/i, /^мар/i, /^апр/i, /^ма[йя]/i, /^июн/i, /^июл/i, /^авг/i, /^сен/i, /^окт/i, /^ноя/i, /^дек/i];
        moment.defineLocale("ru", {
            months: {
                format: "января_февраля_марта_апреля_мая_июня_июля_августа_сентября_октября_ноября_декабря".split("_"),
                standalone: "январь_февраль_март_апрель_май_июнь_июль_август_сентябрь_октябрь_ноябрь_декабрь".split("_")
            },
            monthsShort: {
                format: "янв._февр._мар._апр._мая_июня_июля_авг._сент._окт._нояб._дек.".split("_"),
                standalone: "янв._февр._март_апр._май_июнь_июль_авг._сент._окт._нояб._дек.".split("_")
            },
            weekdays: {
                standalone: "воскресенье_понедельник_вторник_среда_четверг_пятница_суббота".split("_"),
                format: "воскресенье_понедельник_вторник_среду_четверг_пятницу_субботу".split("_"),
                isFormat: /\[ ?[Вв] ?(?:прошлую|следующую|эту)? ?] ?dddd/
            },
            weekdaysShort: "вс_пн_вт_ср_чт_пт_сб".split("_"),
            weekdaysMin: "вс_пн_вт_ср_чт_пт_сб".split("_"),
            monthsParse: monthsParse,
            longMonthsParse: monthsParse,
            shortMonthsParse: monthsParse,
            monthsRegex: /^(январ[ья]|янв\.?|феврал[ья]|февр?\.?|марта?|мар\.?|апрел[ья]|апр\.?|ма[йя]|июн[ья]|июн\.?|июл[ья]|июл\.?|августа?|авг\.?|сентябр[ья]|сент?\.?|октябр[ья]|окт\.?|ноябр[ья]|нояб?\.?|декабр[ья]|дек\.?)/i,
            monthsShortRegex: /^(январ[ья]|янв\.?|феврал[ья]|февр?\.?|марта?|мар\.?|апрел[ья]|апр\.?|ма[йя]|июн[ья]|июн\.?|июл[ья]|июл\.?|августа?|авг\.?|сентябр[ья]|сент?\.?|октябр[ья]|окт\.?|ноябр[ья]|нояб?\.?|декабр[ья]|дек\.?)/i,
            monthsStrictRegex: /^(январ[яь]|феврал[яь]|марта?|апрел[яь]|ма[яй]|июн[яь]|июл[яь]|августа?|сентябр[яь]|октябр[яь]|ноябр[яь]|декабр[яь])/i,
            monthsShortStrictRegex: /^(янв\.|февр?\.|мар[т.]|апр\.|ма[яй]|июн[ья.]|июл[ья.]|авг\.|сент?\.|окт\.|нояб?\.|дек\.)/i,
            longDateFormat: {
                LT: "H:mm",
                LTS: "H:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D MMMM YYYY г.",
                LLL: "D MMMM YYYY г., H:mm",
                LLLL: "dddd, D MMMM YYYY г., H:mm"
            },
            calendar: {
                sameDay: "[Сегодня, в] LT",
                nextDay: "[Завтра, в] LT",
                lastDay: "[Вчера, в] LT",
                nextWeek: function(now) {
                    if (now.week() === this.week()) return 2 === this.day() ? "[Во] dddd, [в] LT" : "[В] dddd, [в] LT";
                    switch (this.day()) {
                        case 0:
                            return "[В следующее] dddd, [в] LT";
                        case 1:
                        case 2:
                        case 4:
                            return "[В следующий] dddd, [в] LT";
                        case 3:
                        case 5:
                        case 6:
                            return "[В следующую] dddd, [в] LT"
                    }
                },
                lastWeek: function(now) {
                    if (now.week() === this.week()) return 2 === this.day() ? "[Во] dddd, [в] LT" : "[В] dddd, [в] LT";
                    switch (this.day()) {
                        case 0:
                            return "[В прошлое] dddd, [в] LT";
                        case 1:
                        case 2:
                        case 4:
                            return "[В прошлый] dddd, [в] LT";
                        case 3:
                        case 5:
                        case 6:
                            return "[В прошлую] dddd, [в] LT"
                    }
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "через %s",
                past: "%s назад",
                s: "несколько секунд",
                ss: relativeTimeWithPlural,
                m: relativeTimeWithPlural,
                mm: relativeTimeWithPlural,
                h: "час",
                hh: relativeTimeWithPlural,
                d: "день",
                dd: relativeTimeWithPlural,
                w: "неделя",
                ww: relativeTimeWithPlural,
                M: "месяц",
                MM: relativeTimeWithPlural,
                y: "год",
                yy: relativeTimeWithPlural
            },
            meridiemParse: /ночи|утра|дня|вечера/i,
            isPM: function(input) {
                return /^(дня|вечера)$/.test(input)
            },
            meridiem: function(hour, minute, isLower) {
                return hour < 4 ? "ночи" : hour < 12 ? "утра" : hour < 17 ? "дня" : "вечера"
            },
            dayOfMonthOrdinalParse: /\d{1,2}-(й|го|я)/,
            ordinal: function(number, period) {
                switch (period) {
                    case "M":
                    case "d":
                    case "DDD":
                        return number + "-й";
                    case "D":
                        return number + "-го";
                    case "w":
                    case "W":
                        return number + "-я";
                    default:
                        return number
                }
            },
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        var months = ["جنوري", "فيبروري", "مارچ", "اپريل", "مئي", "جون", "جولاءِ", "آگسٽ", "سيپٽمبر", "آڪٽوبر", "نومبر", "ڊسمبر"],
            days = ["آچر", "سومر", "اڱارو", "اربع", "خميس", "جمع", "ڇنڇر"];
        moment.defineLocale("sd", {
            months: months,
            monthsShort: months,
            weekdays: days,
            weekdaysShort: days,
            weekdaysMin: days,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd، D MMMM YYYY HH:mm"
            },
            meridiemParse: /صبح|شام/,
            isPM: function(input) {
                return "شام" === input
            },
            meridiem: function(hour, minute, isLower) {
                return hour < 12 ? "صبح" : "شام"
            },
            calendar: {
                sameDay: "[اڄ] LT",
                nextDay: "[سڀاڻي] LT",
                nextWeek: "dddd [اڳين هفتي تي] LT",
                lastDay: "[ڪالهه] LT",
                lastWeek: "[گزريل هفتي] dddd [تي] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s پوء",
                past: "%s اڳ",
                s: "چند سيڪنڊ",
                ss: "%d سيڪنڊ",
                m: "هڪ منٽ",
                mm: "%d منٽ",
                h: "هڪ ڪلاڪ",
                hh: "%d ڪلاڪ",
                d: "هڪ ڏينهن",
                dd: "%d ڏينهن",
                M: "هڪ مهينو",
                MM: "%d مهينا",
                y: "هڪ سال",
                yy: "%d سال"
            },
            preparse: function(string) {
                return string.replace(/،/g, ",")
            },
            postformat: function(string) {
                return string.replace(/,/g, "،")
            },
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("se", {
            months: "ođđajagemánnu_guovvamánnu_njukčamánnu_cuoŋománnu_miessemánnu_geassemánnu_suoidnemánnu_borgemánnu_čakčamánnu_golggotmánnu_skábmamánnu_juovlamánnu".split("_"),
            monthsShort: "ođđj_guov_njuk_cuo_mies_geas_suoi_borg_čakč_golg_skáb_juov".split("_"),
            weekdays: "sotnabeaivi_vuossárga_maŋŋebárga_gaskavahkku_duorastat_bearjadat_lávvardat".split("_"),
            weekdaysShort: "sotn_vuos_maŋ_gask_duor_bear_láv".split("_"),
            weekdaysMin: "s_v_m_g_d_b_L".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD.MM.YYYY",
                LL: "MMMM D. [b.] YYYY",
                LLL: "MMMM D. [b.] YYYY [ti.] HH:mm",
                LLLL: "dddd, MMMM D. [b.] YYYY [ti.] HH:mm"
            },
            calendar: {
                sameDay: "[otne ti] LT",
                nextDay: "[ihttin ti] LT",
                nextWeek: "dddd [ti] LT",
                lastDay: "[ikte ti] LT",
                lastWeek: "[ovddit] dddd [ti] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s geažes",
                past: "maŋit %s",
                s: "moadde sekunddat",
                ss: "%d sekunddat",
                m: "okta minuhta",
                mm: "%d minuhtat",
                h: "okta diimmu",
                hh: "%d diimmut",
                d: "okta beaivi",
                dd: "%d beaivvit",
                M: "okta mánnu",
                MM: "%d mánut",
                y: "okta jahki",
                yy: "%d jagit"
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("si", {
            months: "ජනවාරි_පෙබරවාරි_මාර්තු_අප්‍රේල්_මැයි_ජූනි_ජූලි_අගෝස්තු_සැප්තැම්බර්_ඔක්තෝබර්_නොවැම්බර්_දෙසැම්බර්".split("_"),
            monthsShort: "ජන_පෙබ_මාර්_අප්_මැයි_ජූනි_ජූලි_අගෝ_සැප්_ඔක්_නොවැ_දෙසැ".split("_"),
            weekdays: "ඉරිදා_සඳුදා_අඟහරුවාදා_බදාදා_බ්‍රහස්පතින්දා_සිකුරාදා_සෙනසුරාදා".split("_"),
            weekdaysShort: "ඉරි_සඳු_අඟ_බදා_බ්‍රහ_සිකු_සෙන".split("_"),
            weekdaysMin: "ඉ_ස_අ_බ_බ්‍ර_සි_සෙ".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "a h:mm",
                LTS: "a h:mm:ss",
                L: "YYYY/MM/DD",
                LL: "YYYY MMMM D",
                LLL: "YYYY MMMM D, a h:mm",
                LLLL: "YYYY MMMM D [වැනි] dddd, a h:mm:ss"
            },
            calendar: {
                sameDay: "[අද] LT[ට]",
                nextDay: "[හෙට] LT[ට]",
                nextWeek: "dddd LT[ට]",
                lastDay: "[ඊයේ] LT[ට]",
                lastWeek: "[පසුගිය] dddd LT[ට]",
                sameElse: "L"
            },
            relativeTime: {
                future: "%sකින්",
                past: "%sකට පෙර",
                s: "තත්පර කිහිපය",
                ss: "තත්පර %d",
                m: "මිනිත්තුව",
                mm: "මිනිත්තු %d",
                h: "පැය",
                hh: "පැය %d",
                d: "දිනය",
                dd: "දින %d",
                M: "මාසය",
                MM: "මාස %d",
                y: "වසර",
                yy: "වසර %d"
            },
            dayOfMonthOrdinalParse: /\d{1,2} වැනි/,
            ordinal: function(number) {
                return number + " වැනි"
            },
            meridiemParse: /පෙර වරු|පස් වරු|පෙ.ව|ප.ව./,
            isPM: function(input) {
                return "ප.ව." === input || "පස් වරු" === input
            },
            meridiem: function(hours, minutes, isLower) {
                return hours > 11 ? isLower ? "ප.ව." : "පස් වරු" : isLower ? "පෙ.ව." : "පෙර වරු"
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        var months = "január_február_marec_apríl_máj_jún_júl_august_september_október_november_december".split("_"),
            monthsShort = "jan_feb_mar_apr_máj_jún_júl_aug_sep_okt_nov_dec".split("_");

        function plural(n) {
            return n > 1 && n < 5
        }

        function translate(number, withoutSuffix, key, isFuture) {
            var result = number + " ";
            switch (key) {
                case "s":
                    return withoutSuffix || isFuture ? "pár sekúnd" : "pár sekundami";
                case "ss":
                    return withoutSuffix || isFuture ? result + (plural(number) ? "sekundy" : "sekúnd") : result + "sekundami";
                case "m":
                    return withoutSuffix ? "minúta" : isFuture ? "minútu" : "minútou";
                case "mm":
                    return withoutSuffix || isFuture ? result + (plural(number) ? "minúty" : "minút") : result + "minútami";
                case "h":
                    return withoutSuffix ? "hodina" : isFuture ? "hodinu" : "hodinou";
                case "hh":
                    return withoutSuffix || isFuture ? result + (plural(number) ? "hodiny" : "hodín") : result + "hodinami";
                case "d":
                    return withoutSuffix || isFuture ? "deň" : "dňom";
                case "dd":
                    return withoutSuffix || isFuture ? result + (plural(number) ? "dni" : "dní") : result + "dňami";
                case "M":
                    return withoutSuffix || isFuture ? "mesiac" : "mesiacom";
                case "MM":
                    return withoutSuffix || isFuture ? result + (plural(number) ? "mesiace" : "mesiacov") : result + "mesiacmi";
                case "y":
                    return withoutSuffix || isFuture ? "rok" : "rokom";
                case "yy":
                    return withoutSuffix || isFuture ? result + (plural(number) ? "roky" : "rokov") : result + "rokmi"
            }
        }
        moment.defineLocale("sk", {
            months: months,
            monthsShort: monthsShort,
            weekdays: "nedeľa_pondelok_utorok_streda_štvrtok_piatok_sobota".split("_"),
            weekdaysShort: "ne_po_ut_st_št_pi_so".split("_"),
            weekdaysMin: "ne_po_ut_st_št_pi_so".split("_"),
            longDateFormat: {
                LT: "H:mm",
                LTS: "H:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D. MMMM YYYY",
                LLL: "D. MMMM YYYY H:mm",
                LLLL: "dddd D. MMMM YYYY H:mm"
            },
            calendar: {
                sameDay: "[dnes o] LT",
                nextDay: "[zajtra o] LT",
                nextWeek: function() {
                    switch (this.day()) {
                        case 0:
                            return "[v nedeľu o] LT";
                        case 1:
                        case 2:
                            return "[v] dddd [o] LT";
                        case 3:
                            return "[v stredu o] LT";
                        case 4:
                            return "[vo štvrtok o] LT";
                        case 5:
                            return "[v piatok o] LT";
                        case 6:
                            return "[v sobotu o] LT"
                    }
                },
                lastDay: "[včera o] LT",
                lastWeek: function() {
                    switch (this.day()) {
                        case 0:
                            return "[minulú nedeľu o] LT";
                        case 1:
                        case 2:
                            return "[minulý] dddd [o] LT";
                        case 3:
                            return "[minulú stredu o] LT";
                        case 4:
                        case 5:
                            return "[minulý] dddd [o] LT";
                        case 6:
                            return "[minulú sobotu o] LT"
                    }
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "za %s",
                past: "pred %s",
                s: translate,
                ss: translate,
                m: translate,
                mm: translate,
                h: translate,
                hh: translate,
                d: translate,
                dd: translate,
                M: translate,
                MM: translate,
                y: translate,
                yy: translate
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";

        function processRelativeTime(number, withoutSuffix, key, isFuture) {
            var result = number + " ";
            switch (key) {
                case "s":
                    return withoutSuffix || isFuture ? "nekaj sekund" : "nekaj sekundami";
                case "ss":
                    return result += 1 === number ? withoutSuffix ? "sekundo" : "sekundi" : 2 === number ? withoutSuffix || isFuture ? "sekundi" : "sekundah" : number < 5 ? withoutSuffix || isFuture ? "sekunde" : "sekundah" : "sekund";
                case "m":
                    return withoutSuffix ? "ena minuta" : "eno minuto";
                case "mm":
                    return result += 1 === number ? withoutSuffix ? "minuta" : "minuto" : 2 === number ? withoutSuffix || isFuture ? "minuti" : "minutama" : number < 5 ? withoutSuffix || isFuture ? "minute" : "minutami" : withoutSuffix || isFuture ? "minut" : "minutami";
                case "h":
                    return withoutSuffix ? "ena ura" : "eno uro";
                case "hh":
                    return result += 1 === number ? withoutSuffix ? "ura" : "uro" : 2 === number ? withoutSuffix || isFuture ? "uri" : "urama" : number < 5 ? withoutSuffix || isFuture ? "ure" : "urami" : withoutSuffix || isFuture ? "ur" : "urami";
                case "d":
                    return withoutSuffix || isFuture ? "en dan" : "enim dnem";
                case "dd":
                    return result += 1 === number ? withoutSuffix || isFuture ? "dan" : "dnem" : 2 === number ? withoutSuffix || isFuture ? "dni" : "dnevoma" : withoutSuffix || isFuture ? "dni" : "dnevi";
                case "M":
                    return withoutSuffix || isFuture ? "en mesec" : "enim mesecem";
                case "MM":
                    return result += 1 === number ? withoutSuffix || isFuture ? "mesec" : "mesecem" : 2 === number ? withoutSuffix || isFuture ? "meseca" : "mesecema" : number < 5 ? withoutSuffix || isFuture ? "mesece" : "meseci" : withoutSuffix || isFuture ? "mesecev" : "meseci";
                case "y":
                    return withoutSuffix || isFuture ? "eno leto" : "enim letom";
                case "yy":
                    return result += 1 === number ? withoutSuffix || isFuture ? "leto" : "letom" : 2 === number ? withoutSuffix || isFuture ? "leti" : "letoma" : number < 5 ? withoutSuffix || isFuture ? "leta" : "leti" : withoutSuffix || isFuture ? "let" : "leti"
            }
        }
        moment.defineLocale("sl", {
            months: "januar_februar_marec_april_maj_junij_julij_avgust_september_oktober_november_december".split("_"),
            monthsShort: "jan._feb._mar._apr._maj._jun._jul._avg._sep._okt._nov._dec.".split("_"),
            monthsParseExact: !0,
            weekdays: "nedelja_ponedeljek_torek_sreda_četrtek_petek_sobota".split("_"),
            weekdaysShort: "ned._pon._tor._sre._čet._pet._sob.".split("_"),
            weekdaysMin: "ne_po_to_sr_če_pe_so".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "H:mm",
                LTS: "H:mm:ss",
                L: "DD. MM. YYYY",
                LL: "D. MMMM YYYY",
                LLL: "D. MMMM YYYY H:mm",
                LLLL: "dddd, D. MMMM YYYY H:mm"
            },
            calendar: {
                sameDay: "[danes ob] LT",
                nextDay: "[jutri ob] LT",
                nextWeek: function() {
                    switch (this.day()) {
                        case 0:
                            return "[v] [nedeljo] [ob] LT";
                        case 3:
                            return "[v] [sredo] [ob] LT";
                        case 6:
                            return "[v] [soboto] [ob] LT";
                        case 1:
                        case 2:
                        case 4:
                        case 5:
                            return "[v] dddd [ob] LT"
                    }
                },
                lastDay: "[včeraj ob] LT",
                lastWeek: function() {
                    switch (this.day()) {
                        case 0:
                            return "[prejšnjo] [nedeljo] [ob] LT";
                        case 3:
                            return "[prejšnjo] [sredo] [ob] LT";
                        case 6:
                            return "[prejšnjo] [soboto] [ob] LT";
                        case 1:
                        case 2:
                        case 4:
                        case 5:
                            return "[prejšnji] dddd [ob] LT"
                    }
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "čez %s",
                past: "pred %s",
                s: processRelativeTime,
                ss: processRelativeTime,
                m: processRelativeTime,
                mm: processRelativeTime,
                h: processRelativeTime,
                hh: processRelativeTime,
                d: processRelativeTime,
                dd: processRelativeTime,
                M: processRelativeTime,
                MM: processRelativeTime,
                y: processRelativeTime,
                yy: processRelativeTime
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {
                dow: 1,
                doy: 7
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("sq", {
            months: "Janar_Shkurt_Mars_Prill_Maj_Qershor_Korrik_Gusht_Shtator_Tetor_Nëntor_Dhjetor".split("_"),
            monthsShort: "Jan_Shk_Mar_Pri_Maj_Qer_Kor_Gus_Sht_Tet_Nën_Dhj".split("_"),
            weekdays: "E Diel_E Hënë_E Martë_E Mërkurë_E Enjte_E Premte_E Shtunë".split("_"),
            weekdaysShort: "Die_Hën_Mar_Mër_Enj_Pre_Sht".split("_"),
            weekdaysMin: "D_H_Ma_Më_E_P_Sh".split("_"),
            weekdaysParseExact: !0,
            meridiemParse: /PD|MD/,
            isPM: function(input) {
                return "M" === input.charAt(0)
            },
            meridiem: function(hours, minutes, isLower) {
                return hours < 12 ? "PD" : "MD"
            },
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd, D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[Sot në] LT",
                nextDay: "[Nesër në] LT",
                nextWeek: "dddd [në] LT",
                lastDay: "[Dje në] LT",
                lastWeek: "dddd [e kaluar në] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "në %s",
                past: "%s më parë",
                s: "disa sekonda",
                ss: "%d sekonda",
                m: "një minutë",
                mm: "%d minuta",
                h: "një orë",
                hh: "%d orë",
                d: "një ditë",
                dd: "%d ditë",
                M: "një muaj",
                MM: "%d muaj",
                y: "një vit",
                yy: "%d vite"
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        var translator = {
            words: {
                ss: ["sekunda", "sekunde", "sekundi"],
                m: ["jedan minut", "jedne minute"],
                mm: ["minut", "minute", "minuta"],
                h: ["jedan sat", "jednog sata"],
                hh: ["sat", "sata", "sati"],
                dd: ["dan", "dana", "dana"],
                MM: ["mesec", "meseca", "meseci"],
                yy: ["godina", "godine", "godina"]
            },
            correctGrammaticalCase: function(number, wordKey) {
                return 1 === number ? wordKey[0] : number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]
            },
            translate: function(number, withoutSuffix, key) {
                var wordKey = translator.words[key];
                return 1 === key.length ? withoutSuffix ? wordKey[0] : wordKey[1] : number + " " + translator.correctGrammaticalCase(number, wordKey)
            }
        };
        moment.defineLocale("sr", {
            months: "januar_februar_mart_april_maj_jun_jul_avgust_septembar_oktobar_novembar_decembar".split("_"),
            monthsShort: "jan._feb._mar._apr._maj_jun_jul_avg._sep._okt._nov._dec.".split("_"),
            monthsParseExact: !0,
            weekdays: "nedelja_ponedeljak_utorak_sreda_četvrtak_petak_subota".split("_"),
            weekdaysShort: "ned._pon._uto._sre._čet._pet._sub.".split("_"),
            weekdaysMin: "ne_po_ut_sr_če_pe_su".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "H:mm",
                LTS: "H:mm:ss",
                L: "D. M. YYYY.",
                LL: "D. MMMM YYYY.",
                LLL: "D. MMMM YYYY. H:mm",
                LLLL: "dddd, D. MMMM YYYY. H:mm"
            },
            calendar: {
                sameDay: "[danas u] LT",
                nextDay: "[sutra u] LT",
                nextWeek: function() {
                    switch (this.day()) {
                        case 0:
                            return "[u] [nedelju] [u] LT";
                        case 3:
                            return "[u] [sredu] [u] LT";
                        case 6:
                            return "[u] [subotu] [u] LT";
                        case 1:
                        case 2:
                        case 4:
                        case 5:
                            return "[u] dddd [u] LT"
                    }
                },
                lastDay: "[juče u] LT",
                lastWeek: function() {
                    return ["[prošle] [nedelje] [u] LT", "[prošlog] [ponedeljka] [u] LT", "[prošlog] [utorka] [u] LT", "[prošle] [srede] [u] LT", "[prošlog] [četvrtka] [u] LT", "[prošlog] [petka] [u] LT", "[prošle] [subote] [u] LT"][this.day()]
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "za %s",
                past: "pre %s",
                s: "nekoliko sekundi",
                ss: translator.translate,
                m: translator.translate,
                mm: translator.translate,
                h: translator.translate,
                hh: translator.translate,
                d: "dan",
                dd: translator.translate,
                M: "mesec",
                MM: translator.translate,
                y: "godinu",
                yy: translator.translate
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {
                dow: 1,
                doy: 7
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        var translator = {
            words: {
                ss: ["секунда", "секунде", "секунди"],
                m: ["један минут", "једне минуте"],
                mm: ["минут", "минуте", "минута"],
                h: ["један сат", "једног сата"],
                hh: ["сат", "сата", "сати"],
                dd: ["дан", "дана", "дана"],
                MM: ["месец", "месеца", "месеци"],
                yy: ["година", "године", "година"]
            },
            correctGrammaticalCase: function(number, wordKey) {
                return 1 === number ? wordKey[0] : number >= 2 && number <= 4 ? wordKey[1] : wordKey[2]
            },
            translate: function(number, withoutSuffix, key) {
                var wordKey = translator.words[key];
                return 1 === key.length ? withoutSuffix ? wordKey[0] : wordKey[1] : number + " " + translator.correctGrammaticalCase(number, wordKey)
            }
        };
        moment.defineLocale("sr-cyrl", {
            months: "јануар_фебруар_март_април_мај_јун_јул_август_септембар_октобар_новембар_децембар".split("_"),
            monthsShort: "јан._феб._мар._апр._мај_јун_јул_авг._сеп._окт._нов._дец.".split("_"),
            monthsParseExact: !0,
            weekdays: "недеља_понедељак_уторак_среда_четвртак_петак_субота".split("_"),
            weekdaysShort: "нед._пон._уто._сре._чет._пет._суб.".split("_"),
            weekdaysMin: "не_по_ут_ср_че_пе_су".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "H:mm",
                LTS: "H:mm:ss",
                L: "D. M. YYYY.",
                LL: "D. MMMM YYYY.",
                LLL: "D. MMMM YYYY. H:mm",
                LLLL: "dddd, D. MMMM YYYY. H:mm"
            },
            calendar: {
                sameDay: "[данас у] LT",
                nextDay: "[сутра у] LT",
                nextWeek: function() {
                    switch (this.day()) {
                        case 0:
                            return "[у] [недељу] [у] LT";
                        case 3:
                            return "[у] [среду] [у] LT";
                        case 6:
                            return "[у] [суботу] [у] LT";
                        case 1:
                        case 2:
                        case 4:
                        case 5:
                            return "[у] dddd [у] LT"
                    }
                },
                lastDay: "[јуче у] LT",
                lastWeek: function() {
                    return ["[прошле] [недеље] [у] LT", "[прошлог] [понедељка] [у] LT", "[прошлог] [уторка] [у] LT", "[прошле] [среде] [у] LT", "[прошлог] [четвртка] [у] LT", "[прошлог] [петка] [у] LT", "[прошле] [суботе] [у] LT"][this.day()]
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "за %s",
                past: "пре %s",
                s: "неколико секунди",
                ss: translator.translate,
                m: translator.translate,
                mm: translator.translate,
                h: translator.translate,
                hh: translator.translate,
                d: "дан",
                dd: translator.translate,
                M: "месец",
                MM: translator.translate,
                y: "годину",
                yy: translator.translate
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {
                dow: 1,
                doy: 7
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("ss", {
            months: "Bhimbidvwane_Indlovana_Indlov'lenkhulu_Mabasa_Inkhwekhweti_Inhlaba_Kholwane_Ingci_Inyoni_Imphala_Lweti_Ingongoni".split("_"),
            monthsShort: "Bhi_Ina_Inu_Mab_Ink_Inh_Kho_Igc_Iny_Imp_Lwe_Igo".split("_"),
            weekdays: "Lisontfo_Umsombuluko_Lesibili_Lesitsatfu_Lesine_Lesihlanu_Umgcibelo".split("_"),
            weekdaysShort: "Lis_Umb_Lsb_Les_Lsi_Lsh_Umg".split("_"),
            weekdaysMin: "Li_Us_Lb_Lt_Ls_Lh_Ug".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "h:mm A",
                LTS: "h:mm:ss A",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY h:mm A",
                LLLL: "dddd, D MMMM YYYY h:mm A"
            },
            calendar: {
                sameDay: "[Namuhla nga] LT",
                nextDay: "[Kusasa nga] LT",
                nextWeek: "dddd [nga] LT",
                lastDay: "[Itolo nga] LT",
                lastWeek: "dddd [leliphelile] [nga] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "nga %s",
                past: "wenteka nga %s",
                s: "emizuzwana lomcane",
                ss: "%d mzuzwana",
                m: "umzuzu",
                mm: "%d emizuzu",
                h: "lihora",
                hh: "%d emahora",
                d: "lilanga",
                dd: "%d emalanga",
                M: "inyanga",
                MM: "%d tinyanga",
                y: "umnyaka",
                yy: "%d iminyaka"
            },
            meridiemParse: /ekuseni|emini|entsambama|ebusuku/,
            meridiem: function(hours, minutes, isLower) {
                return hours < 11 ? "ekuseni" : hours < 15 ? "emini" : hours < 19 ? "entsambama" : "ebusuku"
            },
            meridiemHour: function(hour, meridiem) {
                return 12 === hour && (hour = 0), "ekuseni" === meridiem ? hour : "emini" === meridiem ? hour >= 11 ? hour : hour + 12 : "entsambama" === meridiem || "ebusuku" === meridiem ? 0 === hour ? 0 : hour + 12 : void 0
            },
            dayOfMonthOrdinalParse: /\d{1,2}/,
            ordinal: "%d",
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("sv", {
            months: "januari_februari_mars_april_maj_juni_juli_augusti_september_oktober_november_december".split("_"),
            monthsShort: "jan_feb_mar_apr_maj_jun_jul_aug_sep_okt_nov_dec".split("_"),
            weekdays: "söndag_måndag_tisdag_onsdag_torsdag_fredag_lördag".split("_"),
            weekdaysShort: "sön_mån_tis_ons_tor_fre_lör".split("_"),
            weekdaysMin: "sö_må_ti_on_to_fr_lö".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "YYYY-MM-DD",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY [kl.] HH:mm",
                LLLL: "dddd D MMMM YYYY [kl.] HH:mm",
                lll: "D MMM YYYY HH:mm",
                llll: "ddd D MMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[Idag] LT",
                nextDay: "[Imorgon] LT",
                lastDay: "[Igår] LT",
                nextWeek: "[På] dddd LT",
                lastWeek: "[I] dddd[s] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "om %s",
                past: "för %s sedan",
                s: "några sekunder",
                ss: "%d sekunder",
                m: "en minut",
                mm: "%d minuter",
                h: "en timme",
                hh: "%d timmar",
                d: "en dag",
                dd: "%d dagar",
                M: "en månad",
                MM: "%d månader",
                y: "ett år",
                yy: "%d år"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(\:e|\:a)/,
            ordinal: function(number) {
                var b = number % 10;
                return number + (1 == ~~(number % 100 / 10) ? ":e" : 1 === b || 2 === b ? ":a" : ":e")
            },
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("sw", {
            months: "Januari_Februari_Machi_Aprili_Mei_Juni_Julai_Agosti_Septemba_Oktoba_Novemba_Desemba".split("_"),
            monthsShort: "Jan_Feb_Mac_Apr_Mei_Jun_Jul_Ago_Sep_Okt_Nov_Des".split("_"),
            weekdays: "Jumapili_Jumatatu_Jumanne_Jumatano_Alhamisi_Ijumaa_Jumamosi".split("_"),
            weekdaysShort: "Jpl_Jtat_Jnne_Jtan_Alh_Ijm_Jmos".split("_"),
            weekdaysMin: "J2_J3_J4_J5_Al_Ij_J1".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "hh:mm A",
                LTS: "HH:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd, D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[leo saa] LT",
                nextDay: "[kesho saa] LT",
                nextWeek: "[wiki ijayo] dddd [saat] LT",
                lastDay: "[jana] LT",
                lastWeek: "[wiki iliyopita] dddd [saat] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s baadaye",
                past: "tokea %s",
                s: "hivi punde",
                ss: "sekunde %d",
                m: "dakika moja",
                mm: "dakika %d",
                h: "saa limoja",
                hh: "masaa %d",
                d: "siku moja",
                dd: "siku %d",
                M: "mwezi mmoja",
                MM: "miezi %d",
                y: "mwaka mmoja",
                yy: "miaka %d"
            },
            week: {
                dow: 1,
                doy: 7
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        var symbolMap = {
                1: "௧",
                2: "௨",
                3: "௩",
                4: "௪",
                5: "௫",
                6: "௬",
                7: "௭",
                8: "௮",
                9: "௯",
                0: "௦"
            },
            numberMap = {
                "௧": "1",
                "௨": "2",
                "௩": "3",
                "௪": "4",
                "௫": "5",
                "௬": "6",
                "௭": "7",
                "௮": "8",
                "௯": "9",
                "௦": "0"
            };
        moment.defineLocale("ta", {
            months: "ஜனவரி_பிப்ரவரி_மார்ச்_ஏப்ரல்_மே_ஜூன்_ஜூலை_ஆகஸ்ட்_செப்டெம்பர்_அக்டோபர்_நவம்பர்_டிசம்பர்".split("_"),
            monthsShort: "ஜனவரி_பிப்ரவரி_மார்ச்_ஏப்ரல்_மே_ஜூன்_ஜூலை_ஆகஸ்ட்_செப்டெம்பர்_அக்டோபர்_நவம்பர்_டிசம்பர்".split("_"),
            weekdays: "ஞாயிற்றுக்கிழமை_திங்கட்கிழமை_செவ்வாய்கிழமை_புதன்கிழமை_வியாழக்கிழமை_வெள்ளிக்கிழமை_சனிக்கிழமை".split("_"),
            weekdaysShort: "ஞாயிறு_திங்கள்_செவ்வாய்_புதன்_வியாழன்_வெள்ளி_சனி".split("_"),
            weekdaysMin: "ஞா_தி_செ_பு_வி_வெ_ச".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY, HH:mm",
                LLLL: "dddd, D MMMM YYYY, HH:mm"
            },
            calendar: {
                sameDay: "[இன்று] LT",
                nextDay: "[நாளை] LT",
                nextWeek: "dddd, LT",
                lastDay: "[நேற்று] LT",
                lastWeek: "[கடந்த வாரம்] dddd, LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s இல்",
                past: "%s முன்",
                s: "ஒரு சில விநாடிகள்",
                ss: "%d விநாடிகள்",
                m: "ஒரு நிமிடம்",
                mm: "%d நிமிடங்கள்",
                h: "ஒரு மணி நேரம்",
                hh: "%d மணி நேரம்",
                d: "ஒரு நாள்",
                dd: "%d நாட்கள்",
                M: "ஒரு மாதம்",
                MM: "%d மாதங்கள்",
                y: "ஒரு வருடம்",
                yy: "%d ஆண்டுகள்"
            },
            dayOfMonthOrdinalParse: /\d{1,2}வது/,
            ordinal: function(number) {
                return number + "வது"
            },
            preparse: function(string) {
                return string.replace(/[௧௨௩௪௫௬௭௮௯௦]/g, (function(match) {
                    return numberMap[match]
                }))
            },
            postformat: function(string) {
                return string.replace(/\d/g, (function(match) {
                    return symbolMap[match]
                }))
            },
            meridiemParse: /யாமம்|வைகறை|காலை|நண்பகல்|எற்பாடு|மாலை/,
            meridiem: function(hour, minute, isLower) {
                return hour < 2 ? " யாமம்" : hour < 6 ? " வைகறை" : hour < 10 ? " காலை" : hour < 14 ? " நண்பகல்" : hour < 18 ? " எற்பாடு" : hour < 22 ? " மாலை" : " யாமம்"
            },
            meridiemHour: function(hour, meridiem) {
                return 12 === hour && (hour = 0), "யாமம்" === meridiem ? hour < 2 ? hour : hour + 12 : "வைகறை" === meridiem || "காலை" === meridiem || "நண்பகல்" === meridiem && hour >= 10 ? hour : hour + 12
            },
            week: {
                dow: 0,
                doy: 6
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("te", {
            months: "జనవరి_ఫిబ్రవరి_మార్చి_ఏప్రిల్_మే_జూన్_జులై_ఆగస్టు_సెప్టెంబర్_అక్టోబర్_నవంబర్_డిసెంబర్".split("_"),
            monthsShort: "జన._ఫిబ్ర._మార్చి_ఏప్రి._మే_జూన్_జులై_ఆగ._సెప్._అక్టో._నవ._డిసె.".split("_"),
            monthsParseExact: !0,
            weekdays: "ఆదివారం_సోమవారం_మంగళవారం_బుధవారం_గురువారం_శుక్రవారం_శనివారం".split("_"),
            weekdaysShort: "ఆది_సోమ_మంగళ_బుధ_గురు_శుక్ర_శని".split("_"),
            weekdaysMin: "ఆ_సో_మం_బు_గు_శు_శ".split("_"),
            longDateFormat: {
                LT: "A h:mm",
                LTS: "A h:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY, A h:mm",
                LLLL: "dddd, D MMMM YYYY, A h:mm"
            },
            calendar: {
                sameDay: "[నేడు] LT",
                nextDay: "[రేపు] LT",
                nextWeek: "dddd, LT",
                lastDay: "[నిన్న] LT",
                lastWeek: "[గత] dddd, LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s లో",
                past: "%s క్రితం",
                s: "కొన్ని క్షణాలు",
                ss: "%d సెకన్లు",
                m: "ఒక నిమిషం",
                mm: "%d నిమిషాలు",
                h: "ఒక గంట",
                hh: "%d గంటలు",
                d: "ఒక రోజు",
                dd: "%d రోజులు",
                M: "ఒక నెల",
                MM: "%d నెలలు",
                y: "ఒక సంవత్సరం",
                yy: "%d సంవత్సరాలు"
            },
            dayOfMonthOrdinalParse: /\d{1,2}వ/,
            ordinal: "%dవ",
            meridiemParse: /రాత్రి|ఉదయం|మధ్యాహ్నం|సాయంత్రం/,
            meridiemHour: function(hour, meridiem) {
                return 12 === hour && (hour = 0), "రాత్రి" === meridiem ? hour < 4 ? hour : hour + 12 : "ఉదయం" === meridiem ? hour : "మధ్యాహ్నం" === meridiem ? hour >= 10 ? hour : hour + 12 : "సాయంత్రం" === meridiem ? hour + 12 : void 0
            },
            meridiem: function(hour, minute, isLower) {
                return hour < 4 ? "రాత్రి" : hour < 10 ? "ఉదయం" : hour < 17 ? "మధ్యాహ్నం" : hour < 20 ? "సాయంత్రం" : "రాత్రి"
            },
            week: {
                dow: 0,
                doy: 6
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("tet", {
            months: "Janeiru_Fevereiru_Marsu_Abril_Maiu_Juñu_Jullu_Agustu_Setembru_Outubru_Novembru_Dezembru".split("_"),
            monthsShort: "Jan_Fev_Mar_Abr_Mai_Jun_Jul_Ago_Set_Out_Nov_Dez".split("_"),
            weekdays: "Domingu_Segunda_Tersa_Kuarta_Kinta_Sesta_Sabadu".split("_"),
            weekdaysShort: "Dom_Seg_Ters_Kua_Kint_Sest_Sab".split("_"),
            weekdaysMin: "Do_Seg_Te_Ku_Ki_Ses_Sa".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd, D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[Ohin iha] LT",
                nextDay: "[Aban iha] LT",
                nextWeek: "dddd [iha] LT",
                lastDay: "[Horiseik iha] LT",
                lastWeek: "dddd [semana kotuk] [iha] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "iha %s",
                past: "%s liuba",
                s: "segundu balun",
                ss: "segundu %d",
                m: "minutu ida",
                mm: "minutu %d",
                h: "oras ida",
                hh: "oras %d",
                d: "loron ida",
                dd: "loron %d",
                M: "fulan ida",
                MM: "fulan %d",
                y: "tinan ida",
                yy: "tinan %d"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(st|nd|rd|th)/,
            ordinal: function(number) {
                var b = number % 10;
                return number + (1 == ~~(number % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th")
            },
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        var suffixes = {
            0: "-ум",
            1: "-ум",
            2: "-юм",
            3: "-юм",
            4: "-ум",
            5: "-ум",
            6: "-ум",
            7: "-ум",
            8: "-ум",
            9: "-ум",
            10: "-ум",
            12: "-ум",
            13: "-ум",
            20: "-ум",
            30: "-юм",
            40: "-ум",
            50: "-ум",
            60: "-ум",
            70: "-ум",
            80: "-ум",
            90: "-ум",
            100: "-ум"
        };
        moment.defineLocale("tg", {
            months: {
                format: "январи_феврали_марти_апрели_майи_июни_июли_августи_сентябри_октябри_ноябри_декабри".split("_"),
                standalone: "январ_феврал_март_апрел_май_июн_июл_август_сентябр_октябр_ноябр_декабр".split("_")
            },
            monthsShort: "янв_фев_мар_апр_май_июн_июл_авг_сен_окт_ноя_дек".split("_"),
            weekdays: "якшанбе_душанбе_сешанбе_чоршанбе_панҷшанбе_ҷумъа_шанбе".split("_"),
            weekdaysShort: "яшб_дшб_сшб_чшб_пшб_ҷум_шнб".split("_"),
            weekdaysMin: "яш_дш_сш_чш_пш_ҷм_шб".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd, D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[Имрӯз соати] LT",
                nextDay: "[Фардо соати] LT",
                lastDay: "[Дирӯз соати] LT",
                nextWeek: "dddd[и] [ҳафтаи оянда соати] LT",
                lastWeek: "dddd[и] [ҳафтаи гузашта соати] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "баъди %s",
                past: "%s пеш",
                s: "якчанд сония",
                m: "як дақиқа",
                mm: "%d дақиқа",
                h: "як соат",
                hh: "%d соат",
                d: "як рӯз",
                dd: "%d рӯз",
                M: "як моҳ",
                MM: "%d моҳ",
                y: "як сол",
                yy: "%d сол"
            },
            meridiemParse: /шаб|субҳ|рӯз|бегоҳ/,
            meridiemHour: function(hour, meridiem) {
                return 12 === hour && (hour = 0), "шаб" === meridiem ? hour < 4 ? hour : hour + 12 : "субҳ" === meridiem ? hour : "рӯз" === meridiem ? hour >= 11 ? hour : hour + 12 : "бегоҳ" === meridiem ? hour + 12 : void 0
            },
            meridiem: function(hour, minute, isLower) {
                return hour < 4 ? "шаб" : hour < 11 ? "субҳ" : hour < 16 ? "рӯз" : hour < 19 ? "бегоҳ" : "шаб"
            },
            dayOfMonthOrdinalParse: /\d{1,2}-(ум|юм)/,
            ordinal: function(number) {
                var a = number % 10,
                    b = number >= 100 ? 100 : null;
                return number + (suffixes[number] || suffixes[a] || suffixes[b])
            },
            week: {
                dow: 1,
                doy: 7
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("th", {
            months: "มกราคม_กุมภาพันธ์_มีนาคม_เมษายน_พฤษภาคม_มิถุนายน_กรกฎาคม_สิงหาคม_กันยายน_ตุลาคม_พฤศจิกายน_ธันวาคม".split("_"),
            monthsShort: "ม.ค._ก.พ._มี.ค._เม.ย._พ.ค._มิ.ย._ก.ค._ส.ค._ก.ย._ต.ค._พ.ย._ธ.ค.".split("_"),
            monthsParseExact: !0,
            weekdays: "อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัสบดี_ศุกร์_เสาร์".split("_"),
            weekdaysShort: "อาทิตย์_จันทร์_อังคาร_พุธ_พฤหัส_ศุกร์_เสาร์".split("_"),
            weekdaysMin: "อา._จ._อ._พ._พฤ._ศ._ส.".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "H:mm",
                LTS: "H:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY เวลา H:mm",
                LLLL: "วันddddที่ D MMMM YYYY เวลา H:mm"
            },
            meridiemParse: /ก่อนเที่ยง|หลังเที่ยง/,
            isPM: function(input) {
                return "หลังเที่ยง" === input
            },
            meridiem: function(hour, minute, isLower) {
                return hour < 12 ? "ก่อนเที่ยง" : "หลังเที่ยง"
            },
            calendar: {
                sameDay: "[วันนี้ เวลา] LT",
                nextDay: "[พรุ่งนี้ เวลา] LT",
                nextWeek: "dddd[หน้า เวลา] LT",
                lastDay: "[เมื่อวานนี้ เวลา] LT",
                lastWeek: "[วัน]dddd[ที่แล้ว เวลา] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "อีก %s",
                past: "%sที่แล้ว",
                s: "ไม่กี่วินาที",
                ss: "%d วินาที",
                m: "1 นาที",
                mm: "%d นาที",
                h: "1 ชั่วโมง",
                hh: "%d ชั่วโมง",
                d: "1 วัน",
                dd: "%d วัน",
                w: "1 สัปดาห์",
                ww: "%d สัปดาห์",
                M: "1 เดือน",
                MM: "%d เดือน",
                y: "1 ปี",
                yy: "%d ปี"
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        var suffixes = {
            1: "'inji",
            5: "'inji",
            8: "'inji",
            70: "'inji",
            80: "'inji",
            2: "'nji",
            7: "'nji",
            20: "'nji",
            50: "'nji",
            3: "'ünji",
            4: "'ünji",
            100: "'ünji",
            6: "'njy",
            9: "'unjy",
            10: "'unjy",
            30: "'unjy",
            60: "'ynjy",
            90: "'ynjy"
        };
        moment.defineLocale("tk", {
            months: "Ýanwar_Fewral_Mart_Aprel_Maý_Iýun_Iýul_Awgust_Sentýabr_Oktýabr_Noýabr_Dekabr".split("_"),
            monthsShort: "Ýan_Few_Mar_Apr_Maý_Iýn_Iýl_Awg_Sen_Okt_Noý_Dek".split("_"),
            weekdays: "Ýekşenbe_Duşenbe_Sişenbe_Çarşenbe_Penşenbe_Anna_Şenbe".split("_"),
            weekdaysShort: "Ýek_Duş_Siş_Çar_Pen_Ann_Şen".split("_"),
            weekdaysMin: "Ýk_Dş_Sş_Çr_Pn_An_Şn".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd, D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[bugün sagat] LT",
                nextDay: "[ertir sagat] LT",
                nextWeek: "[indiki] dddd [sagat] LT",
                lastDay: "[düýn] LT",
                lastWeek: "[geçen] dddd [sagat] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s soň",
                past: "%s öň",
                s: "birnäçe sekunt",
                m: "bir minut",
                mm: "%d minut",
                h: "bir sagat",
                hh: "%d sagat",
                d: "bir gün",
                dd: "%d gün",
                M: "bir aý",
                MM: "%d aý",
                y: "bir ýyl",
                yy: "%d ýyl"
            },
            ordinal: function(number, period) {
                switch (period) {
                    case "d":
                    case "D":
                    case "Do":
                    case "DD":
                        return number;
                    default:
                        if (0 === number) return number + "'unjy";
                        var a = number % 10,
                            b = number % 100 - a,
                            c = number >= 100 ? 100 : null;
                        return number + (suffixes[a] || suffixes[b] || suffixes[c])
                }
            },
            week: {
                dow: 1,
                doy: 7
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("tl-ph", {
            months: "Enero_Pebrero_Marso_Abril_Mayo_Hunyo_Hulyo_Agosto_Setyembre_Oktubre_Nobyembre_Disyembre".split("_"),
            monthsShort: "Ene_Peb_Mar_Abr_May_Hun_Hul_Ago_Set_Okt_Nob_Dis".split("_"),
            weekdays: "Linggo_Lunes_Martes_Miyerkules_Huwebes_Biyernes_Sabado".split("_"),
            weekdaysShort: "Lin_Lun_Mar_Miy_Huw_Biy_Sab".split("_"),
            weekdaysMin: "Li_Lu_Ma_Mi_Hu_Bi_Sab".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "MM/D/YYYY",
                LL: "MMMM D, YYYY",
                LLL: "MMMM D, YYYY HH:mm",
                LLLL: "dddd, MMMM DD, YYYY HH:mm"
            },
            calendar: {
                sameDay: "LT [ngayong araw]",
                nextDay: "[Bukas ng] LT",
                nextWeek: "LT [sa susunod na] dddd",
                lastDay: "LT [kahapon]",
                lastWeek: "LT [noong nakaraang] dddd",
                sameElse: "L"
            },
            relativeTime: {
                future: "sa loob ng %s",
                past: "%s ang nakalipas",
                s: "ilang segundo",
                ss: "%d segundo",
                m: "isang minuto",
                mm: "%d minuto",
                h: "isang oras",
                hh: "%d oras",
                d: "isang araw",
                dd: "%d araw",
                M: "isang buwan",
                MM: "%d buwan",
                y: "isang taon",
                yy: "%d taon"
            },
            dayOfMonthOrdinalParse: /\d{1,2}/,
            ordinal: function(number) {
                return number
            },
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        var numbersNouns = "pagh_wa’_cha’_wej_loS_vagh_jav_Soch_chorgh_Hut".split("_");

        function translateFuture(output) {
            var time = output;
            return time = -1 !== output.indexOf("jaj") ? time.slice(0, -3) + "leS" : -1 !== output.indexOf("jar") ? time.slice(0, -3) + "waQ" : -1 !== output.indexOf("DIS") ? time.slice(0, -3) + "nem" : time + " pIq"
        }

        function translatePast(output) {
            var time = output;
            return time = -1 !== output.indexOf("jaj") ? time.slice(0, -3) + "Hu’" : -1 !== output.indexOf("jar") ? time.slice(0, -3) + "wen" : -1 !== output.indexOf("DIS") ? time.slice(0, -3) + "ben" : time + " ret"
        }

        function translate(number, withoutSuffix, string, isFuture) {
            var numberNoun = numberAsNoun(number);
            switch (string) {
                case "ss":
                    return numberNoun + " lup";
                case "mm":
                    return numberNoun + " tup";
                case "hh":
                    return numberNoun + " rep";
                case "dd":
                    return numberNoun + " jaj";
                case "MM":
                    return numberNoun + " jar";
                case "yy":
                    return numberNoun + " DIS"
            }
        }

        function numberAsNoun(number) {
            var hundred = Math.floor(number % 1e3 / 100),
                ten = Math.floor(number % 100 / 10),
                one = number % 10,
                word = "";
            return hundred > 0 && (word += numbersNouns[hundred] + "vatlh"), ten > 0 && (word += ("" !== word ? " " : "") + numbersNouns[ten] + "maH"), one > 0 && (word += ("" !== word ? " " : "") + numbersNouns[one]), "" === word ? "pagh" : word
        }
        moment.defineLocale("tlh", {
            months: "tera’ jar wa’_tera’ jar cha’_tera’ jar wej_tera’ jar loS_tera’ jar vagh_tera’ jar jav_tera’ jar Soch_tera’ jar chorgh_tera’ jar Hut_tera’ jar wa’maH_tera’ jar wa’maH wa’_tera’ jar wa’maH cha’".split("_"),
            monthsShort: "jar wa’_jar cha’_jar wej_jar loS_jar vagh_jar jav_jar Soch_jar chorgh_jar Hut_jar wa’maH_jar wa’maH wa’_jar wa’maH cha’".split("_"),
            monthsParseExact: !0,
            weekdays: "lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj".split("_"),
            weekdaysShort: "lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj".split("_"),
            weekdaysMin: "lojmItjaj_DaSjaj_povjaj_ghItlhjaj_loghjaj_buqjaj_ghInjaj".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd, D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[DaHjaj] LT",
                nextDay: "[wa’leS] LT",
                nextWeek: "LLL",
                lastDay: "[wa’Hu’] LT",
                lastWeek: "LLL",
                sameElse: "L"
            },
            relativeTime: {
                future: translateFuture,
                past: translatePast,
                s: "puS lup",
                ss: translate,
                m: "wa’ tup",
                mm: translate,
                h: "wa’ rep",
                hh: translate,
                d: "wa’ jaj",
                dd: translate,
                M: "wa’ jar",
                MM: translate,
                y: "wa’ DIS",
                yy: translate
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        var suffixes = {
            1: "'inci",
            5: "'inci",
            8: "'inci",
            70: "'inci",
            80: "'inci",
            2: "'nci",
            7: "'nci",
            20: "'nci",
            50: "'nci",
            3: "'üncü",
            4: "'üncü",
            100: "'üncü",
            6: "'ncı",
            9: "'uncu",
            10: "'uncu",
            30: "'uncu",
            60: "'ıncı",
            90: "'ıncı"
        };
        moment.defineLocale("tr", {
            months: "Ocak_Şubat_Mart_Nisan_Mayıs_Haziran_Temmuz_Ağustos_Eylül_Ekim_Kasım_Aralık".split("_"),
            monthsShort: "Oca_Şub_Mar_Nis_May_Haz_Tem_Ağu_Eyl_Eki_Kas_Ara".split("_"),
            weekdays: "Pazar_Pazartesi_Salı_Çarşamba_Perşembe_Cuma_Cumartesi".split("_"),
            weekdaysShort: "Paz_Pts_Sal_Çar_Per_Cum_Cts".split("_"),
            weekdaysMin: "Pz_Pt_Sa_Ça_Pe_Cu_Ct".split("_"),
            meridiem: function(hours, minutes, isLower) {
                return hours < 12 ? isLower ? "öö" : "ÖÖ" : isLower ? "ös" : "ÖS"
            },
            meridiemParse: /öö|ÖÖ|ös|ÖS/,
            isPM: function(input) {
                return "ös" === input || "ÖS" === input
            },
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd, D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[bugün saat] LT",
                nextDay: "[yarın saat] LT",
                nextWeek: "[gelecek] dddd [saat] LT",
                lastDay: "[dün] LT",
                lastWeek: "[geçen] dddd [saat] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s sonra",
                past: "%s önce",
                s: "birkaç saniye",
                ss: "%d saniye",
                m: "bir dakika",
                mm: "%d dakika",
                h: "bir saat",
                hh: "%d saat",
                d: "bir gün",
                dd: "%d gün",
                w: "bir hafta",
                ww: "%d hafta",
                M: "bir ay",
                MM: "%d ay",
                y: "bir yıl",
                yy: "%d yıl"
            },
            ordinal: function(number, period) {
                switch (period) {
                    case "d":
                    case "D":
                    case "Do":
                    case "DD":
                        return number;
                    default:
                        if (0 === number) return number + "'ıncı";
                        var a = number % 10,
                            b = number % 100 - a,
                            c = number >= 100 ? 100 : null;
                        return number + (suffixes[a] || suffixes[b] || suffixes[c])
                }
            },
            week: {
                dow: 1,
                doy: 7
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";

        function processRelativeTime(number, withoutSuffix, key, isFuture) {
            var format = {
                s: ["viensas secunds", "'iensas secunds"],
                ss: [number + " secunds", number + " secunds"],
                m: ["'n míut", "'iens míut"],
                mm: [number + " míuts", number + " míuts"],
                h: ["'n þora", "'iensa þora"],
                hh: [number + " þoras", number + " þoras"],
                d: ["'n ziua", "'iensa ziua"],
                dd: [number + " ziuas", number + " ziuas"],
                M: ["'n mes", "'iens mes"],
                MM: [number + " mesen", number + " mesen"],
                y: ["'n ar", "'iens ar"],
                yy: [number + " ars", number + " ars"]
            };
            return isFuture || withoutSuffix ? format[key][0] : format[key][1]
        }
        moment.defineLocale("tzl", {
            months: "Januar_Fevraglh_Març_Avrïu_Mai_Gün_Julia_Guscht_Setemvar_Listopäts_Noemvar_Zecemvar".split("_"),
            monthsShort: "Jan_Fev_Mar_Avr_Mai_Gün_Jul_Gus_Set_Lis_Noe_Zec".split("_"),
            weekdays: "Súladi_Lúneçi_Maitzi_Márcuri_Xhúadi_Viénerçi_Sáturi".split("_"),
            weekdaysShort: "Súl_Lún_Mai_Már_Xhú_Vié_Sát".split("_"),
            weekdaysMin: "Sú_Lú_Ma_Má_Xh_Vi_Sá".split("_"),
            longDateFormat: {
                LT: "HH.mm",
                LTS: "HH.mm.ss",
                L: "DD.MM.YYYY",
                LL: "D. MMMM [dallas] YYYY",
                LLL: "D. MMMM [dallas] YYYY HH.mm",
                LLLL: "dddd, [li] D. MMMM [dallas] YYYY HH.mm"
            },
            meridiemParse: /d\'o|d\'a/i,
            isPM: function(input) {
                return "d'o" === input.toLowerCase()
            },
            meridiem: function(hours, minutes, isLower) {
                return hours > 11 ? isLower ? "d'o" : "D'O" : isLower ? "d'a" : "D'A"
            },
            calendar: {
                sameDay: "[oxhi à] LT",
                nextDay: "[demà à] LT",
                nextWeek: "dddd [à] LT",
                lastDay: "[ieiri à] LT",
                lastWeek: "[sür el] dddd [lasteu à] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "osprei %s",
                past: "ja%s",
                s: processRelativeTime,
                ss: processRelativeTime,
                m: processRelativeTime,
                mm: processRelativeTime,
                h: processRelativeTime,
                hh: processRelativeTime,
                d: processRelativeTime,
                dd: processRelativeTime,
                M: processRelativeTime,
                MM: processRelativeTime,
                y: processRelativeTime,
                yy: processRelativeTime
            },
            dayOfMonthOrdinalParse: /\d{1,2}\./,
            ordinal: "%d.",
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("tzm", {
            months: "ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ".split("_"),
            monthsShort: "ⵉⵏⵏⴰⵢⵔ_ⴱⵕⴰⵢⵕ_ⵎⴰⵕⵚ_ⵉⴱⵔⵉⵔ_ⵎⴰⵢⵢⵓ_ⵢⵓⵏⵢⵓ_ⵢⵓⵍⵢⵓⵣ_ⵖⵓⵛⵜ_ⵛⵓⵜⴰⵏⴱⵉⵔ_ⴽⵟⵓⴱⵕ_ⵏⵓⵡⴰⵏⴱⵉⵔ_ⴷⵓⵊⵏⴱⵉⵔ".split("_"),
            weekdays: "ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ".split("_"),
            weekdaysShort: "ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ".split("_"),
            weekdaysMin: "ⴰⵙⴰⵎⴰⵙ_ⴰⵢⵏⴰⵙ_ⴰⵙⵉⵏⴰⵙ_ⴰⴽⵔⴰⵙ_ⴰⴽⵡⴰⵙ_ⴰⵙⵉⵎⵡⴰⵙ_ⴰⵙⵉⴹⵢⴰⵙ".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[ⴰⵙⴷⵅ ⴴ] LT",
                nextDay: "[ⴰⵙⴽⴰ ⴴ] LT",
                nextWeek: "dddd [ⴴ] LT",
                lastDay: "[ⴰⵚⴰⵏⵜ ⴴ] LT",
                lastWeek: "dddd [ⴴ] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "ⴷⴰⴷⵅ ⵙ ⵢⴰⵏ %s",
                past: "ⵢⴰⵏ %s",
                s: "ⵉⵎⵉⴽ",
                ss: "%d ⵉⵎⵉⴽ",
                m: "ⵎⵉⵏⵓⴺ",
                mm: "%d ⵎⵉⵏⵓⴺ",
                h: "ⵙⴰⵄⴰ",
                hh: "%d ⵜⴰⵙⵙⴰⵄⵉⵏ",
                d: "ⴰⵙⵙ",
                dd: "%d oⵙⵙⴰⵏ",
                M: "ⴰⵢoⵓⵔ",
                MM: "%d ⵉⵢⵢⵉⵔⵏ",
                y: "ⴰⵙⴳⴰⵙ",
                yy: "%d ⵉⵙⴳⴰⵙⵏ"
            },
            week: {
                dow: 6,
                doy: 12
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("tzm-latn", {
            months: "innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir".split("_"),
            monthsShort: "innayr_brˤayrˤ_marˤsˤ_ibrir_mayyw_ywnyw_ywlywz_ɣwšt_šwtanbir_ktˤwbrˤ_nwwanbir_dwjnbir".split("_"),
            weekdays: "asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas".split("_"),
            weekdaysShort: "asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas".split("_"),
            weekdaysMin: "asamas_aynas_asinas_akras_akwas_asimwas_asiḍyas".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[asdkh g] LT",
                nextDay: "[aska g] LT",
                nextWeek: "dddd [g] LT",
                lastDay: "[assant g] LT",
                lastWeek: "dddd [g] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "dadkh s yan %s",
                past: "yan %s",
                s: "imik",
                ss: "%d imik",
                m: "minuḍ",
                mm: "%d minuḍ",
                h: "saɛa",
                hh: "%d tassaɛin",
                d: "ass",
                dd: "%d ossan",
                M: "ayowr",
                MM: "%d iyyirn",
                y: "asgas",
                yy: "%d isgasn"
            },
            week: {
                dow: 6,
                doy: 12
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("ug-cn", {
            months: "يانۋار_فېۋرال_مارت_ئاپرېل_ماي_ئىيۇن_ئىيۇل_ئاۋغۇست_سېنتەبىر_ئۆكتەبىر_نويابىر_دېكابىر".split("_"),
            monthsShort: "يانۋار_فېۋرال_مارت_ئاپرېل_ماي_ئىيۇن_ئىيۇل_ئاۋغۇست_سېنتەبىر_ئۆكتەبىر_نويابىر_دېكابىر".split("_"),
            weekdays: "يەكشەنبە_دۈشەنبە_سەيشەنبە_چارشەنبە_پەيشەنبە_جۈمە_شەنبە".split("_"),
            weekdaysShort: "يە_دۈ_سە_چا_پە_جۈ_شە".split("_"),
            weekdaysMin: "يە_دۈ_سە_چا_پە_جۈ_شە".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "YYYY-MM-DD",
                LL: "YYYY-يىلىM-ئاينىڭD-كۈنى",
                LLL: "YYYY-يىلىM-ئاينىڭD-كۈنى، HH:mm",
                LLLL: "dddd، YYYY-يىلىM-ئاينىڭD-كۈنى، HH:mm"
            },
            meridiemParse: /يېرىم كېچە|سەھەر|چۈشتىن بۇرۇن|چۈش|چۈشتىن كېيىن|كەچ/,
            meridiemHour: function(hour, meridiem) {
                return 12 === hour && (hour = 0), "يېرىم كېچە" === meridiem || "سەھەر" === meridiem || "چۈشتىن بۇرۇن" === meridiem ? hour : "چۈشتىن كېيىن" === meridiem || "كەچ" === meridiem ? hour + 12 : hour >= 11 ? hour : hour + 12
            },
            meridiem: function(hour, minute, isLower) {
                var hm = 100 * hour + minute;
                return hm < 600 ? "يېرىم كېچە" : hm < 900 ? "سەھەر" : hm < 1130 ? "چۈشتىن بۇرۇن" : hm < 1230 ? "چۈش" : hm < 1800 ? "چۈشتىن كېيىن" : "كەچ"
            },
            calendar: {
                sameDay: "[بۈگۈن سائەت] LT",
                nextDay: "[ئەتە سائەت] LT",
                nextWeek: "[كېلەركى] dddd [سائەت] LT",
                lastDay: "[تۆنۈگۈن] LT",
                lastWeek: "[ئالدىنقى] dddd [سائەت] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s كېيىن",
                past: "%s بۇرۇن",
                s: "نەچچە سېكونت",
                ss: "%d سېكونت",
                m: "بىر مىنۇت",
                mm: "%d مىنۇت",
                h: "بىر سائەت",
                hh: "%d سائەت",
                d: "بىر كۈن",
                dd: "%d كۈن",
                M: "بىر ئاي",
                MM: "%d ئاي",
                y: "بىر يىل",
                yy: "%d يىل"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(-كۈنى|-ئاي|-ھەپتە)/,
            ordinal: function(number, period) {
                switch (period) {
                    case "d":
                    case "D":
                    case "DDD":
                        return number + "-كۈنى";
                    case "w":
                    case "W":
                        return number + "-ھەپتە";
                    default:
                        return number
                }
            },
            preparse: function(string) {
                return string.replace(/،/g, ",")
            },
            postformat: function(string) {
                return string.replace(/,/g, "،")
            },
            week: {
                dow: 1,
                doy: 7
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";

        function plural(word, num) {
            var forms = word.split("_");
            return num % 10 == 1 && num % 100 != 11 ? forms[0] : num % 10 >= 2 && num % 10 <= 4 && (num % 100 < 10 || num % 100 >= 20) ? forms[1] : forms[2]
        }

        function relativeTimeWithPlural(number, withoutSuffix, key) {
            return "m" === key ? withoutSuffix ? "хвилина" : "хвилину" : "h" === key ? withoutSuffix ? "година" : "годину" : number + " " + plural({
                ss: withoutSuffix ? "секунда_секунди_секунд" : "секунду_секунди_секунд",
                mm: withoutSuffix ? "хвилина_хвилини_хвилин" : "хвилину_хвилини_хвилин",
                hh: withoutSuffix ? "година_години_годин" : "годину_години_годин",
                dd: "день_дні_днів",
                MM: "місяць_місяці_місяців",
                yy: "рік_роки_років"
            }[key], +number)
        }

        function weekdaysCaseReplace(m, format) {
            var weekdays = {
                nominative: "неділя_понеділок_вівторок_середа_четвер_п’ятниця_субота".split("_"),
                accusative: "неділю_понеділок_вівторок_середу_четвер_п’ятницю_суботу".split("_"),
                genitive: "неділі_понеділка_вівторка_середи_четверга_п’ятниці_суботи".split("_")
            };
            return !0 === m ? weekdays.nominative.slice(1, 7).concat(weekdays.nominative.slice(0, 1)) : m ? weekdays[/(\[[ВвУу]\]) ?dddd/.test(format) ? "accusative" : /\[?(?:минулої|наступної)? ?\] ?dddd/.test(format) ? "genitive" : "nominative"][m.day()] : weekdays.nominative
        }

        function processHoursFunction(str) {
            return function() {
                return str + "о" + (11 === this.hours() ? "б" : "") + "] LT"
            }
        }
        moment.defineLocale("uk", {
            months: {
                format: "січня_лютого_березня_квітня_травня_червня_липня_серпня_вересня_жовтня_листопада_грудня".split("_"),
                standalone: "січень_лютий_березень_квітень_травень_червень_липень_серпень_вересень_жовтень_листопад_грудень".split("_")
            },
            monthsShort: "січ_лют_бер_квіт_трав_черв_лип_серп_вер_жовт_лист_груд".split("_"),
            weekdays: weekdaysCaseReplace,
            weekdaysShort: "нд_пн_вт_ср_чт_пт_сб".split("_"),
            weekdaysMin: "нд_пн_вт_ср_чт_пт_сб".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD.MM.YYYY",
                LL: "D MMMM YYYY р.",
                LLL: "D MMMM YYYY р., HH:mm",
                LLLL: "dddd, D MMMM YYYY р., HH:mm"
            },
            calendar: {
                sameDay: processHoursFunction("[Сьогодні "),
                nextDay: processHoursFunction("[Завтра "),
                lastDay: processHoursFunction("[Вчора "),
                nextWeek: processHoursFunction("[У] dddd ["),
                lastWeek: function() {
                    switch (this.day()) {
                        case 0:
                        case 3:
                        case 5:
                        case 6:
                            return processHoursFunction("[Минулої] dddd [").call(this);
                        case 1:
                        case 2:
                        case 4:
                            return processHoursFunction("[Минулого] dddd [").call(this)
                    }
                },
                sameElse: "L"
            },
            relativeTime: {
                future: "за %s",
                past: "%s тому",
                s: "декілька секунд",
                ss: relativeTimeWithPlural,
                m: relativeTimeWithPlural,
                mm: relativeTimeWithPlural,
                h: "годину",
                hh: relativeTimeWithPlural,
                d: "день",
                dd: relativeTimeWithPlural,
                M: "місяць",
                MM: relativeTimeWithPlural,
                y: "рік",
                yy: relativeTimeWithPlural
            },
            meridiemParse: /ночі|ранку|дня|вечора/,
            isPM: function(input) {
                return /^(дня|вечора)$/.test(input)
            },
            meridiem: function(hour, minute, isLower) {
                return hour < 4 ? "ночі" : hour < 12 ? "ранку" : hour < 17 ? "дня" : "вечора"
            },
            dayOfMonthOrdinalParse: /\d{1,2}-(й|го)/,
            ordinal: function(number, period) {
                switch (period) {
                    case "M":
                    case "d":
                    case "DDD":
                    case "w":
                    case "W":
                        return number + "-й";
                    case "D":
                        return number + "-го";
                    default:
                        return number
                }
            },
            week: {
                dow: 1,
                doy: 7
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        var months = ["جنوری", "فروری", "مارچ", "اپریل", "مئی", "جون", "جولائی", "اگست", "ستمبر", "اکتوبر", "نومبر", "دسمبر"],
            days = ["اتوار", "پیر", "منگل", "بدھ", "جمعرات", "جمعہ", "ہفتہ"];
        moment.defineLocale("ur", {
            months: months,
            monthsShort: months,
            weekdays: days,
            weekdaysShort: days,
            weekdaysMin: days,
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd، D MMMM YYYY HH:mm"
            },
            meridiemParse: /صبح|شام/,
            isPM: function(input) {
                return "شام" === input
            },
            meridiem: function(hour, minute, isLower) {
                return hour < 12 ? "صبح" : "شام"
            },
            calendar: {
                sameDay: "[آج بوقت] LT",
                nextDay: "[کل بوقت] LT",
                nextWeek: "dddd [بوقت] LT",
                lastDay: "[گذشتہ روز بوقت] LT",
                lastWeek: "[گذشتہ] dddd [بوقت] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s بعد",
                past: "%s قبل",
                s: "چند سیکنڈ",
                ss: "%d سیکنڈ",
                m: "ایک منٹ",
                mm: "%d منٹ",
                h: "ایک گھنٹہ",
                hh: "%d گھنٹے",
                d: "ایک دن",
                dd: "%d دن",
                M: "ایک ماہ",
                MM: "%d ماہ",
                y: "ایک سال",
                yy: "%d سال"
            },
            preparse: function(string) {
                return string.replace(/،/g, ",")
            },
            postformat: function(string) {
                return string.replace(/,/g, "،")
            },
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("uz", {
            months: "январ_феврал_март_апрел_май_июн_июл_август_сентябр_октябр_ноябр_декабр".split("_"),
            monthsShort: "янв_фев_мар_апр_май_июн_июл_авг_сен_окт_ноя_дек".split("_"),
            weekdays: "Якшанба_Душанба_Сешанба_Чоршанба_Пайшанба_Жума_Шанба".split("_"),
            weekdaysShort: "Якш_Душ_Сеш_Чор_Пай_Жум_Шан".split("_"),
            weekdaysMin: "Як_Ду_Се_Чо_Па_Жу_Ша".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "D MMMM YYYY, dddd HH:mm"
            },
            calendar: {
                sameDay: "[Бугун соат] LT [да]",
                nextDay: "[Эртага] LT [да]",
                nextWeek: "dddd [куни соат] LT [да]",
                lastDay: "[Кеча соат] LT [да]",
                lastWeek: "[Утган] dddd [куни соат] LT [да]",
                sameElse: "L"
            },
            relativeTime: {
                future: "Якин %s ичида",
                past: "Бир неча %s олдин",
                s: "фурсат",
                ss: "%d фурсат",
                m: "бир дакика",
                mm: "%d дакика",
                h: "бир соат",
                hh: "%d соат",
                d: "бир кун",
                dd: "%d кун",
                M: "бир ой",
                MM: "%d ой",
                y: "бир йил",
                yy: "%d йил"
            },
            week: {
                dow: 1,
                doy: 7
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("uz-latn", {
            months: "Yanvar_Fevral_Mart_Aprel_May_Iyun_Iyul_Avgust_Sentabr_Oktabr_Noyabr_Dekabr".split("_"),
            monthsShort: "Yan_Fev_Mar_Apr_May_Iyun_Iyul_Avg_Sen_Okt_Noy_Dek".split("_"),
            weekdays: "Yakshanba_Dushanba_Seshanba_Chorshanba_Payshanba_Juma_Shanba".split("_"),
            weekdaysShort: "Yak_Dush_Sesh_Chor_Pay_Jum_Shan".split("_"),
            weekdaysMin: "Ya_Du_Se_Cho_Pa_Ju_Sha".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "D MMMM YYYY, dddd HH:mm"
            },
            calendar: {
                sameDay: "[Bugun soat] LT [da]",
                nextDay: "[Ertaga] LT [da]",
                nextWeek: "dddd [kuni soat] LT [da]",
                lastDay: "[Kecha soat] LT [da]",
                lastWeek: "[O'tgan] dddd [kuni soat] LT [da]",
                sameElse: "L"
            },
            relativeTime: {
                future: "Yaqin %s ichida",
                past: "Bir necha %s oldin",
                s: "soniya",
                ss: "%d soniya",
                m: "bir daqiqa",
                mm: "%d daqiqa",
                h: "bir soat",
                hh: "%d soat",
                d: "bir kun",
                dd: "%d kun",
                M: "bir oy",
                MM: "%d oy",
                y: "bir yil",
                yy: "%d yil"
            },
            week: {
                dow: 1,
                doy: 7
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("vi", {
            months: "tháng 1_tháng 2_tháng 3_tháng 4_tháng 5_tháng 6_tháng 7_tháng 8_tháng 9_tháng 10_tháng 11_tháng 12".split("_"),
            monthsShort: "Thg 01_Thg 02_Thg 03_Thg 04_Thg 05_Thg 06_Thg 07_Thg 08_Thg 09_Thg 10_Thg 11_Thg 12".split("_"),
            monthsParseExact: !0,
            weekdays: "chủ nhật_thứ hai_thứ ba_thứ tư_thứ năm_thứ sáu_thứ bảy".split("_"),
            weekdaysShort: "CN_T2_T3_T4_T5_T6_T7".split("_"),
            weekdaysMin: "CN_T2_T3_T4_T5_T6_T7".split("_"),
            weekdaysParseExact: !0,
            meridiemParse: /sa|ch/i,
            isPM: function(input) {
                return /^ch$/i.test(input)
            },
            meridiem: function(hours, minutes, isLower) {
                return hours < 12 ? isLower ? "sa" : "SA" : isLower ? "ch" : "CH"
            },
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "D MMMM [năm] YYYY",
                LLL: "D MMMM [năm] YYYY HH:mm",
                LLLL: "dddd, D MMMM [năm] YYYY HH:mm",
                l: "DD/M/YYYY",
                ll: "D MMM YYYY",
                lll: "D MMM YYYY HH:mm",
                llll: "ddd, D MMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[Hôm nay lúc] LT",
                nextDay: "[Ngày mai lúc] LT",
                nextWeek: "dddd [tuần tới lúc] LT",
                lastDay: "[Hôm qua lúc] LT",
                lastWeek: "dddd [tuần trước lúc] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "%s tới",
                past: "%s trước",
                s: "vài giây",
                ss: "%d giây",
                m: "một phút",
                mm: "%d phút",
                h: "một giờ",
                hh: "%d giờ",
                d: "một ngày",
                dd: "%d ngày",
                w: "một tuần",
                ww: "%d tuần",
                M: "một tháng",
                MM: "%d tháng",
                y: "một năm",
                yy: "%d năm"
            },
            dayOfMonthOrdinalParse: /\d{1,2}/,
            ordinal: function(number) {
                return number
            },
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("x-pseudo", {
            months: "J~áñúá~rý_F~ébrú~árý_~Márc~h_Áp~ríl_~Máý_~Júñé~_Júl~ý_Áú~gúst~_Sép~témb~ér_Ó~ctób~ér_Ñ~óvém~bér_~Décé~mbér".split("_"),
            monthsShort: "J~áñ_~Féb_~Már_~Ápr_~Máý_~Júñ_~Júl_~Áúg_~Sép_~Óct_~Ñóv_~Déc".split("_"),
            monthsParseExact: !0,
            weekdays: "S~úñdá~ý_Mó~ñdáý~_Túé~sdáý~_Wéd~ñésd~áý_T~húrs~dáý_~Fríd~áý_S~átúr~dáý".split("_"),
            weekdaysShort: "S~úñ_~Móñ_~Túé_~Wéd_~Thú_~Frí_~Sát".split("_"),
            weekdaysMin: "S~ú_Mó~_Tú_~Wé_T~h_Fr~_Sá".split("_"),
            weekdaysParseExact: !0,
            longDateFormat: {
                LT: "HH:mm",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY HH:mm",
                LLLL: "dddd, D MMMM YYYY HH:mm"
            },
            calendar: {
                sameDay: "[T~ódá~ý át] LT",
                nextDay: "[T~ómó~rró~w át] LT",
                nextWeek: "dddd [át] LT",
                lastDay: "[Ý~ést~érdá~ý át] LT",
                lastWeek: "[L~ást] dddd [át] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "í~ñ %s",
                past: "%s á~gó",
                s: "á ~féw ~sécó~ñds",
                ss: "%d s~écóñ~ds",
                m: "á ~míñ~úté",
                mm: "%d m~íñú~tés",
                h: "á~ñ hó~úr",
                hh: "%d h~óúrs",
                d: "á ~dáý",
                dd: "%d d~áýs",
                M: "á ~móñ~th",
                MM: "%d m~óñt~hs",
                y: "á ~ýéár",
                yy: "%d ý~éárs"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
            ordinal: function(number) {
                var b = number % 10;
                return number + (1 == ~~(number % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th")
            },
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("yo", {
            months: "Sẹ́rẹ́_Èrèlè_Ẹrẹ̀nà_Ìgbé_Èbibi_Òkùdu_Agẹmo_Ògún_Owewe_Ọ̀wàrà_Bélú_Ọ̀pẹ̀̀".split("_"),
            monthsShort: "Sẹ́r_Èrl_Ẹrn_Ìgb_Èbi_Òkù_Agẹ_Ògú_Owe_Ọ̀wà_Bél_Ọ̀pẹ̀̀".split("_"),
            weekdays: "Àìkú_Ajé_Ìsẹ́gun_Ọjọ́rú_Ọjọ́bọ_Ẹtì_Àbámẹ́ta".split("_"),
            weekdaysShort: "Àìk_Ajé_Ìsẹ́_Ọjr_Ọjb_Ẹtì_Àbá".split("_"),
            weekdaysMin: "Àì_Aj_Ìs_Ọr_Ọb_Ẹt_Àb".split("_"),
            longDateFormat: {
                LT: "h:mm A",
                LTS: "h:mm:ss A",
                L: "DD/MM/YYYY",
                LL: "D MMMM YYYY",
                LLL: "D MMMM YYYY h:mm A",
                LLLL: "dddd, D MMMM YYYY h:mm A"
            },
            calendar: {
                sameDay: "[Ònì ni] LT",
                nextDay: "[Ọ̀la ni] LT",
                nextWeek: "dddd [Ọsẹ̀ tón'bọ] [ni] LT",
                lastDay: "[Àna ni] LT",
                lastWeek: "dddd [Ọsẹ̀ tólọ́] [ni] LT",
                sameElse: "L"
            },
            relativeTime: {
                future: "ní %s",
                past: "%s kọjá",
                s: "ìsẹjú aayá die",
                ss: "aayá %d",
                m: "ìsẹjú kan",
                mm: "ìsẹjú %d",
                h: "wákati kan",
                hh: "wákati %d",
                d: "ọjọ́ kan",
                dd: "ọjọ́ %d",
                M: "osù kan",
                MM: "osù %d",
                y: "ọdún kan",
                yy: "ọdún %d"
            },
            dayOfMonthOrdinalParse: /ọjọ́\s\d{1,2}/,
            ordinal: "ọjọ́ %d",
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("zh-cn", {
            months: "一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月".split("_"),
            monthsShort: "1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"),
            weekdays: "星期日_星期一_星期二_星期三_星期四_星期五_星期六".split("_"),
            weekdaysShort: "周日_周一_周二_周三_周四_周五_周六".split("_"),
            weekdaysMin: "日_一_二_三_四_五_六".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "YYYY/MM/DD",
                LL: "YYYY年M月D日",
                LLL: "YYYY年M月D日Ah点mm分",
                LLLL: "YYYY年M月D日ddddAh点mm分",
                l: "YYYY/M/D",
                ll: "YYYY年M月D日",
                lll: "YYYY年M月D日 HH:mm",
                llll: "YYYY年M月D日dddd HH:mm"
            },
            meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
            meridiemHour: function(hour, meridiem) {
                return 12 === hour && (hour = 0), "凌晨" === meridiem || "早上" === meridiem || "上午" === meridiem ? hour : "下午" === meridiem || "晚上" === meridiem ? hour + 12 : hour >= 11 ? hour : hour + 12
            },
            meridiem: function(hour, minute, isLower) {
                var hm = 100 * hour + minute;
                return hm < 600 ? "凌晨" : hm < 900 ? "早上" : hm < 1130 ? "上午" : hm < 1230 ? "中午" : hm < 1800 ? "下午" : "晚上"
            },
            calendar: {
                sameDay: "[今天]LT",
                nextDay: "[明天]LT",
                nextWeek: function(now) {
                    return now.week() !== this.week() ? "[下]dddLT" : "[本]dddLT"
                },
                lastDay: "[昨天]LT",
                lastWeek: function(now) {
                    return this.week() !== now.week() ? "[上]dddLT" : "[本]dddLT"
                },
                sameElse: "L"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(日|月|周)/,
            ordinal: function(number, period) {
                switch (period) {
                    case "d":
                    case "D":
                    case "DDD":
                        return number + "日";
                    case "M":
                        return number + "月";
                    case "w":
                    case "W":
                        return number + "周";
                    default:
                        return number
                }
            },
            relativeTime: {
                future: "%s后",
                past: "%s前",
                s: "几秒",
                ss: "%d 秒",
                m: "1 分钟",
                mm: "%d 分钟",
                h: "1 小时",
                hh: "%d 小时",
                d: "1 天",
                dd: "%d 天",
                w: "1 周",
                ww: "%d 周",
                M: "1 个月",
                MM: "%d 个月",
                y: "1 年",
                yy: "%d 年"
            },
            week: {
                dow: 1,
                doy: 4
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("zh-hk", {
            months: "一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月".split("_"),
            monthsShort: "1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"),
            weekdays: "星期日_星期一_星期二_星期三_星期四_星期五_星期六".split("_"),
            weekdaysShort: "週日_週一_週二_週三_週四_週五_週六".split("_"),
            weekdaysMin: "日_一_二_三_四_五_六".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "YYYY/MM/DD",
                LL: "YYYY年M月D日",
                LLL: "YYYY年M月D日 HH:mm",
                LLLL: "YYYY年M月D日dddd HH:mm",
                l: "YYYY/M/D",
                ll: "YYYY年M月D日",
                lll: "YYYY年M月D日 HH:mm",
                llll: "YYYY年M月D日dddd HH:mm"
            },
            meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
            meridiemHour: function(hour, meridiem) {
                return 12 === hour && (hour = 0), "凌晨" === meridiem || "早上" === meridiem || "上午" === meridiem ? hour : "中午" === meridiem ? hour >= 11 ? hour : hour + 12 : "下午" === meridiem || "晚上" === meridiem ? hour + 12 : void 0
            },
            meridiem: function(hour, minute, isLower) {
                var hm = 100 * hour + minute;
                return hm < 600 ? "凌晨" : hm < 900 ? "早上" : hm < 1200 ? "上午" : 1200 === hm ? "中午" : hm < 1800 ? "下午" : "晚上"
            },
            calendar: {
                sameDay: "[今天]LT",
                nextDay: "[明天]LT",
                nextWeek: "[下]ddddLT",
                lastDay: "[昨天]LT",
                lastWeek: "[上]ddddLT",
                sameElse: "L"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(日|月|週)/,
            ordinal: function(number, period) {
                switch (period) {
                    case "d":
                    case "D":
                    case "DDD":
                        return number + "日";
                    case "M":
                        return number + "月";
                    case "w":
                    case "W":
                        return number + "週";
                    default:
                        return number
                }
            },
            relativeTime: {
                future: "%s後",
                past: "%s前",
                s: "幾秒",
                ss: "%d 秒",
                m: "1 分鐘",
                mm: "%d 分鐘",
                h: "1 小時",
                hh: "%d 小時",
                d: "1 天",
                dd: "%d 天",
                M: "1 個月",
                MM: "%d 個月",
                y: "1 年",
                yy: "%d 年"
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("zh-mo", {
            months: "一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月".split("_"),
            monthsShort: "1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"),
            weekdays: "星期日_星期一_星期二_星期三_星期四_星期五_星期六".split("_"),
            weekdaysShort: "週日_週一_週二_週三_週四_週五_週六".split("_"),
            weekdaysMin: "日_一_二_三_四_五_六".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "DD/MM/YYYY",
                LL: "YYYY年M月D日",
                LLL: "YYYY年M月D日 HH:mm",
                LLLL: "YYYY年M月D日dddd HH:mm",
                l: "D/M/YYYY",
                ll: "YYYY年M月D日",
                lll: "YYYY年M月D日 HH:mm",
                llll: "YYYY年M月D日dddd HH:mm"
            },
            meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
            meridiemHour: function(hour, meridiem) {
                return 12 === hour && (hour = 0), "凌晨" === meridiem || "早上" === meridiem || "上午" === meridiem ? hour : "中午" === meridiem ? hour >= 11 ? hour : hour + 12 : "下午" === meridiem || "晚上" === meridiem ? hour + 12 : void 0
            },
            meridiem: function(hour, minute, isLower) {
                var hm = 100 * hour + minute;
                return hm < 600 ? "凌晨" : hm < 900 ? "早上" : hm < 1130 ? "上午" : hm < 1230 ? "中午" : hm < 1800 ? "下午" : "晚上"
            },
            calendar: {
                sameDay: "[今天] LT",
                nextDay: "[明天] LT",
                nextWeek: "[下]dddd LT",
                lastDay: "[昨天] LT",
                lastWeek: "[上]dddd LT",
                sameElse: "L"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(日|月|週)/,
            ordinal: function(number, period) {
                switch (period) {
                    case "d":
                    case "D":
                    case "DDD":
                        return number + "日";
                    case "M":
                        return number + "月";
                    case "w":
                    case "W":
                        return number + "週";
                    default:
                        return number
                }
            },
            relativeTime: {
                future: "%s內",
                past: "%s前",
                s: "幾秒",
                ss: "%d 秒",
                m: "1 分鐘",
                mm: "%d 分鐘",
                h: "1 小時",
                hh: "%d 小時",
                d: "1 天",
                dd: "%d 天",
                M: "1 個月",
                MM: "%d 個月",
                y: "1 年",
                yy: "%d 年"
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    ! function(moment) {
        "use strict";
        moment.defineLocale("zh-tw", {
            months: "一月_二月_三月_四月_五月_六月_七月_八月_九月_十月_十一月_十二月".split("_"),
            monthsShort: "1月_2月_3月_4月_5月_6月_7月_8月_9月_10月_11月_12月".split("_"),
            weekdays: "星期日_星期一_星期二_星期三_星期四_星期五_星期六".split("_"),
            weekdaysShort: "週日_週一_週二_週三_週四_週五_週六".split("_"),
            weekdaysMin: "日_一_二_三_四_五_六".split("_"),
            longDateFormat: {
                LT: "HH:mm",
                LTS: "HH:mm:ss",
                L: "YYYY/MM/DD",
                LL: "YYYY年M月D日",
                LLL: "YYYY年M月D日 HH:mm",
                LLLL: "YYYY年M月D日dddd HH:mm",
                l: "YYYY/M/D",
                ll: "YYYY年M月D日",
                lll: "YYYY年M月D日 HH:mm",
                llll: "YYYY年M月D日dddd HH:mm"
            },
            meridiemParse: /凌晨|早上|上午|中午|下午|晚上/,
            meridiemHour: function(hour, meridiem) {
                return 12 === hour && (hour = 0), "凌晨" === meridiem || "早上" === meridiem || "上午" === meridiem ? hour : "中午" === meridiem ? hour >= 11 ? hour : hour + 12 : "下午" === meridiem || "晚上" === meridiem ? hour + 12 : void 0
            },
            meridiem: function(hour, minute, isLower) {
                var hm = 100 * hour + minute;
                return hm < 600 ? "凌晨" : hm < 900 ? "早上" : hm < 1130 ? "上午" : hm < 1230 ? "中午" : hm < 1800 ? "下午" : "晚上"
            },
            calendar: {
                sameDay: "[今天] LT",
                nextDay: "[明天] LT",
                nextWeek: "[下]dddd LT",
                lastDay: "[昨天] LT",
                lastWeek: "[上]dddd LT",
                sameElse: "L"
            },
            dayOfMonthOrdinalParse: /\d{1,2}(日|月|週)/,
            ordinal: function(number, period) {
                switch (period) {
                    case "d":
                    case "D":
                    case "DDD":
                        return number + "日";
                    case "M":
                        return number + "月";
                    case "w":
                    case "W":
                        return number + "週";
                    default:
                        return number
                }
            },
            relativeTime: {
                future: "%s後",
                past: "%s前",
                s: "幾秒",
                ss: "%d 秒",
                m: "1 分鐘",
                mm: "%d 分鐘",
                h: "1 小時",
                hh: "%d 小時",
                d: "1 天",
                dd: "%d 天",
                M: "1 個月",
                MM: "%d 個月",
                y: "1 年",
                yy: "%d 年"
            }
        })
    }(__webpack_require__(3))
}, function(module, exports, __webpack_require__) {
    var ___EXPOSE_LOADER_IMPORT___ = __webpack_require__(263),
        ___EXPOSE_LOADER_GLOBAL_THIS___ = __webpack_require__(101);
    void 0 === ___EXPOSE_LOADER_GLOBAL_THIS___.$ && (___EXPOSE_LOADER_GLOBAL_THIS___.$ = ___EXPOSE_LOADER_IMPORT___), void 0 === ___EXPOSE_LOADER_GLOBAL_THIS___.jQuery && (___EXPOSE_LOADER_GLOBAL_THIS___.jQuery = ___EXPOSE_LOADER_IMPORT___), module.exports = ___EXPOSE_LOADER_IMPORT___
}, function(module, exports) {}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return ParamTypes
    }));
    var makeDefaultType, _common_common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(2),
        _common_predicates__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4),
        _common_hof__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(5),
        _common_coreservices__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(9),
        _paramType__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(42),
        ParamTypes = function() {
            function ParamTypes() {
                this.enqueue = !0, this.typeQueue = [], this.defaultTypes = Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.z)(ParamTypes.prototype, ["hash", "string", "query", "path", "int", "bool", "date", "json", "any"]);
                this.types = Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.t)(Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.u)(this.defaultTypes, (function(definition, name) {
                    return new _paramType__WEBPACK_IMPORTED_MODULE_4__.a(Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.l)({
                        name: name
                    }, definition))
                })), {})
            }
            return ParamTypes.prototype.dispose = function() {
                this.types = {}
            }, ParamTypes.prototype.type = function(name, definition, definitionFn) {
                if (!Object(_common_predicates__WEBPACK_IMPORTED_MODULE_1__.c)(definition)) return this.types[name];
                if (this.types.hasOwnProperty(name)) throw new Error("A type named '" + name + "' has already been defined.");
                return this.types[name] = new _paramType__WEBPACK_IMPORTED_MODULE_4__.a(Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.l)({
                    name: name
                }, definition)), definitionFn && (this.typeQueue.push({
                    name: name,
                    def: definitionFn
                }), this.enqueue || this._flushTypeQueue()), this
            }, ParamTypes.prototype._flushTypeQueue = function() {
                for (; this.typeQueue.length;) {
                    var type = this.typeQueue.shift();
                    if (type.pattern) throw new Error("You cannot override a type's .pattern at runtime.");
                    Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.l)(this.types[type.name], _common_coreservices__WEBPACK_IMPORTED_MODULE_3__.b.$injector.invoke(type.def))
                }
            }, ParamTypes
        }();
    makeDefaultType = function(def) {
        var valToString = function(val) {
                return null != val ? val.toString() : val
            },
            defaultTypeBase = {
                encode: valToString,
                decode: valToString,
                is: Object(_common_hof__WEBPACK_IMPORTED_MODULE_2__.e)(String),
                pattern: /.*/,
                equals: function(a, b) {
                    return a == b
                }
            };
        return Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.l)({}, defaultTypeBase, def)
    }, Object(_common_common__WEBPACK_IMPORTED_MODULE_0__.l)(ParamTypes.prototype, {
        string: makeDefaultType({}),
        path: makeDefaultType({
            pattern: /[^/]*/
        }),
        query: makeDefaultType({}),
        hash: makeDefaultType({
            inherit: !1
        }),
        int: makeDefaultType({
            decode: function(val) {
                return parseInt(val, 10)
            },
            is: function(val) {
                return !Object(_common_predicates__WEBPACK_IMPORTED_MODULE_1__.g)(val) && this.decode(val.toString()) === val
            },
            pattern: /-?\d+/
        }),
        bool: makeDefaultType({
            encode: function(val) {
                return val ? 1 : 0
            },
            decode: function(val) {
                return 0 !== parseInt(val, 10)
            },
            is: Object(_common_hof__WEBPACK_IMPORTED_MODULE_2__.e)(Boolean),
            pattern: /0|1/
        }),
        date: makeDefaultType({
            encode: function(val) {
                return this.is(val) ? [val.getFullYear(), ("0" + (val.getMonth() + 1)).slice(-2), ("0" + val.getDate()).slice(-2)].join("-") : void 0
            },
            decode: function(val) {
                if (this.is(val)) return val;
                var match = this.capture.exec(val);
                return match ? new Date(match[1], match[2] - 1, match[3]) : void 0
            },
            is: function(val) {
                return val instanceof Date && !isNaN(val.valueOf())
            },
            equals: function(l, r) {
                return ["getFullYear", "getMonth", "getDate"].reduce((function(acc, fn) {
                    return acc && l[fn]() === r[fn]()
                }), !0)
            },
            pattern: /[0-9]{4}-(?:0[1-9]|1[0-2])-(?:0[1-9]|[1-2][0-9]|3[0-1])/,
            capture: /([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[1-2][0-9]|3[0-1])/
        }),
        json: makeDefaultType({
            encode: _common_common__WEBPACK_IMPORTED_MODULE_0__.H,
            decode: _common_common__WEBPACK_IMPORTED_MODULE_0__.q,
            is: Object(_common_hof__WEBPACK_IMPORTED_MODULE_2__.e)(Object),
            equals: _common_common__WEBPACK_IMPORTED_MODULE_0__.k,
            pattern: /[^/]*/
        }),
        any: makeDefaultType({
            encode: _common_common__WEBPACK_IMPORTED_MODULE_0__.r,
            decode: _common_common__WEBPACK_IMPORTED_MODULE_0__.r,
            is: function() {
                return !0
            },
            equals: _common_common__WEBPACK_IMPORTED_MODULE_0__.k
        })
    })
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__(43);
    var _pathUtils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(21);
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return _pathUtils__WEBPACK_IMPORTED_MODULE_1__.a
    }))
}, function(module, exports) {}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__(17), __webpack_require__(72), __webpack_require__(38), __webpack_require__(13), __webpack_require__(44), __webpack_require__(20), __webpack_require__(81);
    var _transitionService__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(47);
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return _transitionService__WEBPACK_IMPORTED_MODULE_7__.a
    }))
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var _interface__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(247);
    __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "BaseLocationServices") && __webpack_require__.d(__webpack_exports__, "BaseLocationServices", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.BaseLocationServices
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "BaseUrlRule") && __webpack_require__.d(__webpack_exports__, "BaseUrlRule", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.BaseUrlRule
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "BrowserLocationConfig") && __webpack_require__.d(__webpack_exports__, "BrowserLocationConfig", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.BrowserLocationConfig
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "Param") && __webpack_require__.d(__webpack_exports__, "Param", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.Param
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "StateRegistry") && __webpack_require__.d(__webpack_exports__, "StateRegistry", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.StateRegistry
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "StateService") && __webpack_require__.d(__webpack_exports__, "StateService", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.StateService
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "UIRouter") && __webpack_require__.d(__webpack_exports__, "UIRouter", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.UIRouter
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "UIRouterGlobals") && __webpack_require__.d(__webpack_exports__, "UIRouterGlobals", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.UIRouterGlobals
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "UrlMatcherFactory") && __webpack_require__.d(__webpack_exports__, "UrlMatcherFactory", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.UrlMatcherFactory
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "UrlRouter") && __webpack_require__.d(__webpack_exports__, "UrlRouter", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.UrlRouter
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "UrlService") && __webpack_require__.d(__webpack_exports__, "UrlService", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.UrlService
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "ViewService") && __webpack_require__.d(__webpack_exports__, "ViewService", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.ViewService
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "parseUrl") && __webpack_require__.d(__webpack_exports__, "parseUrl", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.parseUrl
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "servicesPlugin") && __webpack_require__.d(__webpack_exports__, "servicesPlugin", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.servicesPlugin
    }));
    __webpack_require__(29);
    var _urlMatcherFactory__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(74);
    __webpack_require__.d(__webpack_exports__, "UrlMatcherFactory", (function() {
        return _urlMatcherFactory__WEBPACK_IMPORTED_MODULE_2__.a
    }));
    var _urlRouter__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(75);
    __webpack_require__.d(__webpack_exports__, "UrlRouter", (function() {
        return _urlRouter__WEBPACK_IMPORTED_MODULE_3__.a
    }));
    var _urlRule__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(45);
    __webpack_require__.d(__webpack_exports__, "BaseUrlRule", (function() {
        return _urlRule__WEBPACK_IMPORTED_MODULE_4__.a
    }));
    var _urlService__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(78);
    __webpack_require__.d(__webpack_exports__, "UrlService", (function() {
        return _urlService__WEBPACK_IMPORTED_MODULE_5__.a
    }));
    __webpack_require__(79), __webpack_require__(80)
}, function(module, exports) {}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var _interface__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(249);
    __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "BaseLocationServices") && __webpack_require__.d(__webpack_exports__, "BaseLocationServices", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.BaseLocationServices
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "BaseUrlRule") && __webpack_require__.d(__webpack_exports__, "BaseUrlRule", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.BaseUrlRule
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "BrowserLocationConfig") && __webpack_require__.d(__webpack_exports__, "BrowserLocationConfig", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.BrowserLocationConfig
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "Param") && __webpack_require__.d(__webpack_exports__, "Param", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.Param
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "StateRegistry") && __webpack_require__.d(__webpack_exports__, "StateRegistry", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.StateRegistry
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "StateService") && __webpack_require__.d(__webpack_exports__, "StateService", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.StateService
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "UIRouter") && __webpack_require__.d(__webpack_exports__, "UIRouter", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.UIRouter
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "UIRouterGlobals") && __webpack_require__.d(__webpack_exports__, "UIRouterGlobals", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.UIRouterGlobals
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "UrlMatcherFactory") && __webpack_require__.d(__webpack_exports__, "UrlMatcherFactory", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.UrlMatcherFactory
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "UrlRouter") && __webpack_require__.d(__webpack_exports__, "UrlRouter", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.UrlRouter
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "UrlService") && __webpack_require__.d(__webpack_exports__, "UrlService", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.UrlService
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "ViewService") && __webpack_require__.d(__webpack_exports__, "ViewService", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.ViewService
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "parseUrl") && __webpack_require__.d(__webpack_exports__, "parseUrl", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.parseUrl
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "servicesPlugin") && __webpack_require__.d(__webpack_exports__, "servicesPlugin", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.servicesPlugin
    }));
    var _view__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(76);
    __webpack_require__.d(__webpack_exports__, "ViewService", (function() {
        return _view__WEBPACK_IMPORTED_MODULE_1__.a
    }))
}, function(module, exports) {}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var _vanilla_index__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(251);
    __webpack_require__.o(_vanilla_index__WEBPACK_IMPORTED_MODULE_0__, "BaseLocationServices") && __webpack_require__.d(__webpack_exports__, "BaseLocationServices", (function() {
        return _vanilla_index__WEBPACK_IMPORTED_MODULE_0__.BaseLocationServices
    })), __webpack_require__.o(_vanilla_index__WEBPACK_IMPORTED_MODULE_0__, "BaseUrlRule") && __webpack_require__.d(__webpack_exports__, "BaseUrlRule", (function() {
        return _vanilla_index__WEBPACK_IMPORTED_MODULE_0__.BaseUrlRule
    })), __webpack_require__.o(_vanilla_index__WEBPACK_IMPORTED_MODULE_0__, "BrowserLocationConfig") && __webpack_require__.d(__webpack_exports__, "BrowserLocationConfig", (function() {
        return _vanilla_index__WEBPACK_IMPORTED_MODULE_0__.BrowserLocationConfig
    })), __webpack_require__.o(_vanilla_index__WEBPACK_IMPORTED_MODULE_0__, "Param") && __webpack_require__.d(__webpack_exports__, "Param", (function() {
        return _vanilla_index__WEBPACK_IMPORTED_MODULE_0__.Param
    })), __webpack_require__.o(_vanilla_index__WEBPACK_IMPORTED_MODULE_0__, "StateRegistry") && __webpack_require__.d(__webpack_exports__, "StateRegistry", (function() {
        return _vanilla_index__WEBPACK_IMPORTED_MODULE_0__.StateRegistry
    })), __webpack_require__.o(_vanilla_index__WEBPACK_IMPORTED_MODULE_0__, "StateService") && __webpack_require__.d(__webpack_exports__, "StateService", (function() {
        return _vanilla_index__WEBPACK_IMPORTED_MODULE_0__.StateService
    })), __webpack_require__.o(_vanilla_index__WEBPACK_IMPORTED_MODULE_0__, "UrlMatcherFactory") && __webpack_require__.d(__webpack_exports__, "UrlMatcherFactory", (function() {
        return _vanilla_index__WEBPACK_IMPORTED_MODULE_0__.UrlMatcherFactory
    })), __webpack_require__.o(_vanilla_index__WEBPACK_IMPORTED_MODULE_0__, "UrlRouter") && __webpack_require__.d(__webpack_exports__, "UrlRouter", (function() {
        return _vanilla_index__WEBPACK_IMPORTED_MODULE_0__.UrlRouter
    })), __webpack_require__.o(_vanilla_index__WEBPACK_IMPORTED_MODULE_0__, "UrlService") && __webpack_require__.d(__webpack_exports__, "UrlService", (function() {
        return _vanilla_index__WEBPACK_IMPORTED_MODULE_0__.UrlService
    })), __webpack_require__.o(_vanilla_index__WEBPACK_IMPORTED_MODULE_0__, "ViewService") && __webpack_require__.d(__webpack_exports__, "ViewService", (function() {
        return _vanilla_index__WEBPACK_IMPORTED_MODULE_0__.ViewService
    })), __webpack_require__.o(_vanilla_index__WEBPACK_IMPORTED_MODULE_0__, "parseUrl") && __webpack_require__.d(__webpack_exports__, "parseUrl", (function() {
        return _vanilla_index__WEBPACK_IMPORTED_MODULE_0__.parseUrl
    })), __webpack_require__.o(_vanilla_index__WEBPACK_IMPORTED_MODULE_0__, "servicesPlugin") && __webpack_require__.d(__webpack_exports__, "servicesPlugin", (function() {
        return _vanilla_index__WEBPACK_IMPORTED_MODULE_0__.servicesPlugin
    }))
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var _interface__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(252);
    __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "BaseLocationServices") && __webpack_require__.d(__webpack_exports__, "BaseLocationServices", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.BaseLocationServices
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "BaseUrlRule") && __webpack_require__.d(__webpack_exports__, "BaseUrlRule", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.BaseUrlRule
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "BrowserLocationConfig") && __webpack_require__.d(__webpack_exports__, "BrowserLocationConfig", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.BrowserLocationConfig
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "Param") && __webpack_require__.d(__webpack_exports__, "Param", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.Param
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "StateRegistry") && __webpack_require__.d(__webpack_exports__, "StateRegistry", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.StateRegistry
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "StateService") && __webpack_require__.d(__webpack_exports__, "StateService", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.StateService
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "UrlMatcherFactory") && __webpack_require__.d(__webpack_exports__, "UrlMatcherFactory", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.UrlMatcherFactory
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "UrlRouter") && __webpack_require__.d(__webpack_exports__, "UrlRouter", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.UrlRouter
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "UrlService") && __webpack_require__.d(__webpack_exports__, "UrlService", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.UrlService
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "ViewService") && __webpack_require__.d(__webpack_exports__, "ViewService", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.ViewService
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "parseUrl") && __webpack_require__.d(__webpack_exports__, "parseUrl", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.parseUrl
    })), __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "servicesPlugin") && __webpack_require__.d(__webpack_exports__, "servicesPlugin", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.servicesPlugin
    }));
    __webpack_require__(58), __webpack_require__(59);
    var _baseLocationService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(35);
    __webpack_require__.d(__webpack_exports__, "BaseLocationServices", (function() {
        return _baseLocationService__WEBPACK_IMPORTED_MODULE_3__.a
    }));
    __webpack_require__(82), __webpack_require__(83), __webpack_require__(84), __webpack_require__(85);
    var _browserLocationConfig__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(60);
    __webpack_require__.d(__webpack_exports__, "BrowserLocationConfig", (function() {
        return _browserLocationConfig__WEBPACK_IMPORTED_MODULE_8__.a
    }));
    var _utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(28);
    __webpack_require__.d(__webpack_exports__, "parseUrl", (function() {
        return _utils__WEBPACK_IMPORTED_MODULE_9__.d
    }));
    var _plugins__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(253);
    __webpack_require__.d(__webpack_exports__, "servicesPlugin", (function() {
        return _plugins__WEBPACK_IMPORTED_MODULE_10__.a
    }))
}, function(module, exports) {}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return servicesPlugin
    }));
    var _browserLocationConfig__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(60),
        _hashLocationService__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(82),
        _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(28),
        _pushStateLocationService__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(84),
        _memoryLocationService__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(83),
        _memoryLocationConfig__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(85),
        _injector__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(59),
        _q__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(58),
        _common_coreservices__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(9);

    function servicesPlugin(router) {
        return _common_coreservices__WEBPACK_IMPORTED_MODULE_8__.b.$injector = _injector__WEBPACK_IMPORTED_MODULE_6__.a, _common_coreservices__WEBPACK_IMPORTED_MODULE_8__.b.$q = _q__WEBPACK_IMPORTED_MODULE_7__.a, {
            name: "vanilla.services",
            $q: _q__WEBPACK_IMPORTED_MODULE_7__.a,
            $injector: _injector__WEBPACK_IMPORTED_MODULE_6__.a,
            dispose: function() {
                return null
            }
        }
    }
    Object(_utils__WEBPACK_IMPORTED_MODULE_2__.c)("vanilla.hashBangLocation", !1, _hashLocationService__WEBPACK_IMPORTED_MODULE_1__.a, _browserLocationConfig__WEBPACK_IMPORTED_MODULE_0__.a), Object(_utils__WEBPACK_IMPORTED_MODULE_2__.c)("vanilla.pushStateLocation", !0, _pushStateLocationService__WEBPACK_IMPORTED_MODULE_3__.a, _browserLocationConfig__WEBPACK_IMPORTED_MODULE_0__.a), Object(_utils__WEBPACK_IMPORTED_MODULE_2__.c)("vanilla.memoryLocation", !1, _memoryLocationService__WEBPACK_IMPORTED_MODULE_4__.a, _memoryLocationConfig__WEBPACK_IMPORTED_MODULE_5__.a)
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    ! function() {
        function UIRouterPluginBase() {}
        UIRouterPluginBase.prototype.dispose = function(router) {}
    }()
}, function(module, exports) {}, function(module, exports) {
    function webpackEmptyAsyncContext(req) {
        return Promise.resolve().then((function() {
            var e = new Error("Cannot find module '" + req + "'");
            throw e.code = "MODULE_NOT_FOUND", e
        }))
    }
    webpackEmptyAsyncContext.keys = function() {
        return []
    }, webpackEmptyAsyncContext.resolve = webpackEmptyAsyncContext, module.exports = webpackEmptyAsyncContext, webpackEmptyAsyncContext.id = 256
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var _interface__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(255);
    __webpack_require__.o(_interface__WEBPACK_IMPORTED_MODULE_0__, "Ng1ViewConfig") && __webpack_require__.d(__webpack_exports__, "Ng1ViewConfig", (function() {
        return _interface__WEBPACK_IMPORTED_MODULE_0__.Ng1ViewConfig
    }));
    __webpack_require__(88);
    var _statebuilders_views__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(46);
    __webpack_require__.d(__webpack_exports__, "Ng1ViewConfig", (function() {
        return _statebuilders_views__WEBPACK_IMPORTED_MODULE_2__.a
    }));
    __webpack_require__(86), __webpack_require__(87), __webpack_require__(266), __webpack_require__(267), __webpack_require__(268), __webpack_require__(269), __webpack_require__(270), __webpack_require__(1)
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return mergeMap
    }));
    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7),
        _map__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(63),
        _observable_from__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(64),
        _innerSubscribe__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(40);

    function mergeMap(project, resultSelector, concurrent) {
        return void 0 === concurrent && (concurrent = Number.POSITIVE_INFINITY), "function" == typeof resultSelector ? function(source) {
            return source.pipe(mergeMap((function(a, i) {
                return Object(_observable_from__WEBPACK_IMPORTED_MODULE_2__.a)(project(a, i)).pipe(Object(_map__WEBPACK_IMPORTED_MODULE_1__.a)((function(b, ii) {
                    return resultSelector(a, b, i, ii)
                })))
            }), concurrent))
        } : ("number" == typeof resultSelector && (concurrent = resultSelector), function(source) {
            return source.lift(new MergeMapOperator(project, concurrent))
        })
    }
    var MergeMapOperator = function() {
            function MergeMapOperator(project, concurrent) {
                void 0 === concurrent && (concurrent = Number.POSITIVE_INFINITY), this.project = project, this.concurrent = concurrent
            }
            return MergeMapOperator.prototype.call = function(observer, source) {
                return source.subscribe(new MergeMapSubscriber(observer, this.project, this.concurrent))
            }, MergeMapOperator
        }(),
        MergeMapSubscriber = function(_super) {
            function MergeMapSubscriber(destination, project, concurrent) {
                void 0 === concurrent && (concurrent = Number.POSITIVE_INFINITY);
                var _this = _super.call(this, destination) || this;
                return _this.project = project, _this.concurrent = concurrent, _this.hasCompleted = !1, _this.buffer = [], _this.active = 0, _this.index = 0, _this
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(MergeMapSubscriber, _super), MergeMapSubscriber.prototype._next = function(value) {
                this.active < this.concurrent ? this._tryNext(value) : this.buffer.push(value)
            }, MergeMapSubscriber.prototype._tryNext = function(value) {
                var result, index = this.index++;
                try {
                    result = this.project(value, index)
                } catch (err) {
                    return void this.destination.error(err)
                }
                this.active++, this._innerSub(result)
            }, MergeMapSubscriber.prototype._innerSub = function(ish) {
                var innerSubscriber = new _innerSubscribe__WEBPACK_IMPORTED_MODULE_3__.a(this),
                    destination = this.destination;
                destination.add(innerSubscriber);
                var innerSubscription = Object(_innerSubscribe__WEBPACK_IMPORTED_MODULE_3__.c)(ish, innerSubscriber);
                innerSubscription !== innerSubscriber && destination.add(innerSubscription)
            }, MergeMapSubscriber.prototype._complete = function() {
                this.hasCompleted = !0, 0 === this.active && 0 === this.buffer.length && this.destination.complete(), this.unsubscribe()
            }, MergeMapSubscriber.prototype.notifyNext = function(innerValue) {
                this.destination.next(innerValue)
            }, MergeMapSubscriber.prototype.notifyComplete = function() {
                var buffer = this.buffer;
                this.active--, buffer.length > 0 ? this._next(buffer.shift()) : 0 === this.active && this.hasCompleted && this.destination.complete()
            }, MergeMapSubscriber
        }(_innerSubscribe__WEBPACK_IMPORTED_MODULE_3__.b)
}, function(module, exports, __webpack_require__) {
    __webpack_require__(3), __webpack_require__(262), __webpack_require__(240), __webpack_require__(264), __webpack_require__(50), __webpack_require__(280), __webpack_require__(272), __webpack_require__(273), __webpack_require__(275), __webpack_require__(277), __webpack_require__(278), module.exports = __webpack_require__(279)
}, function(module, exports, __webpack_require__) {
    (function(module) {
        module.exports = function() {
            "use strict";
            var hookCallback, some;

            function hooks() {
                return hookCallback.apply(null, arguments)
            }

            function setHookCallback(callback) {
                hookCallback = callback
            }

            function isArray(input) {
                return input instanceof Array || "[object Array]" === Object.prototype.toString.call(input)
            }

            function isObject(input) {
                return null != input && "[object Object]" === Object.prototype.toString.call(input)
            }

            function hasOwnProp(a, b) {
                return Object.prototype.hasOwnProperty.call(a, b)
            }

            function isObjectEmpty(obj) {
                if (Object.getOwnPropertyNames) return 0 === Object.getOwnPropertyNames(obj).length;
                var k;
                for (k in obj)
                    if (hasOwnProp(obj, k)) return !1;
                return !0
            }

            function isUndefined(input) {
                return void 0 === input
            }

            function isNumber(input) {
                return "number" == typeof input || "[object Number]" === Object.prototype.toString.call(input)
            }

            function isDate(input) {
                return input instanceof Date || "[object Date]" === Object.prototype.toString.call(input)
            }

            function map(arr, fn) {
                var i, res = [];
                for (i = 0; i < arr.length; ++i) res.push(fn(arr[i], i));
                return res
            }

            function extend(a, b) {
                for (var i in b) hasOwnProp(b, i) && (a[i] = b[i]);
                return hasOwnProp(b, "toString") && (a.toString = b.toString), hasOwnProp(b, "valueOf") && (a.valueOf = b.valueOf), a
            }

            function createUTC(input, format, locale, strict) {
                return createLocalOrUTC(input, format, locale, strict, !0).utc()
            }

            function defaultParsingFlags() {
                return {
                    empty: !1,
                    unusedTokens: [],
                    unusedInput: [],
                    overflow: -2,
                    charsLeftOver: 0,
                    nullInput: !1,
                    invalidEra: null,
                    invalidMonth: null,
                    invalidFormat: !1,
                    userInvalidated: !1,
                    iso: !1,
                    parsedDateParts: [],
                    era: null,
                    meridiem: null,
                    rfc2822: !1,
                    weekdayMismatch: !1
                }
            }

            function getParsingFlags(m) {
                return null == m._pf && (m._pf = defaultParsingFlags()), m._pf
            }

            function isValid(m) {
                if (null == m._isValid) {
                    var flags = getParsingFlags(m),
                        parsedParts = some.call(flags.parsedDateParts, (function(i) {
                            return null != i
                        })),
                        isNowValid = !isNaN(m._d.getTime()) && flags.overflow < 0 && !flags.empty && !flags.invalidEra && !flags.invalidMonth && !flags.invalidWeekday && !flags.weekdayMismatch && !flags.nullInput && !flags.invalidFormat && !flags.userInvalidated && (!flags.meridiem || flags.meridiem && parsedParts);
                    if (m._strict && (isNowValid = isNowValid && 0 === flags.charsLeftOver && 0 === flags.unusedTokens.length && void 0 === flags.bigHour), null != Object.isFrozen && Object.isFrozen(m)) return isNowValid;
                    m._isValid = isNowValid
                }
                return m._isValid
            }

            function createInvalid(flags) {
                var m = createUTC(NaN);
                return null != flags ? extend(getParsingFlags(m), flags) : getParsingFlags(m).userInvalidated = !0, m
            }
            some = Array.prototype.some ? Array.prototype.some : function(fun) {
                var i, t = Object(this),
                    len = t.length >>> 0;
                for (i = 0; i < len; i++)
                    if (i in t && fun.call(this, t[i], i, t)) return !0;
                return !1
            };
            var momentProperties = hooks.momentProperties = [],
                updateInProgress = !1;

            function copyConfig(to, from) {
                var i, prop, val;
                if (isUndefined(from._isAMomentObject) || (to._isAMomentObject = from._isAMomentObject), isUndefined(from._i) || (to._i = from._i), isUndefined(from._f) || (to._f = from._f), isUndefined(from._l) || (to._l = from._l), isUndefined(from._strict) || (to._strict = from._strict), isUndefined(from._tzm) || (to._tzm = from._tzm), isUndefined(from._isUTC) || (to._isUTC = from._isUTC), isUndefined(from._offset) || (to._offset = from._offset), isUndefined(from._pf) || (to._pf = getParsingFlags(from)), isUndefined(from._locale) || (to._locale = from._locale), momentProperties.length > 0)
                    for (i = 0; i < momentProperties.length; i++) isUndefined(val = from[prop = momentProperties[i]]) || (to[prop] = val);
                return to
            }

            function Moment(config) {
                copyConfig(this, config), this._d = new Date(null != config._d ? config._d.getTime() : NaN), this.isValid() || (this._d = new Date(NaN)), !1 === updateInProgress && (updateInProgress = !0, hooks.updateOffset(this), updateInProgress = !1)
            }

            function isMoment(obj) {
                return obj instanceof Moment || null != obj && null != obj._isAMomentObject
            }

            function warn(msg) {
                !1 === hooks.suppressDeprecationWarnings && "undefined" != typeof console && console.warn && console.warn("Deprecation warning: " + msg)
            }

            function deprecate(msg, fn) {
                var firstTime = !0;
                return extend((function() {
                    if (null != hooks.deprecationHandler && hooks.deprecationHandler(null, msg), firstTime) {
                        var arg, i, key, args = [];
                        for (i = 0; i < arguments.length; i++) {
                            if (arg = "", "object" == typeof arguments[i]) {
                                for (key in arg += "\n[" + i + "] ", arguments[0]) hasOwnProp(arguments[0], key) && (arg += key + ": " + arguments[0][key] + ", ");
                                arg = arg.slice(0, -2)
                            } else arg = arguments[i];
                            args.push(arg)
                        }
                        warn(msg + "\nArguments: " + Array.prototype.slice.call(args).join("") + "\n" + (new Error).stack), firstTime = !1
                    }
                    return fn.apply(this, arguments)
                }), fn)
            }
            var keys, deprecations = {};

            function deprecateSimple(name, msg) {
                null != hooks.deprecationHandler && hooks.deprecationHandler(name, msg), deprecations[name] || (warn(msg), deprecations[name] = !0)
            }

            function isFunction(input) {
                return "undefined" != typeof Function && input instanceof Function || "[object Function]" === Object.prototype.toString.call(input)
            }

            function set(config) {
                var prop, i;
                for (i in config) hasOwnProp(config, i) && (isFunction(prop = config[i]) ? this[i] = prop : this["_" + i] = prop);
                this._config = config, this._dayOfMonthOrdinalParseLenient = new RegExp((this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source)
            }

            function mergeConfigs(parentConfig, childConfig) {
                var prop, res = extend({}, parentConfig);
                for (prop in childConfig) hasOwnProp(childConfig, prop) && (isObject(parentConfig[prop]) && isObject(childConfig[prop]) ? (res[prop] = {}, extend(res[prop], parentConfig[prop]), extend(res[prop], childConfig[prop])) : null != childConfig[prop] ? res[prop] = childConfig[prop] : delete res[prop]);
                for (prop in parentConfig) hasOwnProp(parentConfig, prop) && !hasOwnProp(childConfig, prop) && isObject(parentConfig[prop]) && (res[prop] = extend({}, res[prop]));
                return res
            }

            function Locale(config) {
                null != config && this.set(config)
            }
            hooks.suppressDeprecationWarnings = !1, hooks.deprecationHandler = null, keys = Object.keys ? Object.keys : function(obj) {
                var i, res = [];
                for (i in obj) hasOwnProp(obj, i) && res.push(i);
                return res
            };
            var defaultCalendar = {
                sameDay: "[Today at] LT",
                nextDay: "[Tomorrow at] LT",
                nextWeek: "dddd [at] LT",
                lastDay: "[Yesterday at] LT",
                lastWeek: "[Last] dddd [at] LT",
                sameElse: "L"
            };

            function calendar(key, mom, now) {
                var output = this._calendar[key] || this._calendar.sameElse;
                return isFunction(output) ? output.call(mom, now) : output
            }

            function zeroFill(number, targetLength, forceSign) {
                var absNumber = "" + Math.abs(number),
                    zerosToFill = targetLength - absNumber.length;
                return (number >= 0 ? forceSign ? "+" : "" : "-") + Math.pow(10, Math.max(0, zerosToFill)).toString().substr(1) + absNumber
            }
            var formattingTokens = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g,
                localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g,
                formatFunctions = {},
                formatTokenFunctions = {};

            function addFormatToken(token, padded, ordinal, callback) {
                var func = callback;
                "string" == typeof callback && (func = function() {
                    return this[callback]()
                }), token && (formatTokenFunctions[token] = func), padded && (formatTokenFunctions[padded[0]] = function() {
                    return zeroFill(func.apply(this, arguments), padded[1], padded[2])
                }), ordinal && (formatTokenFunctions[ordinal] = function() {
                    return this.localeData().ordinal(func.apply(this, arguments), token)
                })
            }

            function removeFormattingTokens(input) {
                return input.match(/\[[\s\S]/) ? input.replace(/^\[|\]$/g, "") : input.replace(/\\/g, "")
            }

            function makeFormatFunction(format) {
                var i, length, array = format.match(formattingTokens);
                for (i = 0, length = array.length; i < length; i++) formatTokenFunctions[array[i]] ? array[i] = formatTokenFunctions[array[i]] : array[i] = removeFormattingTokens(array[i]);
                return function(mom) {
                    var i, output = "";
                    for (i = 0; i < length; i++) output += isFunction(array[i]) ? array[i].call(mom, format) : array[i];
                    return output
                }
            }

            function formatMoment(m, format) {
                return m.isValid() ? (format = expandFormat(format, m.localeData()), formatFunctions[format] = formatFunctions[format] || makeFormatFunction(format), formatFunctions[format](m)) : m.localeData().invalidDate()
            }

            function expandFormat(format, locale) {
                var i = 5;

                function replaceLongDateFormatTokens(input) {
                    return locale.longDateFormat(input) || input
                }
                for (localFormattingTokens.lastIndex = 0; i >= 0 && localFormattingTokens.test(format);) format = format.replace(localFormattingTokens, replaceLongDateFormatTokens), localFormattingTokens.lastIndex = 0, i -= 1;
                return format
            }
            var defaultLongDateFormat = {
                LTS: "h:mm:ss A",
                LT: "h:mm A",
                L: "MM/DD/YYYY",
                LL: "MMMM D, YYYY",
                LLL: "MMMM D, YYYY h:mm A",
                LLLL: "dddd, MMMM D, YYYY h:mm A"
            };

            function longDateFormat(key) {
                var format = this._longDateFormat[key],
                    formatUpper = this._longDateFormat[key.toUpperCase()];
                return format || !formatUpper ? format : (this._longDateFormat[key] = formatUpper.match(formattingTokens).map((function(tok) {
                    return "MMMM" === tok || "MM" === tok || "DD" === tok || "dddd" === tok ? tok.slice(1) : tok
                })).join(""), this._longDateFormat[key])
            }
            var defaultInvalidDate = "Invalid date";

            function invalidDate() {
                return this._invalidDate
            }
            var defaultOrdinal = "%d",
                defaultDayOfMonthOrdinalParse = /\d{1,2}/;

            function ordinal(number) {
                return this._ordinal.replace("%d", number)
            }
            var defaultRelativeTime = {
                future: "in %s",
                past: "%s ago",
                s: "a few seconds",
                ss: "%d seconds",
                m: "a minute",
                mm: "%d minutes",
                h: "an hour",
                hh: "%d hours",
                d: "a day",
                dd: "%d days",
                w: "a week",
                ww: "%d weeks",
                M: "a month",
                MM: "%d months",
                y: "a year",
                yy: "%d years"
            };

            function relativeTime(number, withoutSuffix, string, isFuture) {
                var output = this._relativeTime[string];
                return isFunction(output) ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number)
            }

            function pastFuture(diff, output) {
                var format = this._relativeTime[diff > 0 ? "future" : "past"];
                return isFunction(format) ? format(output) : format.replace(/%s/i, output)
            }
            var aliases = {};

            function addUnitAlias(unit, shorthand) {
                var lowerCase = unit.toLowerCase();
                aliases[lowerCase] = aliases[lowerCase + "s"] = aliases[shorthand] = unit
            }

            function normalizeUnits(units) {
                return "string" == typeof units ? aliases[units] || aliases[units.toLowerCase()] : void 0
            }

            function normalizeObjectUnits(inputObject) {
                var normalizedProp, prop, normalizedInput = {};
                for (prop in inputObject) hasOwnProp(inputObject, prop) && (normalizedProp = normalizeUnits(prop)) && (normalizedInput[normalizedProp] = inputObject[prop]);
                return normalizedInput
            }
            var priorities = {};

            function addUnitPriority(unit, priority) {
                priorities[unit] = priority
            }

            function getPrioritizedUnits(unitsObj) {
                var u, units = [];
                for (u in unitsObj) hasOwnProp(unitsObj, u) && units.push({
                    unit: u,
                    priority: priorities[u]
                });
                return units.sort((function(a, b) {
                    return a.priority - b.priority
                })), units
            }

            function isLeapYear(year) {
                return year % 4 == 0 && year % 100 != 0 || year % 400 == 0
            }

            function absFloor(number) {
                return number < 0 ? Math.ceil(number) || 0 : Math.floor(number)
            }

            function toInt(argumentForCoercion) {
                var coercedNumber = +argumentForCoercion,
                    value = 0;
                return 0 !== coercedNumber && isFinite(coercedNumber) && (value = absFloor(coercedNumber)), value
            }

            function makeGetSet(unit, keepTime) {
                return function(value) {
                    return null != value ? (set$1(this, unit, value), hooks.updateOffset(this, keepTime), this) : get(this, unit)
                }
            }

            function get(mom, unit) {
                return mom.isValid() ? mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]() : NaN
            }

            function set$1(mom, unit, value) {
                mom.isValid() && !isNaN(value) && ("FullYear" === unit && isLeapYear(mom.year()) && 1 === mom.month() && 29 === mom.date() ? (value = toInt(value), mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value, mom.month(), daysInMonth(value, mom.month()))) : mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value))
            }

            function stringGet(units) {
                return isFunction(this[units = normalizeUnits(units)]) ? this[units]() : this
            }

            function stringSet(units, value) {
                if ("object" == typeof units) {
                    var i, prioritized = getPrioritizedUnits(units = normalizeObjectUnits(units));
                    for (i = 0; i < prioritized.length; i++) this[prioritized[i].unit](units[prioritized[i].unit])
                } else if (isFunction(this[units = normalizeUnits(units)])) return this[units](value);
                return this
            }
            var regexes, match1 = /\d/,
                match2 = /\d\d/,
                match3 = /\d{3}/,
                match4 = /\d{4}/,
                match6 = /[+-]?\d{6}/,
                match1to2 = /\d\d?/,
                match3to4 = /\d\d\d\d?/,
                match5to6 = /\d\d\d\d\d\d?/,
                match1to3 = /\d{1,3}/,
                match1to4 = /\d{1,4}/,
                match1to6 = /[+-]?\d{1,6}/,
                matchUnsigned = /\d+/,
                matchSigned = /[+-]?\d+/,
                matchOffset = /Z|[+-]\d\d:?\d\d/gi,
                matchShortOffset = /Z|[+-]\d\d(?::?\d\d)?/gi,
                matchTimestamp = /[+-]?\d+(\.\d{1,3})?/,
                matchWord = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i;

            function addRegexToken(token, regex, strictRegex) {
                regexes[token] = isFunction(regex) ? regex : function(isStrict, localeData) {
                    return isStrict && strictRegex ? strictRegex : regex
                }
            }

            function getParseRegexForToken(token, config) {
                return hasOwnProp(regexes, token) ? regexes[token](config._strict, config._locale) : new RegExp(unescapeFormat(token))
            }

            function unescapeFormat(s) {
                return regexEscape(s.replace("\\", "").replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, (function(matched, p1, p2, p3, p4) {
                    return p1 || p2 || p3 || p4
                })))
            }

            function regexEscape(s) {
                return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")
            }
            regexes = {};
            var tokens = {};

            function addParseToken(token, callback) {
                var i, func = callback;
                for ("string" == typeof token && (token = [token]), isNumber(callback) && (func = function(input, array) {
                        array[callback] = toInt(input)
                    }), i = 0; i < token.length; i++) tokens[token[i]] = func
            }

            function addWeekParseToken(token, callback) {
                addParseToken(token, (function(input, array, config, token) {
                    config._w = config._w || {}, callback(input, config._w, config, token)
                }))
            }

            function addTimeToArrayFromToken(token, input, config) {
                null != input && hasOwnProp(tokens, token) && tokens[token](input, config._a, config, token)
            }
            var indexOf, YEAR = 0,
                MONTH = 1,
                DATE = 2,
                HOUR = 3,
                MINUTE = 4,
                SECOND = 5,
                MILLISECOND = 6,
                WEEK = 7,
                WEEKDAY = 8;

            function mod(n, x) {
                return (n % x + x) % x
            }

            function daysInMonth(year, month) {
                if (isNaN(year) || isNaN(month)) return NaN;
                var modMonth = mod(month, 12);
                return year += (month - modMonth) / 12, 1 === modMonth ? isLeapYear(year) ? 29 : 28 : 31 - modMonth % 7 % 2
            }
            indexOf = Array.prototype.indexOf ? Array.prototype.indexOf : function(o) {
                var i;
                for (i = 0; i < this.length; ++i)
                    if (this[i] === o) return i;
                return -1
            }, addFormatToken("M", ["MM", 2], "Mo", (function() {
                return this.month() + 1
            })), addFormatToken("MMM", 0, 0, (function(format) {
                return this.localeData().monthsShort(this, format)
            })), addFormatToken("MMMM", 0, 0, (function(format) {
                return this.localeData().months(this, format)
            })), addUnitAlias("month", "M"), addUnitPriority("month", 8), addRegexToken("M", match1to2), addRegexToken("MM", match1to2, match2), addRegexToken("MMM", (function(isStrict, locale) {
                return locale.monthsShortRegex(isStrict)
            })), addRegexToken("MMMM", (function(isStrict, locale) {
                return locale.monthsRegex(isStrict)
            })), addParseToken(["M", "MM"], (function(input, array) {
                array[MONTH] = toInt(input) - 1
            })), addParseToken(["MMM", "MMMM"], (function(input, array, config, token) {
                var month = config._locale.monthsParse(input, token, config._strict);
                null != month ? array[MONTH] = month : getParsingFlags(config).invalidMonth = input
            }));
            var defaultLocaleMonths = "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
                defaultLocaleMonthsShort = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
                MONTHS_IN_FORMAT = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/,
                defaultMonthsShortRegex = matchWord,
                defaultMonthsRegex = matchWord;

            function localeMonths(m, format) {
                return m ? isArray(this._months) ? this._months[m.month()] : this._months[(this._months.isFormat || MONTHS_IN_FORMAT).test(format) ? "format" : "standalone"][m.month()] : isArray(this._months) ? this._months : this._months.standalone
            }

            function localeMonthsShort(m, format) {
                return m ? isArray(this._monthsShort) ? this._monthsShort[m.month()] : this._monthsShort[MONTHS_IN_FORMAT.test(format) ? "format" : "standalone"][m.month()] : isArray(this._monthsShort) ? this._monthsShort : this._monthsShort.standalone
            }

            function handleStrictParse(monthName, format, strict) {
                var i, ii, mom, llc = monthName.toLocaleLowerCase();
                if (!this._monthsParse)
                    for (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = [], i = 0; i < 12; ++i) mom = createUTC([2e3, i]), this._shortMonthsParse[i] = this.monthsShort(mom, "").toLocaleLowerCase(), this._longMonthsParse[i] = this.months(mom, "").toLocaleLowerCase();
                return strict ? "MMM" === format ? -1 !== (ii = indexOf.call(this._shortMonthsParse, llc)) ? ii : null : -1 !== (ii = indexOf.call(this._longMonthsParse, llc)) ? ii : null : "MMM" === format ? -1 !== (ii = indexOf.call(this._shortMonthsParse, llc)) || -1 !== (ii = indexOf.call(this._longMonthsParse, llc)) ? ii : null : -1 !== (ii = indexOf.call(this._longMonthsParse, llc)) || -1 !== (ii = indexOf.call(this._shortMonthsParse, llc)) ? ii : null
            }

            function localeMonthsParse(monthName, format, strict) {
                var i, mom, regex;
                if (this._monthsParseExact) return handleStrictParse.call(this, monthName, format, strict);
                for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), i = 0; i < 12; i++) {
                    if (mom = createUTC([2e3, i]), strict && !this._longMonthsParse[i] && (this._longMonthsParse[i] = new RegExp("^" + this.months(mom, "").replace(".", "") + "$", "i"), this._shortMonthsParse[i] = new RegExp("^" + this.monthsShort(mom, "").replace(".", "") + "$", "i")), strict || this._monthsParse[i] || (regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, ""), this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i")), strict && "MMMM" === format && this._longMonthsParse[i].test(monthName)) return i;
                    if (strict && "MMM" === format && this._shortMonthsParse[i].test(monthName)) return i;
                    if (!strict && this._monthsParse[i].test(monthName)) return i
                }
            }

            function setMonth(mom, value) {
                var dayOfMonth;
                if (!mom.isValid()) return mom;
                if ("string" == typeof value)
                    if (/^\d+$/.test(value)) value = toInt(value);
                    else if (!isNumber(value = mom.localeData().monthsParse(value))) return mom;
                return dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value)), mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth), mom
            }

            function getSetMonth(value) {
                return null != value ? (setMonth(this, value), hooks.updateOffset(this, !0), this) : get(this, "Month")
            }

            function getDaysInMonth() {
                return daysInMonth(this.year(), this.month())
            }

            function monthsShortRegex(isStrict) {
                return this._monthsParseExact ? (hasOwnProp(this, "_monthsRegex") || computeMonthsParse.call(this), isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex) : (hasOwnProp(this, "_monthsShortRegex") || (this._monthsShortRegex = defaultMonthsShortRegex), this._monthsShortStrictRegex && isStrict ? this._monthsShortStrictRegex : this._monthsShortRegex)
            }

            function monthsRegex(isStrict) {
                return this._monthsParseExact ? (hasOwnProp(this, "_monthsRegex") || computeMonthsParse.call(this), isStrict ? this._monthsStrictRegex : this._monthsRegex) : (hasOwnProp(this, "_monthsRegex") || (this._monthsRegex = defaultMonthsRegex), this._monthsStrictRegex && isStrict ? this._monthsStrictRegex : this._monthsRegex)
            }

            function computeMonthsParse() {
                function cmpLenRev(a, b) {
                    return b.length - a.length
                }
                var i, mom, shortPieces = [],
                    longPieces = [],
                    mixedPieces = [];
                for (i = 0; i < 12; i++) mom = createUTC([2e3, i]), shortPieces.push(this.monthsShort(mom, "")), longPieces.push(this.months(mom, "")), mixedPieces.push(this.months(mom, "")), mixedPieces.push(this.monthsShort(mom, ""));
                for (shortPieces.sort(cmpLenRev), longPieces.sort(cmpLenRev), mixedPieces.sort(cmpLenRev), i = 0; i < 12; i++) shortPieces[i] = regexEscape(shortPieces[i]), longPieces[i] = regexEscape(longPieces[i]);
                for (i = 0; i < 24; i++) mixedPieces[i] = regexEscape(mixedPieces[i]);
                this._monthsRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i"), this._monthsShortRegex = this._monthsRegex, this._monthsStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i"), this._monthsShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i")
            }

            function daysInYear(year) {
                return isLeapYear(year) ? 366 : 365
            }
            addFormatToken("Y", 0, 0, (function() {
                var y = this.year();
                return y <= 9999 ? zeroFill(y, 4) : "+" + y
            })), addFormatToken(0, ["YY", 2], 0, (function() {
                return this.year() % 100
            })), addFormatToken(0, ["YYYY", 4], 0, "year"), addFormatToken(0, ["YYYYY", 5], 0, "year"), addFormatToken(0, ["YYYYYY", 6, !0], 0, "year"), addUnitAlias("year", "y"), addUnitPriority("year", 1), addRegexToken("Y", matchSigned), addRegexToken("YY", match1to2, match2), addRegexToken("YYYY", match1to4, match4), addRegexToken("YYYYY", match1to6, match6), addRegexToken("YYYYYY", match1to6, match6), addParseToken(["YYYYY", "YYYYYY"], YEAR), addParseToken("YYYY", (function(input, array) {
                array[YEAR] = 2 === input.length ? hooks.parseTwoDigitYear(input) : toInt(input)
            })), addParseToken("YY", (function(input, array) {
                array[YEAR] = hooks.parseTwoDigitYear(input)
            })), addParseToken("Y", (function(input, array) {
                array[YEAR] = parseInt(input, 10)
            })), hooks.parseTwoDigitYear = function(input) {
                return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3)
            };
            var getSetYear = makeGetSet("FullYear", !0);

            function getIsLeapYear() {
                return isLeapYear(this.year())
            }

            function createDate(y, m, d, h, M, s, ms) {
                var date;
                return y < 100 && y >= 0 ? (date = new Date(y + 400, m, d, h, M, s, ms), isFinite(date.getFullYear()) && date.setFullYear(y)) : date = new Date(y, m, d, h, M, s, ms), date
            }

            function createUTCDate(y) {
                var date, args;
                return y < 100 && y >= 0 ? ((args = Array.prototype.slice.call(arguments))[0] = y + 400, date = new Date(Date.UTC.apply(null, args)), isFinite(date.getUTCFullYear()) && date.setUTCFullYear(y)) : date = new Date(Date.UTC.apply(null, arguments)), date
            }

            function firstWeekOffset(year, dow, doy) {
                var fwd = 7 + dow - doy;
                return -(7 + createUTCDate(year, 0, fwd).getUTCDay() - dow) % 7 + fwd - 1
            }

            function dayOfYearFromWeeks(year, week, weekday, dow, doy) {
                var resYear, resDayOfYear, dayOfYear = 1 + 7 * (week - 1) + (7 + weekday - dow) % 7 + firstWeekOffset(year, dow, doy);
                return dayOfYear <= 0 ? resDayOfYear = daysInYear(resYear = year - 1) + dayOfYear : dayOfYear > daysInYear(year) ? (resYear = year + 1, resDayOfYear = dayOfYear - daysInYear(year)) : (resYear = year, resDayOfYear = dayOfYear), {
                    year: resYear,
                    dayOfYear: resDayOfYear
                }
            }

            function weekOfYear(mom, dow, doy) {
                var resWeek, resYear, weekOffset = firstWeekOffset(mom.year(), dow, doy),
                    week = Math.floor((mom.dayOfYear() - weekOffset - 1) / 7) + 1;
                return week < 1 ? resWeek = week + weeksInYear(resYear = mom.year() - 1, dow, doy) : week > weeksInYear(mom.year(), dow, doy) ? (resWeek = week - weeksInYear(mom.year(), dow, doy), resYear = mom.year() + 1) : (resYear = mom.year(), resWeek = week), {
                    week: resWeek,
                    year: resYear
                }
            }

            function weeksInYear(year, dow, doy) {
                var weekOffset = firstWeekOffset(year, dow, doy),
                    weekOffsetNext = firstWeekOffset(year + 1, dow, doy);
                return (daysInYear(year) - weekOffset + weekOffsetNext) / 7
            }

            function localeWeek(mom) {
                return weekOfYear(mom, this._week.dow, this._week.doy).week
            }
            addFormatToken("w", ["ww", 2], "wo", "week"), addFormatToken("W", ["WW", 2], "Wo", "isoWeek"), addUnitAlias("week", "w"), addUnitAlias("isoWeek", "W"), addUnitPriority("week", 5), addUnitPriority("isoWeek", 5), addRegexToken("w", match1to2), addRegexToken("ww", match1to2, match2), addRegexToken("W", match1to2), addRegexToken("WW", match1to2, match2), addWeekParseToken(["w", "ww", "W", "WW"], (function(input, week, config, token) {
                week[token.substr(0, 1)] = toInt(input)
            }));
            var defaultLocaleWeek = {
                dow: 0,
                doy: 6
            };

            function localeFirstDayOfWeek() {
                return this._week.dow
            }

            function localeFirstDayOfYear() {
                return this._week.doy
            }

            function getSetWeek(input) {
                var week = this.localeData().week(this);
                return null == input ? week : this.add(7 * (input - week), "d")
            }

            function getSetISOWeek(input) {
                var week = weekOfYear(this, 1, 4).week;
                return null == input ? week : this.add(7 * (input - week), "d")
            }

            function parseWeekday(input, locale) {
                return "string" != typeof input ? input : isNaN(input) ? "number" == typeof(input = locale.weekdaysParse(input)) ? input : null : parseInt(input, 10)
            }

            function parseIsoWeekday(input, locale) {
                return "string" == typeof input ? locale.weekdaysParse(input) % 7 || 7 : isNaN(input) ? null : input
            }

            function shiftWeekdays(ws, n) {
                return ws.slice(n, 7).concat(ws.slice(0, n))
            }
            addFormatToken("d", 0, "do", "day"), addFormatToken("dd", 0, 0, (function(format) {
                return this.localeData().weekdaysMin(this, format)
            })), addFormatToken("ddd", 0, 0, (function(format) {
                return this.localeData().weekdaysShort(this, format)
            })), addFormatToken("dddd", 0, 0, (function(format) {
                return this.localeData().weekdays(this, format)
            })), addFormatToken("e", 0, 0, "weekday"), addFormatToken("E", 0, 0, "isoWeekday"), addUnitAlias("day", "d"), addUnitAlias("weekday", "e"), addUnitAlias("isoWeekday", "E"), addUnitPriority("day", 11), addUnitPriority("weekday", 11), addUnitPriority("isoWeekday", 11), addRegexToken("d", match1to2), addRegexToken("e", match1to2), addRegexToken("E", match1to2), addRegexToken("dd", (function(isStrict, locale) {
                return locale.weekdaysMinRegex(isStrict)
            })), addRegexToken("ddd", (function(isStrict, locale) {
                return locale.weekdaysShortRegex(isStrict)
            })), addRegexToken("dddd", (function(isStrict, locale) {
                return locale.weekdaysRegex(isStrict)
            })), addWeekParseToken(["dd", "ddd", "dddd"], (function(input, week, config, token) {
                var weekday = config._locale.weekdaysParse(input, token, config._strict);
                null != weekday ? week.d = weekday : getParsingFlags(config).invalidWeekday = input
            })), addWeekParseToken(["d", "e", "E"], (function(input, week, config, token) {
                week[token] = toInt(input)
            }));
            var defaultLocaleWeekdays = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
                defaultLocaleWeekdaysShort = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
                defaultLocaleWeekdaysMin = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
                defaultWeekdaysRegex = matchWord,
                defaultWeekdaysShortRegex = matchWord,
                defaultWeekdaysMinRegex = matchWord;

            function localeWeekdays(m, format) {
                var weekdays = isArray(this._weekdays) ? this._weekdays : this._weekdays[m && !0 !== m && this._weekdays.isFormat.test(format) ? "format" : "standalone"];
                return !0 === m ? shiftWeekdays(weekdays, this._week.dow) : m ? weekdays[m.day()] : weekdays
            }

            function localeWeekdaysShort(m) {
                return !0 === m ? shiftWeekdays(this._weekdaysShort, this._week.dow) : m ? this._weekdaysShort[m.day()] : this._weekdaysShort
            }

            function localeWeekdaysMin(m) {
                return !0 === m ? shiftWeekdays(this._weekdaysMin, this._week.dow) : m ? this._weekdaysMin[m.day()] : this._weekdaysMin
            }

            function handleStrictParse$1(weekdayName, format, strict) {
                var i, ii, mom, llc = weekdayName.toLocaleLowerCase();
                if (!this._weekdaysParse)
                    for (this._weekdaysParse = [], this._shortWeekdaysParse = [], this._minWeekdaysParse = [], i = 0; i < 7; ++i) mom = createUTC([2e3, 1]).day(i), this._minWeekdaysParse[i] = this.weekdaysMin(mom, "").toLocaleLowerCase(), this._shortWeekdaysParse[i] = this.weekdaysShort(mom, "").toLocaleLowerCase(), this._weekdaysParse[i] = this.weekdays(mom, "").toLocaleLowerCase();
                return strict ? "dddd" === format ? -1 !== (ii = indexOf.call(this._weekdaysParse, llc)) ? ii : null : "ddd" === format ? -1 !== (ii = indexOf.call(this._shortWeekdaysParse, llc)) ? ii : null : -1 !== (ii = indexOf.call(this._minWeekdaysParse, llc)) ? ii : null : "dddd" === format ? -1 !== (ii = indexOf.call(this._weekdaysParse, llc)) || -1 !== (ii = indexOf.call(this._shortWeekdaysParse, llc)) || -1 !== (ii = indexOf.call(this._minWeekdaysParse, llc)) ? ii : null : "ddd" === format ? -1 !== (ii = indexOf.call(this._shortWeekdaysParse, llc)) || -1 !== (ii = indexOf.call(this._weekdaysParse, llc)) || -1 !== (ii = indexOf.call(this._minWeekdaysParse, llc)) ? ii : null : -1 !== (ii = indexOf.call(this._minWeekdaysParse, llc)) || -1 !== (ii = indexOf.call(this._weekdaysParse, llc)) || -1 !== (ii = indexOf.call(this._shortWeekdaysParse, llc)) ? ii : null
            }

            function localeWeekdaysParse(weekdayName, format, strict) {
                var i, mom, regex;
                if (this._weekdaysParseExact) return handleStrictParse$1.call(this, weekdayName, format, strict);
                for (this._weekdaysParse || (this._weekdaysParse = [], this._minWeekdaysParse = [], this._shortWeekdaysParse = [], this._fullWeekdaysParse = []), i = 0; i < 7; i++) {
                    if (mom = createUTC([2e3, 1]).day(i), strict && !this._fullWeekdaysParse[i] && (this._fullWeekdaysParse[i] = new RegExp("^" + this.weekdays(mom, "").replace(".", "\\.?") + "$", "i"), this._shortWeekdaysParse[i] = new RegExp("^" + this.weekdaysShort(mom, "").replace(".", "\\.?") + "$", "i"), this._minWeekdaysParse[i] = new RegExp("^" + this.weekdaysMin(mom, "").replace(".", "\\.?") + "$", "i")), this._weekdaysParse[i] || (regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, ""), this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i")), strict && "dddd" === format && this._fullWeekdaysParse[i].test(weekdayName)) return i;
                    if (strict && "ddd" === format && this._shortWeekdaysParse[i].test(weekdayName)) return i;
                    if (strict && "dd" === format && this._minWeekdaysParse[i].test(weekdayName)) return i;
                    if (!strict && this._weekdaysParse[i].test(weekdayName)) return i
                }
            }

            function getSetDayOfWeek(input) {
                if (!this.isValid()) return null != input ? this : NaN;
                var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
                return null != input ? (input = parseWeekday(input, this.localeData()), this.add(input - day, "d")) : day
            }

            function getSetLocaleDayOfWeek(input) {
                if (!this.isValid()) return null != input ? this : NaN;
                var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
                return null == input ? weekday : this.add(input - weekday, "d")
            }

            function getSetISODayOfWeek(input) {
                if (!this.isValid()) return null != input ? this : NaN;
                if (null != input) {
                    var weekday = parseIsoWeekday(input, this.localeData());
                    return this.day(this.day() % 7 ? weekday : weekday - 7)
                }
                return this.day() || 7
            }

            function weekdaysRegex(isStrict) {
                return this._weekdaysParseExact ? (hasOwnProp(this, "_weekdaysRegex") || computeWeekdaysParse.call(this), isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex) : (hasOwnProp(this, "_weekdaysRegex") || (this._weekdaysRegex = defaultWeekdaysRegex), this._weekdaysStrictRegex && isStrict ? this._weekdaysStrictRegex : this._weekdaysRegex)
            }

            function weekdaysShortRegex(isStrict) {
                return this._weekdaysParseExact ? (hasOwnProp(this, "_weekdaysRegex") || computeWeekdaysParse.call(this), isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) : (hasOwnProp(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex = defaultWeekdaysShortRegex), this._weekdaysShortStrictRegex && isStrict ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex)
            }

            function weekdaysMinRegex(isStrict) {
                return this._weekdaysParseExact ? (hasOwnProp(this, "_weekdaysRegex") || computeWeekdaysParse.call(this), isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) : (hasOwnProp(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex = defaultWeekdaysMinRegex), this._weekdaysMinStrictRegex && isStrict ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex)
            }

            function computeWeekdaysParse() {
                function cmpLenRev(a, b) {
                    return b.length - a.length
                }
                var i, mom, minp, shortp, longp, minPieces = [],
                    shortPieces = [],
                    longPieces = [],
                    mixedPieces = [];
                for (i = 0; i < 7; i++) mom = createUTC([2e3, 1]).day(i), minp = regexEscape(this.weekdaysMin(mom, "")), shortp = regexEscape(this.weekdaysShort(mom, "")), longp = regexEscape(this.weekdays(mom, "")), minPieces.push(minp), shortPieces.push(shortp), longPieces.push(longp), mixedPieces.push(minp), mixedPieces.push(shortp), mixedPieces.push(longp);
                minPieces.sort(cmpLenRev), shortPieces.sort(cmpLenRev), longPieces.sort(cmpLenRev), mixedPieces.sort(cmpLenRev), this._weekdaysRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i"), this._weekdaysShortRegex = this._weekdaysRegex, this._weekdaysMinRegex = this._weekdaysRegex, this._weekdaysStrictRegex = new RegExp("^(" + longPieces.join("|") + ")", "i"), this._weekdaysShortStrictRegex = new RegExp("^(" + shortPieces.join("|") + ")", "i"), this._weekdaysMinStrictRegex = new RegExp("^(" + minPieces.join("|") + ")", "i")
            }

            function hFormat() {
                return this.hours() % 12 || 12
            }

            function kFormat() {
                return this.hours() || 24
            }

            function meridiem(token, lowercase) {
                addFormatToken(token, 0, 0, (function() {
                    return this.localeData().meridiem(this.hours(), this.minutes(), lowercase)
                }))
            }

            function matchMeridiem(isStrict, locale) {
                return locale._meridiemParse
            }

            function localeIsPM(input) {
                return "p" === (input + "").toLowerCase().charAt(0)
            }
            addFormatToken("H", ["HH", 2], 0, "hour"), addFormatToken("h", ["hh", 2], 0, hFormat), addFormatToken("k", ["kk", 2], 0, kFormat), addFormatToken("hmm", 0, 0, (function() {
                return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2)
            })), addFormatToken("hmmss", 0, 0, (function() {
                return "" + hFormat.apply(this) + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2)
            })), addFormatToken("Hmm", 0, 0, (function() {
                return "" + this.hours() + zeroFill(this.minutes(), 2)
            })), addFormatToken("Hmmss", 0, 0, (function() {
                return "" + this.hours() + zeroFill(this.minutes(), 2) + zeroFill(this.seconds(), 2)
            })), meridiem("a", !0), meridiem("A", !1), addUnitAlias("hour", "h"), addUnitPriority("hour", 13), addRegexToken("a", matchMeridiem), addRegexToken("A", matchMeridiem), addRegexToken("H", match1to2), addRegexToken("h", match1to2), addRegexToken("k", match1to2), addRegexToken("HH", match1to2, match2), addRegexToken("hh", match1to2, match2), addRegexToken("kk", match1to2, match2), addRegexToken("hmm", match3to4), addRegexToken("hmmss", match5to6), addRegexToken("Hmm", match3to4), addRegexToken("Hmmss", match5to6), addParseToken(["H", "HH"], HOUR), addParseToken(["k", "kk"], (function(input, array, config) {
                var kInput = toInt(input);
                array[HOUR] = 24 === kInput ? 0 : kInput
            })), addParseToken(["a", "A"], (function(input, array, config) {
                config._isPm = config._locale.isPM(input), config._meridiem = input
            })), addParseToken(["h", "hh"], (function(input, array, config) {
                array[HOUR] = toInt(input), getParsingFlags(config).bigHour = !0
            })), addParseToken("hmm", (function(input, array, config) {
                var pos = input.length - 2;
                array[HOUR] = toInt(input.substr(0, pos)), array[MINUTE] = toInt(input.substr(pos)), getParsingFlags(config).bigHour = !0
            })), addParseToken("hmmss", (function(input, array, config) {
                var pos1 = input.length - 4,
                    pos2 = input.length - 2;
                array[HOUR] = toInt(input.substr(0, pos1)), array[MINUTE] = toInt(input.substr(pos1, 2)), array[SECOND] = toInt(input.substr(pos2)), getParsingFlags(config).bigHour = !0
            })), addParseToken("Hmm", (function(input, array, config) {
                var pos = input.length - 2;
                array[HOUR] = toInt(input.substr(0, pos)), array[MINUTE] = toInt(input.substr(pos))
            })), addParseToken("Hmmss", (function(input, array, config) {
                var pos1 = input.length - 4,
                    pos2 = input.length - 2;
                array[HOUR] = toInt(input.substr(0, pos1)), array[MINUTE] = toInt(input.substr(pos1, 2)), array[SECOND] = toInt(input.substr(pos2))
            }));
            var defaultLocaleMeridiemParse = /[ap]\.?m?\.?/i,
                getSetHour = makeGetSet("Hours", !0);

            function localeMeridiem(hours, minutes, isLower) {
                return hours > 11 ? isLower ? "pm" : "PM" : isLower ? "am" : "AM"
            }
            var globalLocale, baseConfig = {
                    calendar: defaultCalendar,
                    longDateFormat: defaultLongDateFormat,
                    invalidDate: defaultInvalidDate,
                    ordinal: defaultOrdinal,
                    dayOfMonthOrdinalParse: defaultDayOfMonthOrdinalParse,
                    relativeTime: defaultRelativeTime,
                    months: defaultLocaleMonths,
                    monthsShort: defaultLocaleMonthsShort,
                    week: defaultLocaleWeek,
                    weekdays: defaultLocaleWeekdays,
                    weekdaysMin: defaultLocaleWeekdaysMin,
                    weekdaysShort: defaultLocaleWeekdaysShort,
                    meridiemParse: defaultLocaleMeridiemParse
                },
                locales = {},
                localeFamilies = {};

            function commonPrefix(arr1, arr2) {
                var i, minl = Math.min(arr1.length, arr2.length);
                for (i = 0; i < minl; i += 1)
                    if (arr1[i] !== arr2[i]) return i;
                return minl
            }

            function normalizeLocale(key) {
                return key ? key.toLowerCase().replace("_", "-") : key
            }

            function chooseLocale(names) {
                for (var j, next, locale, split, i = 0; i < names.length;) {
                    for (j = (split = normalizeLocale(names[i]).split("-")).length, next = (next = normalizeLocale(names[i + 1])) ? next.split("-") : null; j > 0;) {
                        if (locale = loadLocale(split.slice(0, j).join("-"))) return locale;
                        if (next && next.length >= j && commonPrefix(split, next) >= j - 1) break;
                        j--
                    }
                    i++
                }
                return globalLocale
            }

            function loadLocale(name) {
                var oldLocale = null;
                if (void 0 === locales[name] && void 0 !== module && module && module.exports) try {
                    oldLocale = globalLocale._abbr, __webpack_require__(261)("./" + name), getSetGlobalLocale(oldLocale)
                } catch (e) {
                    locales[name] = null
                }
                return locales[name]
            }

            function getSetGlobalLocale(key, values) {
                var data;
                return key && ((data = isUndefined(values) ? getLocale(key) : defineLocale(key, values)) ? globalLocale = data : "undefined" != typeof console && console.warn && console.warn("Locale " + key + " not found. Did you forget to load it?")), globalLocale._abbr
            }

            function defineLocale(name, config) {
                if (null !== config) {
                    var locale, parentConfig = baseConfig;
                    if (config.abbr = name, null != locales[name]) deprecateSimple("defineLocaleOverride", "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."), parentConfig = locales[name]._config;
                    else if (null != config.parentLocale)
                        if (null != locales[config.parentLocale]) parentConfig = locales[config.parentLocale]._config;
                        else {
                            if (null == (locale = loadLocale(config.parentLocale))) return localeFamilies[config.parentLocale] || (localeFamilies[config.parentLocale] = []), localeFamilies[config.parentLocale].push({
                                name: name,
                                config: config
                            }), null;
                            parentConfig = locale._config
                        }
                    return locales[name] = new Locale(mergeConfigs(parentConfig, config)), localeFamilies[name] && localeFamilies[name].forEach((function(x) {
                        defineLocale(x.name, x.config)
                    })), getSetGlobalLocale(name), locales[name]
                }
                return delete locales[name], null
            }

            function updateLocale(name, config) {
                if (null != config) {
                    var locale, tmpLocale, parentConfig = baseConfig;
                    null != locales[name] && null != locales[name].parentLocale ? locales[name].set(mergeConfigs(locales[name]._config, config)) : (null != (tmpLocale = loadLocale(name)) && (parentConfig = tmpLocale._config), config = mergeConfigs(parentConfig, config), null == tmpLocale && (config.abbr = name), (locale = new Locale(config)).parentLocale = locales[name], locales[name] = locale), getSetGlobalLocale(name)
                } else null != locales[name] && (null != locales[name].parentLocale ? (locales[name] = locales[name].parentLocale, name === getSetGlobalLocale() && getSetGlobalLocale(name)) : null != locales[name] && delete locales[name]);
                return locales[name]
            }

            function getLocale(key) {
                var locale;
                if (key && key._locale && key._locale._abbr && (key = key._locale._abbr), !key) return globalLocale;
                if (!isArray(key)) {
                    if (locale = loadLocale(key)) return locale;
                    key = [key]
                }
                return chooseLocale(key)
            }

            function listLocales() {
                return keys(locales)
            }

            function checkOverflow(m) {
                var overflow, a = m._a;
                return a && -2 === getParsingFlags(m).overflow && (overflow = a[MONTH] < 0 || a[MONTH] > 11 ? MONTH : a[DATE] < 1 || a[DATE] > daysInMonth(a[YEAR], a[MONTH]) ? DATE : a[HOUR] < 0 || a[HOUR] > 24 || 24 === a[HOUR] && (0 !== a[MINUTE] || 0 !== a[SECOND] || 0 !== a[MILLISECOND]) ? HOUR : a[MINUTE] < 0 || a[MINUTE] > 59 ? MINUTE : a[SECOND] < 0 || a[SECOND] > 59 ? SECOND : a[MILLISECOND] < 0 || a[MILLISECOND] > 999 ? MILLISECOND : -1, getParsingFlags(m)._overflowDayOfYear && (overflow < YEAR || overflow > DATE) && (overflow = DATE), getParsingFlags(m)._overflowWeeks && -1 === overflow && (overflow = WEEK), getParsingFlags(m)._overflowWeekday && -1 === overflow && (overflow = WEEKDAY), getParsingFlags(m).overflow = overflow), m
            }
            var extendedIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
                basicIsoRegex = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/,
                tzRegex = /Z|[+-]\d\d(?::?\d\d)?/,
                isoDates = [
                    ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
                    ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
                    ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
                    ["GGGG-[W]WW", /\d{4}-W\d\d/, !1],
                    ["YYYY-DDD", /\d{4}-\d{3}/],
                    ["YYYY-MM", /\d{4}-\d\d/, !1],
                    ["YYYYYYMMDD", /[+-]\d{10}/],
                    ["YYYYMMDD", /\d{8}/],
                    ["GGGG[W]WWE", /\d{4}W\d{3}/],
                    ["GGGG[W]WW", /\d{4}W\d{2}/, !1],
                    ["YYYYDDD", /\d{7}/],
                    ["YYYYMM", /\d{6}/, !1],
                    ["YYYY", /\d{4}/, !1]
                ],
                isoTimes = [
                    ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
                    ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
                    ["HH:mm:ss", /\d\d:\d\d:\d\d/],
                    ["HH:mm", /\d\d:\d\d/],
                    ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
                    ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
                    ["HHmmss", /\d\d\d\d\d\d/],
                    ["HHmm", /\d\d\d\d/],
                    ["HH", /\d\d/]
                ],
                aspNetJsonRegex = /^\/?Date\((-?\d+)/i,
                rfc2822 = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/,
                obsOffsets = {
                    UT: 0,
                    GMT: 0,
                    EDT: -240,
                    EST: -300,
                    CDT: -300,
                    CST: -360,
                    MDT: -360,
                    MST: -420,
                    PDT: -420,
                    PST: -480
                };

            function configFromISO(config) {
                var i, l, allowTime, dateFormat, timeFormat, tzFormat, string = config._i,
                    match = extendedIsoRegex.exec(string) || basicIsoRegex.exec(string);
                if (match) {
                    for (getParsingFlags(config).iso = !0, i = 0, l = isoDates.length; i < l; i++)
                        if (isoDates[i][1].exec(match[1])) {
                            dateFormat = isoDates[i][0], allowTime = !1 !== isoDates[i][2];
                            break
                        }
                    if (null == dateFormat) return void(config._isValid = !1);
                    if (match[3]) {
                        for (i = 0, l = isoTimes.length; i < l; i++)
                            if (isoTimes[i][1].exec(match[3])) {
                                timeFormat = (match[2] || " ") + isoTimes[i][0];
                                break
                            }
                        if (null == timeFormat) return void(config._isValid = !1)
                    }
                    if (!allowTime && null != timeFormat) return void(config._isValid = !1);
                    if (match[4]) {
                        if (!tzRegex.exec(match[4])) return void(config._isValid = !1);
                        tzFormat = "Z"
                    }
                    config._f = dateFormat + (timeFormat || "") + (tzFormat || ""), configFromStringAndFormat(config)
                } else config._isValid = !1
            }

            function extractFromRFC2822Strings(yearStr, monthStr, dayStr, hourStr, minuteStr, secondStr) {
                var result = [untruncateYear(yearStr), defaultLocaleMonthsShort.indexOf(monthStr), parseInt(dayStr, 10), parseInt(hourStr, 10), parseInt(minuteStr, 10)];
                return secondStr && result.push(parseInt(secondStr, 10)), result
            }

            function untruncateYear(yearStr) {
                var year = parseInt(yearStr, 10);
                return year <= 49 ? 2e3 + year : year <= 999 ? 1900 + year : year
            }

            function preprocessRFC2822(s) {
                return s.replace(/\([^)]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "")
            }

            function checkWeekday(weekdayStr, parsedInput, config) {
                return !weekdayStr || defaultLocaleWeekdaysShort.indexOf(weekdayStr) === new Date(parsedInput[0], parsedInput[1], parsedInput[2]).getDay() || (getParsingFlags(config).weekdayMismatch = !0, config._isValid = !1, !1)
            }

            function calculateOffset(obsOffset, militaryOffset, numOffset) {
                if (obsOffset) return obsOffsets[obsOffset];
                if (militaryOffset) return 0;
                var hm = parseInt(numOffset, 10),
                    m = hm % 100;
                return (hm - m) / 100 * 60 + m
            }

            function configFromRFC2822(config) {
                var parsedArray, match = rfc2822.exec(preprocessRFC2822(config._i));
                if (match) {
                    if (parsedArray = extractFromRFC2822Strings(match[4], match[3], match[2], match[5], match[6], match[7]), !checkWeekday(match[1], parsedArray, config)) return;
                    config._a = parsedArray, config._tzm = calculateOffset(match[8], match[9], match[10]), config._d = createUTCDate.apply(null, config._a), config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm), getParsingFlags(config).rfc2822 = !0
                } else config._isValid = !1
            }

            function configFromString(config) {
                var matched = aspNetJsonRegex.exec(config._i);
                null === matched ? (configFromISO(config), !1 === config._isValid && (delete config._isValid, configFromRFC2822(config), !1 === config._isValid && (delete config._isValid, config._strict ? config._isValid = !1 : hooks.createFromInputFallback(config)))) : config._d = new Date(+matched[1])
            }

            function defaults(a, b, c) {
                return null != a ? a : null != b ? b : c
            }

            function currentDateArray(config) {
                var nowValue = new Date(hooks.now());
                return config._useUTC ? [nowValue.getUTCFullYear(), nowValue.getUTCMonth(), nowValue.getUTCDate()] : [nowValue.getFullYear(), nowValue.getMonth(), nowValue.getDate()]
            }

            function configFromArray(config) {
                var i, date, currentDate, expectedWeekday, yearToUse, input = [];
                if (!config._d) {
                    for (currentDate = currentDateArray(config), config._w && null == config._a[DATE] && null == config._a[MONTH] && dayOfYearFromWeekInfo(config), null != config._dayOfYear && (yearToUse = defaults(config._a[YEAR], currentDate[YEAR]), (config._dayOfYear > daysInYear(yearToUse) || 0 === config._dayOfYear) && (getParsingFlags(config)._overflowDayOfYear = !0), date = createUTCDate(yearToUse, 0, config._dayOfYear), config._a[MONTH] = date.getUTCMonth(), config._a[DATE] = date.getUTCDate()), i = 0; i < 3 && null == config._a[i]; ++i) config._a[i] = input[i] = currentDate[i];
                    for (; i < 7; i++) config._a[i] = input[i] = null == config._a[i] ? 2 === i ? 1 : 0 : config._a[i];
                    24 === config._a[HOUR] && 0 === config._a[MINUTE] && 0 === config._a[SECOND] && 0 === config._a[MILLISECOND] && (config._nextDay = !0, config._a[HOUR] = 0), config._d = (config._useUTC ? createUTCDate : createDate).apply(null, input), expectedWeekday = config._useUTC ? config._d.getUTCDay() : config._d.getDay(), null != config._tzm && config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm), config._nextDay && (config._a[HOUR] = 24), config._w && void 0 !== config._w.d && config._w.d !== expectedWeekday && (getParsingFlags(config).weekdayMismatch = !0)
                }
            }

            function dayOfYearFromWeekInfo(config) {
                var w, weekYear, week, weekday, dow, doy, temp, weekdayOverflow, curWeek;
                null != (w = config._w).GG || null != w.W || null != w.E ? (dow = 1, doy = 4, weekYear = defaults(w.GG, config._a[YEAR], weekOfYear(createLocal(), 1, 4).year), week = defaults(w.W, 1), ((weekday = defaults(w.E, 1)) < 1 || weekday > 7) && (weekdayOverflow = !0)) : (dow = config._locale._week.dow, doy = config._locale._week.doy, curWeek = weekOfYear(createLocal(), dow, doy), weekYear = defaults(w.gg, config._a[YEAR], curWeek.year), week = defaults(w.w, curWeek.week), null != w.d ? ((weekday = w.d) < 0 || weekday > 6) && (weekdayOverflow = !0) : null != w.e ? (weekday = w.e + dow, (w.e < 0 || w.e > 6) && (weekdayOverflow = !0)) : weekday = dow), week < 1 || week > weeksInYear(weekYear, dow, doy) ? getParsingFlags(config)._overflowWeeks = !0 : null != weekdayOverflow ? getParsingFlags(config)._overflowWeekday = !0 : (temp = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy), config._a[YEAR] = temp.year, config._dayOfYear = temp.dayOfYear)
            }

            function configFromStringAndFormat(config) {
                if (config._f !== hooks.ISO_8601)
                    if (config._f !== hooks.RFC_2822) {
                        config._a = [], getParsingFlags(config).empty = !0;
                        var i, parsedInput, tokens, token, skipped, era, string = "" + config._i,
                            stringLength = string.length,
                            totalParsedInputLength = 0;
                        for (tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [], i = 0; i < tokens.length; i++) token = tokens[i], (parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0]) && ((skipped = string.substr(0, string.indexOf(parsedInput))).length > 0 && getParsingFlags(config).unusedInput.push(skipped), string = string.slice(string.indexOf(parsedInput) + parsedInput.length), totalParsedInputLength += parsedInput.length), formatTokenFunctions[token] ? (parsedInput ? getParsingFlags(config).empty = !1 : getParsingFlags(config).unusedTokens.push(token), addTimeToArrayFromToken(token, parsedInput, config)) : config._strict && !parsedInput && getParsingFlags(config).unusedTokens.push(token);
                        getParsingFlags(config).charsLeftOver = stringLength - totalParsedInputLength, string.length > 0 && getParsingFlags(config).unusedInput.push(string), config._a[HOUR] <= 12 && !0 === getParsingFlags(config).bigHour && config._a[HOUR] > 0 && (getParsingFlags(config).bigHour = void 0), getParsingFlags(config).parsedDateParts = config._a.slice(0), getParsingFlags(config).meridiem = config._meridiem, config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem), null !== (era = getParsingFlags(config).era) && (config._a[YEAR] = config._locale.erasConvertYear(era, config._a[YEAR])), configFromArray(config), checkOverflow(config)
                    } else configFromRFC2822(config);
                else configFromISO(config)
            }

            function meridiemFixWrap(locale, hour, meridiem) {
                var isPm;
                return null == meridiem ? hour : null != locale.meridiemHour ? locale.meridiemHour(hour, meridiem) : null != locale.isPM ? ((isPm = locale.isPM(meridiem)) && hour < 12 && (hour += 12), isPm || 12 !== hour || (hour = 0), hour) : hour
            }

            function configFromStringAndArray(config) {
                var tempConfig, bestMoment, scoreToBeat, i, currentScore, validFormatFound, bestFormatIsValid = !1;
                if (0 === config._f.length) return getParsingFlags(config).invalidFormat = !0, void(config._d = new Date(NaN));
                for (i = 0; i < config._f.length; i++) currentScore = 0, validFormatFound = !1, tempConfig = copyConfig({}, config), null != config._useUTC && (tempConfig._useUTC = config._useUTC), tempConfig._f = config._f[i], configFromStringAndFormat(tempConfig), isValid(tempConfig) && (validFormatFound = !0), currentScore += getParsingFlags(tempConfig).charsLeftOver, currentScore += 10 * getParsingFlags(tempConfig).unusedTokens.length, getParsingFlags(tempConfig).score = currentScore, bestFormatIsValid ? currentScore < scoreToBeat && (scoreToBeat = currentScore, bestMoment = tempConfig) : (null == scoreToBeat || currentScore < scoreToBeat || validFormatFound) && (scoreToBeat = currentScore, bestMoment = tempConfig, validFormatFound && (bestFormatIsValid = !0));
                extend(config, bestMoment || tempConfig)
            }

            function configFromObject(config) {
                if (!config._d) {
                    var i = normalizeObjectUnits(config._i),
                        dayOrDate = void 0 === i.day ? i.date : i.day;
                    config._a = map([i.year, i.month, dayOrDate, i.hour, i.minute, i.second, i.millisecond], (function(obj) {
                        return obj && parseInt(obj, 10)
                    })), configFromArray(config)
                }
            }

            function createFromConfig(config) {
                var res = new Moment(checkOverflow(prepareConfig(config)));
                return res._nextDay && (res.add(1, "d"), res._nextDay = void 0), res
            }

            function prepareConfig(config) {
                var input = config._i,
                    format = config._f;
                return config._locale = config._locale || getLocale(config._l), null === input || void 0 === format && "" === input ? createInvalid({
                    nullInput: !0
                }) : ("string" == typeof input && (config._i = input = config._locale.preparse(input)), isMoment(input) ? new Moment(checkOverflow(input)) : (isDate(input) ? config._d = input : isArray(format) ? configFromStringAndArray(config) : format ? configFromStringAndFormat(config) : configFromInput(config), isValid(config) || (config._d = null), config))
            }

            function configFromInput(config) {
                var input = config._i;
                isUndefined(input) ? config._d = new Date(hooks.now()) : isDate(input) ? config._d = new Date(input.valueOf()) : "string" == typeof input ? configFromString(config) : isArray(input) ? (config._a = map(input.slice(0), (function(obj) {
                    return parseInt(obj, 10)
                })), configFromArray(config)) : isObject(input) ? configFromObject(config) : isNumber(input) ? config._d = new Date(input) : hooks.createFromInputFallback(config)
            }

            function createLocalOrUTC(input, format, locale, strict, isUTC) {
                var c = {};
                return !0 !== format && !1 !== format || (strict = format, format = void 0), !0 !== locale && !1 !== locale || (strict = locale, locale = void 0), (isObject(input) && isObjectEmpty(input) || isArray(input) && 0 === input.length) && (input = void 0), c._isAMomentObject = !0, c._useUTC = c._isUTC = isUTC, c._l = locale, c._i = input, c._f = format, c._strict = strict, createFromConfig(c)
            }

            function createLocal(input, format, locale, strict) {
                return createLocalOrUTC(input, format, locale, strict, !1)
            }
            hooks.createFromInputFallback = deprecate("value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.", (function(config) {
                config._d = new Date(config._i + (config._useUTC ? " UTC" : ""))
            })), hooks.ISO_8601 = function() {}, hooks.RFC_2822 = function() {};
            var prototypeMin = deprecate("moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/", (function() {
                    var other = createLocal.apply(null, arguments);
                    return this.isValid() && other.isValid() ? other < this ? this : other : createInvalid()
                })),
                prototypeMax = deprecate("moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/", (function() {
                    var other = createLocal.apply(null, arguments);
                    return this.isValid() && other.isValid() ? other > this ? this : other : createInvalid()
                }));

            function pickBy(fn, moments) {
                var res, i;
                if (1 === moments.length && isArray(moments[0]) && (moments = moments[0]), !moments.length) return createLocal();
                for (res = moments[0], i = 1; i < moments.length; ++i) moments[i].isValid() && !moments[i][fn](res) || (res = moments[i]);
                return res
            }

            function min() {
                return pickBy("isBefore", [].slice.call(arguments, 0))
            }

            function max() {
                return pickBy("isAfter", [].slice.call(arguments, 0))
            }
            var now = function() {
                    return Date.now ? Date.now() : +new Date
                },
                ordering = ["year", "quarter", "month", "week", "day", "hour", "minute", "second", "millisecond"];

            function isDurationValid(m) {
                var key, i, unitHasDecimal = !1;
                for (key in m)
                    if (hasOwnProp(m, key) && (-1 === indexOf.call(ordering, key) || null != m[key] && isNaN(m[key]))) return !1;
                for (i = 0; i < ordering.length; ++i)
                    if (m[ordering[i]]) {
                        if (unitHasDecimal) return !1;
                        parseFloat(m[ordering[i]]) !== toInt(m[ordering[i]]) && (unitHasDecimal = !0)
                    }
                return !0
            }

            function isValid$1() {
                return this._isValid
            }

            function createInvalid$1() {
                return createDuration(NaN)
            }

            function Duration(duration) {
                var normalizedInput = normalizeObjectUnits(duration),
                    years = normalizedInput.year || 0,
                    quarters = normalizedInput.quarter || 0,
                    months = normalizedInput.month || 0,
                    weeks = normalizedInput.week || normalizedInput.isoWeek || 0,
                    days = normalizedInput.day || 0,
                    hours = normalizedInput.hour || 0,
                    minutes = normalizedInput.minute || 0,
                    seconds = normalizedInput.second || 0,
                    milliseconds = normalizedInput.millisecond || 0;
                this._isValid = isDurationValid(normalizedInput), this._milliseconds = +milliseconds + 1e3 * seconds + 6e4 * minutes + 1e3 * hours * 60 * 60, this._days = +days + 7 * weeks, this._months = +months + 3 * quarters + 12 * years, this._data = {}, this._locale = getLocale(), this._bubble()
            }

            function isDuration(obj) {
                return obj instanceof Duration
            }

            function absRound(number) {
                return number < 0 ? -1 * Math.round(-1 * number) : Math.round(number)
            }

            function compareArrays(array1, array2, dontConvert) {
                var i, len = Math.min(array1.length, array2.length),
                    lengthDiff = Math.abs(array1.length - array2.length),
                    diffs = 0;
                for (i = 0; i < len; i++)(dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) && diffs++;
                return diffs + lengthDiff
            }

            function offset(token, separator) {
                addFormatToken(token, 0, 0, (function() {
                    var offset = this.utcOffset(),
                        sign = "+";
                    return offset < 0 && (offset = -offset, sign = "-"), sign + zeroFill(~~(offset / 60), 2) + separator + zeroFill(~~offset % 60, 2)
                }))
            }
            offset("Z", ":"), offset("ZZ", ""), addRegexToken("Z", matchShortOffset), addRegexToken("ZZ", matchShortOffset), addParseToken(["Z", "ZZ"], (function(input, array, config) {
                config._useUTC = !0, config._tzm = offsetFromString(matchShortOffset, input)
            }));
            var chunkOffset = /([\+\-]|\d\d)/gi;

            function offsetFromString(matcher, string) {
                var parts, minutes, matches = (string || "").match(matcher);
                return null === matches ? null : 0 === (minutes = 60 * (parts = ((matches[matches.length - 1] || []) + "").match(chunkOffset) || ["-", 0, 0])[1] + toInt(parts[2])) ? 0 : "+" === parts[0] ? minutes : -minutes
            }

            function cloneWithOffset(input, model) {
                var res, diff;
                return model._isUTC ? (res = model.clone(), diff = (isMoment(input) || isDate(input) ? input.valueOf() : createLocal(input).valueOf()) - res.valueOf(), res._d.setTime(res._d.valueOf() + diff), hooks.updateOffset(res, !1), res) : createLocal(input).local()
            }

            function getDateOffset(m) {
                return -Math.round(m._d.getTimezoneOffset())
            }

            function getSetOffset(input, keepLocalTime, keepMinutes) {
                var localAdjust, offset = this._offset || 0;
                if (!this.isValid()) return null != input ? this : NaN;
                if (null != input) {
                    if ("string" == typeof input) {
                        if (null === (input = offsetFromString(matchShortOffset, input))) return this
                    } else Math.abs(input) < 16 && !keepMinutes && (input *= 60);
                    return !this._isUTC && keepLocalTime && (localAdjust = getDateOffset(this)), this._offset = input, this._isUTC = !0, null != localAdjust && this.add(localAdjust, "m"), offset !== input && (!keepLocalTime || this._changeInProgress ? addSubtract(this, createDuration(input - offset, "m"), 1, !1) : this._changeInProgress || (this._changeInProgress = !0, hooks.updateOffset(this, !0), this._changeInProgress = null)), this
                }
                return this._isUTC ? offset : getDateOffset(this)
            }

            function getSetZone(input, keepLocalTime) {
                return null != input ? ("string" != typeof input && (input = -input), this.utcOffset(input, keepLocalTime), this) : -this.utcOffset()
            }

            function setOffsetToUTC(keepLocalTime) {
                return this.utcOffset(0, keepLocalTime)
            }

            function setOffsetToLocal(keepLocalTime) {
                return this._isUTC && (this.utcOffset(0, keepLocalTime), this._isUTC = !1, keepLocalTime && this.subtract(getDateOffset(this), "m")), this
            }

            function setOffsetToParsedOffset() {
                if (null != this._tzm) this.utcOffset(this._tzm, !1, !0);
                else if ("string" == typeof this._i) {
                    var tZone = offsetFromString(matchOffset, this._i);
                    null != tZone ? this.utcOffset(tZone) : this.utcOffset(0, !0)
                }
                return this
            }

            function hasAlignedHourOffset(input) {
                return !!this.isValid() && (input = input ? createLocal(input).utcOffset() : 0, (this.utcOffset() - input) % 60 == 0)
            }

            function isDaylightSavingTime() {
                return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset()
            }

            function isDaylightSavingTimeShifted() {
                if (!isUndefined(this._isDSTShifted)) return this._isDSTShifted;
                var other, c = {};
                return copyConfig(c, this), (c = prepareConfig(c))._a ? (other = c._isUTC ? createUTC(c._a) : createLocal(c._a), this._isDSTShifted = this.isValid() && compareArrays(c._a, other.toArray()) > 0) : this._isDSTShifted = !1, this._isDSTShifted
            }

            function isLocal() {
                return !!this.isValid() && !this._isUTC
            }

            function isUtcOffset() {
                return !!this.isValid() && this._isUTC
            }

            function isUtc() {
                return !!this.isValid() && this._isUTC && 0 === this._offset
            }
            hooks.updateOffset = function() {};
            var aspNetRegex = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/,
                isoRegex = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;

            function createDuration(input, key) {
                var sign, ret, diffRes, duration = input,
                    match = null;
                return isDuration(input) ? duration = {
                    ms: input._milliseconds,
                    d: input._days,
                    M: input._months
                } : isNumber(input) || !isNaN(+input) ? (duration = {}, key ? duration[key] = +input : duration.milliseconds = +input) : (match = aspNetRegex.exec(input)) ? (sign = "-" === match[1] ? -1 : 1, duration = {
                    y: 0,
                    d: toInt(match[DATE]) * sign,
                    h: toInt(match[HOUR]) * sign,
                    m: toInt(match[MINUTE]) * sign,
                    s: toInt(match[SECOND]) * sign,
                    ms: toInt(absRound(1e3 * match[MILLISECOND])) * sign
                }) : (match = isoRegex.exec(input)) ? (sign = "-" === match[1] ? -1 : 1, duration = {
                    y: parseIso(match[2], sign),
                    M: parseIso(match[3], sign),
                    w: parseIso(match[4], sign),
                    d: parseIso(match[5], sign),
                    h: parseIso(match[6], sign),
                    m: parseIso(match[7], sign),
                    s: parseIso(match[8], sign)
                }) : null == duration ? duration = {} : "object" == typeof duration && ("from" in duration || "to" in duration) && (diffRes = momentsDifference(createLocal(duration.from), createLocal(duration.to)), (duration = {}).ms = diffRes.milliseconds, duration.M = diffRes.months), ret = new Duration(duration), isDuration(input) && hasOwnProp(input, "_locale") && (ret._locale = input._locale), isDuration(input) && hasOwnProp(input, "_isValid") && (ret._isValid = input._isValid), ret
            }

            function parseIso(inp, sign) {
                var res = inp && parseFloat(inp.replace(",", "."));
                return (isNaN(res) ? 0 : res) * sign
            }

            function positiveMomentsDifference(base, other) {
                var res = {};
                return res.months = other.month() - base.month() + 12 * (other.year() - base.year()), base.clone().add(res.months, "M").isAfter(other) && --res.months, res.milliseconds = +other - +base.clone().add(res.months, "M"), res
            }

            function momentsDifference(base, other) {
                var res;
                return base.isValid() && other.isValid() ? (other = cloneWithOffset(other, base), base.isBefore(other) ? res = positiveMomentsDifference(base, other) : ((res = positiveMomentsDifference(other, base)).milliseconds = -res.milliseconds, res.months = -res.months), res) : {
                    milliseconds: 0,
                    months: 0
                }
            }

            function createAdder(direction, name) {
                return function(val, period) {
                    var tmp;
                    return null === period || isNaN(+period) || (deprecateSimple(name, "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."), tmp = val, val = period, period = tmp), addSubtract(this, createDuration(val, period), direction), this
                }
            }

            function addSubtract(mom, duration, isAdding, updateOffset) {
                var milliseconds = duration._milliseconds,
                    days = absRound(duration._days),
                    months = absRound(duration._months);
                mom.isValid() && (updateOffset = null == updateOffset || updateOffset, months && setMonth(mom, get(mom, "Month") + months * isAdding), days && set$1(mom, "Date", get(mom, "Date") + days * isAdding), milliseconds && mom._d.setTime(mom._d.valueOf() + milliseconds * isAdding), updateOffset && hooks.updateOffset(mom, days || months))
            }
            createDuration.fn = Duration.prototype, createDuration.invalid = createInvalid$1;
            var add = createAdder(1, "add"),
                subtract = createAdder(-1, "subtract");

            function isString(input) {
                return "string" == typeof input || input instanceof String
            }

            function isMomentInput(input) {
                return isMoment(input) || isDate(input) || isString(input) || isNumber(input) || isNumberOrStringArray(input) || isMomentInputObject(input) || null == input
            }

            function isMomentInputObject(input) {
                var i, property, objectTest = isObject(input) && !isObjectEmpty(input),
                    propertyTest = !1,
                    properties = ["years", "year", "y", "months", "month", "M", "days", "day", "d", "dates", "date", "D", "hours", "hour", "h", "minutes", "minute", "m", "seconds", "second", "s", "milliseconds", "millisecond", "ms"];
                for (i = 0; i < properties.length; i += 1) property = properties[i], propertyTest = propertyTest || hasOwnProp(input, property);
                return objectTest && propertyTest
            }

            function isNumberOrStringArray(input) {
                var arrayTest = isArray(input),
                    dataTypeTest = !1;
                return arrayTest && (dataTypeTest = 0 === input.filter((function(item) {
                    return !isNumber(item) && isString(input)
                })).length), arrayTest && dataTypeTest
            }

            function isCalendarSpec(input) {
                var i, property, objectTest = isObject(input) && !isObjectEmpty(input),
                    propertyTest = !1,
                    properties = ["sameDay", "nextDay", "lastDay", "nextWeek", "lastWeek", "sameElse"];
                for (i = 0; i < properties.length; i += 1) property = properties[i], propertyTest = propertyTest || hasOwnProp(input, property);
                return objectTest && propertyTest
            }

            function getCalendarFormat(myMoment, now) {
                var diff = myMoment.diff(now, "days", !0);
                return diff < -6 ? "sameElse" : diff < -1 ? "lastWeek" : diff < 0 ? "lastDay" : diff < 1 ? "sameDay" : diff < 2 ? "nextDay" : diff < 7 ? "nextWeek" : "sameElse"
            }

            function calendar$1(time, formats) {
                1 === arguments.length && (arguments[0] ? isMomentInput(arguments[0]) ? (time = arguments[0], formats = void 0) : isCalendarSpec(arguments[0]) && (formats = arguments[0], time = void 0) : (time = void 0, formats = void 0));
                var now = time || createLocal(),
                    sod = cloneWithOffset(now, this).startOf("day"),
                    format = hooks.calendarFormat(this, sod) || "sameElse",
                    output = formats && (isFunction(formats[format]) ? formats[format].call(this, now) : formats[format]);
                return this.format(output || this.localeData().calendar(format, this, createLocal(now)))
            }

            function clone() {
                return new Moment(this)
            }

            function isAfter(input, units) {
                var localInput = isMoment(input) ? input : createLocal(input);
                return !(!this.isValid() || !localInput.isValid()) && ("millisecond" === (units = normalizeUnits(units) || "millisecond") ? this.valueOf() > localInput.valueOf() : localInput.valueOf() < this.clone().startOf(units).valueOf())
            }

            function isBefore(input, units) {
                var localInput = isMoment(input) ? input : createLocal(input);
                return !(!this.isValid() || !localInput.isValid()) && ("millisecond" === (units = normalizeUnits(units) || "millisecond") ? this.valueOf() < localInput.valueOf() : this.clone().endOf(units).valueOf() < localInput.valueOf())
            }

            function isBetween(from, to, units, inclusivity) {
                var localFrom = isMoment(from) ? from : createLocal(from),
                    localTo = isMoment(to) ? to : createLocal(to);
                return !!(this.isValid() && localFrom.isValid() && localTo.isValid()) && ("(" === (inclusivity = inclusivity || "()")[0] ? this.isAfter(localFrom, units) : !this.isBefore(localFrom, units)) && (")" === inclusivity[1] ? this.isBefore(localTo, units) : !this.isAfter(localTo, units))
            }

            function isSame(input, units) {
                var inputMs, localInput = isMoment(input) ? input : createLocal(input);
                return !(!this.isValid() || !localInput.isValid()) && ("millisecond" === (units = normalizeUnits(units) || "millisecond") ? this.valueOf() === localInput.valueOf() : (inputMs = localInput.valueOf(), this.clone().startOf(units).valueOf() <= inputMs && inputMs <= this.clone().endOf(units).valueOf()))
            }

            function isSameOrAfter(input, units) {
                return this.isSame(input, units) || this.isAfter(input, units)
            }

            function isSameOrBefore(input, units) {
                return this.isSame(input, units) || this.isBefore(input, units)
            }

            function diff(input, units, asFloat) {
                var that, zoneDelta, output;
                if (!this.isValid()) return NaN;
                if (!(that = cloneWithOffset(input, this)).isValid()) return NaN;
                switch (zoneDelta = 6e4 * (that.utcOffset() - this.utcOffset()), units = normalizeUnits(units)) {
                    case "year":
                        output = monthDiff(this, that) / 12;
                        break;
                    case "month":
                        output = monthDiff(this, that);
                        break;
                    case "quarter":
                        output = monthDiff(this, that) / 3;
                        break;
                    case "second":
                        output = (this - that) / 1e3;
                        break;
                    case "minute":
                        output = (this - that) / 6e4;
                        break;
                    case "hour":
                        output = (this - that) / 36e5;
                        break;
                    case "day":
                        output = (this - that - zoneDelta) / 864e5;
                        break;
                    case "week":
                        output = (this - that - zoneDelta) / 6048e5;
                        break;
                    default:
                        output = this - that
                }
                return asFloat ? output : absFloor(output)
            }

            function monthDiff(a, b) {
                if (a.date() < b.date()) return -monthDiff(b, a);
                var wholeMonthDiff = 12 * (b.year() - a.year()) + (b.month() - a.month()),
                    anchor = a.clone().add(wholeMonthDiff, "months");
                return -(wholeMonthDiff + (b - anchor < 0 ? (b - anchor) / (anchor - a.clone().add(wholeMonthDiff - 1, "months")) : (b - anchor) / (a.clone().add(wholeMonthDiff + 1, "months") - anchor))) || 0
            }

            function toString() {
                return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")
            }

            function toISOString(keepOffset) {
                if (!this.isValid()) return null;
                var utc = !0 !== keepOffset,
                    m = utc ? this.clone().utc() : this;
                return m.year() < 0 || m.year() > 9999 ? formatMoment(m, utc ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ") : isFunction(Date.prototype.toISOString) ? utc ? this.toDate().toISOString() : new Date(this.valueOf() + 60 * this.utcOffset() * 1e3).toISOString().replace("Z", formatMoment(m, "Z")) : formatMoment(m, utc ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ")
            }

            function inspect() {
                if (!this.isValid()) return "moment.invalid(/* " + this._i + " */)";
                var prefix, year, datetime, suffix, func = "moment",
                    zone = "";
                return this.isLocal() || (func = 0 === this.utcOffset() ? "moment.utc" : "moment.parseZone", zone = "Z"), prefix = "[" + func + '("]', year = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY", datetime = "-MM-DD[T]HH:mm:ss.SSS", suffix = zone + '[")]', this.format(prefix + year + datetime + suffix)
            }

            function format(inputString) {
                inputString || (inputString = this.isUtc() ? hooks.defaultFormatUtc : hooks.defaultFormat);
                var output = formatMoment(this, inputString);
                return this.localeData().postformat(output)
            }

            function from(time, withoutSuffix) {
                return this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid()) ? createDuration({
                    to: this,
                    from: time
                }).locale(this.locale()).humanize(!withoutSuffix) : this.localeData().invalidDate()
            }

            function fromNow(withoutSuffix) {
                return this.from(createLocal(), withoutSuffix)
            }

            function to(time, withoutSuffix) {
                return this.isValid() && (isMoment(time) && time.isValid() || createLocal(time).isValid()) ? createDuration({
                    from: this,
                    to: time
                }).locale(this.locale()).humanize(!withoutSuffix) : this.localeData().invalidDate()
            }

            function toNow(withoutSuffix) {
                return this.to(createLocal(), withoutSuffix)
            }

            function locale(key) {
                var newLocaleData;
                return void 0 === key ? this._locale._abbr : (null != (newLocaleData = getLocale(key)) && (this._locale = newLocaleData), this)
            }
            hooks.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ", hooks.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
            var lang = deprecate("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", (function(key) {
                return void 0 === key ? this.localeData() : this.locale(key)
            }));

            function localeData() {
                return this._locale
            }
            var MS_PER_SECOND = 1e3,
                MS_PER_MINUTE = 60 * MS_PER_SECOND,
                MS_PER_HOUR = 60 * MS_PER_MINUTE,
                MS_PER_400_YEARS = 3506328 * MS_PER_HOUR;

            function mod$1(dividend, divisor) {
                return (dividend % divisor + divisor) % divisor
            }

            function localStartOfDate(y, m, d) {
                return y < 100 && y >= 0 ? new Date(y + 400, m, d) - MS_PER_400_YEARS : new Date(y, m, d).valueOf()
            }

            function utcStartOfDate(y, m, d) {
                return y < 100 && y >= 0 ? Date.UTC(y + 400, m, d) - MS_PER_400_YEARS : Date.UTC(y, m, d)
            }

            function startOf(units) {
                var time, startOfDate;
                if (void 0 === (units = normalizeUnits(units)) || "millisecond" === units || !this.isValid()) return this;
                switch (startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate, units) {
                    case "year":
                        time = startOfDate(this.year(), 0, 1);
                        break;
                    case "quarter":
                        time = startOfDate(this.year(), this.month() - this.month() % 3, 1);
                        break;
                    case "month":
                        time = startOfDate(this.year(), this.month(), 1);
                        break;
                    case "week":
                        time = startOfDate(this.year(), this.month(), this.date() - this.weekday());
                        break;
                    case "isoWeek":
                        time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1));
                        break;
                    case "day":
                    case "date":
                        time = startOfDate(this.year(), this.month(), this.date());
                        break;
                    case "hour":
                        time = this._d.valueOf(), time -= mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR);
                        break;
                    case "minute":
                        time = this._d.valueOf(), time -= mod$1(time, MS_PER_MINUTE);
                        break;
                    case "second":
                        time = this._d.valueOf(), time -= mod$1(time, MS_PER_SECOND)
                }
                return this._d.setTime(time), hooks.updateOffset(this, !0), this
            }

            function endOf(units) {
                var time, startOfDate;
                if (void 0 === (units = normalizeUnits(units)) || "millisecond" === units || !this.isValid()) return this;
                switch (startOfDate = this._isUTC ? utcStartOfDate : localStartOfDate, units) {
                    case "year":
                        time = startOfDate(this.year() + 1, 0, 1) - 1;
                        break;
                    case "quarter":
                        time = startOfDate(this.year(), this.month() - this.month() % 3 + 3, 1) - 1;
                        break;
                    case "month":
                        time = startOfDate(this.year(), this.month() + 1, 1) - 1;
                        break;
                    case "week":
                        time = startOfDate(this.year(), this.month(), this.date() - this.weekday() + 7) - 1;
                        break;
                    case "isoWeek":
                        time = startOfDate(this.year(), this.month(), this.date() - (this.isoWeekday() - 1) + 7) - 1;
                        break;
                    case "day":
                    case "date":
                        time = startOfDate(this.year(), this.month(), this.date() + 1) - 1;
                        break;
                    case "hour":
                        time = this._d.valueOf(), time += MS_PER_HOUR - mod$1(time + (this._isUTC ? 0 : this.utcOffset() * MS_PER_MINUTE), MS_PER_HOUR) - 1;
                        break;
                    case "minute":
                        time = this._d.valueOf(), time += MS_PER_MINUTE - mod$1(time, MS_PER_MINUTE) - 1;
                        break;
                    case "second":
                        time = this._d.valueOf(), time += MS_PER_SECOND - mod$1(time, MS_PER_SECOND) - 1
                }
                return this._d.setTime(time), hooks.updateOffset(this, !0), this
            }

            function valueOf() {
                return this._d.valueOf() - 6e4 * (this._offset || 0)
            }

            function unix() {
                return Math.floor(this.valueOf() / 1e3)
            }

            function toDate() {
                return new Date(this.valueOf())
            }

            function toArray() {
                var m = this;
                return [m.year(), m.month(), m.date(), m.hour(), m.minute(), m.second(), m.millisecond()]
            }

            function toObject() {
                var m = this;
                return {
                    years: m.year(),
                    months: m.month(),
                    date: m.date(),
                    hours: m.hours(),
                    minutes: m.minutes(),
                    seconds: m.seconds(),
                    milliseconds: m.milliseconds()
                }
            }

            function toJSON() {
                return this.isValid() ? this.toISOString() : null
            }

            function isValid$2() {
                return isValid(this)
            }

            function parsingFlags() {
                return extend({}, getParsingFlags(this))
            }

            function invalidAt() {
                return getParsingFlags(this).overflow
            }

            function creationData() {
                return {
                    input: this._i,
                    format: this._f,
                    locale: this._locale,
                    isUTC: this._isUTC,
                    strict: this._strict
                }
            }

            function localeEras(m, format) {
                var i, l, date, eras = this._eras || getLocale("en")._eras;
                for (i = 0, l = eras.length; i < l; ++i) {
                    switch (typeof eras[i].since) {
                        case "string":
                            date = hooks(eras[i].since).startOf("day"), eras[i].since = date.valueOf()
                    }
                    switch (typeof eras[i].until) {
                        case "undefined":
                            eras[i].until = 1 / 0;
                            break;
                        case "string":
                            date = hooks(eras[i].until).startOf("day").valueOf(), eras[i].until = date.valueOf()
                    }
                }
                return eras
            }

            function localeErasParse(eraName, format, strict) {
                var i, l, name, abbr, narrow, eras = this.eras();
                for (eraName = eraName.toUpperCase(), i = 0, l = eras.length; i < l; ++i)
                    if (name = eras[i].name.toUpperCase(), abbr = eras[i].abbr.toUpperCase(), narrow = eras[i].narrow.toUpperCase(), strict) switch (format) {
                        case "N":
                        case "NN":
                        case "NNN":
                            if (abbr === eraName) return eras[i];
                            break;
                        case "NNNN":
                            if (name === eraName) return eras[i];
                            break;
                        case "NNNNN":
                            if (narrow === eraName) return eras[i]
                    } else if ([name, abbr, narrow].indexOf(eraName) >= 0) return eras[i]
            }

            function localeErasConvertYear(era, year) {
                var dir = era.since <= era.until ? 1 : -1;
                return void 0 === year ? hooks(era.since).year() : hooks(era.since).year() + (year - era.offset) * dir
            }

            function getEraName() {
                var i, l, val, eras = this.localeData().eras();
                for (i = 0, l = eras.length; i < l; ++i) {
                    if (val = this.clone().startOf("day").valueOf(), eras[i].since <= val && val <= eras[i].until) return eras[i].name;
                    if (eras[i].until <= val && val <= eras[i].since) return eras[i].name
                }
                return ""
            }

            function getEraNarrow() {
                var i, l, val, eras = this.localeData().eras();
                for (i = 0, l = eras.length; i < l; ++i) {
                    if (val = this.clone().startOf("day").valueOf(), eras[i].since <= val && val <= eras[i].until) return eras[i].narrow;
                    if (eras[i].until <= val && val <= eras[i].since) return eras[i].narrow
                }
                return ""
            }

            function getEraAbbr() {
                var i, l, val, eras = this.localeData().eras();
                for (i = 0, l = eras.length; i < l; ++i) {
                    if (val = this.clone().startOf("day").valueOf(), eras[i].since <= val && val <= eras[i].until) return eras[i].abbr;
                    if (eras[i].until <= val && val <= eras[i].since) return eras[i].abbr
                }
                return ""
            }

            function getEraYear() {
                var i, l, dir, val, eras = this.localeData().eras();
                for (i = 0, l = eras.length; i < l; ++i)
                    if (dir = eras[i].since <= eras[i].until ? 1 : -1, val = this.clone().startOf("day").valueOf(), eras[i].since <= val && val <= eras[i].until || eras[i].until <= val && val <= eras[i].since) return (this.year() - hooks(eras[i].since).year()) * dir + eras[i].offset;
                return this.year()
            }

            function erasNameRegex(isStrict) {
                return hasOwnProp(this, "_erasNameRegex") || computeErasParse.call(this), isStrict ? this._erasNameRegex : this._erasRegex
            }

            function erasAbbrRegex(isStrict) {
                return hasOwnProp(this, "_erasAbbrRegex") || computeErasParse.call(this), isStrict ? this._erasAbbrRegex : this._erasRegex
            }

            function erasNarrowRegex(isStrict) {
                return hasOwnProp(this, "_erasNarrowRegex") || computeErasParse.call(this), isStrict ? this._erasNarrowRegex : this._erasRegex
            }

            function matchEraAbbr(isStrict, locale) {
                return locale.erasAbbrRegex(isStrict)
            }

            function matchEraName(isStrict, locale) {
                return locale.erasNameRegex(isStrict)
            }

            function matchEraNarrow(isStrict, locale) {
                return locale.erasNarrowRegex(isStrict)
            }

            function matchEraYearOrdinal(isStrict, locale) {
                return locale._eraYearOrdinalRegex || matchUnsigned
            }

            function computeErasParse() {
                var i, l, abbrPieces = [],
                    namePieces = [],
                    narrowPieces = [],
                    mixedPieces = [],
                    eras = this.eras();
                for (i = 0, l = eras.length; i < l; ++i) namePieces.push(regexEscape(eras[i].name)), abbrPieces.push(regexEscape(eras[i].abbr)), narrowPieces.push(regexEscape(eras[i].narrow)), mixedPieces.push(regexEscape(eras[i].name)), mixedPieces.push(regexEscape(eras[i].abbr)), mixedPieces.push(regexEscape(eras[i].narrow));
                this._erasRegex = new RegExp("^(" + mixedPieces.join("|") + ")", "i"), this._erasNameRegex = new RegExp("^(" + namePieces.join("|") + ")", "i"), this._erasAbbrRegex = new RegExp("^(" + abbrPieces.join("|") + ")", "i"), this._erasNarrowRegex = new RegExp("^(" + narrowPieces.join("|") + ")", "i")
            }

            function addWeekYearFormatToken(token, getter) {
                addFormatToken(0, [token, token.length], 0, getter)
            }

            function getSetWeekYear(input) {
                return getSetWeekYearHelper.call(this, input, this.week(), this.weekday(), this.localeData()._week.dow, this.localeData()._week.doy)
            }

            function getSetISOWeekYear(input) {
                return getSetWeekYearHelper.call(this, input, this.isoWeek(), this.isoWeekday(), 1, 4)
            }

            function getISOWeeksInYear() {
                return weeksInYear(this.year(), 1, 4)
            }

            function getISOWeeksInISOWeekYear() {
                return weeksInYear(this.isoWeekYear(), 1, 4)
            }

            function getWeeksInYear() {
                var weekInfo = this.localeData()._week;
                return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy)
            }

            function getWeeksInWeekYear() {
                var weekInfo = this.localeData()._week;
                return weeksInYear(this.weekYear(), weekInfo.dow, weekInfo.doy)
            }

            function getSetWeekYearHelper(input, week, weekday, dow, doy) {
                var weeksTarget;
                return null == input ? weekOfYear(this, dow, doy).year : (week > (weeksTarget = weeksInYear(input, dow, doy)) && (week = weeksTarget), setWeekAll.call(this, input, week, weekday, dow, doy))
            }

            function setWeekAll(weekYear, week, weekday, dow, doy) {
                var dayOfYearData = dayOfYearFromWeeks(weekYear, week, weekday, dow, doy),
                    date = createUTCDate(dayOfYearData.year, 0, dayOfYearData.dayOfYear);
                return this.year(date.getUTCFullYear()), this.month(date.getUTCMonth()), this.date(date.getUTCDate()), this
            }

            function getSetQuarter(input) {
                return null == input ? Math.ceil((this.month() + 1) / 3) : this.month(3 * (input - 1) + this.month() % 3)
            }
            addFormatToken("N", 0, 0, "eraAbbr"), addFormatToken("NN", 0, 0, "eraAbbr"), addFormatToken("NNN", 0, 0, "eraAbbr"), addFormatToken("NNNN", 0, 0, "eraName"), addFormatToken("NNNNN", 0, 0, "eraNarrow"), addFormatToken("y", ["y", 1], "yo", "eraYear"), addFormatToken("y", ["yy", 2], 0, "eraYear"), addFormatToken("y", ["yyy", 3], 0, "eraYear"), addFormatToken("y", ["yyyy", 4], 0, "eraYear"), addRegexToken("N", matchEraAbbr), addRegexToken("NN", matchEraAbbr), addRegexToken("NNN", matchEraAbbr), addRegexToken("NNNN", matchEraName), addRegexToken("NNNNN", matchEraNarrow), addParseToken(["N", "NN", "NNN", "NNNN", "NNNNN"], (function(input, array, config, token) {
                var era = config._locale.erasParse(input, token, config._strict);
                era ? getParsingFlags(config).era = era : getParsingFlags(config).invalidEra = input
            })), addRegexToken("y", matchUnsigned), addRegexToken("yy", matchUnsigned), addRegexToken("yyy", matchUnsigned), addRegexToken("yyyy", matchUnsigned), addRegexToken("yo", matchEraYearOrdinal), addParseToken(["y", "yy", "yyy", "yyyy"], YEAR), addParseToken(["yo"], (function(input, array, config, token) {
                var match;
                config._locale._eraYearOrdinalRegex && (match = input.match(config._locale._eraYearOrdinalRegex)), config._locale.eraYearOrdinalParse ? array[YEAR] = config._locale.eraYearOrdinalParse(input, match) : array[YEAR] = parseInt(input, 10)
            })), addFormatToken(0, ["gg", 2], 0, (function() {
                return this.weekYear() % 100
            })), addFormatToken(0, ["GG", 2], 0, (function() {
                return this.isoWeekYear() % 100
            })), addWeekYearFormatToken("gggg", "weekYear"), addWeekYearFormatToken("ggggg", "weekYear"), addWeekYearFormatToken("GGGG", "isoWeekYear"), addWeekYearFormatToken("GGGGG", "isoWeekYear"), addUnitAlias("weekYear", "gg"), addUnitAlias("isoWeekYear", "GG"), addUnitPriority("weekYear", 1), addUnitPriority("isoWeekYear", 1), addRegexToken("G", matchSigned), addRegexToken("g", matchSigned), addRegexToken("GG", match1to2, match2), addRegexToken("gg", match1to2, match2), addRegexToken("GGGG", match1to4, match4), addRegexToken("gggg", match1to4, match4), addRegexToken("GGGGG", match1to6, match6), addRegexToken("ggggg", match1to6, match6), addWeekParseToken(["gggg", "ggggg", "GGGG", "GGGGG"], (function(input, week, config, token) {
                week[token.substr(0, 2)] = toInt(input)
            })), addWeekParseToken(["gg", "GG"], (function(input, week, config, token) {
                week[token] = hooks.parseTwoDigitYear(input)
            })), addFormatToken("Q", 0, "Qo", "quarter"), addUnitAlias("quarter", "Q"), addUnitPriority("quarter", 7), addRegexToken("Q", match1), addParseToken("Q", (function(input, array) {
                array[MONTH] = 3 * (toInt(input) - 1)
            })), addFormatToken("D", ["DD", 2], "Do", "date"), addUnitAlias("date", "D"), addUnitPriority("date", 9), addRegexToken("D", match1to2), addRegexToken("DD", match1to2, match2), addRegexToken("Do", (function(isStrict, locale) {
                return isStrict ? locale._dayOfMonthOrdinalParse || locale._ordinalParse : locale._dayOfMonthOrdinalParseLenient
            })), addParseToken(["D", "DD"], DATE), addParseToken("Do", (function(input, array) {
                array[DATE] = toInt(input.match(match1to2)[0])
            }));
            var getSetDayOfMonth = makeGetSet("Date", !0);

            function getSetDayOfYear(input) {
                var dayOfYear = Math.round((this.clone().startOf("day") - this.clone().startOf("year")) / 864e5) + 1;
                return null == input ? dayOfYear : this.add(input - dayOfYear, "d")
            }
            addFormatToken("DDD", ["DDDD", 3], "DDDo", "dayOfYear"), addUnitAlias("dayOfYear", "DDD"), addUnitPriority("dayOfYear", 4), addRegexToken("DDD", match1to3), addRegexToken("DDDD", match3), addParseToken(["DDD", "DDDD"], (function(input, array, config) {
                config._dayOfYear = toInt(input)
            })), addFormatToken("m", ["mm", 2], 0, "minute"), addUnitAlias("minute", "m"), addUnitPriority("minute", 14), addRegexToken("m", match1to2), addRegexToken("mm", match1to2, match2), addParseToken(["m", "mm"], MINUTE);
            var getSetMinute = makeGetSet("Minutes", !1);
            addFormatToken("s", ["ss", 2], 0, "second"), addUnitAlias("second", "s"), addUnitPriority("second", 15), addRegexToken("s", match1to2), addRegexToken("ss", match1to2, match2), addParseToken(["s", "ss"], SECOND);
            var token, getSetMillisecond, getSetSecond = makeGetSet("Seconds", !1);
            for (addFormatToken("S", 0, 0, (function() {
                    return ~~(this.millisecond() / 100)
                })), addFormatToken(0, ["SS", 2], 0, (function() {
                    return ~~(this.millisecond() / 10)
                })), addFormatToken(0, ["SSS", 3], 0, "millisecond"), addFormatToken(0, ["SSSS", 4], 0, (function() {
                    return 10 * this.millisecond()
                })), addFormatToken(0, ["SSSSS", 5], 0, (function() {
                    return 100 * this.millisecond()
                })), addFormatToken(0, ["SSSSSS", 6], 0, (function() {
                    return 1e3 * this.millisecond()
                })), addFormatToken(0, ["SSSSSSS", 7], 0, (function() {
                    return 1e4 * this.millisecond()
                })), addFormatToken(0, ["SSSSSSSS", 8], 0, (function() {
                    return 1e5 * this.millisecond()
                })), addFormatToken(0, ["SSSSSSSSS", 9], 0, (function() {
                    return 1e6 * this.millisecond()
                })), addUnitAlias("millisecond", "ms"), addUnitPriority("millisecond", 16), addRegexToken("S", match1to3, match1), addRegexToken("SS", match1to3, match2), addRegexToken("SSS", match1to3, match3), token = "SSSS"; token.length <= 9; token += "S") addRegexToken(token, matchUnsigned);

            function parseMs(input, array) {
                array[MILLISECOND] = toInt(1e3 * ("0." + input))
            }
            for (token = "S"; token.length <= 9; token += "S") addParseToken(token, parseMs);

            function getZoneAbbr() {
                return this._isUTC ? "UTC" : ""
            }

            function getZoneName() {
                return this._isUTC ? "Coordinated Universal Time" : ""
            }
            getSetMillisecond = makeGetSet("Milliseconds", !1), addFormatToken("z", 0, 0, "zoneAbbr"), addFormatToken("zz", 0, 0, "zoneName");
            var proto = Moment.prototype;

            function createUnix(input) {
                return createLocal(1e3 * input)
            }

            function createInZone() {
                return createLocal.apply(null, arguments).parseZone()
            }

            function preParsePostFormat(string) {
                return string
            }
            proto.add = add, proto.calendar = calendar$1, proto.clone = clone, proto.diff = diff, proto.endOf = endOf, proto.format = format, proto.from = from, proto.fromNow = fromNow, proto.to = to, proto.toNow = toNow, proto.get = stringGet, proto.invalidAt = invalidAt, proto.isAfter = isAfter, proto.isBefore = isBefore, proto.isBetween = isBetween, proto.isSame = isSame, proto.isSameOrAfter = isSameOrAfter, proto.isSameOrBefore = isSameOrBefore, proto.isValid = isValid$2, proto.lang = lang, proto.locale = locale, proto.localeData = localeData, proto.max = prototypeMax, proto.min = prototypeMin, proto.parsingFlags = parsingFlags, proto.set = stringSet, proto.startOf = startOf, proto.subtract = subtract, proto.toArray = toArray, proto.toObject = toObject, proto.toDate = toDate, proto.toISOString = toISOString, proto.inspect = inspect, "undefined" != typeof Symbol && null != Symbol.for && (proto[Symbol.for("nodejs.util.inspect.custom")] = function() {
                return "Moment<" + this.format() + ">"
            }), proto.toJSON = toJSON, proto.toString = toString, proto.unix = unix, proto.valueOf = valueOf, proto.creationData = creationData, proto.eraName = getEraName, proto.eraNarrow = getEraNarrow, proto.eraAbbr = getEraAbbr, proto.eraYear = getEraYear, proto.year = getSetYear, proto.isLeapYear = getIsLeapYear, proto.weekYear = getSetWeekYear, proto.isoWeekYear = getSetISOWeekYear, proto.quarter = proto.quarters = getSetQuarter, proto.month = getSetMonth, proto.daysInMonth = getDaysInMonth, proto.week = proto.weeks = getSetWeek, proto.isoWeek = proto.isoWeeks = getSetISOWeek, proto.weeksInYear = getWeeksInYear, proto.weeksInWeekYear = getWeeksInWeekYear, proto.isoWeeksInYear = getISOWeeksInYear, proto.isoWeeksInISOWeekYear = getISOWeeksInISOWeekYear, proto.date = getSetDayOfMonth, proto.day = proto.days = getSetDayOfWeek, proto.weekday = getSetLocaleDayOfWeek, proto.isoWeekday = getSetISODayOfWeek, proto.dayOfYear = getSetDayOfYear, proto.hour = proto.hours = getSetHour, proto.minute = proto.minutes = getSetMinute, proto.second = proto.seconds = getSetSecond, proto.millisecond = proto.milliseconds = getSetMillisecond, proto.utcOffset = getSetOffset, proto.utc = setOffsetToUTC, proto.local = setOffsetToLocal, proto.parseZone = setOffsetToParsedOffset, proto.hasAlignedHourOffset = hasAlignedHourOffset, proto.isDST = isDaylightSavingTime, proto.isLocal = isLocal, proto.isUtcOffset = isUtcOffset, proto.isUtc = isUtc, proto.isUTC = isUtc, proto.zoneAbbr = getZoneAbbr, proto.zoneName = getZoneName, proto.dates = deprecate("dates accessor is deprecated. Use date instead.", getSetDayOfMonth), proto.months = deprecate("months accessor is deprecated. Use month instead", getSetMonth), proto.years = deprecate("years accessor is deprecated. Use year instead", getSetYear), proto.zone = deprecate("moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/", getSetZone), proto.isDSTShifted = deprecate("isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information", isDaylightSavingTimeShifted);
            var proto$1 = Locale.prototype;

            function get$1(format, index, field, setter) {
                var locale = getLocale(),
                    utc = createUTC().set(setter, index);
                return locale[field](utc, format)
            }

            function listMonthsImpl(format, index, field) {
                if (isNumber(format) && (index = format, format = void 0), format = format || "", null != index) return get$1(format, index, field, "month");
                var i, out = [];
                for (i = 0; i < 12; i++) out[i] = get$1(format, i, field, "month");
                return out
            }

            function listWeekdaysImpl(localeSorted, format, index, field) {
                "boolean" == typeof localeSorted ? (isNumber(format) && (index = format, format = void 0), format = format || "") : (index = format = localeSorted, localeSorted = !1, isNumber(format) && (index = format, format = void 0), format = format || "");
                var i, locale = getLocale(),
                    shift = localeSorted ? locale._week.dow : 0,
                    out = [];
                if (null != index) return get$1(format, (index + shift) % 7, field, "day");
                for (i = 0; i < 7; i++) out[i] = get$1(format, (i + shift) % 7, field, "day");
                return out
            }

            function listMonths(format, index) {
                return listMonthsImpl(format, index, "months")
            }

            function listMonthsShort(format, index) {
                return listMonthsImpl(format, index, "monthsShort")
            }

            function listWeekdays(localeSorted, format, index) {
                return listWeekdaysImpl(localeSorted, format, index, "weekdays")
            }

            function listWeekdaysShort(localeSorted, format, index) {
                return listWeekdaysImpl(localeSorted, format, index, "weekdaysShort")
            }

            function listWeekdaysMin(localeSorted, format, index) {
                return listWeekdaysImpl(localeSorted, format, index, "weekdaysMin")
            }
            proto$1.calendar = calendar, proto$1.longDateFormat = longDateFormat, proto$1.invalidDate = invalidDate, proto$1.ordinal = ordinal, proto$1.preparse = preParsePostFormat, proto$1.postformat = preParsePostFormat, proto$1.relativeTime = relativeTime, proto$1.pastFuture = pastFuture, proto$1.set = set, proto$1.eras = localeEras, proto$1.erasParse = localeErasParse, proto$1.erasConvertYear = localeErasConvertYear, proto$1.erasAbbrRegex = erasAbbrRegex, proto$1.erasNameRegex = erasNameRegex, proto$1.erasNarrowRegex = erasNarrowRegex, proto$1.months = localeMonths, proto$1.monthsShort = localeMonthsShort, proto$1.monthsParse = localeMonthsParse, proto$1.monthsRegex = monthsRegex, proto$1.monthsShortRegex = monthsShortRegex, proto$1.week = localeWeek, proto$1.firstDayOfYear = localeFirstDayOfYear, proto$1.firstDayOfWeek = localeFirstDayOfWeek, proto$1.weekdays = localeWeekdays, proto$1.weekdaysMin = localeWeekdaysMin, proto$1.weekdaysShort = localeWeekdaysShort, proto$1.weekdaysParse = localeWeekdaysParse, proto$1.weekdaysRegex = weekdaysRegex, proto$1.weekdaysShortRegex = weekdaysShortRegex, proto$1.weekdaysMinRegex = weekdaysMinRegex, proto$1.isPM = localeIsPM, proto$1.meridiem = localeMeridiem, getSetGlobalLocale("en", {
                eras: [{
                    since: "0001-01-01",
                    until: 1 / 0,
                    offset: 1,
                    name: "Anno Domini",
                    narrow: "AD",
                    abbr: "AD"
                }, {
                    since: "0000-12-31",
                    until: -1 / 0,
                    offset: 1,
                    name: "Before Christ",
                    narrow: "BC",
                    abbr: "BC"
                }],
                dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
                ordinal: function(number) {
                    var b = number % 10;
                    return number + (1 === toInt(number % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th")
                }
            }), hooks.lang = deprecate("moment.lang is deprecated. Use moment.locale instead.", getSetGlobalLocale), hooks.langData = deprecate("moment.langData is deprecated. Use moment.localeData instead.", getLocale);
            var mathAbs = Math.abs;

            function abs() {
                var data = this._data;
                return this._milliseconds = mathAbs(this._milliseconds), this._days = mathAbs(this._days), this._months = mathAbs(this._months), data.milliseconds = mathAbs(data.milliseconds), data.seconds = mathAbs(data.seconds), data.minutes = mathAbs(data.minutes), data.hours = mathAbs(data.hours), data.months = mathAbs(data.months), data.years = mathAbs(data.years), this
            }

            function addSubtract$1(duration, input, value, direction) {
                var other = createDuration(input, value);
                return duration._milliseconds += direction * other._milliseconds, duration._days += direction * other._days, duration._months += direction * other._months, duration._bubble()
            }

            function add$1(input, value) {
                return addSubtract$1(this, input, value, 1)
            }

            function subtract$1(input, value) {
                return addSubtract$1(this, input, value, -1)
            }

            function absCeil(number) {
                return number < 0 ? Math.floor(number) : Math.ceil(number)
            }

            function bubble() {
                var seconds, minutes, hours, years, monthsFromDays, milliseconds = this._milliseconds,
                    days = this._days,
                    months = this._months,
                    data = this._data;
                return milliseconds >= 0 && days >= 0 && months >= 0 || milliseconds <= 0 && days <= 0 && months <= 0 || (milliseconds += 864e5 * absCeil(monthsToDays(months) + days), days = 0, months = 0), data.milliseconds = milliseconds % 1e3, seconds = absFloor(milliseconds / 1e3), data.seconds = seconds % 60, minutes = absFloor(seconds / 60), data.minutes = minutes % 60, hours = absFloor(minutes / 60), data.hours = hours % 24, days += absFloor(hours / 24), months += monthsFromDays = absFloor(daysToMonths(days)), days -= absCeil(monthsToDays(monthsFromDays)), years = absFloor(months / 12), months %= 12, data.days = days, data.months = months, data.years = years, this
            }

            function daysToMonths(days) {
                return 4800 * days / 146097
            }

            function monthsToDays(months) {
                return 146097 * months / 4800
            }

            function as(units) {
                if (!this.isValid()) return NaN;
                var days, months, milliseconds = this._milliseconds;
                if ("month" === (units = normalizeUnits(units)) || "quarter" === units || "year" === units) switch (days = this._days + milliseconds / 864e5, months = this._months + daysToMonths(days), units) {
                    case "month":
                        return months;
                    case "quarter":
                        return months / 3;
                    case "year":
                        return months / 12
                } else switch (days = this._days + Math.round(monthsToDays(this._months)), units) {
                    case "week":
                        return days / 7 + milliseconds / 6048e5;
                    case "day":
                        return days + milliseconds / 864e5;
                    case "hour":
                        return 24 * days + milliseconds / 36e5;
                    case "minute":
                        return 1440 * days + milliseconds / 6e4;
                    case "second":
                        return 86400 * days + milliseconds / 1e3;
                    case "millisecond":
                        return Math.floor(864e5 * days) + milliseconds;
                    default:
                        throw new Error("Unknown unit " + units)
                }
            }

            function valueOf$1() {
                return this.isValid() ? this._milliseconds + 864e5 * this._days + this._months % 12 * 2592e6 + 31536e6 * toInt(this._months / 12) : NaN
            }

            function makeAs(alias) {
                return function() {
                    return this.as(alias)
                }
            }
            var asMilliseconds = makeAs("ms"),
                asSeconds = makeAs("s"),
                asMinutes = makeAs("m"),
                asHours = makeAs("h"),
                asDays = makeAs("d"),
                asWeeks = makeAs("w"),
                asMonths = makeAs("M"),
                asQuarters = makeAs("Q"),
                asYears = makeAs("y");

            function clone$1() {
                return createDuration(this)
            }

            function get$2(units) {
                return units = normalizeUnits(units), this.isValid() ? this[units + "s"]() : NaN
            }

            function makeGetter(name) {
                return function() {
                    return this.isValid() ? this._data[name] : NaN
                }
            }
            var milliseconds = makeGetter("milliseconds"),
                seconds = makeGetter("seconds"),
                minutes = makeGetter("minutes"),
                hours = makeGetter("hours"),
                days = makeGetter("days"),
                months = makeGetter("months"),
                years = makeGetter("years");

            function weeks() {
                return absFloor(this.days() / 7)
            }
            var round = Math.round,
                thresholds = {
                    ss: 44,
                    s: 45,
                    m: 45,
                    h: 22,
                    d: 26,
                    w: null,
                    M: 11
                };

            function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
                return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture)
            }

            function relativeTime$1(posNegDuration, withoutSuffix, thresholds, locale) {
                var duration = createDuration(posNegDuration).abs(),
                    seconds = round(duration.as("s")),
                    minutes = round(duration.as("m")),
                    hours = round(duration.as("h")),
                    days = round(duration.as("d")),
                    months = round(duration.as("M")),
                    weeks = round(duration.as("w")),
                    years = round(duration.as("y")),
                    a = seconds <= thresholds.ss && ["s", seconds] || seconds < thresholds.s && ["ss", seconds] || minutes <= 1 && ["m"] || minutes < thresholds.m && ["mm", minutes] || hours <= 1 && ["h"] || hours < thresholds.h && ["hh", hours] || days <= 1 && ["d"] || days < thresholds.d && ["dd", days];
                return null != thresholds.w && (a = a || weeks <= 1 && ["w"] || weeks < thresholds.w && ["ww", weeks]), (a = a || months <= 1 && ["M"] || months < thresholds.M && ["MM", months] || years <= 1 && ["y"] || ["yy", years])[2] = withoutSuffix, a[3] = +posNegDuration > 0, a[4] = locale, substituteTimeAgo.apply(null, a)
            }

            function getSetRelativeTimeRounding(roundingFunction) {
                return void 0 === roundingFunction ? round : "function" == typeof roundingFunction && (round = roundingFunction, !0)
            }

            function getSetRelativeTimeThreshold(threshold, limit) {
                return void 0 !== thresholds[threshold] && (void 0 === limit ? thresholds[threshold] : (thresholds[threshold] = limit, "s" === threshold && (thresholds.ss = limit - 1), !0))
            }

            function humanize(argWithSuffix, argThresholds) {
                if (!this.isValid()) return this.localeData().invalidDate();
                var locale, output, withSuffix = !1,
                    th = thresholds;
                return "object" == typeof argWithSuffix && (argThresholds = argWithSuffix, argWithSuffix = !1), "boolean" == typeof argWithSuffix && (withSuffix = argWithSuffix), "object" == typeof argThresholds && (th = Object.assign({}, thresholds, argThresholds), null != argThresholds.s && null == argThresholds.ss && (th.ss = argThresholds.s - 1)), output = relativeTime$1(this, !withSuffix, th, locale = this.localeData()), withSuffix && (output = locale.pastFuture(+this, output)), locale.postformat(output)
            }
            var abs$1 = Math.abs;

            function sign(x) {
                return (x > 0) - (x < 0) || +x
            }

            function toISOString$1() {
                if (!this.isValid()) return this.localeData().invalidDate();
                var minutes, hours, years, s, totalSign, ymSign, daysSign, hmsSign, seconds = abs$1(this._milliseconds) / 1e3,
                    days = abs$1(this._days),
                    months = abs$1(this._months),
                    total = this.asSeconds();
                return total ? (minutes = absFloor(seconds / 60), hours = absFloor(minutes / 60), seconds %= 60, minutes %= 60, years = absFloor(months / 12), months %= 12, s = seconds ? seconds.toFixed(3).replace(/\.?0+$/, "") : "", totalSign = total < 0 ? "-" : "", ymSign = sign(this._months) !== sign(total) ? "-" : "", daysSign = sign(this._days) !== sign(total) ? "-" : "", hmsSign = sign(this._milliseconds) !== sign(total) ? "-" : "", totalSign + "P" + (years ? ymSign + years + "Y" : "") + (months ? ymSign + months + "M" : "") + (days ? daysSign + days + "D" : "") + (hours || minutes || seconds ? "T" : "") + (hours ? hmsSign + hours + "H" : "") + (minutes ? hmsSign + minutes + "M" : "") + (seconds ? hmsSign + s + "S" : "")) : "P0D"
            }
            var proto$2 = Duration.prototype;
            return proto$2.isValid = isValid$1, proto$2.abs = abs, proto$2.add = add$1, proto$2.subtract = subtract$1, proto$2.as = as, proto$2.asMilliseconds = asMilliseconds, proto$2.asSeconds = asSeconds, proto$2.asMinutes = asMinutes, proto$2.asHours = asHours, proto$2.asDays = asDays, proto$2.asWeeks = asWeeks, proto$2.asMonths = asMonths, proto$2.asQuarters = asQuarters, proto$2.asYears = asYears, proto$2.valueOf = valueOf$1, proto$2._bubble = bubble, proto$2.clone = clone$1, proto$2.get = get$2, proto$2.milliseconds = milliseconds, proto$2.seconds = seconds, proto$2.minutes = minutes, proto$2.hours = hours, proto$2.days = days, proto$2.weeks = weeks, proto$2.months = months, proto$2.years = years, proto$2.humanize = humanize, proto$2.toISOString = toISOString$1, proto$2.toString = toISOString$1, proto$2.toJSON = toISOString$1, proto$2.locale = locale, proto$2.localeData = localeData, proto$2.toIsoString = deprecate("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", toISOString$1), proto$2.lang = lang, addFormatToken("X", 0, 0, "unix"), addFormatToken("x", 0, 0, "valueOf"), addRegexToken("x", matchSigned), addRegexToken("X", matchTimestamp), addParseToken("X", (function(input, array, config) {
                config._d = new Date(1e3 * parseFloat(input))
            })), addParseToken("x", (function(input, array, config) {
                config._d = new Date(toInt(input))
            })), hooks.version = "2.29.1", setHookCallback(createLocal), hooks.fn = proto, hooks.min = min, hooks.max = max, hooks.now = now, hooks.utc = createUTC, hooks.unix = createUnix, hooks.months = listMonths, hooks.isDate = isDate, hooks.locale = getSetGlobalLocale, hooks.invalid = createInvalid, hooks.duration = createDuration, hooks.isMoment = isMoment, hooks.weekdays = listWeekdays, hooks.parseZone = createInZone, hooks.localeData = getLocale, hooks.isDuration = isDuration, hooks.monthsShort = listMonthsShort, hooks.weekdaysMin = listWeekdaysMin, hooks.defineLocale = defineLocale, hooks.updateLocale = updateLocale, hooks.locales = listLocales, hooks.weekdaysShort = listWeekdaysShort, hooks.normalizeUnits = normalizeUnits, hooks.relativeTimeRounding = getSetRelativeTimeRounding, hooks.relativeTimeThreshold = getSetRelativeTimeThreshold, hooks.calendarFormat = getCalendarFormat, hooks.prototype = proto, hooks.HTML5_FMT = {
                DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
                DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
                DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
                DATE: "YYYY-MM-DD",
                TIME: "HH:mm",
                TIME_SECONDS: "HH:mm:ss",
                TIME_MS: "HH:mm:ss.SSS",
                WEEK: "GGGG-[W]WW",
                MONTH: "YYYY-MM"
            }, hooks
        }()
    }).call(this, __webpack_require__(104)(module))
}, function(module, exports, __webpack_require__) {
    var map = {
        "./af": 105,
        "./af.js": 105,
        "./ar": 106,
        "./ar-dz": 107,
        "./ar-dz.js": 107,
        "./ar-kw": 108,
        "./ar-kw.js": 108,
        "./ar-ly": 109,
        "./ar-ly.js": 109,
        "./ar-ma": 110,
        "./ar-ma.js": 110,
        "./ar-sa": 111,
        "./ar-sa.js": 111,
        "./ar-tn": 112,
        "./ar-tn.js": 112,
        "./ar.js": 106,
        "./az": 113,
        "./az.js": 113,
        "./be": 114,
        "./be.js": 114,
        "./bg": 115,
        "./bg.js": 115,
        "./bm": 116,
        "./bm.js": 116,
        "./bn": 117,
        "./bn-bd": 118,
        "./bn-bd.js": 118,
        "./bn.js": 117,
        "./bo": 119,
        "./bo.js": 119,
        "./br": 120,
        "./br.js": 120,
        "./bs": 121,
        "./bs.js": 121,
        "./ca": 122,
        "./ca.js": 122,
        "./cs": 123,
        "./cs.js": 123,
        "./cv": 124,
        "./cv.js": 124,
        "./cy": 125,
        "./cy.js": 125,
        "./da": 126,
        "./da.js": 126,
        "./de": 127,
        "./de-at": 128,
        "./de-at.js": 128,
        "./de-ch": 129,
        "./de-ch.js": 129,
        "./de.js": 127,
        "./dv": 130,
        "./dv.js": 130,
        "./el": 131,
        "./el.js": 131,
        "./en-au": 132,
        "./en-au.js": 132,
        "./en-ca": 133,
        "./en-ca.js": 133,
        "./en-gb": 134,
        "./en-gb.js": 134,
        "./en-ie": 135,
        "./en-ie.js": 135,
        "./en-il": 136,
        "./en-il.js": 136,
        "./en-in": 137,
        "./en-in.js": 137,
        "./en-nz": 138,
        "./en-nz.js": 138,
        "./en-sg": 139,
        "./en-sg.js": 139,
        "./eo": 140,
        "./eo.js": 140,
        "./es": 141,
        "./es-do": 142,
        "./es-do.js": 142,
        "./es-mx": 143,
        "./es-mx.js": 143,
        "./es-us": 144,
        "./es-us.js": 144,
        "./es.js": 141,
        "./et": 145,
        "./et.js": 145,
        "./eu": 146,
        "./eu.js": 146,
        "./fa": 147,
        "./fa.js": 147,
        "./fi": 148,
        "./fi.js": 148,
        "./fil": 149,
        "./fil.js": 149,
        "./fo": 150,
        "./fo.js": 150,
        "./fr": 151,
        "./fr-ca": 152,
        "./fr-ca.js": 152,
        "./fr-ch": 153,
        "./fr-ch.js": 153,
        "./fr.js": 151,
        "./fy": 154,
        "./fy.js": 154,
        "./ga": 155,
        "./ga.js": 155,
        "./gd": 156,
        "./gd.js": 156,
        "./gl": 157,
        "./gl.js": 157,
        "./gom-deva": 158,
        "./gom-deva.js": 158,
        "./gom-latn": 159,
        "./gom-latn.js": 159,
        "./gu": 160,
        "./gu.js": 160,
        "./he": 161,
        "./he.js": 161,
        "./hi": 162,
        "./hi.js": 162,
        "./hr": 163,
        "./hr.js": 163,
        "./hu": 164,
        "./hu.js": 164,
        "./hy-am": 165,
        "./hy-am.js": 165,
        "./id": 166,
        "./id.js": 166,
        "./is": 167,
        "./is.js": 167,
        "./it": 168,
        "./it-ch": 169,
        "./it-ch.js": 169,
        "./it.js": 168,
        "./ja": 170,
        "./ja.js": 170,
        "./jv": 171,
        "./jv.js": 171,
        "./ka": 172,
        "./ka.js": 172,
        "./kk": 173,
        "./kk.js": 173,
        "./km": 174,
        "./km.js": 174,
        "./kn": 175,
        "./kn.js": 175,
        "./ko": 176,
        "./ko.js": 176,
        "./ku": 177,
        "./ku.js": 177,
        "./ky": 178,
        "./ky.js": 178,
        "./lb": 179,
        "./lb.js": 179,
        "./lo": 180,
        "./lo.js": 180,
        "./lt": 181,
        "./lt.js": 181,
        "./lv": 182,
        "./lv.js": 182,
        "./me": 183,
        "./me.js": 183,
        "./mi": 184,
        "./mi.js": 184,
        "./mk": 185,
        "./mk.js": 185,
        "./ml": 186,
        "./ml.js": 186,
        "./mn": 187,
        "./mn.js": 187,
        "./mr": 188,
        "./mr.js": 188,
        "./ms": 189,
        "./ms-my": 190,
        "./ms-my.js": 190,
        "./ms.js": 189,
        "./mt": 191,
        "./mt.js": 191,
        "./my": 192,
        "./my.js": 192,
        "./nb": 193,
        "./nb.js": 193,
        "./ne": 194,
        "./ne.js": 194,
        "./nl": 195,
        "./nl-be": 196,
        "./nl-be.js": 196,
        "./nl.js": 195,
        "./nn": 197,
        "./nn.js": 197,
        "./oc-lnc": 198,
        "./oc-lnc.js": 198,
        "./pa-in": 199,
        "./pa-in.js": 199,
        "./pl": 200,
        "./pl.js": 200,
        "./pt": 201,
        "./pt-br": 202,
        "./pt-br.js": 202,
        "./pt.js": 201,
        "./ro": 203,
        "./ro.js": 203,
        "./ru": 204,
        "./ru.js": 204,
        "./sd": 205,
        "./sd.js": 205,
        "./se": 206,
        "./se.js": 206,
        "./si": 207,
        "./si.js": 207,
        "./sk": 208,
        "./sk.js": 208,
        "./sl": 209,
        "./sl.js": 209,
        "./sq": 210,
        "./sq.js": 210,
        "./sr": 211,
        "./sr-cyrl": 212,
        "./sr-cyrl.js": 212,
        "./sr.js": 211,
        "./ss": 213,
        "./ss.js": 213,
        "./sv": 214,
        "./sv.js": 214,
        "./sw": 215,
        "./sw.js": 215,
        "./ta": 216,
        "./ta.js": 216,
        "./te": 217,
        "./te.js": 217,
        "./tet": 218,
        "./tet.js": 218,
        "./tg": 219,
        "./tg.js": 219,
        "./th": 220,
        "./th.js": 220,
        "./tk": 221,
        "./tk.js": 221,
        "./tl-ph": 222,
        "./tl-ph.js": 222,
        "./tlh": 223,
        "./tlh.js": 223,
        "./tr": 224,
        "./tr.js": 224,
        "./tzl": 225,
        "./tzl.js": 225,
        "./tzm": 226,
        "./tzm-latn": 227,
        "./tzm-latn.js": 227,
        "./tzm.js": 226,
        "./ug-cn": 228,
        "./ug-cn.js": 228,
        "./uk": 229,
        "./uk.js": 229,
        "./ur": 230,
        "./ur.js": 230,
        "./uz": 231,
        "./uz-latn": 232,
        "./uz-latn.js": 232,
        "./uz.js": 231,
        "./vi": 233,
        "./vi.js": 233,
        "./x-pseudo": 234,
        "./x-pseudo.js": 234,
        "./yo": 235,
        "./yo.js": 235,
        "./zh-cn": 236,
        "./zh-cn.js": 236,
        "./zh-hk": 237,
        "./zh-hk.js": 237,
        "./zh-mo": 238,
        "./zh-mo.js": 238,
        "./zh-tw": 239,
        "./zh-tw.js": 239
    };

    function webpackContext(req) {
        var id = webpackContextResolve(req);
        return __webpack_require__(id)
    }

    function webpackContextResolve(req) {
        if (!__webpack_require__.o(map, req)) {
            var e = new Error("Cannot find module '" + req + "'");
            throw e.code = "MODULE_NOT_FOUND", e
        }
        return map[req]
    }
    webpackContext.keys = function() {
        return Object.keys(map)
    }, webpackContext.resolve = webpackContextResolve, module.exports = webpackContext, webpackContext.id = 261
}, function(module, exports, __webpack_require__) {
    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
    ! function(a, i) {
        "use strict";
        module.exports ? module.exports = i(__webpack_require__(3)) : (__WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(3)], void 0 === (__WEBPACK_AMD_DEFINE_RESULT__ = "function" == typeof(__WEBPACK_AMD_DEFINE_FACTORY__ = i) ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__) || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__))
    }(0, (function(c) {
        "use strict";
        void 0 === c.version && c.default && (c = c.default);
        var i, A = {},
            n = {},
            t = {},
            s = {},
            u = {};
        c && "string" == typeof c.version || O("Moment Timezone requires Moment.js. See https://momentjs.com/timezone/docs/#/use-it/browser/");
        var a = c.version.split("."),
            e = +a[0],
            r = +a[1];

        function m(a) {
            return 96 < a ? a - 87 : 64 < a ? a - 29 : a - 48
        }

        function o(a) {
            var i = 0,
                e = a.split("."),
                r = e[0],
                o = e[1] || "",
                c = 1,
                A = 0,
                n = 1;
            for (45 === a.charCodeAt(0) && (n = -(i = 1)); i < r.length; i++) A = 60 * A + m(r.charCodeAt(i));
            for (i = 0; i < o.length; i++) c /= 60, A += m(o.charCodeAt(i)) * c;
            return A * n
        }

        function f(a) {
            for (var i = 0; i < a.length; i++) a[i] = o(a[i])
        }

        function l(a, i) {
            for (var e = [], r = 0; r < i.length; r++) e[r] = a[i[r]];
            return e
        }

        function p(a) {
            var i = a.split("|"),
                e = i[2].split(" "),
                r = i[3].split(""),
                o = i[4].split(" ");
            return f(e), f(r), f(o),
                function(a, i) {
                    for (var e = 0; e < i; e++) a[e] = Math.round((a[e - 1] || 0) + 6e4 * a[e]);
                    a[i - 1] = 1 / 0
                }(o, r.length), {
                    name: i[0],
                    abbrs: l(i[1].split(" "), r),
                    offsets: l(e, r),
                    untils: o,
                    population: 0 | i[5]
                }
        }

        function M(a) {
            a && this._set(p(a))
        }

        function d(a, i) {
            this.name = a, this.zones = i
        }

        function b(a) {
            var i = a.toTimeString(),
                e = i.match(/\([a-z ]+\)/i);
            "GMT" === (e = e && e[0] ? (e = e[0].match(/[A-Z]/g)) ? e.join("") : void 0 : (e = i.match(/[A-Z]{3,5}/g)) ? e[0] : void 0) && (e = void 0), this.at = +a, this.abbr = e, this.offset = a.getTimezoneOffset()
        }

        function h(a) {
            this.zone = a, this.offsetScore = 0, this.abbrScore = 0
        }

        function E(a, i) {
            return a.offsetScore !== i.offsetScore ? a.offsetScore - i.offsetScore : a.abbrScore !== i.abbrScore ? a.abbrScore - i.abbrScore : a.zone.population !== i.zone.population ? i.zone.population - a.zone.population : i.zone.name.localeCompare(a.zone.name)
        }

        function z() {
            try {
                var a = Intl.DateTimeFormat().resolvedOptions().timeZone;
                if (a && 3 < a.length) {
                    var i = s[P(a)];
                    if (i) return i;
                    O("Moment Timezone found " + a + " from the Intl api, but did not have that data loaded.")
                }
            } catch (a) {}
            for (var e, r, o = function() {
                    for (var a, i, e = (new Date).getFullYear() - 2, r = new b(new Date(e, 0, 1)), o = [r], c = 1; c < 48; c++)(i = new b(new Date(e, c, 1))).offset !== r.offset && (a = function(a, i) {
                        for (var e, r; r = 6e4 * ((i.at - a.at) / 12e4 | 0);)(e = new b(new Date(a.at + r))).offset === a.offset ? a = e : i = e;
                        return a
                    }(r, i), o.push(a), o.push(new b(new Date(a.at + 6e4)))), r = i;
                    for (c = 0; c < 4; c++) o.push(new b(new Date(e + c, 0, 1))), o.push(new b(new Date(e + c, 6, 1)));
                    return o
                }(), c = o.length, A = function(a) {
                    for (var i, e, r = a.length, o = {}, c = [], A = 0; A < r; A++)
                        for (i in e = u[a[A].offset] || {}) e.hasOwnProperty(i) && (o[i] = !0);
                    for (A in o) o.hasOwnProperty(A) && c.push(s[A]);
                    return c
                }(o), n = [], t = 0; t < A.length; t++) {
                for (e = new h(T(A[t])), r = 0; r < c; r++) e.scoreOffsetAt(o[r]);
                n.push(e)
            }
            return n.sort(E), 0 < n.length ? n[0].zone.name : void 0
        }

        function P(a) {
            return (a || "").toLowerCase().replace(/\//g, "_")
        }

        function S(a) {
            var i, e, r, o;
            for ("string" == typeof a && (a = [a]), i = 0; i < a.length; i++) o = P(e = (r = a[i].split("|"))[0]), A[o] = a[i], s[o] = e,
                function(a, i) {
                    var e, r;
                    for (f(i), e = 0; e < i.length; e++) r = i[e], u[r] = u[r] || {}, u[r][a] = !0
                }(o, r[2].split(" "))
        }

        function T(a, i) {
            a = P(a);
            var e, r = A[a];
            return r instanceof M ? r : "string" == typeof r ? (r = new M(r), A[a] = r) : n[a] && i !== T && (e = T(n[a], T)) ? ((r = A[a] = new M)._set(e), r.name = s[a], r) : null
        }

        function _(a) {
            var i, e, r, o;
            for ("string" == typeof a && (a = [a]), i = 0; i < a.length; i++) r = P((e = a[i].split("|"))[0]), o = P(e[1]), n[r] = o, s[r] = e[0], n[o] = r, s[o] = e[1]
        }

        function k(a) {
            S(a.zones), _(a.links),
                function(a) {
                    var i, e, r, o;
                    if (a && a.length)
                        for (i = 0; i < a.length; i++) e = (o = a[i].split("|"))[0].toUpperCase(), r = o[1].split(" "), t[e] = new d(e, r)
                }(a.countries), L.dataVersion = a.version
        }

        function C(a) {
            var i = "X" === a._f || "x" === a._f;
            return !(!a._a || void 0 !== a._tzm || i)
        }

        function O(a) {
            "undefined" != typeof console && "function" == typeof console.error && console.error(a)
        }

        function L(a) {
            var i = Array.prototype.slice.call(arguments, 0, -1),
                e = arguments[arguments.length - 1],
                r = T(e),
                o = c.utc.apply(null, i);
            return r && !c.isMoment(a) && C(o) && o.add(r.parse(o), "minutes"), o.tz(e), o
        }(e < 2 || 2 == e && r < 6) && O("Moment Timezone requires Moment.js >= 2.6.0. You are using Moment.js " + c.version + ". See momentjs.com"), M.prototype = {
            _set: function(a) {
                this.name = a.name, this.abbrs = a.abbrs, this.untils = a.untils, this.offsets = a.offsets, this.population = a.population
            },
            _index: function(a) {
                for (var i = +a, e = this.untils, r = 0; r < e.length; r++)
                    if (i < e[r]) return r
            },
            countries: function() {
                var i = this.name;
                return Object.keys(t).filter((function(a) {
                    return -1 !== t[a].zones.indexOf(i)
                }))
            },
            parse: function(a) {
                for (var i, e, r, o = +a, c = this.offsets, A = this.untils, n = A.length - 1, t = 0; t < n; t++)
                    if (i = c[t], e = c[t + 1], r = c[t ? t - 1 : t], i < e && L.moveAmbiguousForward ? i = e : r < i && L.moveInvalidForward && (i = r), o < A[t] - 6e4 * i) return c[t];
                return c[n]
            },
            abbr: function(a) {
                return this.abbrs[this._index(a)]
            },
            offset: function(a) {
                return O("zone.offset has been deprecated in favor of zone.utcOffset"), this.offsets[this._index(a)]
            },
            utcOffset: function(a) {
                return this.offsets[this._index(a)]
            }
        }, h.prototype.scoreOffsetAt = function(a) {
            this.offsetScore += Math.abs(this.zone.utcOffset(a.at) - a.offset), this.zone.abbr(a.at).replace(/[^A-Z]/g, "") !== a.abbr && this.abbrScore++
        }, L.version = "0.5.32", L.dataVersion = "", L._zones = A, L._links = n, L._names = s, L._countries = t, L.add = S, L.link = _, L.load = k, L.zone = T, L.zoneExists = function B(a) {
            return B.didShowError || (B.didShowError = !0, O("moment.tz.zoneExists('" + a + "') has been deprecated in favor of !moment.tz.zone('" + a + "')")), !!T(a)
        }, L.guess = function(a) {
            return i && !a || (i = z()), i
        }, L.names = function() {
            var a, i = [];
            for (a in s) s.hasOwnProperty(a) && (A[a] || A[n[a]]) && s[a] && i.push(s[a]);
            return i.sort()
        }, L.Zone = M, L.unpack = p, L.unpackBase60 = o, L.needsOffset = C, L.moveInvalidForward = !0, L.moveAmbiguousForward = !1, L.countries = function() {
            return Object.keys(t)
        }, L.zonesForCountry = function(a, i) {
            var e;
            if (e = (e = a).toUpperCase(), !(a = t[e] || null)) return null;
            var r = a.zones.sort();
            return i ? r.map((function(a) {
                return {
                    name: a,
                    offset: T(a).utcOffset(new Date)
                }
            })) : r
        };
        var y, N = c.fn;

        function D(a) {
            return function() {
                return this._z ? this._z.abbr(this) : a.call(this)
            }
        }

        function v(a) {
            return function() {
                return this._z = null, a.apply(this, arguments)
            }
        }
        c.tz = L, c.defaultZone = null, c.updateOffset = function(a, i) {
            var e, r, o = c.defaultZone;
            void 0 === a._z && (o && C(a) && !a._isUTC && (a._d = c.utc(a._a)._d, a.utc().add(o.parse(a), "minutes")), a._z = o), a._z && (r = a._z.utcOffset(a), Math.abs(r) < 16 && (r /= 60), void 0 !== a.utcOffset ? (e = a._z, a.utcOffset(-r, i), a._z = e) : a.zone(r, i))
        }, N.tz = function(a, i) {
            if (a) {
                if ("string" != typeof a) throw new Error("Time zone name must be a string, got " + a + " [" + typeof a + "]");
                return this._z = T(a), this._z ? c.updateOffset(this, i) : O("Moment Timezone has no data for " + a + ". See http://momentjs.com/timezone/docs/#/data-loading/."), this
            }
            if (this._z) return this._z.name
        }, N.zoneName = D(N.zoneName), N.zoneAbbr = D(N.zoneAbbr), N.utc = v(N.utc), N.local = v(N.local), N.utcOffset = (y = N.utcOffset, function() {
            return 0 < arguments.length && (this._z = null), y.apply(this, arguments)
        }), c.tz.setDefault = function(a) {
            return (e < 2 || 2 == e && r < 9) && O("Moment Timezone setDefault() requires Moment.js >= 2.9.0. You are using Moment.js " + c.version + "."), c.defaultZone = a ? T(a) : null, c
        };
        var G = c.momentProperties;
        return "[object Array]" === Object.prototype.toString.call(G) ? (G.push("_z"), G.push("_a")) : G && (G._z = null), k({
            version: "2020a",
            zones: ["Africa/Abidjan|GMT|0|0||48e5", "Africa/Nairobi|EAT|-30|0||47e5", "Africa/Algiers|CET|-10|0||26e5", "Africa/Lagos|WAT|-10|0||17e6", "Africa/Maputo|CAT|-20|0||26e5", "Africa/Cairo|EET|-20|0||15e6", "Africa/Casablanca|+00 +01|0 -10|010101010101010101010101010101|1O9e0 uM0 e00 Dc0 11A0 s00 e00 IM0 WM0 mo0 gM0 LA0 WM0 jA0 e00 28M0 e00 2600 gM0 2600 e00 2600 gM0 2600 e00 28M0 e00 2600 gM0|32e5", "Europe/Paris|CET CEST|-10 -20|01010101010101010101010|1O9d0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|11e6", "Africa/Johannesburg|SAST|-20|0||84e5", "Africa/Khartoum|EAT CAT|-30 -20|01|1Usl0|51e5", "Africa/Sao_Tome|GMT WAT|0 -10|010|1UQN0 2q00|", "Africa/Windhoek|CAT WAT|-20 -10|0101010|1Oc00 11B0 1nX0 11B0 1nX0 11B0|32e4", "America/Adak|HST HDT|a0 90|01010101010101010101010|1O100 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|326", "America/Anchorage|AKST AKDT|90 80|01010101010101010101010|1O0X0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|30e4", "America/Santo_Domingo|AST|40|0||29e5", "America/Fortaleza|-03|30|0||34e5", "America/Asuncion|-03 -04|30 40|01010101010101010101010|1O6r0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0 17b0 1ip0 19X0 1fB0 19X0 1fB0 19X0 1fB0 19X0 1ip0 17b0 1ip0|28e5", "America/Panama|EST|50|0||15e5", "America/Mexico_City|CST CDT|60 50|01010101010101010101010|1Oc80 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0|20e6", "America/Managua|CST|60|0||22e5", "America/La_Paz|-04|40|0||19e5", "America/Lima|-05|50|0||11e6", "America/Denver|MST MDT|70 60|01010101010101010101010|1O0V0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|26e5", "America/Campo_Grande|-03 -04|30 40|0101010101|1NTf0 1zd0 On0 1zd0 On0 1zd0 On0 1HB0 FX0|77e4", "America/Cancun|CST EST|60 50|01|1NKU0|63e4", "America/Caracas|-0430 -04|4u 40|01|1QMT0|29e5", "America/Chicago|CST CDT|60 50|01010101010101010101010|1O0U0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|92e5", "America/Chihuahua|MST MDT|70 60|01010101010101010101010|1Oc90 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0 14p0 1nX0 11B0 1nX0 11B0 1nX0 14p0 1lb0 14p0 1lb0|81e4", "America/Phoenix|MST|70|0||42e5", "America/Whitehorse|PST PDT MST|80 70 70|010101010102|1O0W0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0|23e3", "America/New_York|EST EDT|50 40|01010101010101010101010|1O0T0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|21e6", "America/Los_Angeles|PST PDT|80 70|01010101010101010101010|1O0W0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|15e6", "America/Fort_Nelson|PST MST|80 70|01|1O0W0|39e2", "America/Halifax|AST ADT|40 30|01010101010101010101010|1O0S0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|39e4", "America/Godthab|-03 -02|30 20|01010101010101010101010|1O9d0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|17e3", "America/Grand_Turk|EST EDT AST|50 40 40|0121010101010101010|1O0T0 1zb0 5Ip0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|37e2", "America/Havana|CST CDT|50 40|01010101010101010101010|1O0R0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Rc0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0 Oo0 1zc0|21e5", "America/Metlakatla|PST AKST AKDT|80 90 80|01212120121212121212121|1PAa0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 uM0 jB0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|14e2", "America/Miquelon|-03 -02|30 20|01010101010101010101010|1O0R0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|61e2", "America/Montevideo|-02 -03|20 30|01|1O0Q0|17e5", "America/Noronha|-02|20|0||30e2", "America/Port-au-Prince|EST EDT|50 40|010101010101010101010|1O0T0 1zb0 3iN0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|23e5", "Antarctica/Palmer|-03 -04|30 40|010|1QSr0 Ap0|40", "America/Santiago|-03 -04|30 40|010101010101010101010|1QSr0 Ap0 1Nb0 Ap0 1Nb0 Ap0 1zb0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 11B0 1nX0 11B0|62e5", "America/Sao_Paulo|-02 -03|20 30|0101010101|1NTe0 1zd0 On0 1zd0 On0 1zd0 On0 1HB0 FX0|20e6", "Atlantic/Azores|-01 +00|10 0|01010101010101010101010|1O9d0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|25e4", "America/St_Johns|NST NDT|3u 2u|01010101010101010101010|1O0Ru 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Rd0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0 Op0 1zb0|11e4", "Antarctica/Casey|+08 +11|-80 -b0|010|1RWg0 3m10|10", "Asia/Bangkok|+07|-70|0||15e6", "Asia/Vladivostok|+10|-a0|0||60e4", "Pacific/Bougainville|+11|-b0|0||18e4", "Asia/Tashkent|+05|-50|0||23e5", "Pacific/Auckland|NZDT NZST|-d0 -c0|01010101010101010101010|1ObO0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1io0 1a00 1fA0 1a00|14e5", "Asia/Baghdad|+03|-30|0||66e5", "Antarctica/Troll|+00 +02|0 -20|01010101010101010101010|1O9d0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|40", "Asia/Dhaka|+06|-60|0||16e6", "Asia/Amman|EET EEST|-20 -30|01010101010101010101010|1O8m0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1o00 11A0 1qM0|25e5", "Asia/Kamchatka|+12|-c0|0||18e4", "Asia/Baku|+04 +05|-40 -50|010|1O9c0 1o00|27e5", "Asia/Barnaul|+06 +07|-60 -70|01|1QyI0|", "Asia/Beirut|EET EEST|-20 -30|01010101010101010101010|1O9a0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0|22e5", "Asia/Kuala_Lumpur|+08|-80|0||71e5", "Asia/Kolkata|IST|-5u|0||15e6", "Asia/Chita|+08 +09|-80 -90|01|1QyG0|33e4", "Asia/Ulaanbaatar|+08 +09|-80 -90|01010|1O8G0 1cJ0 1cP0 1cJ0|12e5", "Asia/Shanghai|CST|-80|0||23e6", "Asia/Colombo|+0530|-5u|0||22e5", "Asia/Damascus|EET EEST|-20 -30|01010101010101010101010|1O8m0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 WN0 1qL0 WN0 1qL0 11B0 1nX0 11B0 1nX0 11B0 1qL0|26e5", "Asia/Yakutsk|+09|-90|0||28e4", "Asia/Dubai|+04|-40|0||39e5", "Asia/Famagusta|EET EEST +03|-20 -30 -30|0101201010101010101010|1O9d0 1o00 11A0 15U0 2Ks0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|", "Asia/Gaza|EET EEST|-20 -30|01010101010101010101010|1O8K0 1nz0 1220 1qL0 WN0 1qL0 WN0 1qL0 11c0 1oo0 11c0 1rc0 Wo0 1rc0 Wo0 1rc0 11c0 1oo0 11c0 1oo0 11c0 1oo0|18e5", "Asia/Hong_Kong|HKT|-80|0||73e5", "Asia/Hovd|+07 +08|-70 -80|01010|1O8H0 1cJ0 1cP0 1cJ0|81e3", "Europe/Istanbul|EET EEST +03|-20 -30 -30|01012|1O9d0 1tA0 U00 15w0|13e6", "Asia/Jakarta|WIB|-70|0||31e6", "Asia/Jayapura|WIT|-90|0||26e4", "Asia/Jerusalem|IST IDT|-20 -30|01010101010101010101010|1O8o0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0 10N0 1rz0 W10 1rz0 W10 1rz0 10N0 1oL0 10N0 1oL0|81e4", "Asia/Kabul|+0430|-4u|0||46e5", "Asia/Karachi|PKT|-50|0||24e6", "Asia/Kathmandu|+0545|-5J|0||12e5", "Asia/Magadan|+10 +11|-a0 -b0|01|1QJQ0|95e3", "Asia/Makassar|WITA|-80|0||15e5", "Asia/Manila|PST|-80|0||24e6", "Europe/Athens|EET EEST|-20 -30|01010101010101010101010|1O9d0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|35e5", "Asia/Novosibirsk|+06 +07|-60 -70|01|1Rmk0|15e5", "Asia/Pyongyang|KST KST|-90 -8u|010|1P4D0 6BA0|29e5", "Asia/Qyzylorda|+06 +05|-60 -50|01|1Xei0|73e4", "Asia/Rangoon|+0630|-6u|0||48e5", "Asia/Sakhalin|+10 +11|-a0 -b0|01|1QyE0|58e4", "Asia/Seoul|KST|-90|0||23e6", "Asia/Tehran|+0330 +0430|-3u -4u|01010101010101010101010|1O6ku 1dz0 1cp0 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0 1cp0 1dz0 1cp0 1dz0 1cp0 1dz0 1cN0 1dz0|14e6", "Asia/Tokyo|JST|-90|0||38e6", "Asia/Tomsk|+06 +07|-60 -70|01|1QXU0|10e5", "Europe/Lisbon|WET WEST|0 -10|01010101010101010101010|1O9d0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|27e5", "Atlantic/Cape_Verde|-01|10|0||50e4", "Australia/Sydney|AEDT AEST|-b0 -a0|01010101010101010101010|1ObQ0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0|40e5", "Australia/Adelaide|ACDT ACST|-au -9u|01010101010101010101010|1ObQu 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0|11e5", "Australia/Brisbane|AEST|-a0|0||20e5", "Australia/Darwin|ACST|-9u|0||12e4", "Australia/Eucla|+0845|-8J|0||368", "Australia/Lord_Howe|+11 +1030|-b0 -au|01010101010101010101010|1ObP0 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1fAu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1cLu 1cMu 1fzu 1cMu 1cLu 1cMu|347", "Australia/Perth|AWST|-80|0||18e5", "Pacific/Easter|-05 -06|50 60|010101010101010101010|1QSr0 Ap0 1Nb0 Ap0 1Nb0 Ap0 1zb0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1nX0 11B0 1qL0 11B0 1nX0 11B0|30e2", "Europe/Dublin|GMT IST|0 -10|01010101010101010101010|1O9d0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|12e5", "Etc/GMT-1|+01|-10|0||", "Pacific/Fakaofo|+13|-d0|0||483", "Pacific/Kiritimati|+14|-e0|0||51e2", "Etc/GMT-2|+02|-20|0||", "Pacific/Tahiti|-10|a0|0||18e4", "Pacific/Niue|-11|b0|0||12e2", "Etc/GMT+12|-12|c0|0||", "Pacific/Galapagos|-06|60|0||25e3", "Etc/GMT+7|-07|70|0||", "Pacific/Pitcairn|-08|80|0||56", "Pacific/Gambier|-09|90|0||125", "Etc/UTC|UTC|0|0||", "Europe/Ulyanovsk|+03 +04|-30 -40|01|1QyL0|13e5", "Europe/London|GMT BST|0 -10|01010101010101010101010|1O9d0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|10e6", "Europe/Chisinau|EET EEST|-20 -30|01010101010101010101010|1O9c0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|67e4", "Europe/Moscow|MSK|-30|0||16e6", "Europe/Saratov|+03 +04|-30 -40|01|1Sfz0|", "Europe/Volgograd|+03 +04|-30 -40|01|1WQL0|10e5", "Pacific/Honolulu|HST|a0|0||37e4", "MET|MET MEST|-10 -20|01010101010101010101010|1O9d0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00 11A0 1qM0 WM0 1qM0 WM0 1qM0 11A0 1o00 11A0 1o00|", "Pacific/Chatham|+1345 +1245|-dJ -cJ|01010101010101010101010|1ObO0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1io0 1a00 1fA0 1a00|600", "Pacific/Apia|+14 +13|-e0 -d0|01010101010101010101010|1ObO0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1cM0 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1fA0 1a00 1io0 1a00 1fA0 1a00|37e3", "Pacific/Fiji|+13 +12|-d0 -c0|01010101010101010101010|1NF20 1SM0 uM0 1VA0 s00 1VA0 s00 1VA0 s00 20o0 pc0 20o0 s00 20o0 pc0 20o0 pc0 20o0 pc0 20o0 pc0 20o0|88e4", "Pacific/Guam|ChST|-a0|0||17e4", "Pacific/Marquesas|-0930|9u|0||86e2", "Pacific/Pago_Pago|SST|b0|0||37e2", "Pacific/Norfolk|+1130 +11 +12|-bu -b0 -c0|012121212121212|1PoCu 9Jcu 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1cM0 1fA0 1cM0 1cM0 1cM0|25e4", "Pacific/Tongatapu|+13 +14|-d0 -e0|010|1S4d0 s00|75e3"],
            links: ["Africa/Abidjan|Africa/Accra", "Africa/Abidjan|Africa/Bamako", "Africa/Abidjan|Africa/Banjul", "Africa/Abidjan|Africa/Bissau", "Africa/Abidjan|Africa/Conakry", "Africa/Abidjan|Africa/Dakar", "Africa/Abidjan|Africa/Freetown", "Africa/Abidjan|Africa/Lome", "Africa/Abidjan|Africa/Monrovia", "Africa/Abidjan|Africa/Nouakchott", "Africa/Abidjan|Africa/Ouagadougou", "Africa/Abidjan|Africa/Timbuktu", "Africa/Abidjan|America/Danmarkshavn", "Africa/Abidjan|Atlantic/Reykjavik", "Africa/Abidjan|Atlantic/St_Helena", "Africa/Abidjan|Etc/GMT", "Africa/Abidjan|Etc/GMT+0", "Africa/Abidjan|Etc/GMT-0", "Africa/Abidjan|Etc/GMT0", "Africa/Abidjan|Etc/Greenwich", "Africa/Abidjan|GMT", "Africa/Abidjan|GMT+0", "Africa/Abidjan|GMT-0", "Africa/Abidjan|GMT0", "Africa/Abidjan|Greenwich", "Africa/Abidjan|Iceland", "Africa/Algiers|Africa/Tunis", "Africa/Cairo|Africa/Tripoli", "Africa/Cairo|Egypt", "Africa/Cairo|Europe/Kaliningrad", "Africa/Cairo|Libya", "Africa/Casablanca|Africa/El_Aaiun", "Africa/Johannesburg|Africa/Maseru", "Africa/Johannesburg|Africa/Mbabane", "Africa/Lagos|Africa/Bangui", "Africa/Lagos|Africa/Brazzaville", "Africa/Lagos|Africa/Douala", "Africa/Lagos|Africa/Kinshasa", "Africa/Lagos|Africa/Libreville", "Africa/Lagos|Africa/Luanda", "Africa/Lagos|Africa/Malabo", "Africa/Lagos|Africa/Ndjamena", "Africa/Lagos|Africa/Niamey", "Africa/Lagos|Africa/Porto-Novo", "Africa/Maputo|Africa/Blantyre", "Africa/Maputo|Africa/Bujumbura", "Africa/Maputo|Africa/Gaborone", "Africa/Maputo|Africa/Harare", "Africa/Maputo|Africa/Kigali", "Africa/Maputo|Africa/Lubumbashi", "Africa/Maputo|Africa/Lusaka", "Africa/Nairobi|Africa/Addis_Ababa", "Africa/Nairobi|Africa/Asmara", "Africa/Nairobi|Africa/Asmera", "Africa/Nairobi|Africa/Dar_es_Salaam", "Africa/Nairobi|Africa/Djibouti", "Africa/Nairobi|Africa/Juba", "Africa/Nairobi|Africa/Kampala", "Africa/Nairobi|Africa/Mogadishu", "Africa/Nairobi|Indian/Antananarivo", "Africa/Nairobi|Indian/Comoro", "Africa/Nairobi|Indian/Mayotte", "America/Adak|America/Atka", "America/Adak|US/Aleutian", "America/Anchorage|America/Juneau", "America/Anchorage|America/Nome", "America/Anchorage|America/Sitka", "America/Anchorage|America/Yakutat", "America/Anchorage|US/Alaska", "America/Campo_Grande|America/Cuiaba", "America/Chicago|America/Indiana/Knox", "America/Chicago|America/Indiana/Tell_City", "America/Chicago|America/Knox_IN", "America/Chicago|America/Matamoros", "America/Chicago|America/Menominee", "America/Chicago|America/North_Dakota/Beulah", "America/Chicago|America/North_Dakota/Center", "America/Chicago|America/North_Dakota/New_Salem", "America/Chicago|America/Rainy_River", "America/Chicago|America/Rankin_Inlet", "America/Chicago|America/Resolute", "America/Chicago|America/Winnipeg", "America/Chicago|CST6CDT", "America/Chicago|Canada/Central", "America/Chicago|US/Central", "America/Chicago|US/Indiana-Starke", "America/Chihuahua|America/Mazatlan", "America/Chihuahua|Mexico/BajaSur", "America/Denver|America/Boise", "America/Denver|America/Cambridge_Bay", "America/Denver|America/Edmonton", "America/Denver|America/Inuvik", "America/Denver|America/Ojinaga", "America/Denver|America/Shiprock", "America/Denver|America/Yellowknife", "America/Denver|Canada/Mountain", "America/Denver|MST7MDT", "America/Denver|Navajo", "America/Denver|US/Mountain", "America/Fortaleza|America/Araguaina", "America/Fortaleza|America/Argentina/Buenos_Aires", "America/Fortaleza|America/Argentina/Catamarca", "America/Fortaleza|America/Argentina/ComodRivadavia", "America/Fortaleza|America/Argentina/Cordoba", "America/Fortaleza|America/Argentina/Jujuy", "America/Fortaleza|America/Argentina/La_Rioja", "America/Fortaleza|America/Argentina/Mendoza", "America/Fortaleza|America/Argentina/Rio_Gallegos", "America/Fortaleza|America/Argentina/Salta", "America/Fortaleza|America/Argentina/San_Juan", "America/Fortaleza|America/Argentina/San_Luis", "America/Fortaleza|America/Argentina/Tucuman", "America/Fortaleza|America/Argentina/Ushuaia", "America/Fortaleza|America/Bahia", "America/Fortaleza|America/Belem", "America/Fortaleza|America/Buenos_Aires", "America/Fortaleza|America/Catamarca", "America/Fortaleza|America/Cayenne", "America/Fortaleza|America/Cordoba", "America/Fortaleza|America/Jujuy", "America/Fortaleza|America/Maceio", "America/Fortaleza|America/Mendoza", "America/Fortaleza|America/Paramaribo", "America/Fortaleza|America/Recife", "America/Fortaleza|America/Rosario", "America/Fortaleza|America/Santarem", "America/Fortaleza|Antarctica/Rothera", "America/Fortaleza|Atlantic/Stanley", "America/Fortaleza|Etc/GMT+3", "America/Godthab|America/Nuuk", "America/Halifax|America/Glace_Bay", "America/Halifax|America/Goose_Bay", "America/Halifax|America/Moncton", "America/Halifax|America/Thule", "America/Halifax|Atlantic/Bermuda", "America/Halifax|Canada/Atlantic", "America/Havana|Cuba", "America/La_Paz|America/Boa_Vista", "America/La_Paz|America/Guyana", "America/La_Paz|America/Manaus", "America/La_Paz|America/Porto_Velho", "America/La_Paz|Brazil/West", "America/La_Paz|Etc/GMT+4", "America/Lima|America/Bogota", "America/Lima|America/Eirunepe", "America/Lima|America/Guayaquil", "America/Lima|America/Porto_Acre", "America/Lima|America/Rio_Branco", "America/Lima|Brazil/Acre", "America/Lima|Etc/GMT+5", "America/Los_Angeles|America/Ensenada", "America/Los_Angeles|America/Santa_Isabel", "America/Los_Angeles|America/Tijuana", "America/Los_Angeles|America/Vancouver", "America/Los_Angeles|Canada/Pacific", "America/Los_Angeles|Mexico/BajaNorte", "America/Los_Angeles|PST8PDT", "America/Los_Angeles|US/Pacific", "America/Los_Angeles|US/Pacific-New", "America/Managua|America/Belize", "America/Managua|America/Costa_Rica", "America/Managua|America/El_Salvador", "America/Managua|America/Guatemala", "America/Managua|America/Regina", "America/Managua|America/Swift_Current", "America/Managua|America/Tegucigalpa", "America/Managua|Canada/Saskatchewan", "America/Mexico_City|America/Bahia_Banderas", "America/Mexico_City|America/Merida", "America/Mexico_City|America/Monterrey", "America/Mexico_City|Mexico/General", "America/New_York|America/Detroit", "America/New_York|America/Fort_Wayne", "America/New_York|America/Indiana/Indianapolis", "America/New_York|America/Indiana/Marengo", "America/New_York|America/Indiana/Petersburg", "America/New_York|America/Indiana/Vevay", "America/New_York|America/Indiana/Vincennes", "America/New_York|America/Indiana/Winamac", "America/New_York|America/Indianapolis", "America/New_York|America/Iqaluit", "America/New_York|America/Kentucky/Louisville", "America/New_York|America/Kentucky/Monticello", "America/New_York|America/Louisville", "America/New_York|America/Montreal", "America/New_York|America/Nassau", "America/New_York|America/Nipigon", "America/New_York|America/Pangnirtung", "America/New_York|America/Thunder_Bay", "America/New_York|America/Toronto", "America/New_York|Canada/Eastern", "America/New_York|EST5EDT", "America/New_York|US/East-Indiana", "America/New_York|US/Eastern", "America/New_York|US/Michigan", "America/Noronha|Atlantic/South_Georgia", "America/Noronha|Brazil/DeNoronha", "America/Noronha|Etc/GMT+2", "America/Panama|America/Atikokan", "America/Panama|America/Cayman", "America/Panama|America/Coral_Harbour", "America/Panama|America/Jamaica", "America/Panama|EST", "America/Panama|Jamaica", "America/Phoenix|America/Creston", "America/Phoenix|America/Dawson_Creek", "America/Phoenix|America/Hermosillo", "America/Phoenix|MST", "America/Phoenix|US/Arizona", "America/Santiago|Chile/Continental", "America/Santo_Domingo|America/Anguilla", "America/Santo_Domingo|America/Antigua", "America/Santo_Domingo|America/Aruba", "America/Santo_Domingo|America/Barbados", "America/Santo_Domingo|America/Blanc-Sablon", "America/Santo_Domingo|America/Curacao", "America/Santo_Domingo|America/Dominica", "America/Santo_Domingo|America/Grenada", "America/Santo_Domingo|America/Guadeloupe", "America/Santo_Domingo|America/Kralendijk", "America/Santo_Domingo|America/Lower_Princes", "America/Santo_Domingo|America/Marigot", "America/Santo_Domingo|America/Martinique", "America/Santo_Domingo|America/Montserrat", "America/Santo_Domingo|America/Port_of_Spain", "America/Santo_Domingo|America/Puerto_Rico", "America/Santo_Domingo|America/St_Barthelemy", "America/Santo_Domingo|America/St_Kitts", "America/Santo_Domingo|America/St_Lucia", "America/Santo_Domingo|America/St_Thomas", "America/Santo_Domingo|America/St_Vincent", "America/Santo_Domingo|America/Tortola", "America/Santo_Domingo|America/Virgin", "America/Sao_Paulo|Brazil/East", "America/St_Johns|Canada/Newfoundland", "America/Whitehorse|America/Dawson", "America/Whitehorse|Canada/Yukon", "Antarctica/Palmer|America/Punta_Arenas", "Asia/Baghdad|Antarctica/Syowa", "Asia/Baghdad|Asia/Aden", "Asia/Baghdad|Asia/Bahrain", "Asia/Baghdad|Asia/Kuwait", "Asia/Baghdad|Asia/Qatar", "Asia/Baghdad|Asia/Riyadh", "Asia/Baghdad|Etc/GMT-3", "Asia/Baghdad|Europe/Kirov", "Asia/Baghdad|Europe/Minsk", "Asia/Bangkok|Antarctica/Davis", "Asia/Bangkok|Asia/Ho_Chi_Minh", "Asia/Bangkok|Asia/Krasnoyarsk", "Asia/Bangkok|Asia/Novokuznetsk", "Asia/Bangkok|Asia/Phnom_Penh", "Asia/Bangkok|Asia/Saigon", "Asia/Bangkok|Asia/Vientiane", "Asia/Bangkok|Etc/GMT-7", "Asia/Bangkok|Indian/Christmas", "Asia/Dhaka|Antarctica/Vostok", "Asia/Dhaka|Asia/Almaty", "Asia/Dhaka|Asia/Bishkek", "Asia/Dhaka|Asia/Dacca", "Asia/Dhaka|Asia/Kashgar", "Asia/Dhaka|Asia/Omsk", "Asia/Dhaka|Asia/Qostanay", "Asia/Dhaka|Asia/Thimbu", "Asia/Dhaka|Asia/Thimphu", "Asia/Dhaka|Asia/Urumqi", "Asia/Dhaka|Etc/GMT-6", "Asia/Dhaka|Indian/Chagos", "Asia/Dubai|Asia/Muscat", "Asia/Dubai|Asia/Tbilisi", "Asia/Dubai|Asia/Yerevan", "Asia/Dubai|Etc/GMT-4", "Asia/Dubai|Europe/Samara", "Asia/Dubai|Indian/Mahe", "Asia/Dubai|Indian/Mauritius", "Asia/Dubai|Indian/Reunion", "Asia/Gaza|Asia/Hebron", "Asia/Hong_Kong|Hongkong", "Asia/Jakarta|Asia/Pontianak", "Asia/Jerusalem|Asia/Tel_Aviv", "Asia/Jerusalem|Israel", "Asia/Kamchatka|Asia/Anadyr", "Asia/Kamchatka|Etc/GMT-12", "Asia/Kamchatka|Kwajalein", "Asia/Kamchatka|Pacific/Funafuti", "Asia/Kamchatka|Pacific/Kwajalein", "Asia/Kamchatka|Pacific/Majuro", "Asia/Kamchatka|Pacific/Nauru", "Asia/Kamchatka|Pacific/Tarawa", "Asia/Kamchatka|Pacific/Wake", "Asia/Kamchatka|Pacific/Wallis", "Asia/Kathmandu|Asia/Katmandu", "Asia/Kolkata|Asia/Calcutta", "Asia/Kuala_Lumpur|Asia/Brunei", "Asia/Kuala_Lumpur|Asia/Irkutsk", "Asia/Kuala_Lumpur|Asia/Kuching", "Asia/Kuala_Lumpur|Asia/Singapore", "Asia/Kuala_Lumpur|Etc/GMT-8", "Asia/Kuala_Lumpur|Singapore", "Asia/Makassar|Asia/Ujung_Pandang", "Asia/Rangoon|Asia/Yangon", "Asia/Rangoon|Indian/Cocos", "Asia/Seoul|ROK", "Asia/Shanghai|Asia/Chongqing", "Asia/Shanghai|Asia/Chungking", "Asia/Shanghai|Asia/Harbin", "Asia/Shanghai|Asia/Macao", "Asia/Shanghai|Asia/Macau", "Asia/Shanghai|Asia/Taipei", "Asia/Shanghai|PRC", "Asia/Shanghai|ROC", "Asia/Tashkent|Antarctica/Mawson", "Asia/Tashkent|Asia/Aqtau", "Asia/Tashkent|Asia/Aqtobe", "Asia/Tashkent|Asia/Ashgabat", "Asia/Tashkent|Asia/Ashkhabad", "Asia/Tashkent|Asia/Atyrau", "Asia/Tashkent|Asia/Dushanbe", "Asia/Tashkent|Asia/Oral", "Asia/Tashkent|Asia/Samarkand", "Asia/Tashkent|Asia/Yekaterinburg", "Asia/Tashkent|Etc/GMT-5", "Asia/Tashkent|Indian/Kerguelen", "Asia/Tashkent|Indian/Maldives", "Asia/Tehran|Iran", "Asia/Tokyo|Japan", "Asia/Ulaanbaatar|Asia/Choibalsan", "Asia/Ulaanbaatar|Asia/Ulan_Bator", "Asia/Vladivostok|Antarctica/DumontDUrville", "Asia/Vladivostok|Asia/Ust-Nera", "Asia/Vladivostok|Etc/GMT-10", "Asia/Vladivostok|Pacific/Chuuk", "Asia/Vladivostok|Pacific/Port_Moresby", "Asia/Vladivostok|Pacific/Truk", "Asia/Vladivostok|Pacific/Yap", "Asia/Yakutsk|Asia/Dili", "Asia/Yakutsk|Asia/Khandyga", "Asia/Yakutsk|Etc/GMT-9", "Asia/Yakutsk|Pacific/Palau", "Atlantic/Azores|America/Scoresbysund", "Atlantic/Cape_Verde|Etc/GMT+1", "Australia/Adelaide|Australia/Broken_Hill", "Australia/Adelaide|Australia/South", "Australia/Adelaide|Australia/Yancowinna", "Australia/Brisbane|Australia/Lindeman", "Australia/Brisbane|Australia/Queensland", "Australia/Darwin|Australia/North", "Australia/Lord_Howe|Australia/LHI", "Australia/Perth|Australia/West", "Australia/Sydney|Australia/ACT", "Australia/Sydney|Australia/Canberra", "Australia/Sydney|Australia/Currie", "Australia/Sydney|Australia/Hobart", "Australia/Sydney|Australia/Melbourne", "Australia/Sydney|Australia/NSW", "Australia/Sydney|Australia/Tasmania", "Australia/Sydney|Australia/Victoria", "Etc/UTC|Etc/UCT", "Etc/UTC|Etc/Universal", "Etc/UTC|Etc/Zulu", "Etc/UTC|UCT", "Etc/UTC|UTC", "Etc/UTC|Universal", "Etc/UTC|Zulu", "Europe/Athens|Asia/Nicosia", "Europe/Athens|EET", "Europe/Athens|Europe/Bucharest", "Europe/Athens|Europe/Helsinki", "Europe/Athens|Europe/Kiev", "Europe/Athens|Europe/Mariehamn", "Europe/Athens|Europe/Nicosia", "Europe/Athens|Europe/Riga", "Europe/Athens|Europe/Sofia", "Europe/Athens|Europe/Tallinn", "Europe/Athens|Europe/Uzhgorod", "Europe/Athens|Europe/Vilnius", "Europe/Athens|Europe/Zaporozhye", "Europe/Chisinau|Europe/Tiraspol", "Europe/Dublin|Eire", "Europe/Istanbul|Asia/Istanbul", "Europe/Istanbul|Turkey", "Europe/Lisbon|Atlantic/Canary", "Europe/Lisbon|Atlantic/Faeroe", "Europe/Lisbon|Atlantic/Faroe", "Europe/Lisbon|Atlantic/Madeira", "Europe/Lisbon|Portugal", "Europe/Lisbon|WET", "Europe/London|Europe/Belfast", "Europe/London|Europe/Guernsey", "Europe/London|Europe/Isle_of_Man", "Europe/London|Europe/Jersey", "Europe/London|GB", "Europe/London|GB-Eire", "Europe/Moscow|Europe/Simferopol", "Europe/Moscow|W-SU", "Europe/Paris|Africa/Ceuta", "Europe/Paris|Arctic/Longyearbyen", "Europe/Paris|Atlantic/Jan_Mayen", "Europe/Paris|CET", "Europe/Paris|Europe/Amsterdam", "Europe/Paris|Europe/Andorra", "Europe/Paris|Europe/Belgrade", "Europe/Paris|Europe/Berlin", "Europe/Paris|Europe/Bratislava", "Europe/Paris|Europe/Brussels", "Europe/Paris|Europe/Budapest", "Europe/Paris|Europe/Busingen", "Europe/Paris|Europe/Copenhagen", "Europe/Paris|Europe/Gibraltar", "Europe/Paris|Europe/Ljubljana", "Europe/Paris|Europe/Luxembourg", "Europe/Paris|Europe/Madrid", "Europe/Paris|Europe/Malta", "Europe/Paris|Europe/Monaco", "Europe/Paris|Europe/Oslo", "Europe/Paris|Europe/Podgorica", "Europe/Paris|Europe/Prague", "Europe/Paris|Europe/Rome", "Europe/Paris|Europe/San_Marino", "Europe/Paris|Europe/Sarajevo", "Europe/Paris|Europe/Skopje", "Europe/Paris|Europe/Stockholm", "Europe/Paris|Europe/Tirane", "Europe/Paris|Europe/Vaduz", "Europe/Paris|Europe/Vatican", "Europe/Paris|Europe/Vienna", "Europe/Paris|Europe/Warsaw", "Europe/Paris|Europe/Zagreb", "Europe/Paris|Europe/Zurich", "Europe/Paris|Poland", "Europe/Ulyanovsk|Europe/Astrakhan", "Pacific/Auckland|Antarctica/McMurdo", "Pacific/Auckland|Antarctica/South_Pole", "Pacific/Auckland|NZ", "Pacific/Bougainville|Antarctica/Macquarie", "Pacific/Bougainville|Asia/Srednekolymsk", "Pacific/Bougainville|Etc/GMT-11", "Pacific/Bougainville|Pacific/Efate", "Pacific/Bougainville|Pacific/Guadalcanal", "Pacific/Bougainville|Pacific/Kosrae", "Pacific/Bougainville|Pacific/Noumea", "Pacific/Bougainville|Pacific/Pohnpei", "Pacific/Bougainville|Pacific/Ponape", "Pacific/Chatham|NZ-CHAT", "Pacific/Easter|Chile/EasterIsland", "Pacific/Fakaofo|Etc/GMT-13", "Pacific/Fakaofo|Pacific/Enderbury", "Pacific/Galapagos|Etc/GMT+6", "Pacific/Gambier|Etc/GMT+9", "Pacific/Guam|Pacific/Saipan", "Pacific/Honolulu|HST", "Pacific/Honolulu|Pacific/Johnston", "Pacific/Honolulu|US/Hawaii", "Pacific/Kiritimati|Etc/GMT-14", "Pacific/Niue|Etc/GMT+11", "Pacific/Pago_Pago|Pacific/Midway", "Pacific/Pago_Pago|Pacific/Samoa", "Pacific/Pago_Pago|US/Samoa", "Pacific/Pitcairn|Etc/GMT+8", "Pacific/Tahiti|Etc/GMT+10", "Pacific/Tahiti|Pacific/Rarotonga"],
            countries: ["AD|Europe/Andorra", "AE|Asia/Dubai", "AF|Asia/Kabul", "AG|America/Port_of_Spain America/Antigua", "AI|America/Port_of_Spain America/Anguilla", "AL|Europe/Tirane", "AM|Asia/Yerevan", "AO|Africa/Lagos Africa/Luanda", "AQ|Antarctica/Casey Antarctica/Davis Antarctica/DumontDUrville Antarctica/Mawson Antarctica/Palmer Antarctica/Rothera Antarctica/Syowa Antarctica/Troll Antarctica/Vostok Pacific/Auckland Antarctica/McMurdo", "AR|America/Argentina/Buenos_Aires America/Argentina/Cordoba America/Argentina/Salta America/Argentina/Jujuy America/Argentina/Tucuman America/Argentina/Catamarca America/Argentina/La_Rioja America/Argentina/San_Juan America/Argentina/Mendoza America/Argentina/San_Luis America/Argentina/Rio_Gallegos America/Argentina/Ushuaia", "AS|Pacific/Pago_Pago", "AT|Europe/Vienna", "AU|Australia/Lord_Howe Antarctica/Macquarie Australia/Hobart Australia/Currie Australia/Melbourne Australia/Sydney Australia/Broken_Hill Australia/Brisbane Australia/Lindeman Australia/Adelaide Australia/Darwin Australia/Perth Australia/Eucla", "AW|America/Curacao America/Aruba", "AX|Europe/Helsinki Europe/Mariehamn", "AZ|Asia/Baku", "BA|Europe/Belgrade Europe/Sarajevo", "BB|America/Barbados", "BD|Asia/Dhaka", "BE|Europe/Brussels", "BF|Africa/Abidjan Africa/Ouagadougou", "BG|Europe/Sofia", "BH|Asia/Qatar Asia/Bahrain", "BI|Africa/Maputo Africa/Bujumbura", "BJ|Africa/Lagos Africa/Porto-Novo", "BL|America/Port_of_Spain America/St_Barthelemy", "BM|Atlantic/Bermuda", "BN|Asia/Brunei", "BO|America/La_Paz", "BQ|America/Curacao America/Kralendijk", "BR|America/Noronha America/Belem America/Fortaleza America/Recife America/Araguaina America/Maceio America/Bahia America/Sao_Paulo America/Campo_Grande America/Cuiaba America/Santarem America/Porto_Velho America/Boa_Vista America/Manaus America/Eirunepe America/Rio_Branco", "BS|America/Nassau", "BT|Asia/Thimphu", "BW|Africa/Maputo Africa/Gaborone", "BY|Europe/Minsk", "BZ|America/Belize", "CA|America/St_Johns America/Halifax America/Glace_Bay America/Moncton America/Goose_Bay America/Blanc-Sablon America/Toronto America/Nipigon America/Thunder_Bay America/Iqaluit America/Pangnirtung America/Atikokan America/Winnipeg America/Rainy_River America/Resolute America/Rankin_Inlet America/Regina America/Swift_Current America/Edmonton America/Cambridge_Bay America/Yellowknife America/Inuvik America/Creston America/Dawson_Creek America/Fort_Nelson America/Vancouver America/Whitehorse America/Dawson", "CC|Indian/Cocos", "CD|Africa/Maputo Africa/Lagos Africa/Kinshasa Africa/Lubumbashi", "CF|Africa/Lagos Africa/Bangui", "CG|Africa/Lagos Africa/Brazzaville", "CH|Europe/Zurich", "CI|Africa/Abidjan", "CK|Pacific/Rarotonga", "CL|America/Santiago America/Punta_Arenas Pacific/Easter", "CM|Africa/Lagos Africa/Douala", "CN|Asia/Shanghai Asia/Urumqi", "CO|America/Bogota", "CR|America/Costa_Rica", "CU|America/Havana", "CV|Atlantic/Cape_Verde", "CW|America/Curacao", "CX|Indian/Christmas", "CY|Asia/Nicosia Asia/Famagusta", "CZ|Europe/Prague", "DE|Europe/Zurich Europe/Berlin Europe/Busingen", "DJ|Africa/Nairobi Africa/Djibouti", "DK|Europe/Copenhagen", "DM|America/Port_of_Spain America/Dominica", "DO|America/Santo_Domingo", "DZ|Africa/Algiers", "EC|America/Guayaquil Pacific/Galapagos", "EE|Europe/Tallinn", "EG|Africa/Cairo", "EH|Africa/El_Aaiun", "ER|Africa/Nairobi Africa/Asmara", "ES|Europe/Madrid Africa/Ceuta Atlantic/Canary", "ET|Africa/Nairobi Africa/Addis_Ababa", "FI|Europe/Helsinki", "FJ|Pacific/Fiji", "FK|Atlantic/Stanley", "FM|Pacific/Chuuk Pacific/Pohnpei Pacific/Kosrae", "FO|Atlantic/Faroe", "FR|Europe/Paris", "GA|Africa/Lagos Africa/Libreville", "GB|Europe/London", "GD|America/Port_of_Spain America/Grenada", "GE|Asia/Tbilisi", "GF|America/Cayenne", "GG|Europe/London Europe/Guernsey", "GH|Africa/Accra", "GI|Europe/Gibraltar", "GL|America/Godthab America/Danmarkshavn America/Scoresbysund America/Thule", "GM|Africa/Abidjan Africa/Banjul", "GN|Africa/Abidjan Africa/Conakry", "GP|America/Port_of_Spain America/Guadeloupe", "GQ|Africa/Lagos Africa/Malabo", "GR|Europe/Athens", "GS|Atlantic/South_Georgia", "GT|America/Guatemala", "GU|Pacific/Guam", "GW|Africa/Bissau", "GY|America/Guyana", "HK|Asia/Hong_Kong", "HN|America/Tegucigalpa", "HR|Europe/Belgrade Europe/Zagreb", "HT|America/Port-au-Prince", "HU|Europe/Budapest", "ID|Asia/Jakarta Asia/Pontianak Asia/Makassar Asia/Jayapura", "IE|Europe/Dublin", "IL|Asia/Jerusalem", "IM|Europe/London Europe/Isle_of_Man", "IN|Asia/Kolkata", "IO|Indian/Chagos", "IQ|Asia/Baghdad", "IR|Asia/Tehran", "IS|Atlantic/Reykjavik", "IT|Europe/Rome", "JE|Europe/London Europe/Jersey", "JM|America/Jamaica", "JO|Asia/Amman", "JP|Asia/Tokyo", "KE|Africa/Nairobi", "KG|Asia/Bishkek", "KH|Asia/Bangkok Asia/Phnom_Penh", "KI|Pacific/Tarawa Pacific/Enderbury Pacific/Kiritimati", "KM|Africa/Nairobi Indian/Comoro", "KN|America/Port_of_Spain America/St_Kitts", "KP|Asia/Pyongyang", "KR|Asia/Seoul", "KW|Asia/Riyadh Asia/Kuwait", "KY|America/Panama America/Cayman", "KZ|Asia/Almaty Asia/Qyzylorda Asia/Qostanay Asia/Aqtobe Asia/Aqtau Asia/Atyrau Asia/Oral", "LA|Asia/Bangkok Asia/Vientiane", "LB|Asia/Beirut", "LC|America/Port_of_Spain America/St_Lucia", "LI|Europe/Zurich Europe/Vaduz", "LK|Asia/Colombo", "LR|Africa/Monrovia", "LS|Africa/Johannesburg Africa/Maseru", "LT|Europe/Vilnius", "LU|Europe/Luxembourg", "LV|Europe/Riga", "LY|Africa/Tripoli", "MA|Africa/Casablanca", "MC|Europe/Monaco", "MD|Europe/Chisinau", "ME|Europe/Belgrade Europe/Podgorica", "MF|America/Port_of_Spain America/Marigot", "MG|Africa/Nairobi Indian/Antananarivo", "MH|Pacific/Majuro Pacific/Kwajalein", "MK|Europe/Belgrade Europe/Skopje", "ML|Africa/Abidjan Africa/Bamako", "MM|Asia/Yangon", "MN|Asia/Ulaanbaatar Asia/Hovd Asia/Choibalsan", "MO|Asia/Macau", "MP|Pacific/Guam Pacific/Saipan", "MQ|America/Martinique", "MR|Africa/Abidjan Africa/Nouakchott", "MS|America/Port_of_Spain America/Montserrat", "MT|Europe/Malta", "MU|Indian/Mauritius", "MV|Indian/Maldives", "MW|Africa/Maputo Africa/Blantyre", "MX|America/Mexico_City America/Cancun America/Merida America/Monterrey America/Matamoros America/Mazatlan America/Chihuahua America/Ojinaga America/Hermosillo America/Tijuana America/Bahia_Banderas", "MY|Asia/Kuala_Lumpur Asia/Kuching", "MZ|Africa/Maputo", "NA|Africa/Windhoek", "NC|Pacific/Noumea", "NE|Africa/Lagos Africa/Niamey", "NF|Pacific/Norfolk", "NG|Africa/Lagos", "NI|America/Managua", "NL|Europe/Amsterdam", "NO|Europe/Oslo", "NP|Asia/Kathmandu", "NR|Pacific/Nauru", "NU|Pacific/Niue", "NZ|Pacific/Auckland Pacific/Chatham", "OM|Asia/Dubai Asia/Muscat", "PA|America/Panama", "PE|America/Lima", "PF|Pacific/Tahiti Pacific/Marquesas Pacific/Gambier", "PG|Pacific/Port_Moresby Pacific/Bougainville", "PH|Asia/Manila", "PK|Asia/Karachi", "PL|Europe/Warsaw", "PM|America/Miquelon", "PN|Pacific/Pitcairn", "PR|America/Puerto_Rico", "PS|Asia/Gaza Asia/Hebron", "PT|Europe/Lisbon Atlantic/Madeira Atlantic/Azores", "PW|Pacific/Palau", "PY|America/Asuncion", "QA|Asia/Qatar", "RE|Indian/Reunion", "RO|Europe/Bucharest", "RS|Europe/Belgrade", "RU|Europe/Kaliningrad Europe/Moscow Europe/Simferopol Europe/Kirov Europe/Astrakhan Europe/Volgograd Europe/Saratov Europe/Ulyanovsk Europe/Samara Asia/Yekaterinburg Asia/Omsk Asia/Novosibirsk Asia/Barnaul Asia/Tomsk Asia/Novokuznetsk Asia/Krasnoyarsk Asia/Irkutsk Asia/Chita Asia/Yakutsk Asia/Khandyga Asia/Vladivostok Asia/Ust-Nera Asia/Magadan Asia/Sakhalin Asia/Srednekolymsk Asia/Kamchatka Asia/Anadyr", "RW|Africa/Maputo Africa/Kigali", "SA|Asia/Riyadh", "SB|Pacific/Guadalcanal", "SC|Indian/Mahe", "SD|Africa/Khartoum", "SE|Europe/Stockholm", "SG|Asia/Singapore", "SH|Africa/Abidjan Atlantic/St_Helena", "SI|Europe/Belgrade Europe/Ljubljana", "SJ|Europe/Oslo Arctic/Longyearbyen", "SK|Europe/Prague Europe/Bratislava", "SL|Africa/Abidjan Africa/Freetown", "SM|Europe/Rome Europe/San_Marino", "SN|Africa/Abidjan Africa/Dakar", "SO|Africa/Nairobi Africa/Mogadishu", "SR|America/Paramaribo", "SS|Africa/Juba", "ST|Africa/Sao_Tome", "SV|America/El_Salvador", "SX|America/Curacao America/Lower_Princes", "SY|Asia/Damascus", "SZ|Africa/Johannesburg Africa/Mbabane", "TC|America/Grand_Turk", "TD|Africa/Ndjamena", "TF|Indian/Reunion Indian/Kerguelen", "TG|Africa/Abidjan Africa/Lome", "TH|Asia/Bangkok", "TJ|Asia/Dushanbe", "TK|Pacific/Fakaofo", "TL|Asia/Dili", "TM|Asia/Ashgabat", "TN|Africa/Tunis", "TO|Pacific/Tongatapu", "TR|Europe/Istanbul", "TT|America/Port_of_Spain", "TV|Pacific/Funafuti", "TW|Asia/Taipei", "TZ|Africa/Nairobi Africa/Dar_es_Salaam", "UA|Europe/Simferopol Europe/Kiev Europe/Uzhgorod Europe/Zaporozhye", "UG|Africa/Nairobi Africa/Kampala", "UM|Pacific/Pago_Pago Pacific/Wake Pacific/Honolulu Pacific/Midway", "US|America/New_York America/Detroit America/Kentucky/Louisville America/Kentucky/Monticello America/Indiana/Indianapolis America/Indiana/Vincennes America/Indiana/Winamac America/Indiana/Marengo America/Indiana/Petersburg America/Indiana/Vevay America/Chicago America/Indiana/Tell_City America/Indiana/Knox America/Menominee America/North_Dakota/Center America/North_Dakota/New_Salem America/North_Dakota/Beulah America/Denver America/Boise America/Phoenix America/Los_Angeles America/Anchorage America/Juneau America/Sitka America/Metlakatla America/Yakutat America/Nome America/Adak Pacific/Honolulu", "UY|America/Montevideo", "UZ|Asia/Samarkand Asia/Tashkent", "VA|Europe/Rome Europe/Vatican", "VC|America/Port_of_Spain America/St_Vincent", "VE|America/Caracas", "VG|America/Port_of_Spain America/Tortola", "VI|America/Port_of_Spain America/St_Thomas", "VN|Asia/Bangkok Asia/Ho_Chi_Minh", "VU|Pacific/Efate", "WF|Pacific/Wallis", "WS|Pacific/Apia", "YE|Asia/Riyadh Asia/Aden", "YT|Africa/Nairobi Indian/Mayotte", "ZA|Africa/Johannesburg", "ZM|Africa/Maputo Africa/Lusaka", "ZW|Africa/Maputo Africa/Harare"]
        }), c
    }))
}, function(module, exports, __webpack_require__) {
    var __WEBPACK_AMD_DEFINE_RESULT__;
    ! function(global, factory) {
        "use strict";
        "object" == typeof module.exports ? module.exports = global.document ? factory(global, !0) : function(w) {
            if (!w.document) throw new Error("jQuery requires a window with a document");
            return factory(w)
        } : factory(global)
    }("undefined" != typeof window ? window : this, (function(window, noGlobal) {
        "use strict";
        var arr = [],
            getProto = Object.getPrototypeOf,
            slice = arr.slice,
            flat = arr.flat ? function(array) {
                return arr.flat.call(array)
            } : function(array) {
                return arr.concat.apply([], array)
            },
            push = arr.push,
            indexOf = arr.indexOf,
            class2type = {},
            toString = class2type.toString,
            hasOwn = class2type.hasOwnProperty,
            fnToString = hasOwn.toString,
            ObjectFunctionString = fnToString.call(Object),
            support = {},
            isFunction = function(obj) {
                return "function" == typeof obj && "number" != typeof obj.nodeType
            },
            isWindow = function(obj) {
                return null != obj && obj === obj.window
            },
            document = window.document,
            preservedScriptAttributes = {
                type: !0,
                src: !0,
                nonce: !0,
                noModule: !0
            };

        function DOMEval(code, node, doc) {
            var i, val, script = (doc = doc || document).createElement("script");
            if (script.text = code, node)
                for (i in preservedScriptAttributes)(val = node[i] || node.getAttribute && node.getAttribute(i)) && script.setAttribute(i, val);
            doc.head.appendChild(script).parentNode.removeChild(script)
        }

        function toType(obj) {
            return null == obj ? obj + "" : "object" == typeof obj || "function" == typeof obj ? class2type[toString.call(obj)] || "object" : typeof obj
        }
        var jQuery = function(selector, context) {
            return new jQuery.fn.init(selector, context)
        };

        function isArrayLike(obj) {
            var length = !!obj && "length" in obj && obj.length,
                type = toType(obj);
            return !isFunction(obj) && !isWindow(obj) && ("array" === type || 0 === length || "number" == typeof length && length > 0 && length - 1 in obj)
        }
        jQuery.fn = jQuery.prototype = {
            jquery: "3.5.1",
            constructor: jQuery,
            length: 0,
            toArray: function() {
                return slice.call(this)
            },
            get: function(num) {
                return null == num ? slice.call(this) : num < 0 ? this[num + this.length] : this[num]
            },
            pushStack: function(elems) {
                var ret = jQuery.merge(this.constructor(), elems);
                return ret.prevObject = this, ret
            },
            each: function(callback) {
                return jQuery.each(this, callback)
            },
            map: function(callback) {
                return this.pushStack(jQuery.map(this, (function(elem, i) {
                    return callback.call(elem, i, elem)
                })))
            },
            slice: function() {
                return this.pushStack(slice.apply(this, arguments))
            },
            first: function() {
                return this.eq(0)
            },
            last: function() {
                return this.eq(-1)
            },
            even: function() {
                return this.pushStack(jQuery.grep(this, (function(_elem, i) {
                    return (i + 1) % 2
                })))
            },
            odd: function() {
                return this.pushStack(jQuery.grep(this, (function(_elem, i) {
                    return i % 2
                })))
            },
            eq: function(i) {
                var len = this.length,
                    j = +i + (i < 0 ? len : 0);
                return this.pushStack(j >= 0 && j < len ? [this[j]] : [])
            },
            end: function() {
                return this.prevObject || this.constructor()
            },
            push: push,
            sort: arr.sort,
            splice: arr.splice
        }, jQuery.extend = jQuery.fn.extend = function() {
            var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {},
                i = 1,
                length = arguments.length,
                deep = !1;
            for ("boolean" == typeof target && (deep = target, target = arguments[i] || {}, i++), "object" == typeof target || isFunction(target) || (target = {}), i === length && (target = this, i--); i < length; i++)
                if (null != (options = arguments[i]))
                    for (name in options) copy = options[name], "__proto__" !== name && target !== copy && (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = Array.isArray(copy))) ? (src = target[name], clone = copyIsArray && !Array.isArray(src) ? [] : copyIsArray || jQuery.isPlainObject(src) ? src : {}, copyIsArray = !1, target[name] = jQuery.extend(deep, clone, copy)) : void 0 !== copy && (target[name] = copy));
            return target
        }, jQuery.extend({
            expando: "jQuery" + ("3.5.1" + Math.random()).replace(/\D/g, ""),
            isReady: !0,
            error: function(msg) {
                throw new Error(msg)
            },
            noop: function() {},
            isPlainObject: function(obj) {
                var proto, Ctor;
                return !(!obj || "[object Object]" !== toString.call(obj)) && (!(proto = getProto(obj)) || "function" == typeof(Ctor = hasOwn.call(proto, "constructor") && proto.constructor) && fnToString.call(Ctor) === ObjectFunctionString)
            },
            isEmptyObject: function(obj) {
                var name;
                for (name in obj) return !1;
                return !0
            },
            globalEval: function(code, options, doc) {
                DOMEval(code, {
                    nonce: options && options.nonce
                }, doc)
            },
            each: function(obj, callback) {
                var length, i = 0;
                if (isArrayLike(obj))
                    for (length = obj.length; i < length && !1 !== callback.call(obj[i], i, obj[i]); i++);
                else
                    for (i in obj)
                        if (!1 === callback.call(obj[i], i, obj[i])) break;
                return obj
            },
            makeArray: function(arr, results) {
                var ret = results || [];
                return null != arr && (isArrayLike(Object(arr)) ? jQuery.merge(ret, "string" == typeof arr ? [arr] : arr) : push.call(ret, arr)), ret
            },
            inArray: function(elem, arr, i) {
                return null == arr ? -1 : indexOf.call(arr, elem, i)
            },
            merge: function(first, second) {
                for (var len = +second.length, j = 0, i = first.length; j < len; j++) first[i++] = second[j];
                return first.length = i, first
            },
            grep: function(elems, callback, invert) {
                for (var matches = [], i = 0, length = elems.length, callbackExpect = !invert; i < length; i++) !callback(elems[i], i) !== callbackExpect && matches.push(elems[i]);
                return matches
            },
            map: function(elems, callback, arg) {
                var length, value, i = 0,
                    ret = [];
                if (isArrayLike(elems))
                    for (length = elems.length; i < length; i++) null != (value = callback(elems[i], i, arg)) && ret.push(value);
                else
                    for (i in elems) null != (value = callback(elems[i], i, arg)) && ret.push(value);
                return flat(ret)
            },
            guid: 1,
            support: support
        }), "function" == typeof Symbol && (jQuery.fn[Symbol.iterator] = arr[Symbol.iterator]), jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), (function(_i, name) {
            class2type["[object " + name + "]"] = name.toLowerCase()
        }));
        var Sizzle = function(window) {
            var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = "sizzle" + 1 * new Date,
                preferredDoc = window.document,
                dirruns = 0,
                done = 0,
                classCache = createCache(),
                tokenCache = createCache(),
                compilerCache = createCache(),
                nonnativeSelectorCache = createCache(),
                sortOrder = function(a, b) {
                    return a === b && (hasDuplicate = !0), 0
                },
                hasOwn = {}.hasOwnProperty,
                arr = [],
                pop = arr.pop,
                pushNative = arr.push,
                push = arr.push,
                slice = arr.slice,
                indexOf = function(list, elem) {
                    for (var i = 0, len = list.length; i < len; i++)
                        if (list[i] === elem) return i;
                    return -1
                },
                booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",
                whitespace = "[\\x20\\t\\r\\n\\f]",
                identifier = "(?:\\\\[\\da-fA-F]{1,6}[\\x20\\t\\r\\n\\f]?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",
                attributes = "\\[[\\x20\\t\\r\\n\\f]*(" + identifier + ")(?:" + whitespace + "*([*^$|!~]?=)" + whitespace + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]",
                pseudos = ":(" + identifier + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|.*)\\)|)",
                rwhitespace = new RegExp(whitespace + "+", "g"),
                rtrim = new RegExp("^[\\x20\\t\\r\\n\\f]+|((?:^|[^\\\\])(?:\\\\.)*)[\\x20\\t\\r\\n\\f]+$", "g"),
                rcomma = new RegExp("^[\\x20\\t\\r\\n\\f]*,[\\x20\\t\\r\\n\\f]*"),
                rcombinators = new RegExp("^[\\x20\\t\\r\\n\\f]*([>+~]|[\\x20\\t\\r\\n\\f])[\\x20\\t\\r\\n\\f]*"),
                rdescend = new RegExp(whitespace + "|>"),
                rpseudo = new RegExp(pseudos),
                ridentifier = new RegExp("^" + identifier + "$"),
                matchExpr = {
                    ID: new RegExp("^#(" + identifier + ")"),
                    CLASS: new RegExp("^\\.(" + identifier + ")"),
                    TAG: new RegExp("^(" + identifier + "|[*])"),
                    ATTR: new RegExp("^" + attributes),
                    PSEUDO: new RegExp("^" + pseudos),
                    CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\([\\x20\\t\\r\\n\\f]*(even|odd|(([+-]|)(\\d*)n|)[\\x20\\t\\r\\n\\f]*(?:([+-]|)[\\x20\\t\\r\\n\\f]*(\\d+)|))[\\x20\\t\\r\\n\\f]*\\)|)", "i"),
                    bool: new RegExp("^(?:" + booleans + ")$", "i"),
                    needsContext: new RegExp("^[\\x20\\t\\r\\n\\f]*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\([\\x20\\t\\r\\n\\f]*((?:-\\d)?\\d*)[\\x20\\t\\r\\n\\f]*\\)|)(?=[^-]|$)", "i")
                },
                rhtml = /HTML$/i,
                rinputs = /^(?:input|select|textarea|button)$/i,
                rheader = /^h\d$/i,
                rnative = /^[^{]+\{\s*\[native \w/,
                rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,
                rsibling = /[+~]/,
                runescape = new RegExp("\\\\[\\da-fA-F]{1,6}[\\x20\\t\\r\\n\\f]?|\\\\([^\\r\\n\\f])", "g"),
                funescape = function(escape, nonHex) {
                    var high = "0x" + escape.slice(1) - 65536;
                    return nonHex || (high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, 1023 & high | 56320))
                },
                rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
                fcssescape = function(ch, asCodePoint) {
                    return asCodePoint ? "\0" === ch ? "�" : ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " " : "\\" + ch
                },
                unloadHandler = function() {
                    setDocument()
                },
                inDisabledFieldset = addCombinator((function(elem) {
                    return !0 === elem.disabled && "fieldset" === elem.nodeName.toLowerCase()
                }), {
                    dir: "parentNode",
                    next: "legend"
                });
            try {
                push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes), arr[preferredDoc.childNodes.length].nodeType
            } catch (e) {
                push = {
                    apply: arr.length ? function(target, els) {
                        pushNative.apply(target, slice.call(els))
                    } : function(target, els) {
                        for (var j = target.length, i = 0; target[j++] = els[i++];);
                        target.length = j - 1
                    }
                }
            }

            function Sizzle(selector, context, results, seed) {
                var m, i, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument,
                    nodeType = context ? context.nodeType : 9;
                if (results = results || [], "string" != typeof selector || !selector || 1 !== nodeType && 9 !== nodeType && 11 !== nodeType) return results;
                if (!seed && (setDocument(context), context = context || document, documentIsHTML)) {
                    if (11 !== nodeType && (match = rquickExpr.exec(selector)))
                        if (m = match[1]) {
                            if (9 === nodeType) {
                                if (!(elem = context.getElementById(m))) return results;
                                if (elem.id === m) return results.push(elem), results
                            } else if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m) return results.push(elem), results
                        } else {
                            if (match[2]) return push.apply(results, context.getElementsByTagName(selector)), results;
                            if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) return push.apply(results, context.getElementsByClassName(m)), results
                        }
                    if (support.qsa && !nonnativeSelectorCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector)) && (1 !== nodeType || "object" !== context.nodeName.toLowerCase())) {
                        if (newSelector = selector, newContext = context, 1 === nodeType && (rdescend.test(selector) || rcombinators.test(selector))) {
                            for ((newContext = rsibling.test(selector) && testContext(context.parentNode) || context) === context && support.scope || ((nid = context.getAttribute("id")) ? nid = nid.replace(rcssescape, fcssescape) : context.setAttribute("id", nid = expando)), i = (groups = tokenize(selector)).length; i--;) groups[i] = (nid ? "#" + nid : ":scope") + " " + toSelector(groups[i]);
                            newSelector = groups.join(",")
                        }
                        try {
                            return push.apply(results, newContext.querySelectorAll(newSelector)), results
                        } catch (qsaError) {
                            nonnativeSelectorCache(selector, !0)
                        } finally {
                            nid === expando && context.removeAttribute("id")
                        }
                    }
                }
                return select(selector.replace(rtrim, "$1"), context, results, seed)
            }

            function createCache() {
                var keys = [];
                return function cache(key, value) {
                    return keys.push(key + " ") > Expr.cacheLength && delete cache[keys.shift()], cache[key + " "] = value
                }
            }

            function markFunction(fn) {
                return fn[expando] = !0, fn
            }

            function assert(fn) {
                var el = document.createElement("fieldset");
                try {
                    return !!fn(el)
                } catch (e) {
                    return !1
                } finally {
                    el.parentNode && el.parentNode.removeChild(el), el = null
                }
            }

            function addHandle(attrs, handler) {
                for (var arr = attrs.split("|"), i = arr.length; i--;) Expr.attrHandle[arr[i]] = handler
            }

            function siblingCheck(a, b) {
                var cur = b && a,
                    diff = cur && 1 === a.nodeType && 1 === b.nodeType && a.sourceIndex - b.sourceIndex;
                if (diff) return diff;
                if (cur)
                    for (; cur = cur.nextSibling;)
                        if (cur === b) return -1;
                return a ? 1 : -1
            }

            function createInputPseudo(type) {
                return function(elem) {
                    return "input" === elem.nodeName.toLowerCase() && elem.type === type
                }
            }

            function createButtonPseudo(type) {
                return function(elem) {
                    var name = elem.nodeName.toLowerCase();
                    return ("input" === name || "button" === name) && elem.type === type
                }
            }

            function createDisabledPseudo(disabled) {
                return function(elem) {
                    return "form" in elem ? elem.parentNode && !1 === elem.disabled ? "label" in elem ? "label" in elem.parentNode ? elem.parentNode.disabled === disabled : elem.disabled === disabled : elem.isDisabled === disabled || elem.isDisabled !== !disabled && inDisabledFieldset(elem) === disabled : elem.disabled === disabled : "label" in elem && elem.disabled === disabled
                }
            }

            function createPositionalPseudo(fn) {
                return markFunction((function(argument) {
                    return argument = +argument, markFunction((function(seed, matches) {
                        for (var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length; i--;) seed[j = matchIndexes[i]] && (seed[j] = !(matches[j] = seed[j]))
                    }))
                }))
            }

            function testContext(context) {
                return context && void 0 !== context.getElementsByTagName && context
            }
            for (i in support = Sizzle.support = {}, isXML = Sizzle.isXML = function(elem) {
                    var namespace = elem.namespaceURI,
                        docElem = (elem.ownerDocument || elem).documentElement;
                    return !rhtml.test(namespace || docElem && docElem.nodeName || "HTML")
                }, setDocument = Sizzle.setDocument = function(node) {
                    var hasCompare, subWindow, doc = node ? node.ownerDocument || node : preferredDoc;
                    return doc != document && 9 === doc.nodeType && doc.documentElement ? (docElem = (document = doc).documentElement, documentIsHTML = !isXML(document), preferredDoc != document && (subWindow = document.defaultView) && subWindow.top !== subWindow && (subWindow.addEventListener ? subWindow.addEventListener("unload", unloadHandler, !1) : subWindow.attachEvent && subWindow.attachEvent("onunload", unloadHandler)), support.scope = assert((function(el) {
                        return docElem.appendChild(el).appendChild(document.createElement("div")), void 0 !== el.querySelectorAll && !el.querySelectorAll(":scope fieldset div").length
                    })), support.attributes = assert((function(el) {
                        return el.className = "i", !el.getAttribute("className")
                    })), support.getElementsByTagName = assert((function(el) {
                        return el.appendChild(document.createComment("")), !el.getElementsByTagName("*").length
                    })), support.getElementsByClassName = rnative.test(document.getElementsByClassName), support.getById = assert((function(el) {
                        return docElem.appendChild(el).id = expando, !document.getElementsByName || !document.getElementsByName(expando).length
                    })), support.getById ? (Expr.filter.ID = function(id) {
                        var attrId = id.replace(runescape, funescape);
                        return function(elem) {
                            return elem.getAttribute("id") === attrId
                        }
                    }, Expr.find.ID = function(id, context) {
                        if (void 0 !== context.getElementById && documentIsHTML) {
                            var elem = context.getElementById(id);
                            return elem ? [elem] : []
                        }
                    }) : (Expr.filter.ID = function(id) {
                        var attrId = id.replace(runescape, funescape);
                        return function(elem) {
                            var node = void 0 !== elem.getAttributeNode && elem.getAttributeNode("id");
                            return node && node.value === attrId
                        }
                    }, Expr.find.ID = function(id, context) {
                        if (void 0 !== context.getElementById && documentIsHTML) {
                            var node, i, elems, elem = context.getElementById(id);
                            if (elem) {
                                if ((node = elem.getAttributeNode("id")) && node.value === id) return [elem];
                                for (elems = context.getElementsByName(id), i = 0; elem = elems[i++];)
                                    if ((node = elem.getAttributeNode("id")) && node.value === id) return [elem]
                            }
                            return []
                        }
                    }), Expr.find.TAG = support.getElementsByTagName ? function(tag, context) {
                        return void 0 !== context.getElementsByTagName ? context.getElementsByTagName(tag) : support.qsa ? context.querySelectorAll(tag) : void 0
                    } : function(tag, context) {
                        var elem, tmp = [],
                            i = 0,
                            results = context.getElementsByTagName(tag);
                        if ("*" === tag) {
                            for (; elem = results[i++];) 1 === elem.nodeType && tmp.push(elem);
                            return tmp
                        }
                        return results
                    }, Expr.find.CLASS = support.getElementsByClassName && function(className, context) {
                        if (void 0 !== context.getElementsByClassName && documentIsHTML) return context.getElementsByClassName(className)
                    }, rbuggyMatches = [], rbuggyQSA = [], (support.qsa = rnative.test(document.querySelectorAll)) && (assert((function(el) {
                        var input;
                        docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a><select id='" + expando + "-\r\\' msallowcapture=''><option selected=''></option></select>", el.querySelectorAll("[msallowcapture^='']").length && rbuggyQSA.push("[*^$]=[\\x20\\t\\r\\n\\f]*(?:''|\"\")"), el.querySelectorAll("[selected]").length || rbuggyQSA.push("\\[[\\x20\\t\\r\\n\\f]*(?:value|" + booleans + ")"), el.querySelectorAll("[id~=" + expando + "-]").length || rbuggyQSA.push("~="), (input = document.createElement("input")).setAttribute("name", ""), el.appendChild(input), el.querySelectorAll("[name='']").length || rbuggyQSA.push("\\[[\\x20\\t\\r\\n\\f]*name[\\x20\\t\\r\\n\\f]*=[\\x20\\t\\r\\n\\f]*(?:''|\"\")"), el.querySelectorAll(":checked").length || rbuggyQSA.push(":checked"), el.querySelectorAll("a#" + expando + "+*").length || rbuggyQSA.push(".#.+[+~]"), el.querySelectorAll("\\\f"), rbuggyQSA.push("[\\r\\n\\f]")
                    })), assert((function(el) {
                        el.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
                        var input = document.createElement("input");
                        input.setAttribute("type", "hidden"), el.appendChild(input).setAttribute("name", "D"), el.querySelectorAll("[name=d]").length && rbuggyQSA.push("name[\\x20\\t\\r\\n\\f]*[*^$|!~]?="), 2 !== el.querySelectorAll(":enabled").length && rbuggyQSA.push(":enabled", ":disabled"), docElem.appendChild(el).disabled = !0, 2 !== el.querySelectorAll(":disabled").length && rbuggyQSA.push(":enabled", ":disabled"), el.querySelectorAll("*,:x"), rbuggyQSA.push(",.*:")
                    }))), (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) && assert((function(el) {
                        support.disconnectedMatch = matches.call(el, "*"), matches.call(el, "[s!='']:x"), rbuggyMatches.push("!=", pseudos)
                    })), rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|")), rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|")), hasCompare = rnative.test(docElem.compareDocumentPosition), contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
                        var adown = 9 === a.nodeType ? a.documentElement : a,
                            bup = b && b.parentNode;
                        return a === bup || !(!bup || 1 !== bup.nodeType || !(adown.contains ? adown.contains(bup) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(bup)))
                    } : function(a, b) {
                        if (b)
                            for (; b = b.parentNode;)
                                if (b === a) return !0;
                        return !1
                    }, sortOrder = hasCompare ? function(a, b) {
                        if (a === b) return hasDuplicate = !0, 0;
                        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                        return compare || (1 & (compare = (a.ownerDocument || a) == (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1) || !support.sortDetached && b.compareDocumentPosition(a) === compare ? a == document || a.ownerDocument == preferredDoc && contains(preferredDoc, a) ? -1 : b == document || b.ownerDocument == preferredDoc && contains(preferredDoc, b) ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0 : 4 & compare ? -1 : 1)
                    } : function(a, b) {
                        if (a === b) return hasDuplicate = !0, 0;
                        var cur, i = 0,
                            aup = a.parentNode,
                            bup = b.parentNode,
                            ap = [a],
                            bp = [b];
                        if (!aup || !bup) return a == document ? -1 : b == document ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
                        if (aup === bup) return siblingCheck(a, b);
                        for (cur = a; cur = cur.parentNode;) ap.unshift(cur);
                        for (cur = b; cur = cur.parentNode;) bp.unshift(cur);
                        for (; ap[i] === bp[i];) i++;
                        return i ? siblingCheck(ap[i], bp[i]) : ap[i] == preferredDoc ? -1 : bp[i] == preferredDoc ? 1 : 0
                    }, document) : document
                }, Sizzle.matches = function(expr, elements) {
                    return Sizzle(expr, null, null, elements)
                }, Sizzle.matchesSelector = function(elem, expr) {
                    if (setDocument(elem), support.matchesSelector && documentIsHTML && !nonnativeSelectorCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) try {
                        var ret = matches.call(elem, expr);
                        if (ret || support.disconnectedMatch || elem.document && 11 !== elem.document.nodeType) return ret
                    } catch (e) {
                        nonnativeSelectorCache(expr, !0)
                    }
                    return Sizzle(expr, document, null, [elem]).length > 0
                }, Sizzle.contains = function(context, elem) {
                    return (context.ownerDocument || context) != document && setDocument(context), contains(context, elem)
                }, Sizzle.attr = function(elem, name) {
                    (elem.ownerDocument || elem) != document && setDocument(elem);
                    var fn = Expr.attrHandle[name.toLowerCase()],
                        val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : void 0;
                    return void 0 !== val ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null
                }, Sizzle.escape = function(sel) {
                    return (sel + "").replace(rcssescape, fcssescape)
                }, Sizzle.error = function(msg) {
                    throw new Error("Syntax error, unrecognized expression: " + msg)
                }, Sizzle.uniqueSort = function(results) {
                    var elem, duplicates = [],
                        j = 0,
                        i = 0;
                    if (hasDuplicate = !support.detectDuplicates, sortInput = !support.sortStable && results.slice(0), results.sort(sortOrder), hasDuplicate) {
                        for (; elem = results[i++];) elem === results[i] && (j = duplicates.push(i));
                        for (; j--;) results.splice(duplicates[j], 1)
                    }
                    return sortInput = null, results
                }, getText = Sizzle.getText = function(elem) {
                    var node, ret = "",
                        i = 0,
                        nodeType = elem.nodeType;
                    if (nodeType) {
                        if (1 === nodeType || 9 === nodeType || 11 === nodeType) {
                            if ("string" == typeof elem.textContent) return elem.textContent;
                            for (elem = elem.firstChild; elem; elem = elem.nextSibling) ret += getText(elem)
                        } else if (3 === nodeType || 4 === nodeType) return elem.nodeValue
                    } else
                        for (; node = elem[i++];) ret += getText(node);
                    return ret
                }, (Expr = Sizzle.selectors = {
                    cacheLength: 50,
                    createPseudo: markFunction,
                    match: matchExpr,
                    attrHandle: {},
                    find: {},
                    relative: {
                        ">": {
                            dir: "parentNode",
                            first: !0
                        },
                        " ": {
                            dir: "parentNode"
                        },
                        "+": {
                            dir: "previousSibling",
                            first: !0
                        },
                        "~": {
                            dir: "previousSibling"
                        }
                    },
                    preFilter: {
                        ATTR: function(match) {
                            return match[1] = match[1].replace(runescape, funescape), match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape), "~=" === match[2] && (match[3] = " " + match[3] + " "), match.slice(0, 4)
                        },
                        CHILD: function(match) {
                            return match[1] = match[1].toLowerCase(), "nth" === match[1].slice(0, 3) ? (match[3] || Sizzle.error(match[0]), match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * ("even" === match[3] || "odd" === match[3])), match[5] = +(match[7] + match[8] || "odd" === match[3])) : match[3] && Sizzle.error(match[0]), match
                        },
                        PSEUDO: function(match) {
                            var excess, unquoted = !match[6] && match[2];
                            return matchExpr.CHILD.test(match[0]) ? null : (match[3] ? match[2] = match[4] || match[5] || "" : unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, !0)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length) && (match[0] = match[0].slice(0, excess), match[2] = unquoted.slice(0, excess)), match.slice(0, 3))
                        }
                    },
                    filter: {
                        TAG: function(nodeNameSelector) {
                            var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                            return "*" === nodeNameSelector ? function() {
                                return !0
                            } : function(elem) {
                                return elem.nodeName && elem.nodeName.toLowerCase() === nodeName
                            }
                        },
                        CLASS: function(className) {
                            var pattern = classCache[className + " "];
                            return pattern || (pattern = new RegExp("(^|[\\x20\\t\\r\\n\\f])" + className + "(" + whitespace + "|$)")) && classCache(className, (function(elem) {
                                return pattern.test("string" == typeof elem.className && elem.className || void 0 !== elem.getAttribute && elem.getAttribute("class") || "")
                            }))
                        },
                        ATTR: function(name, operator, check) {
                            return function(elem) {
                                var result = Sizzle.attr(elem, name);
                                return null == result ? "!=" === operator : !operator || (result += "", "=" === operator ? result === check : "!=" === operator ? result !== check : "^=" === operator ? check && 0 === result.indexOf(check) : "*=" === operator ? check && result.indexOf(check) > -1 : "$=" === operator ? check && result.slice(-check.length) === check : "~=" === operator ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : "|=" === operator && (result === check || result.slice(0, check.length + 1) === check + "-"))
                            }
                        },
                        CHILD: function(type, what, _argument, first, last) {
                            var simple = "nth" !== type.slice(0, 3),
                                forward = "last" !== type.slice(-4),
                                ofType = "of-type" === what;
                            return 1 === first && 0 === last ? function(elem) {
                                return !!elem.parentNode
                            } : function(elem, _context, xml) {
                                var cache, uniqueCache, outerCache, node, nodeIndex, start, dir = simple !== forward ? "nextSibling" : "previousSibling",
                                    parent = elem.parentNode,
                                    name = ofType && elem.nodeName.toLowerCase(),
                                    useCache = !xml && !ofType,
                                    diff = !1;
                                if (parent) {
                                    if (simple) {
                                        for (; dir;) {
                                            for (node = elem; node = node[dir];)
                                                if (ofType ? node.nodeName.toLowerCase() === name : 1 === node.nodeType) return !1;
                                            start = dir = "only" === type && !start && "nextSibling"
                                        }
                                        return !0
                                    }
                                    if (start = [forward ? parent.firstChild : parent.lastChild], forward && useCache) {
                                        for (diff = (nodeIndex = (cache = (uniqueCache = (outerCache = (node = parent)[expando] || (node[expando] = {}))[node.uniqueID] || (outerCache[node.uniqueID] = {}))[type] || [])[0] === dirruns && cache[1]) && cache[2], node = nodeIndex && parent.childNodes[nodeIndex]; node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop();)
                                            if (1 === node.nodeType && ++diff && node === elem) {
                                                uniqueCache[type] = [dirruns, nodeIndex, diff];
                                                break
                                            }
                                    } else if (useCache && (diff = nodeIndex = (cache = (uniqueCache = (outerCache = (node = elem)[expando] || (node[expando] = {}))[node.uniqueID] || (outerCache[node.uniqueID] = {}))[type] || [])[0] === dirruns && cache[1]), !1 === diff)
                                        for (;
                                            (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) && ((ofType ? node.nodeName.toLowerCase() !== name : 1 !== node.nodeType) || !++diff || (useCache && ((uniqueCache = (outerCache = node[expando] || (node[expando] = {}))[node.uniqueID] || (outerCache[node.uniqueID] = {}))[type] = [dirruns, diff]), node !== elem)););
                                    return (diff -= last) === first || diff % first == 0 && diff / first >= 0
                                }
                            }
                        },
                        PSEUDO: function(pseudo, argument) {
                            var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
                            return fn[expando] ? fn(argument) : fn.length > 1 ? (args = [pseudo, pseudo, "", argument], Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction((function(seed, matches) {
                                for (var idx, matched = fn(seed, argument), i = matched.length; i--;) seed[idx = indexOf(seed, matched[i])] = !(matches[idx] = matched[i])
                            })) : function(elem) {
                                return fn(elem, 0, args)
                            }) : fn
                        }
                    },
                    pseudos: {
                        not: markFunction((function(selector) {
                            var input = [],
                                results = [],
                                matcher = compile(selector.replace(rtrim, "$1"));
                            return matcher[expando] ? markFunction((function(seed, matches, _context, xml) {
                                for (var elem, unmatched = matcher(seed, null, xml, []), i = seed.length; i--;)(elem = unmatched[i]) && (seed[i] = !(matches[i] = elem))
                            })) : function(elem, _context, xml) {
                                return input[0] = elem, matcher(input, null, xml, results), input[0] = null, !results.pop()
                            }
                        })),
                        has: markFunction((function(selector) {
                            return function(elem) {
                                return Sizzle(selector, elem).length > 0
                            }
                        })),
                        contains: markFunction((function(text) {
                            return text = text.replace(runescape, funescape),
                                function(elem) {
                                    return (elem.textContent || getText(elem)).indexOf(text) > -1
                                }
                        })),
                        lang: markFunction((function(lang) {
                            return ridentifier.test(lang || "") || Sizzle.error("unsupported lang: " + lang), lang = lang.replace(runescape, funescape).toLowerCase(),
                                function(elem) {
                                    var elemLang;
                                    do {
                                        if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang")) return (elemLang = elemLang.toLowerCase()) === lang || 0 === elemLang.indexOf(lang + "-")
                                    } while ((elem = elem.parentNode) && 1 === elem.nodeType);
                                    return !1
                                }
                        })),
                        target: function(elem) {
                            var hash = window.location && window.location.hash;
                            return hash && hash.slice(1) === elem.id
                        },
                        root: function(elem) {
                            return elem === docElem
                        },
                        focus: function(elem) {
                            return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex)
                        },
                        enabled: createDisabledPseudo(!1),
                        disabled: createDisabledPseudo(!0),
                        checked: function(elem) {
                            var nodeName = elem.nodeName.toLowerCase();
                            return "input" === nodeName && !!elem.checked || "option" === nodeName && !!elem.selected
                        },
                        selected: function(elem) {
                            return elem.parentNode && elem.parentNode.selectedIndex, !0 === elem.selected
                        },
                        empty: function(elem) {
                            for (elem = elem.firstChild; elem; elem = elem.nextSibling)
                                if (elem.nodeType < 6) return !1;
                            return !0
                        },
                        parent: function(elem) {
                            return !Expr.pseudos.empty(elem)
                        },
                        header: function(elem) {
                            return rheader.test(elem.nodeName)
                        },
                        input: function(elem) {
                            return rinputs.test(elem.nodeName)
                        },
                        button: function(elem) {
                            var name = elem.nodeName.toLowerCase();
                            return "input" === name && "button" === elem.type || "button" === name
                        },
                        text: function(elem) {
                            var attr;
                            return "input" === elem.nodeName.toLowerCase() && "text" === elem.type && (null == (attr = elem.getAttribute("type")) || "text" === attr.toLowerCase())
                        },
                        first: createPositionalPseudo((function() {
                            return [0]
                        })),
                        last: createPositionalPseudo((function(_matchIndexes, length) {
                            return [length - 1]
                        })),
                        eq: createPositionalPseudo((function(_matchIndexes, length, argument) {
                            return [argument < 0 ? argument + length : argument]
                        })),
                        even: createPositionalPseudo((function(matchIndexes, length) {
                            for (var i = 0; i < length; i += 2) matchIndexes.push(i);
                            return matchIndexes
                        })),
                        odd: createPositionalPseudo((function(matchIndexes, length) {
                            for (var i = 1; i < length; i += 2) matchIndexes.push(i);
                            return matchIndexes
                        })),
                        lt: createPositionalPseudo((function(matchIndexes, length, argument) {
                            for (var i = argument < 0 ? argument + length : argument > length ? length : argument; --i >= 0;) matchIndexes.push(i);
                            return matchIndexes
                        })),
                        gt: createPositionalPseudo((function(matchIndexes, length, argument) {
                            for (var i = argument < 0 ? argument + length : argument; ++i < length;) matchIndexes.push(i);
                            return matchIndexes
                        }))
                    }
                }).pseudos.nth = Expr.pseudos.eq, {
                    radio: !0,
                    checkbox: !0,
                    file: !0,
                    password: !0,
                    image: !0
                }) Expr.pseudos[i] = createInputPseudo(i);
            for (i in {
                    submit: !0,
                    reset: !0
                }) Expr.pseudos[i] = createButtonPseudo(i);

            function setFilters() {}

            function toSelector(tokens) {
                for (var i = 0, len = tokens.length, selector = ""; i < len; i++) selector += tokens[i].value;
                return selector
            }

            function addCombinator(matcher, combinator, base) {
                var dir = combinator.dir,
                    skip = combinator.next,
                    key = skip || dir,
                    checkNonElements = base && "parentNode" === key,
                    doneName = done++;
                return combinator.first ? function(elem, context, xml) {
                    for (; elem = elem[dir];)
                        if (1 === elem.nodeType || checkNonElements) return matcher(elem, context, xml);
                    return !1
                } : function(elem, context, xml) {
                    var oldCache, uniqueCache, outerCache, newCache = [dirruns, doneName];
                    if (xml) {
                        for (; elem = elem[dir];)
                            if ((1 === elem.nodeType || checkNonElements) && matcher(elem, context, xml)) return !0
                    } else
                        for (; elem = elem[dir];)
                            if (1 === elem.nodeType || checkNonElements)
                                if (uniqueCache = (outerCache = elem[expando] || (elem[expando] = {}))[elem.uniqueID] || (outerCache[elem.uniqueID] = {}), skip && skip === elem.nodeName.toLowerCase()) elem = elem[dir] || elem;
                                else {
                                    if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName) return newCache[2] = oldCache[2];
                                    if (uniqueCache[key] = newCache, newCache[2] = matcher(elem, context, xml)) return !0
                                } return !1
                }
            }

            function elementMatcher(matchers) {
                return matchers.length > 1 ? function(elem, context, xml) {
                    for (var i = matchers.length; i--;)
                        if (!matchers[i](elem, context, xml)) return !1;
                    return !0
                } : matchers[0]
            }

            function condense(unmatched, map, filter, context, xml) {
                for (var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = null != map; i < len; i++)(elem = unmatched[i]) && (filter && !filter(elem, context, xml) || (newUnmatched.push(elem), mapped && map.push(i)));
                return newUnmatched
            }

            function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
                return postFilter && !postFilter[expando] && (postFilter = setMatcher(postFilter)), postFinder && !postFinder[expando] && (postFinder = setMatcher(postFinder, postSelector)), markFunction((function(seed, results, context, xml) {
                    var temp, i, elem, preMap = [],
                        postMap = [],
                        preexisting = results.length,
                        elems = seed || function(selector, contexts, results) {
                            for (var i = 0, len = contexts.length; i < len; i++) Sizzle(selector, contexts[i], results);
                            return results
                        }(selector || "*", context.nodeType ? [context] : context, []),
                        matcherIn = !preFilter || !seed && selector ? elems : condense(elems, preMap, preFilter, context, xml),
                        matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
                    if (matcher && matcher(matcherIn, matcherOut, context, xml), postFilter)
                        for (temp = condense(matcherOut, postMap), postFilter(temp, [], context, xml), i = temp.length; i--;)(elem = temp[i]) && (matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem));
                    if (seed) {
                        if (postFinder || preFilter) {
                            if (postFinder) {
                                for (temp = [], i = matcherOut.length; i--;)(elem = matcherOut[i]) && temp.push(matcherIn[i] = elem);
                                postFinder(null, matcherOut = [], temp, xml)
                            }
                            for (i = matcherOut.length; i--;)(elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1 && (seed[temp] = !(results[temp] = elem))
                        }
                    } else matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut), postFinder ? postFinder(null, results, matcherOut, xml) : push.apply(results, matcherOut)
                }))
            }

            function matcherFromTokens(tokens) {
                for (var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i = leadingRelative ? 1 : 0, matchContext = addCombinator((function(elem) {
                        return elem === checkContext
                    }), implicitRelative, !0), matchAnyContext = addCombinator((function(elem) {
                        return indexOf(checkContext, elem) > -1
                    }), implicitRelative, !0), matchers = [function(elem, context, xml) {
                        var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
                        return checkContext = null, ret
                    }]; i < len; i++)
                    if (matcher = Expr.relative[tokens[i].type]) matchers = [addCombinator(elementMatcher(matchers), matcher)];
                    else {
                        if ((matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches))[expando]) {
                            for (j = ++i; j < len && !Expr.relative[tokens[j].type]; j++);
                            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({
                                value: " " === tokens[i - 2].type ? "*" : ""
                            })).replace(rtrim, "$1"), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens))
                        }
                        matchers.push(matcher)
                    }
                return elementMatcher(matchers)
            }
            return setFilters.prototype = Expr.filters = Expr.pseudos, Expr.setFilters = new setFilters, tokenize = Sizzle.tokenize = function(selector, parseOnly) {
                var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
                if (cached) return parseOnly ? 0 : cached.slice(0);
                for (soFar = selector, groups = [], preFilters = Expr.preFilter; soFar;) {
                    for (type in matched && !(match = rcomma.exec(soFar)) || (match && (soFar = soFar.slice(match[0].length) || soFar), groups.push(tokens = [])), matched = !1, (match = rcombinators.exec(soFar)) && (matched = match.shift(), tokens.push({
                            value: matched,
                            type: match[0].replace(rtrim, " ")
                        }), soFar = soFar.slice(matched.length)), Expr.filter) !(match = matchExpr[type].exec(soFar)) || preFilters[type] && !(match = preFilters[type](match)) || (matched = match.shift(), tokens.push({
                        value: matched,
                        type: type,
                        matches: match
                    }), soFar = soFar.slice(matched.length));
                    if (!matched) break
                }
                return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0)
            }, compile = Sizzle.compile = function(selector, match) {
                var i, setMatchers = [],
                    elementMatchers = [],
                    cached = compilerCache[selector + " "];
                if (!cached) {
                    for (match || (match = tokenize(selector)), i = match.length; i--;)(cached = matcherFromTokens(match[i]))[expando] ? setMatchers.push(cached) : elementMatchers.push(cached);
                    (cached = compilerCache(selector, function(elementMatchers, setMatchers) {
                        var bySet = setMatchers.length > 0,
                            byElement = elementMatchers.length > 0,
                            superMatcher = function(seed, context, xml, results, outermost) {
                                var elem, j, matcher, matchedCount = 0,
                                    i = "0",
                                    unmatched = seed && [],
                                    setMatched = [],
                                    contextBackup = outermostContext,
                                    elems = seed || byElement && Expr.find.TAG("*", outermost),
                                    dirrunsUnique = dirruns += null == contextBackup ? 1 : Math.random() || .1,
                                    len = elems.length;
                                for (outermost && (outermostContext = context == document || context || outermost); i !== len && null != (elem = elems[i]); i++) {
                                    if (byElement && elem) {
                                        for (j = 0, context || elem.ownerDocument == document || (setDocument(elem), xml = !documentIsHTML); matcher = elementMatchers[j++];)
                                            if (matcher(elem, context || document, xml)) {
                                                results.push(elem);
                                                break
                                            }
                                        outermost && (dirruns = dirrunsUnique)
                                    }
                                    bySet && ((elem = !matcher && elem) && matchedCount--, seed && unmatched.push(elem))
                                }
                                if (matchedCount += i, bySet && i !== matchedCount) {
                                    for (j = 0; matcher = setMatchers[j++];) matcher(unmatched, setMatched, context, xml);
                                    if (seed) {
                                        if (matchedCount > 0)
                                            for (; i--;) unmatched[i] || setMatched[i] || (setMatched[i] = pop.call(results));
                                        setMatched = condense(setMatched)
                                    }
                                    push.apply(results, setMatched), outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1 && Sizzle.uniqueSort(results)
                                }
                                return outermost && (dirruns = dirrunsUnique, outermostContext = contextBackup), unmatched
                            };
                        return bySet ? markFunction(superMatcher) : superMatcher
                    }(elementMatchers, setMatchers))).selector = selector
                }
                return cached
            }, select = Sizzle.select = function(selector, context, results, seed) {
                var i, tokens, token, type, find, compiled = "function" == typeof selector && selector,
                    match = !seed && tokenize(selector = compiled.selector || selector);
                if (results = results || [], 1 === match.length) {
                    if ((tokens = match[0] = match[0].slice(0)).length > 2 && "ID" === (token = tokens[0]).type && 9 === context.nodeType && documentIsHTML && Expr.relative[tokens[1].type]) {
                        if (!(context = (Expr.find.ID(token.matches[0].replace(runescape, funescape), context) || [])[0])) return results;
                        compiled && (context = context.parentNode), selector = selector.slice(tokens.shift().value.length)
                    }
                    for (i = matchExpr.needsContext.test(selector) ? 0 : tokens.length; i-- && (token = tokens[i], !Expr.relative[type = token.type]);)
                        if ((find = Expr.find[type]) && (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context))) {
                            if (tokens.splice(i, 1), !(selector = seed.length && toSelector(tokens))) return push.apply(results, seed), results;
                            break
                        }
                }
                return (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context), results
            }, support.sortStable = expando.split("").sort(sortOrder).join("") === expando, support.detectDuplicates = !!hasDuplicate, setDocument(), support.sortDetached = assert((function(el) {
                return 1 & el.compareDocumentPosition(document.createElement("fieldset"))
            })), assert((function(el) {
                return el.innerHTML = "<a href='#'></a>", "#" === el.firstChild.getAttribute("href")
            })) || addHandle("type|href|height|width", (function(elem, name, isXML) {
                if (!isXML) return elem.getAttribute(name, "type" === name.toLowerCase() ? 1 : 2)
            })), support.attributes && assert((function(el) {
                return el.innerHTML = "<input/>", el.firstChild.setAttribute("value", ""), "" === el.firstChild.getAttribute("value")
            })) || addHandle("value", (function(elem, _name, isXML) {
                if (!isXML && "input" === elem.nodeName.toLowerCase()) return elem.defaultValue
            })), assert((function(el) {
                return null == el.getAttribute("disabled")
            })) || addHandle(booleans, (function(elem, name, isXML) {
                var val;
                if (!isXML) return !0 === elem[name] ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null
            })), Sizzle
        }(window);
        jQuery.find = Sizzle, jQuery.expr = Sizzle.selectors, jQuery.expr[":"] = jQuery.expr.pseudos, jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort, jQuery.text = Sizzle.getText, jQuery.isXMLDoc = Sizzle.isXML, jQuery.contains = Sizzle.contains, jQuery.escapeSelector = Sizzle.escape;
        var dir = function(elem, dir, until) {
                for (var matched = [], truncate = void 0 !== until;
                    (elem = elem[dir]) && 9 !== elem.nodeType;)
                    if (1 === elem.nodeType) {
                        if (truncate && jQuery(elem).is(until)) break;
                        matched.push(elem)
                    }
                return matched
            },
            siblings = function(n, elem) {
                for (var matched = []; n; n = n.nextSibling) 1 === n.nodeType && n !== elem && matched.push(n);
                return matched
            },
            rneedsContext = jQuery.expr.match.needsContext;

        function nodeName(elem, name) {
            return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase()
        }
        var rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i;

        function winnow(elements, qualifier, not) {
            return isFunction(qualifier) ? jQuery.grep(elements, (function(elem, i) {
                return !!qualifier.call(elem, i, elem) !== not
            })) : qualifier.nodeType ? jQuery.grep(elements, (function(elem) {
                return elem === qualifier !== not
            })) : "string" != typeof qualifier ? jQuery.grep(elements, (function(elem) {
                return indexOf.call(qualifier, elem) > -1 !== not
            })) : jQuery.filter(qualifier, elements, not)
        }
        jQuery.filter = function(expr, elems, not) {
            var elem = elems[0];
            return not && (expr = ":not(" + expr + ")"), 1 === elems.length && 1 === elem.nodeType ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, (function(elem) {
                return 1 === elem.nodeType
            })))
        }, jQuery.fn.extend({
            find: function(selector) {
                var i, ret, len = this.length,
                    self = this;
                if ("string" != typeof selector) return this.pushStack(jQuery(selector).filter((function() {
                    for (i = 0; i < len; i++)
                        if (jQuery.contains(self[i], this)) return !0
                })));
                for (ret = this.pushStack([]), i = 0; i < len; i++) jQuery.find(selector, self[i], ret);
                return len > 1 ? jQuery.uniqueSort(ret) : ret
            },
            filter: function(selector) {
                return this.pushStack(winnow(this, selector || [], !1))
            },
            not: function(selector) {
                return this.pushStack(winnow(this, selector || [], !0))
            },
            is: function(selector) {
                return !!winnow(this, "string" == typeof selector && rneedsContext.test(selector) ? jQuery(selector) : selector || [], !1).length
            }
        });
        var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/;
        (jQuery.fn.init = function(selector, context, root) {
            var match, elem;
            if (!selector) return this;
            if (root = root || rootjQuery, "string" == typeof selector) {
                if (!(match = "<" === selector[0] && ">" === selector[selector.length - 1] && selector.length >= 3 ? [null, selector, null] : rquickExpr.exec(selector)) || !match[1] && context) return !context || context.jquery ? (context || root).find(selector) : this.constructor(context).find(selector);
                if (match[1]) {
                    if (context = context instanceof jQuery ? context[0] : context, jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, !0)), rsingleTag.test(match[1]) && jQuery.isPlainObject(context))
                        for (match in context) isFunction(this[match]) ? this[match](context[match]) : this.attr(match, context[match]);
                    return this
                }
                return (elem = document.getElementById(match[2])) && (this[0] = elem, this.length = 1), this
            }
            return selector.nodeType ? (this[0] = selector, this.length = 1, this) : isFunction(selector) ? void 0 !== root.ready ? root.ready(selector) : selector(jQuery) : jQuery.makeArray(selector, this)
        }).prototype = jQuery.fn, rootjQuery = jQuery(document);
        var rparentsprev = /^(?:parents|prev(?:Until|All))/,
            guaranteedUnique = {
                children: !0,
                contents: !0,
                next: !0,
                prev: !0
            };

        function sibling(cur, dir) {
            for (;
                (cur = cur[dir]) && 1 !== cur.nodeType;);
            return cur
        }
        jQuery.fn.extend({
            has: function(target) {
                var targets = jQuery(target, this),
                    l = targets.length;
                return this.filter((function() {
                    for (var i = 0; i < l; i++)
                        if (jQuery.contains(this, targets[i])) return !0
                }))
            },
            closest: function(selectors, context) {
                var cur, i = 0,
                    l = this.length,
                    matched = [],
                    targets = "string" != typeof selectors && jQuery(selectors);
                if (!rneedsContext.test(selectors))
                    for (; i < l; i++)
                        for (cur = this[i]; cur && cur !== context; cur = cur.parentNode)
                            if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : 1 === cur.nodeType && jQuery.find.matchesSelector(cur, selectors))) {
                                matched.push(cur);
                                break
                            }
                return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched)
            },
            index: function(elem) {
                return elem ? "string" == typeof elem ? indexOf.call(jQuery(elem), this[0]) : indexOf.call(this, elem.jquery ? elem[0] : elem) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
            },
            add: function(selector, context) {
                return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))))
            },
            addBack: function(selector) {
                return this.add(null == selector ? this.prevObject : this.prevObject.filter(selector))
            }
        }), jQuery.each({
            parent: function(elem) {
                var parent = elem.parentNode;
                return parent && 11 !== parent.nodeType ? parent : null
            },
            parents: function(elem) {
                return dir(elem, "parentNode")
            },
            parentsUntil: function(elem, _i, until) {
                return dir(elem, "parentNode", until)
            },
            next: function(elem) {
                return sibling(elem, "nextSibling")
            },
            prev: function(elem) {
                return sibling(elem, "previousSibling")
            },
            nextAll: function(elem) {
                return dir(elem, "nextSibling")
            },
            prevAll: function(elem) {
                return dir(elem, "previousSibling")
            },
            nextUntil: function(elem, _i, until) {
                return dir(elem, "nextSibling", until)
            },
            prevUntil: function(elem, _i, until) {
                return dir(elem, "previousSibling", until)
            },
            siblings: function(elem) {
                return siblings((elem.parentNode || {}).firstChild, elem)
            },
            children: function(elem) {
                return siblings(elem.firstChild)
            },
            contents: function(elem) {
                return null != elem.contentDocument && getProto(elem.contentDocument) ? elem.contentDocument : (nodeName(elem, "template") && (elem = elem.content || elem), jQuery.merge([], elem.childNodes))
            }
        }, (function(name, fn) {
            jQuery.fn[name] = function(until, selector) {
                var matched = jQuery.map(this, fn, until);
                return "Until" !== name.slice(-5) && (selector = until), selector && "string" == typeof selector && (matched = jQuery.filter(selector, matched)), this.length > 1 && (guaranteedUnique[name] || jQuery.uniqueSort(matched), rparentsprev.test(name) && matched.reverse()), this.pushStack(matched)
            }
        }));
        var rnothtmlwhite = /[^\x20\t\r\n\f]+/g;

        function Identity(v) {
            return v
        }

        function Thrower(ex) {
            throw ex
        }

        function adoptValue(value, resolve, reject, noValue) {
            var method;
            try {
                value && isFunction(method = value.promise) ? method.call(value).done(resolve).fail(reject) : value && isFunction(method = value.then) ? method.call(value, resolve, reject) : resolve.apply(void 0, [value].slice(noValue))
            } catch (value) {
                reject.apply(void 0, [value])
            }
        }
        jQuery.Callbacks = function(options) {
            options = "string" == typeof options ? function(options) {
                var object = {};
                return jQuery.each(options.match(rnothtmlwhite) || [], (function(_, flag) {
                    object[flag] = !0
                })), object
            }(options) : jQuery.extend({}, options);
            var firing, memory, fired, locked, list = [],
                queue = [],
                firingIndex = -1,
                fire = function() {
                    for (locked = locked || options.once, fired = firing = !0; queue.length; firingIndex = -1)
                        for (memory = queue.shift(); ++firingIndex < list.length;) !1 === list[firingIndex].apply(memory[0], memory[1]) && options.stopOnFalse && (firingIndex = list.length, memory = !1);
                    options.memory || (memory = !1), firing = !1, locked && (list = memory ? [] : "")
                },
                self = {
                    add: function() {
                        return list && (memory && !firing && (firingIndex = list.length - 1, queue.push(memory)), function add(args) {
                            jQuery.each(args, (function(_, arg) {
                                isFunction(arg) ? options.unique && self.has(arg) || list.push(arg) : arg && arg.length && "string" !== toType(arg) && add(arg)
                            }))
                        }(arguments), memory && !firing && fire()), this
                    },
                    remove: function() {
                        return jQuery.each(arguments, (function(_, arg) {
                            for (var index;
                                (index = jQuery.inArray(arg, list, index)) > -1;) list.splice(index, 1), index <= firingIndex && firingIndex--
                        })), this
                    },
                    has: function(fn) {
                        return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0
                    },
                    empty: function() {
                        return list && (list = []), this
                    },
                    disable: function() {
                        return locked = queue = [], list = memory = "", this
                    },
                    disabled: function() {
                        return !list
                    },
                    lock: function() {
                        return locked = queue = [], memory || firing || (list = memory = ""), this
                    },
                    locked: function() {
                        return !!locked
                    },
                    fireWith: function(context, args) {
                        return locked || (args = [context, (args = args || []).slice ? args.slice() : args], queue.push(args), firing || fire()), this
                    },
                    fire: function() {
                        return self.fireWith(this, arguments), this
                    },
                    fired: function() {
                        return !!fired
                    }
                };
            return self
        }, jQuery.extend({
            Deferred: function(func) {
                var tuples = [
                        ["notify", "progress", jQuery.Callbacks("memory"), jQuery.Callbacks("memory"), 2],
                        ["resolve", "done", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 0, "resolved"],
                        ["reject", "fail", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 1, "rejected"]
                    ],
                    state = "pending",
                    promise = {
                        state: function() {
                            return state
                        },
                        always: function() {
                            return deferred.done(arguments).fail(arguments), this
                        },
                        catch: function(fn) {
                            return promise.then(null, fn)
                        },
                        pipe: function() {
                            var fns = arguments;
                            return jQuery.Deferred((function(newDefer) {
                                jQuery.each(tuples, (function(_i, tuple) {
                                    var fn = isFunction(fns[tuple[4]]) && fns[tuple[4]];
                                    deferred[tuple[1]]((function() {
                                        var returned = fn && fn.apply(this, arguments);
                                        returned && isFunction(returned.promise) ? returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject) : newDefer[tuple[0] + "With"](this, fn ? [returned] : arguments)
                                    }))
                                })), fns = null
                            })).promise()
                        },
                        then: function(onFulfilled, onRejected, onProgress) {
                            var maxDepth = 0;

                            function resolve(depth, deferred, handler, special) {
                                return function() {
                                    var that = this,
                                        args = arguments,
                                        mightThrow = function() {
                                            var returned, then;
                                            if (!(depth < maxDepth)) {
                                                if ((returned = handler.apply(that, args)) === deferred.promise()) throw new TypeError("Thenable self-resolution");
                                                then = returned && ("object" == typeof returned || "function" == typeof returned) && returned.then, isFunction(then) ? special ? then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special)) : (maxDepth++, then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith))) : (handler !== Identity && (that = void 0, args = [returned]), (special || deferred.resolveWith)(that, args))
                                            }
                                        },
                                        process = special ? mightThrow : function() {
                                            try {
                                                mightThrow()
                                            } catch (e) {
                                                jQuery.Deferred.exceptionHook && jQuery.Deferred.exceptionHook(e, process.stackTrace), depth + 1 >= maxDepth && (handler !== Thrower && (that = void 0, args = [e]), deferred.rejectWith(that, args))
                                            }
                                        };
                                    depth ? process() : (jQuery.Deferred.getStackHook && (process.stackTrace = jQuery.Deferred.getStackHook()), window.setTimeout(process))
                                }
                            }
                            return jQuery.Deferred((function(newDefer) {
                                tuples[0][3].add(resolve(0, newDefer, isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith)), tuples[1][3].add(resolve(0, newDefer, isFunction(onFulfilled) ? onFulfilled : Identity)), tuples[2][3].add(resolve(0, newDefer, isFunction(onRejected) ? onRejected : Thrower))
                            })).promise()
                        },
                        promise: function(obj) {
                            return null != obj ? jQuery.extend(obj, promise) : promise
                        }
                    },
                    deferred = {};
                return jQuery.each(tuples, (function(i, tuple) {
                    var list = tuple[2],
                        stateString = tuple[5];
                    promise[tuple[1]] = list.add, stateString && list.add((function() {
                        state = stateString
                    }), tuples[3 - i][2].disable, tuples[3 - i][3].disable, tuples[0][2].lock, tuples[0][3].lock), list.add(tuple[3].fire), deferred[tuple[0]] = function() {
                        return deferred[tuple[0] + "With"](this === deferred ? void 0 : this, arguments), this
                    }, deferred[tuple[0] + "With"] = list.fireWith
                })), promise.promise(deferred), func && func.call(deferred, deferred), deferred
            },
            when: function(singleValue) {
                var remaining = arguments.length,
                    i = remaining,
                    resolveContexts = Array(i),
                    resolveValues = slice.call(arguments),
                    master = jQuery.Deferred(),
                    updateFunc = function(i) {
                        return function(value) {
                            resolveContexts[i] = this, resolveValues[i] = arguments.length > 1 ? slice.call(arguments) : value, --remaining || master.resolveWith(resolveContexts, resolveValues)
                        }
                    };
                if (remaining <= 1 && (adoptValue(singleValue, master.done(updateFunc(i)).resolve, master.reject, !remaining), "pending" === master.state() || isFunction(resolveValues[i] && resolveValues[i].then))) return master.then();
                for (; i--;) adoptValue(resolveValues[i], updateFunc(i), master.reject);
                return master.promise()
            }
        });
        var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
        jQuery.Deferred.exceptionHook = function(error, stack) {
            window.console && window.console.warn && error && rerrorNames.test(error.name) && window.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack)
        }, jQuery.readyException = function(error) {
            window.setTimeout((function() {
                throw error
            }))
        };
        var readyList = jQuery.Deferred();

        function completed() {
            document.removeEventListener("DOMContentLoaded", completed), window.removeEventListener("load", completed), jQuery.ready()
        }
        jQuery.fn.ready = function(fn) {
            return readyList.then(fn).catch((function(error) {
                jQuery.readyException(error)
            })), this
        }, jQuery.extend({
            isReady: !1,
            readyWait: 1,
            ready: function(wait) {
                (!0 === wait ? --jQuery.readyWait : jQuery.isReady) || (jQuery.isReady = !0, !0 !== wait && --jQuery.readyWait > 0 || readyList.resolveWith(document, [jQuery]))
            }
        }), jQuery.ready.then = readyList.then, "complete" === document.readyState || "loading" !== document.readyState && !document.documentElement.doScroll ? window.setTimeout(jQuery.ready) : (document.addEventListener("DOMContentLoaded", completed), window.addEventListener("load", completed));
        var access = function(elems, fn, key, value, chainable, emptyGet, raw) {
                var i = 0,
                    len = elems.length,
                    bulk = null == key;
                if ("object" === toType(key))
                    for (i in chainable = !0, key) access(elems, fn, i, key[i], !0, emptyGet, raw);
                else if (void 0 !== value && (chainable = !0, isFunction(value) || (raw = !0), bulk && (raw ? (fn.call(elems, value), fn = null) : (bulk = fn, fn = function(elem, _key, value) {
                        return bulk.call(jQuery(elem), value)
                    })), fn))
                    for (; i < len; i++) fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
                return chainable ? elems : bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet
            },
            rmsPrefix = /^-ms-/,
            rdashAlpha = /-([a-z])/g;

        function fcamelCase(_all, letter) {
            return letter.toUpperCase()
        }

        function camelCase(string) {
            return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase)
        }
        var acceptData = function(owner) {
            return 1 === owner.nodeType || 9 === owner.nodeType || !+owner.nodeType
        };

        function Data() {
            this.expando = jQuery.expando + Data.uid++
        }
        Data.uid = 1, Data.prototype = {
            cache: function(owner) {
                var value = owner[this.expando];
                return value || (value = {}, acceptData(owner) && (owner.nodeType ? owner[this.expando] = value : Object.defineProperty(owner, this.expando, {
                    value: value,
                    configurable: !0
                }))), value
            },
            set: function(owner, data, value) {
                var prop, cache = this.cache(owner);
                if ("string" == typeof data) cache[camelCase(data)] = value;
                else
                    for (prop in data) cache[camelCase(prop)] = data[prop];
                return cache
            },
            get: function(owner, key) {
                return void 0 === key ? this.cache(owner) : owner[this.expando] && owner[this.expando][camelCase(key)]
            },
            access: function(owner, key, value) {
                return void 0 === key || key && "string" == typeof key && void 0 === value ? this.get(owner, key) : (this.set(owner, key, value), void 0 !== value ? value : key)
            },
            remove: function(owner, key) {
                var i, cache = owner[this.expando];
                if (void 0 !== cache) {
                    if (void 0 !== key) {
                        i = (key = Array.isArray(key) ? key.map(camelCase) : (key = camelCase(key)) in cache ? [key] : key.match(rnothtmlwhite) || []).length;
                        for (; i--;) delete cache[key[i]]
                    }(void 0 === key || jQuery.isEmptyObject(cache)) && (owner.nodeType ? owner[this.expando] = void 0 : delete owner[this.expando])
                }
            },
            hasData: function(owner) {
                var cache = owner[this.expando];
                return void 0 !== cache && !jQuery.isEmptyObject(cache)
            }
        };
        var dataPriv = new Data,
            dataUser = new Data,
            rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
            rmultiDash = /[A-Z]/g;

        function dataAttr(elem, key, data) {
            var name;
            if (void 0 === data && 1 === elem.nodeType)
                if (name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase(), "string" == typeof(data = elem.getAttribute(name))) {
                    try {
                        data = function(data) {
                            return "true" === data || "false" !== data && ("null" === data ? null : data === +data + "" ? +data : rbrace.test(data) ? JSON.parse(data) : data)
                        }(data)
                    } catch (e) {}
                    dataUser.set(elem, key, data)
                } else data = void 0;
            return data
        }
        jQuery.extend({
            hasData: function(elem) {
                return dataUser.hasData(elem) || dataPriv.hasData(elem)
            },
            data: function(elem, name, data) {
                return dataUser.access(elem, name, data)
            },
            removeData: function(elem, name) {
                dataUser.remove(elem, name)
            },
            _data: function(elem, name, data) {
                return dataPriv.access(elem, name, data)
            },
            _removeData: function(elem, name) {
                dataPriv.remove(elem, name)
            }
        }), jQuery.fn.extend({
            data: function(key, value) {
                var i, name, data, elem = this[0],
                    attrs = elem && elem.attributes;
                if (void 0 === key) {
                    if (this.length && (data = dataUser.get(elem), 1 === elem.nodeType && !dataPriv.get(elem, "hasDataAttrs"))) {
                        for (i = attrs.length; i--;) attrs[i] && 0 === (name = attrs[i].name).indexOf("data-") && (name = camelCase(name.slice(5)), dataAttr(elem, name, data[name]));
                        dataPriv.set(elem, "hasDataAttrs", !0)
                    }
                    return data
                }
                return "object" == typeof key ? this.each((function() {
                    dataUser.set(this, key)
                })) : access(this, (function(value) {
                    var data;
                    if (elem && void 0 === value) return void 0 !== (data = dataUser.get(elem, key)) || void 0 !== (data = dataAttr(elem, key)) ? data : void 0;
                    this.each((function() {
                        dataUser.set(this, key, value)
                    }))
                }), null, value, arguments.length > 1, null, !0)
            },
            removeData: function(key) {
                return this.each((function() {
                    dataUser.remove(this, key)
                }))
            }
        }), jQuery.extend({
            queue: function(elem, type, data) {
                var queue;
                if (elem) return type = (type || "fx") + "queue", queue = dataPriv.get(elem, type), data && (!queue || Array.isArray(data) ? queue = dataPriv.access(elem, type, jQuery.makeArray(data)) : queue.push(data)), queue || []
            },
            dequeue: function(elem, type) {
                type = type || "fx";
                var queue = jQuery.queue(elem, type),
                    startLength = queue.length,
                    fn = queue.shift(),
                    hooks = jQuery._queueHooks(elem, type);
                "inprogress" === fn && (fn = queue.shift(), startLength--), fn && ("fx" === type && queue.unshift("inprogress"), delete hooks.stop, fn.call(elem, (function() {
                    jQuery.dequeue(elem, type)
                }), hooks)), !startLength && hooks && hooks.empty.fire()
            },
            _queueHooks: function(elem, type) {
                var key = type + "queueHooks";
                return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
                    empty: jQuery.Callbacks("once memory").add((function() {
                        dataPriv.remove(elem, [type + "queue", key])
                    }))
                })
            }
        }), jQuery.fn.extend({
            queue: function(type, data) {
                var setter = 2;
                return "string" != typeof type && (data = type, type = "fx", setter--), arguments.length < setter ? jQuery.queue(this[0], type) : void 0 === data ? this : this.each((function() {
                    var queue = jQuery.queue(this, type, data);
                    jQuery._queueHooks(this, type), "fx" === type && "inprogress" !== queue[0] && jQuery.dequeue(this, type)
                }))
            },
            dequeue: function(type) {
                return this.each((function() {
                    jQuery.dequeue(this, type)
                }))
            },
            clearQueue: function(type) {
                return this.queue(type || "fx", [])
            },
            promise: function(type, obj) {
                var tmp, count = 1,
                    defer = jQuery.Deferred(),
                    elements = this,
                    i = this.length,
                    resolve = function() {
                        --count || defer.resolveWith(elements, [elements])
                    };
                for ("string" != typeof type && (obj = type, type = void 0), type = type || "fx"; i--;)(tmp = dataPriv.get(elements[i], type + "queueHooks")) && tmp.empty && (count++, tmp.empty.add(resolve));
                return resolve(), defer.promise(obj)
            }
        });
        var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source,
            rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i"),
            cssExpand = ["Top", "Right", "Bottom", "Left"],
            documentElement = document.documentElement,
            isAttached = function(elem) {
                return jQuery.contains(elem.ownerDocument, elem)
            },
            composed = {
                composed: !0
            };
        documentElement.getRootNode && (isAttached = function(elem) {
            return jQuery.contains(elem.ownerDocument, elem) || elem.getRootNode(composed) === elem.ownerDocument
        });
        var isHiddenWithinTree = function(elem, el) {
            return "none" === (elem = el || elem).style.display || "" === elem.style.display && isAttached(elem) && "none" === jQuery.css(elem, "display")
        };

        function adjustCSS(elem, prop, valueParts, tween) {
            var adjusted, scale, maxIterations = 20,
                currentValue = tween ? function() {
                    return tween.cur()
                } : function() {
                    return jQuery.css(elem, prop, "")
                },
                initial = currentValue(),
                unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"),
                initialInUnit = elem.nodeType && (jQuery.cssNumber[prop] || "px" !== unit && +initial) && rcssNum.exec(jQuery.css(elem, prop));
            if (initialInUnit && initialInUnit[3] !== unit) {
                for (initial /= 2, unit = unit || initialInUnit[3], initialInUnit = +initial || 1; maxIterations--;) jQuery.style(elem, prop, initialInUnit + unit), (1 - scale) * (1 - (scale = currentValue() / initial || .5)) <= 0 && (maxIterations = 0), initialInUnit /= scale;
                initialInUnit *= 2, jQuery.style(elem, prop, initialInUnit + unit), valueParts = valueParts || []
            }
            return valueParts && (initialInUnit = +initialInUnit || +initial || 0, adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2], tween && (tween.unit = unit, tween.start = initialInUnit, tween.end = adjusted)), adjusted
        }
        var defaultDisplayMap = {};

        function getDefaultDisplay(elem) {
            var temp, doc = elem.ownerDocument,
                nodeName = elem.nodeName,
                display = defaultDisplayMap[nodeName];
            return display || (temp = doc.body.appendChild(doc.createElement(nodeName)), display = jQuery.css(temp, "display"), temp.parentNode.removeChild(temp), "none" === display && (display = "block"), defaultDisplayMap[nodeName] = display, display)
        }

        function showHide(elements, show) {
            for (var display, elem, values = [], index = 0, length = elements.length; index < length; index++)(elem = elements[index]).style && (display = elem.style.display, show ? ("none" === display && (values[index] = dataPriv.get(elem, "display") || null, values[index] || (elem.style.display = "")), "" === elem.style.display && isHiddenWithinTree(elem) && (values[index] = getDefaultDisplay(elem))) : "none" !== display && (values[index] = "none", dataPriv.set(elem, "display", display)));
            for (index = 0; index < length; index++) null != values[index] && (elements[index].style.display = values[index]);
            return elements
        }
        jQuery.fn.extend({
            show: function() {
                return showHide(this, !0)
            },
            hide: function() {
                return showHide(this)
            },
            toggle: function(state) {
                return "boolean" == typeof state ? state ? this.show() : this.hide() : this.each((function() {
                    isHiddenWithinTree(this) ? jQuery(this).show() : jQuery(this).hide()
                }))
            }
        });
        var div, input, rcheckableType = /^(?:checkbox|radio)$/i,
            rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]*)/i,
            rscriptType = /^$|^module$|\/(?:java|ecma)script/i;
        div = document.createDocumentFragment().appendChild(document.createElement("div")), (input = document.createElement("input")).setAttribute("type", "radio"), input.setAttribute("checked", "checked"), input.setAttribute("name", "t"), div.appendChild(input), support.checkClone = div.cloneNode(!0).cloneNode(!0).lastChild.checked, div.innerHTML = "<textarea>x</textarea>", support.noCloneChecked = !!div.cloneNode(!0).lastChild.defaultValue, div.innerHTML = "<option></option>", support.option = !!div.lastChild;
        var wrapMap = {
            thead: [1, "<table>", "</table>"],
            col: [2, "<table><colgroup>", "</colgroup></table>"],
            tr: [2, "<table><tbody>", "</tbody></table>"],
            td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
            _default: [0, "", ""]
        };

        function getAll(context, tag) {
            var ret;
            return ret = void 0 !== context.getElementsByTagName ? context.getElementsByTagName(tag || "*") : void 0 !== context.querySelectorAll ? context.querySelectorAll(tag || "*") : [], void 0 === tag || tag && nodeName(context, tag) ? jQuery.merge([context], ret) : ret
        }

        function setGlobalEval(elems, refElements) {
            for (var i = 0, l = elems.length; i < l; i++) dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"))
        }
        wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead, wrapMap.th = wrapMap.td, support.option || (wrapMap.optgroup = wrapMap.option = [1, "<select multiple='multiple'>", "</select>"]);
        var rhtml = /<|&#?\w+;/;

        function buildFragment(elems, context, scripts, selection, ignored) {
            for (var elem, tmp, tag, wrap, attached, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length; i < l; i++)
                if ((elem = elems[i]) || 0 === elem)
                    if ("object" === toType(elem)) jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
                    else if (rhtml.test(elem)) {
                for (tmp = tmp || fragment.appendChild(context.createElement("div")), tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase(), wrap = wrapMap[tag] || wrapMap._default, tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2], j = wrap[0]; j--;) tmp = tmp.lastChild;
                jQuery.merge(nodes, tmp.childNodes), (tmp = fragment.firstChild).textContent = ""
            } else nodes.push(context.createTextNode(elem));
            for (fragment.textContent = "", i = 0; elem = nodes[i++];)
                if (selection && jQuery.inArray(elem, selection) > -1) ignored && ignored.push(elem);
                else if (attached = isAttached(elem), tmp = getAll(fragment.appendChild(elem), "script"), attached && setGlobalEval(tmp), scripts)
                for (j = 0; elem = tmp[j++];) rscriptType.test(elem.type || "") && scripts.push(elem);
            return fragment
        }
        var rkeyEvent = /^key/,
            rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
            rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

        function returnTrue() {
            return !0
        }

        function returnFalse() {
            return !1
        }

        function expectSync(elem, type) {
            return elem === function() {
                try {
                    return document.activeElement
                } catch (err) {}
            }() == ("focus" === type)
        }

        function on(elem, types, selector, data, fn, one) {
            var origFn, type;
            if ("object" == typeof types) {
                for (type in "string" != typeof selector && (data = data || selector, selector = void 0), types) on(elem, type, selector, data, types[type], one);
                return elem
            }
            if (null == data && null == fn ? (fn = selector, data = selector = void 0) : null == fn && ("string" == typeof selector ? (fn = data, data = void 0) : (fn = data, data = selector, selector = void 0)), !1 === fn) fn = returnFalse;
            else if (!fn) return elem;
            return 1 === one && (origFn = fn, (fn = function(event) {
                return jQuery().off(event), origFn.apply(this, arguments)
            }).guid = origFn.guid || (origFn.guid = jQuery.guid++)), elem.each((function() {
                jQuery.event.add(this, types, fn, data, selector)
            }))
        }

        function leverageNative(el, type, expectSync) {
            expectSync ? (dataPriv.set(el, type, !1), jQuery.event.add(el, type, {
                namespace: !1,
                handler: function(event) {
                    var notAsync, result, saved = dataPriv.get(this, type);
                    if (1 & event.isTrigger && this[type]) {
                        if (saved.length)(jQuery.event.special[type] || {}).delegateType && event.stopPropagation();
                        else if (saved = slice.call(arguments), dataPriv.set(this, type, saved), notAsync = expectSync(this, type), this[type](), saved !== (result = dataPriv.get(this, type)) || notAsync ? dataPriv.set(this, type, !1) : result = {}, saved !== result) return event.stopImmediatePropagation(), event.preventDefault(), result.value
                    } else saved.length && (dataPriv.set(this, type, {
                        value: jQuery.event.trigger(jQuery.extend(saved[0], jQuery.Event.prototype), saved.slice(1), this)
                    }), event.stopImmediatePropagation())
                }
            })) : void 0 === dataPriv.get(el, type) && jQuery.event.add(el, type, returnTrue)
        }
        jQuery.event = {
            global: {},
            add: function(elem, types, handler, data, selector) {
                var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
                if (acceptData(elem))
                    for (handler.handler && (handler = (handleObjIn = handler).handler, selector = handleObjIn.selector), selector && jQuery.find.matchesSelector(documentElement, selector), handler.guid || (handler.guid = jQuery.guid++), (events = elemData.events) || (events = elemData.events = Object.create(null)), (eventHandle = elemData.handle) || (eventHandle = elemData.handle = function(e) {
                            return void 0 !== jQuery && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : void 0
                        }), t = (types = (types || "").match(rnothtmlwhite) || [""]).length; t--;) type = origType = (tmp = rtypenamespace.exec(types[t]) || [])[1], namespaces = (tmp[2] || "").split(".").sort(), type && (special = jQuery.event.special[type] || {}, type = (selector ? special.delegateType : special.bindType) || type, special = jQuery.event.special[type] || {}, handleObj = jQuery.extend({
                        type: type,
                        origType: origType,
                        data: data,
                        handler: handler,
                        guid: handler.guid,
                        selector: selector,
                        needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                        namespace: namespaces.join(".")
                    }, handleObjIn), (handlers = events[type]) || ((handlers = events[type] = []).delegateCount = 0, special.setup && !1 !== special.setup.call(elem, data, namespaces, eventHandle) || elem.addEventListener && elem.addEventListener(type, eventHandle)), special.add && (special.add.call(elem, handleObj), handleObj.handler.guid || (handleObj.handler.guid = handler.guid)), selector ? handlers.splice(handlers.delegateCount++, 0, handleObj) : handlers.push(handleObj), jQuery.event.global[type] = !0)
            },
            remove: function(elem, types, handler, selector, mappedTypes) {
                var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
                if (elemData && (events = elemData.events)) {
                    for (t = (types = (types || "").match(rnothtmlwhite) || [""]).length; t--;)
                        if (type = origType = (tmp = rtypenamespace.exec(types[t]) || [])[1], namespaces = (tmp[2] || "").split(".").sort(), type) {
                            for (special = jQuery.event.special[type] || {}, handlers = events[type = (selector ? special.delegateType : special.bindType) || type] || [], tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)"), origCount = j = handlers.length; j--;) handleObj = handlers[j], !mappedTypes && origType !== handleObj.origType || handler && handler.guid !== handleObj.guid || tmp && !tmp.test(handleObj.namespace) || selector && selector !== handleObj.selector && ("**" !== selector || !handleObj.selector) || (handlers.splice(j, 1), handleObj.selector && handlers.delegateCount--, special.remove && special.remove.call(elem, handleObj));
                            origCount && !handlers.length && (special.teardown && !1 !== special.teardown.call(elem, namespaces, elemData.handle) || jQuery.removeEvent(elem, type, elemData.handle), delete events[type])
                        } else
                            for (type in events) jQuery.event.remove(elem, type + types[t], handler, selector, !0);
                    jQuery.isEmptyObject(events) && dataPriv.remove(elem, "handle events")
                }
            },
            dispatch: function(nativeEvent) {
                var i, j, ret, matched, handleObj, handlerQueue, args = new Array(arguments.length),
                    event = jQuery.event.fix(nativeEvent),
                    handlers = (dataPriv.get(this, "events") || Object.create(null))[event.type] || [],
                    special = jQuery.event.special[event.type] || {};
                for (args[0] = event, i = 1; i < arguments.length; i++) args[i] = arguments[i];
                if (event.delegateTarget = this, !special.preDispatch || !1 !== special.preDispatch.call(this, event)) {
                    for (handlerQueue = jQuery.event.handlers.call(this, event, handlers), i = 0;
                        (matched = handlerQueue[i++]) && !event.isPropagationStopped();)
                        for (event.currentTarget = matched.elem, j = 0;
                            (handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped();) event.rnamespace && !1 !== handleObj.namespace && !event.rnamespace.test(handleObj.namespace) || (event.handleObj = handleObj, event.data = handleObj.data, void 0 !== (ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args)) && !1 === (event.result = ret) && (event.preventDefault(), event.stopPropagation()));
                    return special.postDispatch && special.postDispatch.call(this, event), event.result
                }
            },
            handlers: function(event, handlers) {
                var i, handleObj, sel, matchedHandlers, matchedSelectors, handlerQueue = [],
                    delegateCount = handlers.delegateCount,
                    cur = event.target;
                if (delegateCount && cur.nodeType && !("click" === event.type && event.button >= 1))
                    for (; cur !== this; cur = cur.parentNode || this)
                        if (1 === cur.nodeType && ("click" !== event.type || !0 !== cur.disabled)) {
                            for (matchedHandlers = [], matchedSelectors = {}, i = 0; i < delegateCount; i++) void 0 === matchedSelectors[sel = (handleObj = handlers[i]).selector + " "] && (matchedSelectors[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length), matchedSelectors[sel] && matchedHandlers.push(handleObj);
                            matchedHandlers.length && handlerQueue.push({
                                elem: cur,
                                handlers: matchedHandlers
                            })
                        }
                return cur = this, delegateCount < handlers.length && handlerQueue.push({
                    elem: cur,
                    handlers: handlers.slice(delegateCount)
                }), handlerQueue
            },
            addProp: function(name, hook) {
                Object.defineProperty(jQuery.Event.prototype, name, {
                    enumerable: !0,
                    configurable: !0,
                    get: isFunction(hook) ? function() {
                        if (this.originalEvent) return hook(this.originalEvent)
                    } : function() {
                        if (this.originalEvent) return this.originalEvent[name]
                    },
                    set: function(value) {
                        Object.defineProperty(this, name, {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: value
                        })
                    }
                })
            },
            fix: function(originalEvent) {
                return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent)
            },
            special: {
                load: {
                    noBubble: !0
                },
                click: {
                    setup: function(data) {
                        var el = this || data;
                        return rcheckableType.test(el.type) && el.click && nodeName(el, "input") && leverageNative(el, "click", returnTrue), !1
                    },
                    trigger: function(data) {
                        var el = this || data;
                        return rcheckableType.test(el.type) && el.click && nodeName(el, "input") && leverageNative(el, "click"), !0
                    },
                    _default: function(event) {
                        var target = event.target;
                        return rcheckableType.test(target.type) && target.click && nodeName(target, "input") && dataPriv.get(target, "click") || nodeName(target, "a")
                    }
                },
                beforeunload: {
                    postDispatch: function(event) {
                        void 0 !== event.result && event.originalEvent && (event.originalEvent.returnValue = event.result)
                    }
                }
            }
        }, jQuery.removeEvent = function(elem, type, handle) {
            elem.removeEventListener && elem.removeEventListener(type, handle)
        }, jQuery.Event = function(src, props) {
            if (!(this instanceof jQuery.Event)) return new jQuery.Event(src, props);
            src && src.type ? (this.originalEvent = src, this.type = src.type, this.isDefaultPrevented = src.defaultPrevented || void 0 === src.defaultPrevented && !1 === src.returnValue ? returnTrue : returnFalse, this.target = src.target && 3 === src.target.nodeType ? src.target.parentNode : src.target, this.currentTarget = src.currentTarget, this.relatedTarget = src.relatedTarget) : this.type = src, props && jQuery.extend(this, props), this.timeStamp = src && src.timeStamp || Date.now(), this[jQuery.expando] = !0
        }, jQuery.Event.prototype = {
            constructor: jQuery.Event,
            isDefaultPrevented: returnFalse,
            isPropagationStopped: returnFalse,
            isImmediatePropagationStopped: returnFalse,
            isSimulated: !1,
            preventDefault: function() {
                var e = this.originalEvent;
                this.isDefaultPrevented = returnTrue, e && !this.isSimulated && e.preventDefault()
            },
            stopPropagation: function() {
                var e = this.originalEvent;
                this.isPropagationStopped = returnTrue, e && !this.isSimulated && e.stopPropagation()
            },
            stopImmediatePropagation: function() {
                var e = this.originalEvent;
                this.isImmediatePropagationStopped = returnTrue, e && !this.isSimulated && e.stopImmediatePropagation(), this.stopPropagation()
            }
        }, jQuery.each({
            altKey: !0,
            bubbles: !0,
            cancelable: !0,
            changedTouches: !0,
            ctrlKey: !0,
            detail: !0,
            eventPhase: !0,
            metaKey: !0,
            pageX: !0,
            pageY: !0,
            shiftKey: !0,
            view: !0,
            char: !0,
            code: !0,
            charCode: !0,
            key: !0,
            keyCode: !0,
            button: !0,
            buttons: !0,
            clientX: !0,
            clientY: !0,
            offsetX: !0,
            offsetY: !0,
            pointerId: !0,
            pointerType: !0,
            screenX: !0,
            screenY: !0,
            targetTouches: !0,
            toElement: !0,
            touches: !0,
            which: function(event) {
                var button = event.button;
                return null == event.which && rkeyEvent.test(event.type) ? null != event.charCode ? event.charCode : event.keyCode : !event.which && void 0 !== button && rmouseEvent.test(event.type) ? 1 & button ? 1 : 2 & button ? 3 : 4 & button ? 2 : 0 : event.which
            }
        }, jQuery.event.addProp), jQuery.each({
            focus: "focusin",
            blur: "focusout"
        }, (function(type, delegateType) {
            jQuery.event.special[type] = {
                setup: function() {
                    return leverageNative(this, type, expectSync), !1
                },
                trigger: function() {
                    return leverageNative(this, type), !0
                },
                delegateType: delegateType
            }
        })), jQuery.each({
            mouseenter: "mouseover",
            mouseleave: "mouseout",
            pointerenter: "pointerover",
            pointerleave: "pointerout"
        }, (function(orig, fix) {
            jQuery.event.special[orig] = {
                delegateType: fix,
                bindType: fix,
                handle: function(event) {
                    var ret, target = this,
                        related = event.relatedTarget,
                        handleObj = event.handleObj;
                    return related && (related === target || jQuery.contains(target, related)) || (event.type = handleObj.origType, ret = handleObj.handler.apply(this, arguments), event.type = fix), ret
                }
            }
        })), jQuery.fn.extend({
            on: function(types, selector, data, fn) {
                return on(this, types, selector, data, fn)
            },
            one: function(types, selector, data, fn) {
                return on(this, types, selector, data, fn, 1)
            },
            off: function(types, selector, fn) {
                var handleObj, type;
                if (types && types.preventDefault && types.handleObj) return handleObj = types.handleObj, jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler), this;
                if ("object" == typeof types) {
                    for (type in types) this.off(type, selector, types[type]);
                    return this
                }
                return !1 !== selector && "function" != typeof selector || (fn = selector, selector = void 0), !1 === fn && (fn = returnFalse), this.each((function() {
                    jQuery.event.remove(this, types, fn, selector)
                }))
            }
        });
        var rnoInnerhtml = /<script|<style|<link/i,
            rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
            rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

        function manipulationTarget(elem, content) {
            return nodeName(elem, "table") && nodeName(11 !== content.nodeType ? content : content.firstChild, "tr") && jQuery(elem).children("tbody")[0] || elem
        }

        function disableScript(elem) {
            return elem.type = (null !== elem.getAttribute("type")) + "/" + elem.type, elem
        }

        function restoreScript(elem) {
            return "true/" === (elem.type || "").slice(0, 5) ? elem.type = elem.type.slice(5) : elem.removeAttribute("type"), elem
        }

        function cloneCopyEvent(src, dest) {
            var i, l, type, udataOld, udataCur, events;
            if (1 === dest.nodeType) {
                if (dataPriv.hasData(src) && (events = dataPriv.get(src).events))
                    for (type in dataPriv.remove(dest, "handle events"), events)
                        for (i = 0, l = events[type].length; i < l; i++) jQuery.event.add(dest, type, events[type][i]);
                dataUser.hasData(src) && (udataOld = dataUser.access(src), udataCur = jQuery.extend({}, udataOld), dataUser.set(dest, udataCur))
            }
        }

        function fixInput(src, dest) {
            var nodeName = dest.nodeName.toLowerCase();
            "input" === nodeName && rcheckableType.test(src.type) ? dest.checked = src.checked : "input" !== nodeName && "textarea" !== nodeName || (dest.defaultValue = src.defaultValue)
        }

        function domManip(collection, args, callback, ignored) {
            args = flat(args);
            var fragment, first, scripts, hasScripts, node, doc, i = 0,
                l = collection.length,
                iNoClone = l - 1,
                value = args[0],
                valueIsFunction = isFunction(value);
            if (valueIsFunction || l > 1 && "string" == typeof value && !support.checkClone && rchecked.test(value)) return collection.each((function(index) {
                var self = collection.eq(index);
                valueIsFunction && (args[0] = value.call(this, index, self.html())), domManip(self, args, callback, ignored)
            }));
            if (l && (first = (fragment = buildFragment(args, collection[0].ownerDocument, !1, collection, ignored)).firstChild, 1 === fragment.childNodes.length && (fragment = first), first || ignored)) {
                for (hasScripts = (scripts = jQuery.map(getAll(fragment, "script"), disableScript)).length; i < l; i++) node = fragment, i !== iNoClone && (node = jQuery.clone(node, !0, !0), hasScripts && jQuery.merge(scripts, getAll(node, "script"))), callback.call(collection[i], node, i);
                if (hasScripts)
                    for (doc = scripts[scripts.length - 1].ownerDocument, jQuery.map(scripts, restoreScript), i = 0; i < hasScripts; i++) node = scripts[i], rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node) && (node.src && "module" !== (node.type || "").toLowerCase() ? jQuery._evalUrl && !node.noModule && jQuery._evalUrl(node.src, {
                        nonce: node.nonce || node.getAttribute("nonce")
                    }, doc) : DOMEval(node.textContent.replace(rcleanScript, ""), node, doc))
            }
            return collection
        }

        function remove(elem, selector, keepData) {
            for (var node, nodes = selector ? jQuery.filter(selector, elem) : elem, i = 0; null != (node = nodes[i]); i++) keepData || 1 !== node.nodeType || jQuery.cleanData(getAll(node)), node.parentNode && (keepData && isAttached(node) && setGlobalEval(getAll(node, "script")), node.parentNode.removeChild(node));
            return elem
        }
        jQuery.extend({
            htmlPrefilter: function(html) {
                return html
            },
            clone: function(elem, dataAndEvents, deepDataAndEvents) {
                var i, l, srcElements, destElements, clone = elem.cloneNode(!0),
                    inPage = isAttached(elem);
                if (!(support.noCloneChecked || 1 !== elem.nodeType && 11 !== elem.nodeType || jQuery.isXMLDoc(elem)))
                    for (destElements = getAll(clone), i = 0, l = (srcElements = getAll(elem)).length; i < l; i++) fixInput(srcElements[i], destElements[i]);
                if (dataAndEvents)
                    if (deepDataAndEvents)
                        for (srcElements = srcElements || getAll(elem), destElements = destElements || getAll(clone), i = 0, l = srcElements.length; i < l; i++) cloneCopyEvent(srcElements[i], destElements[i]);
                    else cloneCopyEvent(elem, clone);
                return (destElements = getAll(clone, "script")).length > 0 && setGlobalEval(destElements, !inPage && getAll(elem, "script")), clone
            },
            cleanData: function(elems) {
                for (var data, elem, type, special = jQuery.event.special, i = 0; void 0 !== (elem = elems[i]); i++)
                    if (acceptData(elem)) {
                        if (data = elem[dataPriv.expando]) {
                            if (data.events)
                                for (type in data.events) special[type] ? jQuery.event.remove(elem, type) : jQuery.removeEvent(elem, type, data.handle);
                            elem[dataPriv.expando] = void 0
                        }
                        elem[dataUser.expando] && (elem[dataUser.expando] = void 0)
                    }
            }
        }), jQuery.fn.extend({
            detach: function(selector) {
                return remove(this, selector, !0)
            },
            remove: function(selector) {
                return remove(this, selector)
            },
            text: function(value) {
                return access(this, (function(value) {
                    return void 0 === value ? jQuery.text(this) : this.empty().each((function() {
                        1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || (this.textContent = value)
                    }))
                }), null, value, arguments.length)
            },
            append: function() {
                return domManip(this, arguments, (function(elem) {
                    1 !== this.nodeType && 11 !== this.nodeType && 9 !== this.nodeType || manipulationTarget(this, elem).appendChild(elem)
                }))
            },
            prepend: function() {
                return domManip(this, arguments, (function(elem) {
                    if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                        var target = manipulationTarget(this, elem);
                        target.insertBefore(elem, target.firstChild)
                    }
                }))
            },
            before: function() {
                return domManip(this, arguments, (function(elem) {
                    this.parentNode && this.parentNode.insertBefore(elem, this)
                }))
            },
            after: function() {
                return domManip(this, arguments, (function(elem) {
                    this.parentNode && this.parentNode.insertBefore(elem, this.nextSibling)
                }))
            },
            empty: function() {
                for (var elem, i = 0; null != (elem = this[i]); i++) 1 === elem.nodeType && (jQuery.cleanData(getAll(elem, !1)), elem.textContent = "");
                return this
            },
            clone: function(dataAndEvents, deepDataAndEvents) {
                return dataAndEvents = null != dataAndEvents && dataAndEvents, deepDataAndEvents = null == deepDataAndEvents ? dataAndEvents : deepDataAndEvents, this.map((function() {
                    return jQuery.clone(this, dataAndEvents, deepDataAndEvents)
                }))
            },
            html: function(value) {
                return access(this, (function(value) {
                    var elem = this[0] || {},
                        i = 0,
                        l = this.length;
                    if (void 0 === value && 1 === elem.nodeType) return elem.innerHTML;
                    if ("string" == typeof value && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
                        value = jQuery.htmlPrefilter(value);
                        try {
                            for (; i < l; i++) 1 === (elem = this[i] || {}).nodeType && (jQuery.cleanData(getAll(elem, !1)), elem.innerHTML = value);
                            elem = 0
                        } catch (e) {}
                    }
                    elem && this.empty().append(value)
                }), null, value, arguments.length)
            },
            replaceWith: function() {
                var ignored = [];
                return domManip(this, arguments, (function(elem) {
                    var parent = this.parentNode;
                    jQuery.inArray(this, ignored) < 0 && (jQuery.cleanData(getAll(this)), parent && parent.replaceChild(elem, this))
                }), ignored)
            }
        }), jQuery.each({
            appendTo: "append",
            prependTo: "prepend",
            insertBefore: "before",
            insertAfter: "after",
            replaceAll: "replaceWith"
        }, (function(name, original) {
            jQuery.fn[name] = function(selector) {
                for (var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0; i <= last; i++) elems = i === last ? this : this.clone(!0), jQuery(insert[i])[original](elems), push.apply(ret, elems.get());
                return this.pushStack(ret)
            }
        }));
        var rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i"),
            getStyles = function(elem) {
                var view = elem.ownerDocument.defaultView;
                return view && view.opener || (view = window), view.getComputedStyle(elem)
            },
            swap = function(elem, options, callback) {
                var ret, name, old = {};
                for (name in options) old[name] = elem.style[name], elem.style[name] = options[name];
                for (name in ret = callback.call(elem), options) elem.style[name] = old[name];
                return ret
            },
            rboxStyle = new RegExp(cssExpand.join("|"), "i");

        function curCSS(elem, name, computed) {
            var width, minWidth, maxWidth, ret, style = elem.style;
            return (computed = computed || getStyles(elem)) && ("" !== (ret = computed.getPropertyValue(name) || computed[name]) || isAttached(elem) || (ret = jQuery.style(elem, name)), !support.pixelBoxStyles() && rnumnonpx.test(ret) && rboxStyle.test(name) && (width = style.width, minWidth = style.minWidth, maxWidth = style.maxWidth, style.minWidth = style.maxWidth = style.width = ret, ret = computed.width, style.width = width, style.minWidth = minWidth, style.maxWidth = maxWidth)), void 0 !== ret ? ret + "" : ret
        }

        function addGetHookIf(conditionFn, hookFn) {
            return {
                get: function() {
                    if (!conditionFn()) return (this.get = hookFn).apply(this, arguments);
                    delete this.get
                }
            }
        }! function() {
            function computeStyleTests() {
                if (div) {
                    container.style.cssText = "position:absolute;left:-11111px;width:60px;margin-top:1px;padding:0;border:0", div.style.cssText = "position:relative;display:block;box-sizing:border-box;overflow:scroll;margin:auto;border:1px;padding:1px;width:60%;top:1%", documentElement.appendChild(container).appendChild(div);
                    var divStyle = window.getComputedStyle(div);
                    pixelPositionVal = "1%" !== divStyle.top, reliableMarginLeftVal = 12 === roundPixelMeasures(divStyle.marginLeft), div.style.right = "60%", pixelBoxStylesVal = 36 === roundPixelMeasures(divStyle.right), boxSizingReliableVal = 36 === roundPixelMeasures(divStyle.width), div.style.position = "absolute", scrollboxSizeVal = 12 === roundPixelMeasures(div.offsetWidth / 3), documentElement.removeChild(container), div = null
                }
            }

            function roundPixelMeasures(measure) {
                return Math.round(parseFloat(measure))
            }
            var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal, reliableTrDimensionsVal, reliableMarginLeftVal, container = document.createElement("div"),
                div = document.createElement("div");
            div.style && (div.style.backgroundClip = "content-box", div.cloneNode(!0).style.backgroundClip = "", support.clearCloneStyle = "content-box" === div.style.backgroundClip, jQuery.extend(support, {
                boxSizingReliable: function() {
                    return computeStyleTests(), boxSizingReliableVal
                },
                pixelBoxStyles: function() {
                    return computeStyleTests(), pixelBoxStylesVal
                },
                pixelPosition: function() {
                    return computeStyleTests(), pixelPositionVal
                },
                reliableMarginLeft: function() {
                    return computeStyleTests(), reliableMarginLeftVal
                },
                scrollboxSize: function() {
                    return computeStyleTests(), scrollboxSizeVal
                },
                reliableTrDimensions: function() {
                    var table, tr, trChild, trStyle;
                    return null == reliableTrDimensionsVal && (table = document.createElement("table"), tr = document.createElement("tr"), trChild = document.createElement("div"), table.style.cssText = "position:absolute;left:-11111px", tr.style.height = "1px", trChild.style.height = "9px", documentElement.appendChild(table).appendChild(tr).appendChild(trChild), trStyle = window.getComputedStyle(tr), reliableTrDimensionsVal = parseInt(trStyle.height) > 3, documentElement.removeChild(table)), reliableTrDimensionsVal
                }
            }))
        }();
        var cssPrefixes = ["Webkit", "Moz", "ms"],
            emptyStyle = document.createElement("div").style,
            vendorProps = {};

        function finalPropName(name) {
            var final = jQuery.cssProps[name] || vendorProps[name];
            return final || (name in emptyStyle ? name : vendorProps[name] = function(name) {
                for (var capName = name[0].toUpperCase() + name.slice(1), i = cssPrefixes.length; i--;)
                    if ((name = cssPrefixes[i] + capName) in emptyStyle) return name
            }(name) || name)
        }
        var rdisplayswap = /^(none|table(?!-c[ea]).+)/,
            rcustomProp = /^--/,
            cssShow = {
                position: "absolute",
                visibility: "hidden",
                display: "block"
            },
            cssNormalTransform = {
                letterSpacing: "0",
                fontWeight: "400"
            };

        function setPositiveNumber(_elem, value, subtract) {
            var matches = rcssNum.exec(value);
            return matches ? Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value
        }

        function boxModelAdjustment(elem, dimension, box, isBorderBox, styles, computedVal) {
            var i = "width" === dimension ? 1 : 0,
                extra = 0,
                delta = 0;
            if (box === (isBorderBox ? "border" : "content")) return 0;
            for (; i < 4; i += 2) "margin" === box && (delta += jQuery.css(elem, box + cssExpand[i], !0, styles)), isBorderBox ? ("content" === box && (delta -= jQuery.css(elem, "padding" + cssExpand[i], !0, styles)), "margin" !== box && (delta -= jQuery.css(elem, "border" + cssExpand[i] + "Width", !0, styles))) : (delta += jQuery.css(elem, "padding" + cssExpand[i], !0, styles), "padding" !== box ? delta += jQuery.css(elem, "border" + cssExpand[i] + "Width", !0, styles) : extra += jQuery.css(elem, "border" + cssExpand[i] + "Width", !0, styles));
            return !isBorderBox && computedVal >= 0 && (delta += Math.max(0, Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - computedVal - delta - extra - .5)) || 0), delta
        }

        function getWidthOrHeight(elem, dimension, extra) {
            var styles = getStyles(elem),
                isBorderBox = (!support.boxSizingReliable() || extra) && "border-box" === jQuery.css(elem, "boxSizing", !1, styles),
                valueIsBorderBox = isBorderBox,
                val = curCSS(elem, dimension, styles),
                offsetProp = "offset" + dimension[0].toUpperCase() + dimension.slice(1);
            if (rnumnonpx.test(val)) {
                if (!extra) return val;
                val = "auto"
            }
            return (!support.boxSizingReliable() && isBorderBox || !support.reliableTrDimensions() && nodeName(elem, "tr") || "auto" === val || !parseFloat(val) && "inline" === jQuery.css(elem, "display", !1, styles)) && elem.getClientRects().length && (isBorderBox = "border-box" === jQuery.css(elem, "boxSizing", !1, styles), (valueIsBorderBox = offsetProp in elem) && (val = elem[offsetProp])), (val = parseFloat(val) || 0) + boxModelAdjustment(elem, dimension, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles, val) + "px"
        }

        function Tween(elem, options, prop, end, easing) {
            return new Tween.prototype.init(elem, options, prop, end, easing)
        }
        jQuery.extend({
            cssHooks: {
                opacity: {
                    get: function(elem, computed) {
                        if (computed) {
                            var ret = curCSS(elem, "opacity");
                            return "" === ret ? "1" : ret
                        }
                    }
                }
            },
            cssNumber: {
                animationIterationCount: !0,
                columnCount: !0,
                fillOpacity: !0,
                flexGrow: !0,
                flexShrink: !0,
                fontWeight: !0,
                gridArea: !0,
                gridColumn: !0,
                gridColumnEnd: !0,
                gridColumnStart: !0,
                gridRow: !0,
                gridRowEnd: !0,
                gridRowStart: !0,
                lineHeight: !0,
                opacity: !0,
                order: !0,
                orphans: !0,
                widows: !0,
                zIndex: !0,
                zoom: !0
            },
            cssProps: {},
            style: function(elem, name, value, extra) {
                if (elem && 3 !== elem.nodeType && 8 !== elem.nodeType && elem.style) {
                    var ret, type, hooks, origName = camelCase(name),
                        isCustomProp = rcustomProp.test(name),
                        style = elem.style;
                    if (isCustomProp || (name = finalPropName(origName)), hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName], void 0 === value) return hooks && "get" in hooks && void 0 !== (ret = hooks.get(elem, !1, extra)) ? ret : style[name];
                    "string" === (type = typeof value) && (ret = rcssNum.exec(value)) && ret[1] && (value = adjustCSS(elem, name, ret), type = "number"), null != value && value == value && ("number" !== type || isCustomProp || (value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px")), support.clearCloneStyle || "" !== value || 0 !== name.indexOf("background") || (style[name] = "inherit"), hooks && "set" in hooks && void 0 === (value = hooks.set(elem, value, extra)) || (isCustomProp ? style.setProperty(name, value) : style[name] = value))
                }
            },
            css: function(elem, name, extra, styles) {
                var val, num, hooks, origName = camelCase(name);
                return rcustomProp.test(name) || (name = finalPropName(origName)), (hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName]) && "get" in hooks && (val = hooks.get(elem, !0, extra)), void 0 === val && (val = curCSS(elem, name, styles)), "normal" === val && name in cssNormalTransform && (val = cssNormalTransform[name]), "" === extra || extra ? (num = parseFloat(val), !0 === extra || isFinite(num) ? num || 0 : val) : val
            }
        }), jQuery.each(["height", "width"], (function(_i, dimension) {
            jQuery.cssHooks[dimension] = {
                get: function(elem, computed, extra) {
                    if (computed) return !rdisplayswap.test(jQuery.css(elem, "display")) || elem.getClientRects().length && elem.getBoundingClientRect().width ? getWidthOrHeight(elem, dimension, extra) : swap(elem, cssShow, (function() {
                        return getWidthOrHeight(elem, dimension, extra)
                    }))
                },
                set: function(elem, value, extra) {
                    var matches, styles = getStyles(elem),
                        scrollboxSizeBuggy = !support.scrollboxSize() && "absolute" === styles.position,
                        isBorderBox = (scrollboxSizeBuggy || extra) && "border-box" === jQuery.css(elem, "boxSizing", !1, styles),
                        subtract = extra ? boxModelAdjustment(elem, dimension, extra, isBorderBox, styles) : 0;
                    return isBorderBox && scrollboxSizeBuggy && (subtract -= Math.ceil(elem["offset" + dimension[0].toUpperCase() + dimension.slice(1)] - parseFloat(styles[dimension]) - boxModelAdjustment(elem, dimension, "border", !1, styles) - .5)), subtract && (matches = rcssNum.exec(value)) && "px" !== (matches[3] || "px") && (elem.style[dimension] = value, value = jQuery.css(elem, dimension)), setPositiveNumber(0, value, subtract)
                }
            }
        })), jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, (function(elem, computed) {
            if (computed) return (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, {
                marginLeft: 0
            }, (function() {
                return elem.getBoundingClientRect().left
            }))) + "px"
        })), jQuery.each({
            margin: "",
            padding: "",
            border: "Width"
        }, (function(prefix, suffix) {
            jQuery.cssHooks[prefix + suffix] = {
                expand: function(value) {
                    for (var i = 0, expanded = {}, parts = "string" == typeof value ? value.split(" ") : [value]; i < 4; i++) expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                    return expanded
                }
            }, "margin" !== prefix && (jQuery.cssHooks[prefix + suffix].set = setPositiveNumber)
        })), jQuery.fn.extend({
            css: function(name, value) {
                return access(this, (function(elem, name, value) {
                    var styles, len, map = {},
                        i = 0;
                    if (Array.isArray(name)) {
                        for (styles = getStyles(elem), len = name.length; i < len; i++) map[name[i]] = jQuery.css(elem, name[i], !1, styles);
                        return map
                    }
                    return void 0 !== value ? jQuery.style(elem, name, value) : jQuery.css(elem, name)
                }), name, value, arguments.length > 1)
            }
        }), jQuery.Tween = Tween, Tween.prototype = {
            constructor: Tween,
            init: function(elem, options, prop, end, easing, unit) {
                this.elem = elem, this.prop = prop, this.easing = easing || jQuery.easing._default, this.options = options, this.start = this.now = this.cur(), this.end = end, this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px")
            },
            cur: function() {
                var hooks = Tween.propHooks[this.prop];
                return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this)
            },
            run: function(percent) {
                var eased, hooks = Tween.propHooks[this.prop];
                return this.options.duration ? this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration) : this.pos = eased = percent, this.now = (this.end - this.start) * eased + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), hooks && hooks.set ? hooks.set(this) : Tween.propHooks._default.set(this), this
            }
        }, Tween.prototype.init.prototype = Tween.prototype, Tween.propHooks = {
            _default: {
                get: function(tween) {
                    var result;
                    return 1 !== tween.elem.nodeType || null != tween.elem[tween.prop] && null == tween.elem.style[tween.prop] ? tween.elem[tween.prop] : (result = jQuery.css(tween.elem, tween.prop, "")) && "auto" !== result ? result : 0
                },
                set: function(tween) {
                    jQuery.fx.step[tween.prop] ? jQuery.fx.step[tween.prop](tween) : 1 !== tween.elem.nodeType || !jQuery.cssHooks[tween.prop] && null == tween.elem.style[finalPropName(tween.prop)] ? tween.elem[tween.prop] = tween.now : jQuery.style(tween.elem, tween.prop, tween.now + tween.unit)
                }
            }
        }, Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
            set: function(tween) {
                tween.elem.nodeType && tween.elem.parentNode && (tween.elem[tween.prop] = tween.now)
            }
        }, jQuery.easing = {
            linear: function(p) {
                return p
            },
            swing: function(p) {
                return .5 - Math.cos(p * Math.PI) / 2
            },
            _default: "swing"
        }, jQuery.fx = Tween.prototype.init, jQuery.fx.step = {};
        var fxNow, inProgress, rfxtypes = /^(?:toggle|show|hide)$/,
            rrun = /queueHooks$/;

        function schedule() {
            inProgress && (!1 === document.hidden && window.requestAnimationFrame ? window.requestAnimationFrame(schedule) : window.setTimeout(schedule, jQuery.fx.interval), jQuery.fx.tick())
        }

        function createFxNow() {
            return window.setTimeout((function() {
                fxNow = void 0
            })), fxNow = Date.now()
        }

        function genFx(type, includeWidth) {
            var which, i = 0,
                attrs = {
                    height: type
                };
            for (includeWidth = includeWidth ? 1 : 0; i < 4; i += 2 - includeWidth) attrs["margin" + (which = cssExpand[i])] = attrs["padding" + which] = type;
            return includeWidth && (attrs.opacity = attrs.width = type), attrs
        }

        function createTween(value, prop, animation) {
            for (var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]), index = 0, length = collection.length; index < length; index++)
                if (tween = collection[index].call(animation, prop, value)) return tween
        }

        function Animation(elem, properties, options) {
            var result, stopped, index = 0,
                length = Animation.prefilters.length,
                deferred = jQuery.Deferred().always((function() {
                    delete tick.elem
                })),
                tick = function() {
                    if (stopped) return !1;
                    for (var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), percent = 1 - (remaining / animation.duration || 0), index = 0, length = animation.tweens.length; index < length; index++) animation.tweens[index].run(percent);
                    return deferred.notifyWith(elem, [animation, percent, remaining]), percent < 1 && length ? remaining : (length || deferred.notifyWith(elem, [animation, 1, 0]), deferred.resolveWith(elem, [animation]), !1)
                },
                animation = deferred.promise({
                    elem: elem,
                    props: jQuery.extend({}, properties),
                    opts: jQuery.extend(!0, {
                        specialEasing: {},
                        easing: jQuery.easing._default
                    }, options),
                    originalProperties: properties,
                    originalOptions: options,
                    startTime: fxNow || createFxNow(),
                    duration: options.duration,
                    tweens: [],
                    createTween: function(prop, end) {
                        var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                        return animation.tweens.push(tween), tween
                    },
                    stop: function(gotoEnd) {
                        var index = 0,
                            length = gotoEnd ? animation.tweens.length : 0;
                        if (stopped) return this;
                        for (stopped = !0; index < length; index++) animation.tweens[index].run(1);
                        return gotoEnd ? (deferred.notifyWith(elem, [animation, 1, 0]), deferred.resolveWith(elem, [animation, gotoEnd])) : deferred.rejectWith(elem, [animation, gotoEnd]), this
                    }
                }),
                props = animation.props;
            for (! function(props, specialEasing) {
                    var index, name, easing, value, hooks;
                    for (index in props)
                        if (easing = specialEasing[name = camelCase(index)], value = props[index], Array.isArray(value) && (easing = value[1], value = props[index] = value[0]), index !== name && (props[name] = value, delete props[index]), (hooks = jQuery.cssHooks[name]) && "expand" in hooks)
                            for (index in value = hooks.expand(value), delete props[name], value) index in props || (props[index] = value[index], specialEasing[index] = easing);
                        else specialEasing[name] = easing
                }(props, animation.opts.specialEasing); index < length; index++)
                if (result = Animation.prefilters[index].call(animation, elem, props, animation.opts)) return isFunction(result.stop) && (jQuery._queueHooks(animation.elem, animation.opts.queue).stop = result.stop.bind(result)), result;
            return jQuery.map(props, createTween, animation), isFunction(animation.opts.start) && animation.opts.start.call(elem, animation), animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always), jQuery.fx.timer(jQuery.extend(tick, {
                elem: elem,
                anim: animation,
                queue: animation.opts.queue
            })), animation
        }
        jQuery.Animation = jQuery.extend(Animation, {
                tweeners: {
                    "*": [function(prop, value) {
                        var tween = this.createTween(prop, value);
                        return adjustCSS(tween.elem, prop, rcssNum.exec(value), tween), tween
                    }]
                },
                tweener: function(props, callback) {
                    isFunction(props) ? (callback = props, props = ["*"]) : props = props.match(rnothtmlwhite);
                    for (var prop, index = 0, length = props.length; index < length; index++) prop = props[index], Animation.tweeners[prop] = Animation.tweeners[prop] || [], Animation.tweeners[prop].unshift(callback)
                },
                prefilters: [function(elem, props, opts) {
                    var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display, isBox = "width" in props || "height" in props,
                        anim = this,
                        orig = {},
                        style = elem.style,
                        hidden = elem.nodeType && isHiddenWithinTree(elem),
                        dataShow = dataPriv.get(elem, "fxshow");
                    for (prop in opts.queue || (null == (hooks = jQuery._queueHooks(elem, "fx")).unqueued && (hooks.unqueued = 0, oldfire = hooks.empty.fire, hooks.empty.fire = function() {
                            hooks.unqueued || oldfire()
                        }), hooks.unqueued++, anim.always((function() {
                            anim.always((function() {
                                hooks.unqueued--, jQuery.queue(elem, "fx").length || hooks.empty.fire()
                            }))
                        }))), props)
                        if (value = props[prop], rfxtypes.test(value)) {
                            if (delete props[prop], toggle = toggle || "toggle" === value, value === (hidden ? "hide" : "show")) {
                                if ("show" !== value || !dataShow || void 0 === dataShow[prop]) continue;
                                hidden = !0
                            }
                            orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop)
                        }
                    if ((propTween = !jQuery.isEmptyObject(props)) || !jQuery.isEmptyObject(orig))
                        for (prop in isBox && 1 === elem.nodeType && (opts.overflow = [style.overflow, style.overflowX, style.overflowY], null == (restoreDisplay = dataShow && dataShow.display) && (restoreDisplay = dataPriv.get(elem, "display")), "none" === (display = jQuery.css(elem, "display")) && (restoreDisplay ? display = restoreDisplay : (showHide([elem], !0), restoreDisplay = elem.style.display || restoreDisplay, display = jQuery.css(elem, "display"), showHide([elem]))), ("inline" === display || "inline-block" === display && null != restoreDisplay) && "none" === jQuery.css(elem, "float") && (propTween || (anim.done((function() {
                                style.display = restoreDisplay
                            })), null == restoreDisplay && (display = style.display, restoreDisplay = "none" === display ? "" : display)), style.display = "inline-block")), opts.overflow && (style.overflow = "hidden", anim.always((function() {
                                style.overflow = opts.overflow[0], style.overflowX = opts.overflow[1], style.overflowY = opts.overflow[2]
                            }))), propTween = !1, orig) propTween || (dataShow ? "hidden" in dataShow && (hidden = dataShow.hidden) : dataShow = dataPriv.access(elem, "fxshow", {
                            display: restoreDisplay
                        }), toggle && (dataShow.hidden = !hidden), hidden && showHide([elem], !0), anim.done((function() {
                            for (prop in hidden || showHide([elem]), dataPriv.remove(elem, "fxshow"), orig) jQuery.style(elem, prop, orig[prop])
                        }))), propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim), prop in dataShow || (dataShow[prop] = propTween.start, hidden && (propTween.end = propTween.start, propTween.start = 0))
                }],
                prefilter: function(callback, prepend) {
                    prepend ? Animation.prefilters.unshift(callback) : Animation.prefilters.push(callback)
                }
            }), jQuery.speed = function(speed, easing, fn) {
                var opt = speed && "object" == typeof speed ? jQuery.extend({}, speed) : {
                    complete: fn || !fn && easing || isFunction(speed) && speed,
                    duration: speed,
                    easing: fn && easing || easing && !isFunction(easing) && easing
                };
                return jQuery.fx.off ? opt.duration = 0 : "number" != typeof opt.duration && (opt.duration in jQuery.fx.speeds ? opt.duration = jQuery.fx.speeds[opt.duration] : opt.duration = jQuery.fx.speeds._default), null != opt.queue && !0 !== opt.queue || (opt.queue = "fx"), opt.old = opt.complete, opt.complete = function() {
                    isFunction(opt.old) && opt.old.call(this), opt.queue && jQuery.dequeue(this, opt.queue)
                }, opt
            }, jQuery.fn.extend({
                fadeTo: function(speed, to, easing, callback) {
                    return this.filter(isHiddenWithinTree).css("opacity", 0).show().end().animate({
                        opacity: to
                    }, speed, easing, callback)
                },
                animate: function(prop, speed, easing, callback) {
                    var empty = jQuery.isEmptyObject(prop),
                        optall = jQuery.speed(speed, easing, callback),
                        doAnimation = function() {
                            var anim = Animation(this, jQuery.extend({}, prop), optall);
                            (empty || dataPriv.get(this, "finish")) && anim.stop(!0)
                        };
                    return doAnimation.finish = doAnimation, empty || !1 === optall.queue ? this.each(doAnimation) : this.queue(optall.queue, doAnimation)
                },
                stop: function(type, clearQueue, gotoEnd) {
                    var stopQueue = function(hooks) {
                        var stop = hooks.stop;
                        delete hooks.stop, stop(gotoEnd)
                    };
                    return "string" != typeof type && (gotoEnd = clearQueue, clearQueue = type, type = void 0), clearQueue && this.queue(type || "fx", []), this.each((function() {
                        var dequeue = !0,
                            index = null != type && type + "queueHooks",
                            timers = jQuery.timers,
                            data = dataPriv.get(this);
                        if (index) data[index] && data[index].stop && stopQueue(data[index]);
                        else
                            for (index in data) data[index] && data[index].stop && rrun.test(index) && stopQueue(data[index]);
                        for (index = timers.length; index--;) timers[index].elem !== this || null != type && timers[index].queue !== type || (timers[index].anim.stop(gotoEnd), dequeue = !1, timers.splice(index, 1));
                        !dequeue && gotoEnd || jQuery.dequeue(this, type)
                    }))
                },
                finish: function(type) {
                    return !1 !== type && (type = type || "fx"), this.each((function() {
                        var index, data = dataPriv.get(this),
                            queue = data[type + "queue"],
                            hooks = data[type + "queueHooks"],
                            timers = jQuery.timers,
                            length = queue ? queue.length : 0;
                        for (data.finish = !0, jQuery.queue(this, type, []), hooks && hooks.stop && hooks.stop.call(this, !0), index = timers.length; index--;) timers[index].elem === this && timers[index].queue === type && (timers[index].anim.stop(!0), timers.splice(index, 1));
                        for (index = 0; index < length; index++) queue[index] && queue[index].finish && queue[index].finish.call(this);
                        delete data.finish
                    }))
                }
            }), jQuery.each(["toggle", "show", "hide"], (function(_i, name) {
                var cssFn = jQuery.fn[name];
                jQuery.fn[name] = function(speed, easing, callback) {
                    return null == speed || "boolean" == typeof speed ? cssFn.apply(this, arguments) : this.animate(genFx(name, !0), speed, easing, callback)
                }
            })), jQuery.each({
                slideDown: genFx("show"),
                slideUp: genFx("hide"),
                slideToggle: genFx("toggle"),
                fadeIn: {
                    opacity: "show"
                },
                fadeOut: {
                    opacity: "hide"
                },
                fadeToggle: {
                    opacity: "toggle"
                }
            }, (function(name, props) {
                jQuery.fn[name] = function(speed, easing, callback) {
                    return this.animate(props, speed, easing, callback)
                }
            })), jQuery.timers = [], jQuery.fx.tick = function() {
                var timer, i = 0,
                    timers = jQuery.timers;
                for (fxNow = Date.now(); i < timers.length; i++)(timer = timers[i])() || timers[i] !== timer || timers.splice(i--, 1);
                timers.length || jQuery.fx.stop(), fxNow = void 0
            }, jQuery.fx.timer = function(timer) {
                jQuery.timers.push(timer), jQuery.fx.start()
            }, jQuery.fx.interval = 13, jQuery.fx.start = function() {
                inProgress || (inProgress = !0, schedule())
            }, jQuery.fx.stop = function() {
                inProgress = null
            }, jQuery.fx.speeds = {
                slow: 600,
                fast: 200,
                _default: 400
            }, jQuery.fn.delay = function(time, type) {
                return time = jQuery.fx && jQuery.fx.speeds[time] || time, type = type || "fx", this.queue(type, (function(next, hooks) {
                    var timeout = window.setTimeout(next, time);
                    hooks.stop = function() {
                        window.clearTimeout(timeout)
                    }
                }))
            },
            function() {
                var input = document.createElement("input"),
                    opt = document.createElement("select").appendChild(document.createElement("option"));
                input.type = "checkbox", support.checkOn = "" !== input.value, support.optSelected = opt.selected, (input = document.createElement("input")).value = "t", input.type = "radio", support.radioValue = "t" === input.value
            }();
        var boolHook, attrHandle = jQuery.expr.attrHandle;
        jQuery.fn.extend({
            attr: function(name, value) {
                return access(this, jQuery.attr, name, value, arguments.length > 1)
            },
            removeAttr: function(name) {
                return this.each((function() {
                    jQuery.removeAttr(this, name)
                }))
            }
        }), jQuery.extend({
            attr: function(elem, name, value) {
                var ret, hooks, nType = elem.nodeType;
                if (3 !== nType && 8 !== nType && 2 !== nType) return void 0 === elem.getAttribute ? jQuery.prop(elem, name, value) : (1 === nType && jQuery.isXMLDoc(elem) || (hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : void 0)), void 0 !== value ? null === value ? void jQuery.removeAttr(elem, name) : hooks && "set" in hooks && void 0 !== (ret = hooks.set(elem, value, name)) ? ret : (elem.setAttribute(name, value + ""), value) : hooks && "get" in hooks && null !== (ret = hooks.get(elem, name)) ? ret : null == (ret = jQuery.find.attr(elem, name)) ? void 0 : ret)
            },
            attrHooks: {
                type: {
                    set: function(elem, value) {
                        if (!support.radioValue && "radio" === value && nodeName(elem, "input")) {
                            var val = elem.value;
                            return elem.setAttribute("type", value), val && (elem.value = val), value
                        }
                    }
                }
            },
            removeAttr: function(elem, value) {
                var name, i = 0,
                    attrNames = value && value.match(rnothtmlwhite);
                if (attrNames && 1 === elem.nodeType)
                    for (; name = attrNames[i++];) elem.removeAttribute(name)
            }
        }), boolHook = {
            set: function(elem, value, name) {
                return !1 === value ? jQuery.removeAttr(elem, name) : elem.setAttribute(name, name), name
            }
        }, jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), (function(_i, name) {
            var getter = attrHandle[name] || jQuery.find.attr;
            attrHandle[name] = function(elem, name, isXML) {
                var ret, handle, lowercaseName = name.toLowerCase();
                return isXML || (handle = attrHandle[lowercaseName], attrHandle[lowercaseName] = ret, ret = null != getter(elem, name, isXML) ? lowercaseName : null, attrHandle[lowercaseName] = handle), ret
            }
        }));
        var rfocusable = /^(?:input|select|textarea|button)$/i,
            rclickable = /^(?:a|area)$/i;

        function stripAndCollapse(value) {
            return (value.match(rnothtmlwhite) || []).join(" ")
        }

        function getClass(elem) {
            return elem.getAttribute && elem.getAttribute("class") || ""
        }

        function classesToArray(value) {
            return Array.isArray(value) ? value : "string" == typeof value && value.match(rnothtmlwhite) || []
        }
        jQuery.fn.extend({
            prop: function(name, value) {
                return access(this, jQuery.prop, name, value, arguments.length > 1)
            },
            removeProp: function(name) {
                return this.each((function() {
                    delete this[jQuery.propFix[name] || name]
                }))
            }
        }), jQuery.extend({
            prop: function(elem, name, value) {
                var ret, hooks, nType = elem.nodeType;
                if (3 !== nType && 8 !== nType && 2 !== nType) return 1 === nType && jQuery.isXMLDoc(elem) || (name = jQuery.propFix[name] || name, hooks = jQuery.propHooks[name]), void 0 !== value ? hooks && "set" in hooks && void 0 !== (ret = hooks.set(elem, value, name)) ? ret : elem[name] = value : hooks && "get" in hooks && null !== (ret = hooks.get(elem, name)) ? ret : elem[name]
            },
            propHooks: {
                tabIndex: {
                    get: function(elem) {
                        var tabindex = jQuery.find.attr(elem, "tabindex");
                        return tabindex ? parseInt(tabindex, 10) : rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ? 0 : -1
                    }
                }
            },
            propFix: {
                for: "htmlFor",
                class: "className"
            }
        }), support.optSelected || (jQuery.propHooks.selected = {
            get: function(elem) {
                var parent = elem.parentNode;
                return parent && parent.parentNode && parent.parentNode.selectedIndex, null
            },
            set: function(elem) {
                var parent = elem.parentNode;
                parent && (parent.selectedIndex, parent.parentNode && parent.parentNode.selectedIndex)
            }
        }), jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], (function() {
            jQuery.propFix[this.toLowerCase()] = this
        })), jQuery.fn.extend({
            addClass: function(value) {
                var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;
                if (isFunction(value)) return this.each((function(j) {
                    jQuery(this).addClass(value.call(this, j, getClass(this)))
                }));
                if ((classes = classesToArray(value)).length)
                    for (; elem = this[i++];)
                        if (curValue = getClass(elem), cur = 1 === elem.nodeType && " " + stripAndCollapse(curValue) + " ") {
                            for (j = 0; clazz = classes[j++];) cur.indexOf(" " + clazz + " ") < 0 && (cur += clazz + " ");
                            curValue !== (finalValue = stripAndCollapse(cur)) && elem.setAttribute("class", finalValue)
                        }
                return this
            },
            removeClass: function(value) {
                var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;
                if (isFunction(value)) return this.each((function(j) {
                    jQuery(this).removeClass(value.call(this, j, getClass(this)))
                }));
                if (!arguments.length) return this.attr("class", "");
                if ((classes = classesToArray(value)).length)
                    for (; elem = this[i++];)
                        if (curValue = getClass(elem), cur = 1 === elem.nodeType && " " + stripAndCollapse(curValue) + " ") {
                            for (j = 0; clazz = classes[j++];)
                                for (; cur.indexOf(" " + clazz + " ") > -1;) cur = cur.replace(" " + clazz + " ", " ");
                            curValue !== (finalValue = stripAndCollapse(cur)) && elem.setAttribute("class", finalValue)
                        }
                return this
            },
            toggleClass: function(value, stateVal) {
                var type = typeof value,
                    isValidValue = "string" === type || Array.isArray(value);
                return "boolean" == typeof stateVal && isValidValue ? stateVal ? this.addClass(value) : this.removeClass(value) : isFunction(value) ? this.each((function(i) {
                    jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal)
                })) : this.each((function() {
                    var className, i, self, classNames;
                    if (isValidValue)
                        for (i = 0, self = jQuery(this), classNames = classesToArray(value); className = classNames[i++];) self.hasClass(className) ? self.removeClass(className) : self.addClass(className);
                    else void 0 !== value && "boolean" !== type || ((className = getClass(this)) && dataPriv.set(this, "__className__", className), this.setAttribute && this.setAttribute("class", className || !1 === value ? "" : dataPriv.get(this, "__className__") || ""))
                }))
            },
            hasClass: function(selector) {
                var className, elem, i = 0;
                for (className = " " + selector + " "; elem = this[i++];)
                    if (1 === elem.nodeType && (" " + stripAndCollapse(getClass(elem)) + " ").indexOf(className) > -1) return !0;
                return !1
            }
        });
        var rreturn = /\r/g;
        jQuery.fn.extend({
            val: function(value) {
                var hooks, ret, valueIsFunction, elem = this[0];
                return arguments.length ? (valueIsFunction = isFunction(value), this.each((function(i) {
                    var val;
                    1 === this.nodeType && (null == (val = valueIsFunction ? value.call(this, i, jQuery(this).val()) : value) ? val = "" : "number" == typeof val ? val += "" : Array.isArray(val) && (val = jQuery.map(val, (function(value) {
                        return null == value ? "" : value + ""
                    }))), (hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()]) && "set" in hooks && void 0 !== hooks.set(this, val, "value") || (this.value = val))
                }))) : elem ? (hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()]) && "get" in hooks && void 0 !== (ret = hooks.get(elem, "value")) ? ret : "string" == typeof(ret = elem.value) ? ret.replace(rreturn, "") : null == ret ? "" : ret : void 0
            }
        }), jQuery.extend({
            valHooks: {
                option: {
                    get: function(elem) {
                        var val = jQuery.find.attr(elem, "value");
                        return null != val ? val : stripAndCollapse(jQuery.text(elem))
                    }
                },
                select: {
                    get: function(elem) {
                        var value, option, i, options = elem.options,
                            index = elem.selectedIndex,
                            one = "select-one" === elem.type,
                            values = one ? null : [],
                            max = one ? index + 1 : options.length;
                        for (i = index < 0 ? max : one ? index : 0; i < max; i++)
                            if (((option = options[i]).selected || i === index) && !option.disabled && (!option.parentNode.disabled || !nodeName(option.parentNode, "optgroup"))) {
                                if (value = jQuery(option).val(), one) return value;
                                values.push(value)
                            }
                        return values
                    },
                    set: function(elem, value) {
                        for (var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length; i--;)((option = options[i]).selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) && (optionSet = !0);
                        return optionSet || (elem.selectedIndex = -1), values
                    }
                }
            }
        }), jQuery.each(["radio", "checkbox"], (function() {
            jQuery.valHooks[this] = {
                set: function(elem, value) {
                    if (Array.isArray(value)) return elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1
                }
            }, support.checkOn || (jQuery.valHooks[this].get = function(elem) {
                return null === elem.getAttribute("value") ? "on" : elem.value
            })
        })), support.focusin = "onfocusin" in window;
        var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
            stopPropagationCallback = function(e) {
                e.stopPropagation()
            };
        jQuery.extend(jQuery.event, {
            trigger: function(event, data, elem, onlyHandlers) {
                var i, cur, tmp, bubbleType, ontype, handle, special, lastElement, eventPath = [elem || document],
                    type = hasOwn.call(event, "type") ? event.type : event,
                    namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
                if (cur = lastElement = tmp = elem = elem || document, 3 !== elem.nodeType && 8 !== elem.nodeType && !rfocusMorph.test(type + jQuery.event.triggered) && (type.indexOf(".") > -1 && (namespaces = type.split("."), type = namespaces.shift(), namespaces.sort()), ontype = type.indexOf(":") < 0 && "on" + type, (event = event[jQuery.expando] ? event : new jQuery.Event(type, "object" == typeof event && event)).isTrigger = onlyHandlers ? 2 : 3, event.namespace = namespaces.join("."), event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, event.result = void 0, event.target || (event.target = elem), data = null == data ? [event] : jQuery.makeArray(data, [event]), special = jQuery.event.special[type] || {}, onlyHandlers || !special.trigger || !1 !== special.trigger.apply(elem, data))) {
                    if (!onlyHandlers && !special.noBubble && !isWindow(elem)) {
                        for (bubbleType = special.delegateType || type, rfocusMorph.test(bubbleType + type) || (cur = cur.parentNode); cur; cur = cur.parentNode) eventPath.push(cur), tmp = cur;
                        tmp === (elem.ownerDocument || document) && eventPath.push(tmp.defaultView || tmp.parentWindow || window)
                    }
                    for (i = 0;
                        (cur = eventPath[i++]) && !event.isPropagationStopped();) lastElement = cur, event.type = i > 1 ? bubbleType : special.bindType || type, (handle = (dataPriv.get(cur, "events") || Object.create(null))[event.type] && dataPriv.get(cur, "handle")) && handle.apply(cur, data), (handle = ontype && cur[ontype]) && handle.apply && acceptData(cur) && (event.result = handle.apply(cur, data), !1 === event.result && event.preventDefault());
                    return event.type = type, onlyHandlers || event.isDefaultPrevented() || special._default && !1 !== special._default.apply(eventPath.pop(), data) || !acceptData(elem) || ontype && isFunction(elem[type]) && !isWindow(elem) && ((tmp = elem[ontype]) && (elem[ontype] = null), jQuery.event.triggered = type, event.isPropagationStopped() && lastElement.addEventListener(type, stopPropagationCallback), elem[type](), event.isPropagationStopped() && lastElement.removeEventListener(type, stopPropagationCallback), jQuery.event.triggered = void 0, tmp && (elem[ontype] = tmp)), event.result
                }
            },
            simulate: function(type, elem, event) {
                var e = jQuery.extend(new jQuery.Event, event, {
                    type: type,
                    isSimulated: !0
                });
                jQuery.event.trigger(e, null, elem)
            }
        }), jQuery.fn.extend({
            trigger: function(type, data) {
                return this.each((function() {
                    jQuery.event.trigger(type, data, this)
                }))
            },
            triggerHandler: function(type, data) {
                var elem = this[0];
                if (elem) return jQuery.event.trigger(type, data, elem, !0)
            }
        }), support.focusin || jQuery.each({
            focus: "focusin",
            blur: "focusout"
        }, (function(orig, fix) {
            var handler = function(event) {
                jQuery.event.simulate(fix, event.target, jQuery.event.fix(event))
            };
            jQuery.event.special[fix] = {
                setup: function() {
                    var doc = this.ownerDocument || this.document || this,
                        attaches = dataPriv.access(doc, fix);
                    attaches || doc.addEventListener(orig, handler, !0), dataPriv.access(doc, fix, (attaches || 0) + 1)
                },
                teardown: function() {
                    var doc = this.ownerDocument || this.document || this,
                        attaches = dataPriv.access(doc, fix) - 1;
                    attaches ? dataPriv.access(doc, fix, attaches) : (doc.removeEventListener(orig, handler, !0), dataPriv.remove(doc, fix))
                }
            }
        }));
        var location = window.location,
            nonce = {
                guid: Date.now()
            },
            rquery = /\?/;
        jQuery.parseXML = function(data) {
            var xml;
            if (!data || "string" != typeof data) return null;
            try {
                xml = (new window.DOMParser).parseFromString(data, "text/xml")
            } catch (e) {
                xml = void 0
            }
            return xml && !xml.getElementsByTagName("parsererror").length || jQuery.error("Invalid XML: " + data), xml
        };
        var rbracket = /\[\]$/,
            rCRLF = /\r?\n/g,
            rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
            rsubmittable = /^(?:input|select|textarea|keygen)/i;

        function buildParams(prefix, obj, traditional, add) {
            var name;
            if (Array.isArray(obj)) jQuery.each(obj, (function(i, v) {
                traditional || rbracket.test(prefix) ? add(prefix, v) : buildParams(prefix + "[" + ("object" == typeof v && null != v ? i : "") + "]", v, traditional, add)
            }));
            else if (traditional || "object" !== toType(obj)) add(prefix, obj);
            else
                for (name in obj) buildParams(prefix + "[" + name + "]", obj[name], traditional, add)
        }
        jQuery.param = function(a, traditional) {
            var prefix, s = [],
                add = function(key, valueOrFunction) {
                    var value = isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
                    s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(null == value ? "" : value)
                };
            if (null == a) return "";
            if (Array.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) jQuery.each(a, (function() {
                add(this.name, this.value)
            }));
            else
                for (prefix in a) buildParams(prefix, a[prefix], traditional, add);
            return s.join("&")
        }, jQuery.fn.extend({
            serialize: function() {
                return jQuery.param(this.serializeArray())
            },
            serializeArray: function() {
                return this.map((function() {
                    var elements = jQuery.prop(this, "elements");
                    return elements ? jQuery.makeArray(elements) : this
                })).filter((function() {
                    var type = this.type;
                    return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type))
                })).map((function(_i, elem) {
                    var val = jQuery(this).val();
                    return null == val ? null : Array.isArray(val) ? jQuery.map(val, (function(val) {
                        return {
                            name: elem.name,
                            value: val.replace(rCRLF, "\r\n")
                        }
                    })) : {
                        name: elem.name,
                        value: val.replace(rCRLF, "\r\n")
                    }
                })).get()
            }
        });
        var r20 = /%20/g,
            rhash = /#.*$/,
            rantiCache = /([?&])_=[^&]*/,
            rheaders = /^(.*?):[ \t]*([^\r\n]*)$/gm,
            rnoContent = /^(?:GET|HEAD)$/,
            rprotocol = /^\/\//,
            prefilters = {},
            transports = {},
            allTypes = "*/".concat("*"),
            originAnchor = document.createElement("a");

        function addToPrefiltersOrTransports(structure) {
            return function(dataTypeExpression, func) {
                "string" != typeof dataTypeExpression && (func = dataTypeExpression, dataTypeExpression = "*");
                var dataType, i = 0,
                    dataTypes = dataTypeExpression.toLowerCase().match(rnothtmlwhite) || [];
                if (isFunction(func))
                    for (; dataType = dataTypes[i++];) "+" === dataType[0] ? (dataType = dataType.slice(1) || "*", (structure[dataType] = structure[dataType] || []).unshift(func)) : (structure[dataType] = structure[dataType] || []).push(func)
            }
        }

        function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
            var inspected = {},
                seekingTransport = structure === transports;

            function inspect(dataType) {
                var selected;
                return inspected[dataType] = !0, jQuery.each(structure[dataType] || [], (function(_, prefilterOrFactory) {
                    var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                    return "string" != typeof dataTypeOrTransport || seekingTransport || inspected[dataTypeOrTransport] ? seekingTransport ? !(selected = dataTypeOrTransport) : void 0 : (options.dataTypes.unshift(dataTypeOrTransport), inspect(dataTypeOrTransport), !1)
                })), selected
            }
            return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*")
        }

        function ajaxExtend(target, src) {
            var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
            for (key in src) void 0 !== src[key] && ((flatOptions[key] ? target : deep || (deep = {}))[key] = src[key]);
            return deep && jQuery.extend(!0, target, deep), target
        }
        originAnchor.href = location.href, jQuery.extend({
            active: 0,
            lastModified: {},
            etag: {},
            ajaxSettings: {
                url: location.href,
                type: "GET",
                isLocal: /^(?:about|app|app-storage|.+-extension|file|res|widget):$/.test(location.protocol),
                global: !0,
                processData: !0,
                async: !0,
                contentType: "application/x-www-form-urlencoded; charset=UTF-8",
                accepts: {
                    "*": allTypes,
                    text: "text/plain",
                    html: "text/html",
                    xml: "application/xml, text/xml",
                    json: "application/json, text/javascript"
                },
                contents: {
                    xml: /\bxml\b/,
                    html: /\bhtml/,
                    json: /\bjson\b/
                },
                responseFields: {
                    xml: "responseXML",
                    text: "responseText",
                    json: "responseJSON"
                },
                converters: {
                    "* text": String,
                    "text html": !0,
                    "text json": JSON.parse,
                    "text xml": jQuery.parseXML
                },
                flatOptions: {
                    url: !0,
                    context: !0
                }
            },
            ajaxSetup: function(target, settings) {
                return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target)
            },
            ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
            ajaxTransport: addToPrefiltersOrTransports(transports),
            ajax: function(url, options) {
                "object" == typeof url && (options = url, url = void 0), options = options || {};
                var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, urlAnchor, completed, fireGlobals, i, uncached, s = jQuery.ajaxSetup({}, options),
                    callbackContext = s.context || s,
                    globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event,
                    deferred = jQuery.Deferred(),
                    completeDeferred = jQuery.Callbacks("once memory"),
                    statusCode = s.statusCode || {},
                    requestHeaders = {},
                    requestHeadersNames = {},
                    strAbort = "canceled",
                    jqXHR = {
                        readyState: 0,
                        getResponseHeader: function(key) {
                            var match;
                            if (completed) {
                                if (!responseHeaders)
                                    for (responseHeaders = {}; match = rheaders.exec(responseHeadersString);) responseHeaders[match[1].toLowerCase() + " "] = (responseHeaders[match[1].toLowerCase() + " "] || []).concat(match[2]);
                                match = responseHeaders[key.toLowerCase() + " "]
                            }
                            return null == match ? null : match.join(", ")
                        },
                        getAllResponseHeaders: function() {
                            return completed ? responseHeadersString : null
                        },
                        setRequestHeader: function(name, value) {
                            return null == completed && (name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name, requestHeaders[name] = value), this
                        },
                        overrideMimeType: function(type) {
                            return null == completed && (s.mimeType = type), this
                        },
                        statusCode: function(map) {
                            var code;
                            if (map)
                                if (completed) jqXHR.always(map[jqXHR.status]);
                                else
                                    for (code in map) statusCode[code] = [statusCode[code], map[code]];
                            return this
                        },
                        abort: function(statusText) {
                            var finalText = statusText || strAbort;
                            return transport && transport.abort(finalText), done(0, finalText), this
                        }
                    };
                if (deferred.promise(jqXHR), s.url = ((url || s.url || location.href) + "").replace(rprotocol, location.protocol + "//"), s.type = options.method || options.type || s.method || s.type, s.dataTypes = (s.dataType || "*").toLowerCase().match(rnothtmlwhite) || [""], null == s.crossDomain) {
                    urlAnchor = document.createElement("a");
                    try {
                        urlAnchor.href = s.url, urlAnchor.href = urlAnchor.href, s.crossDomain = originAnchor.protocol + "//" + originAnchor.host != urlAnchor.protocol + "//" + urlAnchor.host
                    } catch (e) {
                        s.crossDomain = !0
                    }
                }
                if (s.data && s.processData && "string" != typeof s.data && (s.data = jQuery.param(s.data, s.traditional)), inspectPrefiltersOrTransports(prefilters, s, options, jqXHR), completed) return jqXHR;
                for (i in (fireGlobals = jQuery.event && s.global) && 0 == jQuery.active++ && jQuery.event.trigger("ajaxStart"), s.type = s.type.toUpperCase(), s.hasContent = !rnoContent.test(s.type), cacheURL = s.url.replace(rhash, ""), s.hasContent ? s.data && s.processData && 0 === (s.contentType || "").indexOf("application/x-www-form-urlencoded") && (s.data = s.data.replace(r20, "+")) : (uncached = s.url.slice(cacheURL.length), s.data && (s.processData || "string" == typeof s.data) && (cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data, delete s.data), !1 === s.cache && (cacheURL = cacheURL.replace(rantiCache, "$1"), uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce.guid++ + uncached), s.url = cacheURL + uncached), s.ifModified && (jQuery.lastModified[cacheURL] && jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]), jQuery.etag[cacheURL] && jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL])), (s.data && s.hasContent && !1 !== s.contentType || options.contentType) && jqXHR.setRequestHeader("Content-Type", s.contentType), jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + ("*" !== s.dataTypes[0] ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]), s.headers) jqXHR.setRequestHeader(i, s.headers[i]);
                if (s.beforeSend && (!1 === s.beforeSend.call(callbackContext, jqXHR, s) || completed)) return jqXHR.abort();
                if (strAbort = "abort", completeDeferred.add(s.complete), jqXHR.done(s.success), jqXHR.fail(s.error), transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR)) {
                    if (jqXHR.readyState = 1, fireGlobals && globalEventContext.trigger("ajaxSend", [jqXHR, s]), completed) return jqXHR;
                    s.async && s.timeout > 0 && (timeoutTimer = window.setTimeout((function() {
                        jqXHR.abort("timeout")
                    }), s.timeout));
                    try {
                        completed = !1, transport.send(requestHeaders, done)
                    } catch (e) {
                        if (completed) throw e;
                        done(-1, e)
                    }
                } else done(-1, "No Transport");

                function done(status, nativeStatusText, responses, headers) {
                    var isSuccess, success, error, response, modified, statusText = nativeStatusText;
                    completed || (completed = !0, timeoutTimer && window.clearTimeout(timeoutTimer), transport = void 0, responseHeadersString = headers || "", jqXHR.readyState = status > 0 ? 4 : 0, isSuccess = status >= 200 && status < 300 || 304 === status, responses && (response = function(s, jqXHR, responses) {
                        for (var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes;
                            "*" === dataTypes[0];) dataTypes.shift(), void 0 === ct && (ct = s.mimeType || jqXHR.getResponseHeader("Content-Type"));
                        if (ct)
                            for (type in contents)
                                if (contents[type] && contents[type].test(ct)) {
                                    dataTypes.unshift(type);
                                    break
                                }
                        if (dataTypes[0] in responses) finalDataType = dataTypes[0];
                        else {
                            for (type in responses) {
                                if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                                    finalDataType = type;
                                    break
                                }
                                firstDataType || (firstDataType = type)
                            }
                            finalDataType = finalDataType || firstDataType
                        }
                        if (finalDataType) return finalDataType !== dataTypes[0] && dataTypes.unshift(finalDataType), responses[finalDataType]
                    }(s, jqXHR, responses)), !isSuccess && jQuery.inArray("script", s.dataTypes) > -1 && (s.converters["text script"] = function() {}), response = function(s, response, jqXHR, isSuccess) {
                        var conv2, current, conv, tmp, prev, converters = {},
                            dataTypes = s.dataTypes.slice();
                        if (dataTypes[1])
                            for (conv in s.converters) converters[conv.toLowerCase()] = s.converters[conv];
                        for (current = dataTypes.shift(); current;)
                            if (s.responseFields[current] && (jqXHR[s.responseFields[current]] = response), !prev && isSuccess && s.dataFilter && (response = s.dataFilter(response, s.dataType)), prev = current, current = dataTypes.shift())
                                if ("*" === current) current = prev;
                                else if ("*" !== prev && prev !== current) {
                            if (!(conv = converters[prev + " " + current] || converters["* " + current]))
                                for (conv2 in converters)
                                    if ((tmp = conv2.split(" "))[1] === current && (conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]])) {
                                        !0 === conv ? conv = converters[conv2] : !0 !== converters[conv2] && (current = tmp[0], dataTypes.unshift(tmp[1]));
                                        break
                                    }
                            if (!0 !== conv)
                                if (conv && s.throws) response = conv(response);
                                else try {
                                    response = conv(response)
                                } catch (e) {
                                    return {
                                        state: "parsererror",
                                        error: conv ? e : "No conversion from " + prev + " to " + current
                                    }
                                }
                        }
                        return {
                            state: "success",
                            data: response
                        }
                    }(s, response, jqXHR, isSuccess), isSuccess ? (s.ifModified && ((modified = jqXHR.getResponseHeader("Last-Modified")) && (jQuery.lastModified[cacheURL] = modified), (modified = jqXHR.getResponseHeader("etag")) && (jQuery.etag[cacheURL] = modified)), 204 === status || "HEAD" === s.type ? statusText = "nocontent" : 304 === status ? statusText = "notmodified" : (statusText = response.state, success = response.data, isSuccess = !(error = response.error))) : (error = statusText, !status && statusText || (statusText = "error", status < 0 && (status = 0))), jqXHR.status = status, jqXHR.statusText = (nativeStatusText || statusText) + "", isSuccess ? deferred.resolveWith(callbackContext, [success, statusText, jqXHR]) : deferred.rejectWith(callbackContext, [jqXHR, statusText, error]), jqXHR.statusCode(statusCode), statusCode = void 0, fireGlobals && globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]), completeDeferred.fireWith(callbackContext, [jqXHR, statusText]), fireGlobals && (globalEventContext.trigger("ajaxComplete", [jqXHR, s]), --jQuery.active || jQuery.event.trigger("ajaxStop")))
                }
                return jqXHR
            },
            getJSON: function(url, data, callback) {
                return jQuery.get(url, data, callback, "json")
            },
            getScript: function(url, callback) {
                return jQuery.get(url, void 0, callback, "script")
            }
        }), jQuery.each(["get", "post"], (function(_i, method) {
            jQuery[method] = function(url, data, callback, type) {
                return isFunction(data) && (type = type || callback, callback = data, data = void 0), jQuery.ajax(jQuery.extend({
                    url: url,
                    type: method,
                    dataType: type,
                    data: data,
                    success: callback
                }, jQuery.isPlainObject(url) && url))
            }
        })), jQuery.ajaxPrefilter((function(s) {
            var i;
            for (i in s.headers) "content-type" === i.toLowerCase() && (s.contentType = s.headers[i] || "")
        })), jQuery._evalUrl = function(url, options, doc) {
            return jQuery.ajax({
                url: url,
                type: "GET",
                dataType: "script",
                cache: !0,
                async: !1,
                global: !1,
                converters: {
                    "text script": function() {}
                },
                dataFilter: function(response) {
                    jQuery.globalEval(response, options, doc)
                }
            })
        }, jQuery.fn.extend({
            wrapAll: function(html) {
                var wrap;
                return this[0] && (isFunction(html) && (html = html.call(this[0])), wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && wrap.insertBefore(this[0]), wrap.map((function() {
                    for (var elem = this; elem.firstElementChild;) elem = elem.firstElementChild;
                    return elem
                })).append(this)), this
            },
            wrapInner: function(html) {
                return isFunction(html) ? this.each((function(i) {
                    jQuery(this).wrapInner(html.call(this, i))
                })) : this.each((function() {
                    var self = jQuery(this),
                        contents = self.contents();
                    contents.length ? contents.wrapAll(html) : self.append(html)
                }))
            },
            wrap: function(html) {
                var htmlIsFunction = isFunction(html);
                return this.each((function(i) {
                    jQuery(this).wrapAll(htmlIsFunction ? html.call(this, i) : html)
                }))
            },
            unwrap: function(selector) {
                return this.parent(selector).not("body").each((function() {
                    jQuery(this).replaceWith(this.childNodes)
                })), this
            }
        }), jQuery.expr.pseudos.hidden = function(elem) {
            return !jQuery.expr.pseudos.visible(elem)
        }, jQuery.expr.pseudos.visible = function(elem) {
            return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length)
        }, jQuery.ajaxSettings.xhr = function() {
            try {
                return new window.XMLHttpRequest
            } catch (e) {}
        };
        var xhrSuccessStatus = {
                0: 200,
                1223: 204
            },
            xhrSupported = jQuery.ajaxSettings.xhr();
        support.cors = !!xhrSupported && "withCredentials" in xhrSupported, support.ajax = xhrSupported = !!xhrSupported, jQuery.ajaxTransport((function(options) {
            var callback, errorCallback;
            if (support.cors || xhrSupported && !options.crossDomain) return {
                send: function(headers, complete) {
                    var i, xhr = options.xhr();
                    if (xhr.open(options.type, options.url, options.async, options.username, options.password), options.xhrFields)
                        for (i in options.xhrFields) xhr[i] = options.xhrFields[i];
                    for (i in options.mimeType && xhr.overrideMimeType && xhr.overrideMimeType(options.mimeType), options.crossDomain || headers["X-Requested-With"] || (headers["X-Requested-With"] = "XMLHttpRequest"), headers) xhr.setRequestHeader(i, headers[i]);
                    callback = function(type) {
                        return function() {
                            callback && (callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.ontimeout = xhr.onreadystatechange = null, "abort" === type ? xhr.abort() : "error" === type ? "number" != typeof xhr.status ? complete(0, "error") : complete(xhr.status, xhr.statusText) : complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, "text" !== (xhr.responseType || "text") || "string" != typeof xhr.responseText ? {
                                binary: xhr.response
                            } : {
                                text: xhr.responseText
                            }, xhr.getAllResponseHeaders()))
                        }
                    }, xhr.onload = callback(), errorCallback = xhr.onerror = xhr.ontimeout = callback("error"), void 0 !== xhr.onabort ? xhr.onabort = errorCallback : xhr.onreadystatechange = function() {
                        4 === xhr.readyState && window.setTimeout((function() {
                            callback && errorCallback()
                        }))
                    }, callback = callback("abort");
                    try {
                        xhr.send(options.hasContent && options.data || null)
                    } catch (e) {
                        if (callback) throw e
                    }
                },
                abort: function() {
                    callback && callback()
                }
            }
        })), jQuery.ajaxPrefilter((function(s) {
            s.crossDomain && (s.contents.script = !1)
        })), jQuery.ajaxSetup({
            accepts: {
                script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"
            },
            contents: {
                script: /\b(?:java|ecma)script\b/
            },
            converters: {
                "text script": function(text) {
                    return jQuery.globalEval(text), text
                }
            }
        }), jQuery.ajaxPrefilter("script", (function(s) {
            void 0 === s.cache && (s.cache = !1), s.crossDomain && (s.type = "GET")
        })), jQuery.ajaxTransport("script", (function(s) {
            var script, callback;
            if (s.crossDomain || s.scriptAttrs) return {
                send: function(_, complete) {
                    script = jQuery("<script>").attr(s.scriptAttrs || {}).prop({
                        charset: s.scriptCharset,
                        src: s.url
                    }).on("load error", callback = function(evt) {
                        script.remove(), callback = null, evt && complete("error" === evt.type ? 404 : 200, evt.type)
                    }), document.head.appendChild(script[0])
                },
                abort: function() {
                    callback && callback()
                }
            }
        }));
        var body, oldCallbacks = [],
            rjsonp = /(=)\?(?=&|$)|\?\?/;
        jQuery.ajaxSetup({
            jsonp: "callback",
            jsonpCallback: function() {
                var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce.guid++;
                return this[callback] = !0, callback
            }
        }), jQuery.ajaxPrefilter("json jsonp", (function(s, originalSettings, jqXHR) {
            var callbackName, overwritten, responseContainer, jsonProp = !1 !== s.jsonp && (rjsonp.test(s.url) ? "url" : "string" == typeof s.data && 0 === (s.contentType || "").indexOf("application/x-www-form-urlencoded") && rjsonp.test(s.data) && "data");
            if (jsonProp || "jsonp" === s.dataTypes[0]) return callbackName = s.jsonpCallback = isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback, jsonProp ? s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName) : !1 !== s.jsonp && (s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName), s.converters["script json"] = function() {
                return responseContainer || jQuery.error(callbackName + " was not called"), responseContainer[0]
            }, s.dataTypes[0] = "json", overwritten = window[callbackName], window[callbackName] = function() {
                responseContainer = arguments
            }, jqXHR.always((function() {
                void 0 === overwritten ? jQuery(window).removeProp(callbackName) : window[callbackName] = overwritten, s[callbackName] && (s.jsonpCallback = originalSettings.jsonpCallback, oldCallbacks.push(callbackName)), responseContainer && isFunction(overwritten) && overwritten(responseContainer[0]), responseContainer = overwritten = void 0
            })), "script"
        })), support.createHTMLDocument = ((body = document.implementation.createHTMLDocument("").body).innerHTML = "<form></form><form></form>", 2 === body.childNodes.length), jQuery.parseHTML = function(data, context, keepScripts) {
            return "string" != typeof data ? [] : ("boolean" == typeof context && (keepScripts = context, context = !1), context || (support.createHTMLDocument ? ((base = (context = document.implementation.createHTMLDocument("")).createElement("base")).href = document.location.href, context.head.appendChild(base)) : context = document), scripts = !keepScripts && [], (parsed = rsingleTag.exec(data)) ? [context.createElement(parsed[1])] : (parsed = buildFragment([data], context, scripts), scripts && scripts.length && jQuery(scripts).remove(), jQuery.merge([], parsed.childNodes)));
            var base, parsed, scripts
        }, jQuery.fn.load = function(url, params, callback) {
            var selector, type, response, self = this,
                off = url.indexOf(" ");
            return off > -1 && (selector = stripAndCollapse(url.slice(off)), url = url.slice(0, off)), isFunction(params) ? (callback = params, params = void 0) : params && "object" == typeof params && (type = "POST"), self.length > 0 && jQuery.ajax({
                url: url,
                type: type || "GET",
                dataType: "html",
                data: params
            }).done((function(responseText) {
                response = arguments, self.html(selector ? jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : responseText)
            })).always(callback && function(jqXHR, status) {
                self.each((function() {
                    callback.apply(this, response || [jqXHR.responseText, status, jqXHR])
                }))
            }), this
        }, jQuery.expr.pseudos.animated = function(elem) {
            return jQuery.grep(jQuery.timers, (function(fn) {
                return elem === fn.elem
            })).length
        }, jQuery.offset = {
            setOffset: function(elem, options, i) {
                var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, position = jQuery.css(elem, "position"),
                    curElem = jQuery(elem),
                    props = {};
                "static" === position && (elem.style.position = "relative"), curOffset = curElem.offset(), curCSSTop = jQuery.css(elem, "top"), curCSSLeft = jQuery.css(elem, "left"), ("absolute" === position || "fixed" === position) && (curCSSTop + curCSSLeft).indexOf("auto") > -1 ? (curTop = (curPosition = curElem.position()).top, curLeft = curPosition.left) : (curTop = parseFloat(curCSSTop) || 0, curLeft = parseFloat(curCSSLeft) || 0), isFunction(options) && (options = options.call(elem, i, jQuery.extend({}, curOffset))), null != options.top && (props.top = options.top - curOffset.top + curTop), null != options.left && (props.left = options.left - curOffset.left + curLeft), "using" in options ? options.using.call(elem, props) : ("number" == typeof props.top && (props.top += "px"), "number" == typeof props.left && (props.left += "px"), curElem.css(props))
            }
        }, jQuery.fn.extend({
            offset: function(options) {
                if (arguments.length) return void 0 === options ? this : this.each((function(i) {
                    jQuery.offset.setOffset(this, options, i)
                }));
                var rect, win, elem = this[0];
                return elem ? elem.getClientRects().length ? (rect = elem.getBoundingClientRect(), win = elem.ownerDocument.defaultView, {
                    top: rect.top + win.pageYOffset,
                    left: rect.left + win.pageXOffset
                }) : {
                    top: 0,
                    left: 0
                } : void 0
            },
            position: function() {
                if (this[0]) {
                    var offsetParent, offset, doc, elem = this[0],
                        parentOffset = {
                            top: 0,
                            left: 0
                        };
                    if ("fixed" === jQuery.css(elem, "position")) offset = elem.getBoundingClientRect();
                    else {
                        for (offset = this.offset(), doc = elem.ownerDocument, offsetParent = elem.offsetParent || doc.documentElement; offsetParent && (offsetParent === doc.body || offsetParent === doc.documentElement) && "static" === jQuery.css(offsetParent, "position");) offsetParent = offsetParent.parentNode;
                        offsetParent && offsetParent !== elem && 1 === offsetParent.nodeType && ((parentOffset = jQuery(offsetParent).offset()).top += jQuery.css(offsetParent, "borderTopWidth", !0), parentOffset.left += jQuery.css(offsetParent, "borderLeftWidth", !0))
                    }
                    return {
                        top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", !0),
                        left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", !0)
                    }
                }
            },
            offsetParent: function() {
                return this.map((function() {
                    for (var offsetParent = this.offsetParent; offsetParent && "static" === jQuery.css(offsetParent, "position");) offsetParent = offsetParent.offsetParent;
                    return offsetParent || documentElement
                }))
            }
        }), jQuery.each({
            scrollLeft: "pageXOffset",
            scrollTop: "pageYOffset"
        }, (function(method, prop) {
            var top = "pageYOffset" === prop;
            jQuery.fn[method] = function(val) {
                return access(this, (function(elem, method, val) {
                    var win;
                    if (isWindow(elem) ? win = elem : 9 === elem.nodeType && (win = elem.defaultView), void 0 === val) return win ? win[prop] : elem[method];
                    win ? win.scrollTo(top ? win.pageXOffset : val, top ? val : win.pageYOffset) : elem[method] = val
                }), method, val, arguments.length)
            }
        })), jQuery.each(["top", "left"], (function(_i, prop) {
            jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, (function(elem, computed) {
                if (computed) return computed = curCSS(elem, prop), rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed
            }))
        })), jQuery.each({
            Height: "height",
            Width: "width"
        }, (function(name, type) {
            jQuery.each({
                padding: "inner" + name,
                content: type,
                "": "outer" + name
            }, (function(defaultExtra, funcName) {
                jQuery.fn[funcName] = function(margin, value) {
                    var chainable = arguments.length && (defaultExtra || "boolean" != typeof margin),
                        extra = defaultExtra || (!0 === margin || !0 === value ? "margin" : "border");
                    return access(this, (function(elem, type, value) {
                        var doc;
                        return isWindow(elem) ? 0 === funcName.indexOf("outer") ? elem["inner" + name] : elem.document.documentElement["client" + name] : 9 === elem.nodeType ? (doc = elem.documentElement, Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name])) : void 0 === value ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra)
                    }), type, chainable ? margin : void 0, chainable)
                }
            }))
        })), jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], (function(_i, type) {
            jQuery.fn[type] = function(fn) {
                return this.on(type, fn)
            }
        })), jQuery.fn.extend({
            bind: function(types, data, fn) {
                return this.on(types, null, data, fn)
            },
            unbind: function(types, fn) {
                return this.off(types, null, fn)
            },
            delegate: function(selector, types, data, fn) {
                return this.on(types, selector, data, fn)
            },
            undelegate: function(selector, types, fn) {
                return 1 === arguments.length ? this.off(selector, "**") : this.off(types, selector || "**", fn)
            },
            hover: function(fnOver, fnOut) {
                return this.mouseenter(fnOver).mouseleave(fnOut || fnOver)
            }
        }), jQuery.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), (function(_i, name) {
            jQuery.fn[name] = function(data, fn) {
                return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name)
            }
        }));
        var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
        jQuery.proxy = function(fn, context) {
            var tmp, args, proxy;
            if ("string" == typeof context && (tmp = fn[context], context = fn, fn = tmp), isFunction(fn)) return args = slice.call(arguments, 2), (proxy = function() {
                return fn.apply(context || this, args.concat(slice.call(arguments)))
            }).guid = fn.guid = fn.guid || jQuery.guid++, proxy
        }, jQuery.holdReady = function(hold) {
            hold ? jQuery.readyWait++ : jQuery.ready(!0)
        }, jQuery.isArray = Array.isArray, jQuery.parseJSON = JSON.parse, jQuery.nodeName = nodeName, jQuery.isFunction = isFunction, jQuery.isWindow = isWindow, jQuery.camelCase = camelCase, jQuery.type = toType, jQuery.now = Date.now, jQuery.isNumeric = function(obj) {
            var type = jQuery.type(obj);
            return ("number" === type || "string" === type) && !isNaN(obj - parseFloat(obj))
        }, jQuery.trim = function(text) {
            return null == text ? "" : (text + "").replace(rtrim, "")
        }, void 0 === (__WEBPACK_AMD_DEFINE_RESULT__ = function() {
            return jQuery
        }.apply(exports, [])) || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__);
        var _jQuery = window.jQuery,
            _$ = window.$;
        return jQuery.noConflict = function(deep) {
            return window.$ === jQuery && (window.$ = _$), deep && window.jQuery === jQuery && (window.jQuery = _jQuery), jQuery
        }, void 0 === noGlobal && (window.jQuery = window.$ = jQuery), jQuery
    }))
}, function(module, exports, __webpack_require__) {
    var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
    ! function(factory) {
        "use strict";
        __WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(240)], void 0 === (__WEBPACK_AMD_DEFINE_RESULT__ = function($) {
            return function($, window, document, undefined) {
                var _ext, _Api, _api_register, _api_registerPlural, DataTable = function(options) {
                        this.$ = function(sSelector, oOpts) {
                            return this.api(!0).$(sSelector, oOpts)
                        }, this._ = function(sSelector, oOpts) {
                            return this.api(!0).rows(sSelector, oOpts).data()
                        }, this.api = function(traditional) {
                            return new _Api(traditional ? _fnSettingsFromNode(this[_ext.iApiIndex]) : this)
                        }, this.fnAddData = function(data, redraw) {
                            var api = this.api(!0),
                                rows = $.isArray(data) && ($.isArray(data[0]) || $.isPlainObject(data[0])) ? api.rows.add(data) : api.row.add(data);
                            return (redraw === undefined || redraw) && api.draw(), rows.flatten().toArray()
                        }, this.fnAdjustColumnSizing = function(bRedraw) {
                            var api = this.api(!0).columns.adjust(),
                                settings = api.settings()[0],
                                scroll = settings.oScroll;
                            bRedraw === undefined || bRedraw ? api.draw(!1) : "" === scroll.sX && "" === scroll.sY || _fnScrollDraw(settings)
                        }, this.fnClearTable = function(bRedraw) {
                            var api = this.api(!0).clear();
                            (bRedraw === undefined || bRedraw) && api.draw()
                        }, this.fnClose = function(nTr) {
                            this.api(!0).row(nTr).child.hide()
                        }, this.fnDeleteRow = function(target, callback, redraw) {
                            var api = this.api(!0),
                                rows = api.rows(target),
                                settings = rows.settings()[0],
                                data = settings.aoData[rows[0][0]];
                            return rows.remove(), callback && callback.call(this, settings, data), (redraw === undefined || redraw) && api.draw(), data
                        }, this.fnDestroy = function(remove) {
                            this.api(!0).destroy(remove)
                        }, this.fnDraw = function(complete) {
                            this.api(!0).draw(complete)
                        }, this.fnFilter = function(sInput, iColumn, bRegex, bSmart, bShowGlobal, bCaseInsensitive) {
                            var api = this.api(!0);
                            null === iColumn || iColumn === undefined ? api.search(sInput, bRegex, bSmart, bCaseInsensitive) : api.column(iColumn).search(sInput, bRegex, bSmart, bCaseInsensitive), api.draw()
                        }, this.fnGetData = function(src, col) {
                            var api = this.api(!0);
                            if (src !== undefined) {
                                var type = src.nodeName ? src.nodeName.toLowerCase() : "";
                                return col !== undefined || "td" == type || "th" == type ? api.cell(src, col).data() : api.row(src).data() || null
                            }
                            return api.data().toArray()
                        }, this.fnGetNodes = function(iRow) {
                            var api = this.api(!0);
                            return iRow !== undefined ? api.row(iRow).node() : api.rows().nodes().flatten().toArray()
                        }, this.fnGetPosition = function(node) {
                            var api = this.api(!0),
                                nodeName = node.nodeName.toUpperCase();
                            if ("TR" == nodeName) return api.row(node).index();
                            if ("TD" == nodeName || "TH" == nodeName) {
                                var cell = api.cell(node).index();
                                return [cell.row, cell.columnVisible, cell.column]
                            }
                            return null
                        }, this.fnIsOpen = function(nTr) {
                            return this.api(!0).row(nTr).child.isShown()
                        }, this.fnOpen = function(nTr, mHtml, sClass) {
                            return this.api(!0).row(nTr).child(mHtml, sClass).show().child()[0]
                        }, this.fnPageChange = function(mAction, bRedraw) {
                            var api = this.api(!0).page(mAction);
                            (bRedraw === undefined || bRedraw) && api.draw(!1)
                        }, this.fnSetColumnVis = function(iCol, bShow, bRedraw) {
                            var api = this.api(!0).column(iCol).visible(bShow);
                            (bRedraw === undefined || bRedraw) && api.columns.adjust().draw()
                        }, this.fnSettings = function() {
                            return _fnSettingsFromNode(this[_ext.iApiIndex])
                        }, this.fnSort = function(aaSort) {
                            this.api(!0).order(aaSort).draw()
                        }, this.fnSortListener = function(nNode, iColumn, fnCallback) {
                            this.api(!0).order.listener(nNode, iColumn, fnCallback)
                        }, this.fnUpdate = function(mData, mRow, iColumn, bRedraw, bAction) {
                            var api = this.api(!0);
                            return iColumn === undefined || null === iColumn ? api.row(mRow).data(mData) : api.cell(mRow, iColumn).data(mData), (bAction === undefined || bAction) && api.columns.adjust(), (bRedraw === undefined || bRedraw) && api.draw(), 0
                        }, this.fnVersionCheck = _ext.fnVersionCheck;
                        var _that = this,
                            emptyInit = options === undefined,
                            len = this.length;
                        for (var fn in emptyInit && (options = {}), this.oApi = this.internal = _ext.internal, DataTable.ext.internal) fn && (this[fn] = _fnExternApiFunc(fn));
                        return this.each((function() {
                            var iLen, oInit = len > 1 ? _fnExtend({}, options, !0) : options,
                                i = 0,
                                sId = this.getAttribute("id"),
                                bInitHandedOff = !1,
                                defaults = DataTable.defaults,
                                $this = $(this);
                            if ("table" == this.nodeName.toLowerCase()) {
                                _fnCompatOpts(defaults), _fnCompatCols(defaults.column), _fnCamelToHungarian(defaults, defaults, !0), _fnCamelToHungarian(defaults.column, defaults.column, !0), _fnCamelToHungarian(defaults, $.extend(oInit, $this.data()));
                                var allSettings = DataTable.settings;
                                for (i = 0, iLen = allSettings.length; i < iLen; i++) {
                                    var s = allSettings[i];
                                    if (s.nTable == this || s.nTHead && s.nTHead.parentNode == this || s.nTFoot && s.nTFoot.parentNode == this) {
                                        var bRetrieve = oInit.bRetrieve !== undefined ? oInit.bRetrieve : defaults.bRetrieve,
                                            bDestroy = oInit.bDestroy !== undefined ? oInit.bDestroy : defaults.bDestroy;
                                        if (emptyInit || bRetrieve) return s.oInstance;
                                        if (bDestroy) {
                                            s.oInstance.fnDestroy();
                                            break
                                        }
                                        return void _fnLog(s, 0, "Cannot reinitialise DataTable", 3)
                                    }
                                    if (s.sTableId == this.id) {
                                        allSettings.splice(i, 1);
                                        break
                                    }
                                }
                                null !== sId && "" !== sId || (sId = "DataTables_Table_" + DataTable.ext._unique++, this.id = sId);
                                var oSettings = $.extend(!0, {}, DataTable.models.oSettings, {
                                    sDestroyWidth: $this[0].style.width,
                                    sInstance: sId,
                                    sTableId: sId
                                });
                                oSettings.nTable = this, oSettings.oApi = _that.internal, oSettings.oInit = oInit, allSettings.push(oSettings), oSettings.oInstance = 1 === _that.length ? _that : $this.dataTable(), _fnCompatOpts(oInit), _fnLanguageCompat(oInit.oLanguage), oInit.aLengthMenu && !oInit.iDisplayLength && (oInit.iDisplayLength = $.isArray(oInit.aLengthMenu[0]) ? oInit.aLengthMenu[0][0] : oInit.aLengthMenu[0]), oInit = _fnExtend($.extend(!0, {}, defaults), oInit), _fnMap(oSettings.oFeatures, oInit, ["bPaginate", "bLengthChange", "bFilter", "bSort", "bSortMulti", "bInfo", "bProcessing", "bAutoWidth", "bSortClasses", "bServerSide", "bDeferRender"]), _fnMap(oSettings, oInit, ["asStripeClasses", "ajax", "fnServerData", "fnFormatNumber", "sServerMethod", "aaSorting", "aaSortingFixed", "aLengthMenu", "sPaginationType", "sAjaxSource", "sAjaxDataProp", "iStateDuration", "sDom", "bSortCellsTop", "iTabIndex", "fnStateLoadCallback", "fnStateSaveCallback", "renderer", "searchDelay", "rowId", ["iCookieDuration", "iStateDuration"],
                                    ["oSearch", "oPreviousSearch"],
                                    ["aoSearchCols", "aoPreSearchCols"],
                                    ["iDisplayLength", "_iDisplayLength"]
                                ]), _fnMap(oSettings.oScroll, oInit, [
                                    ["sScrollX", "sX"],
                                    ["sScrollXInner", "sXInner"],
                                    ["sScrollY", "sY"],
                                    ["bScrollCollapse", "bCollapse"]
                                ]), _fnMap(oSettings.oLanguage, oInit, "fnInfoCallback"), _fnCallbackReg(oSettings, "aoDrawCallback", oInit.fnDrawCallback, "user"), _fnCallbackReg(oSettings, "aoServerParams", oInit.fnServerParams, "user"), _fnCallbackReg(oSettings, "aoStateSaveParams", oInit.fnStateSaveParams, "user"), _fnCallbackReg(oSettings, "aoStateLoadParams", oInit.fnStateLoadParams, "user"), _fnCallbackReg(oSettings, "aoStateLoaded", oInit.fnStateLoaded, "user"), _fnCallbackReg(oSettings, "aoRowCallback", oInit.fnRowCallback, "user"), _fnCallbackReg(oSettings, "aoRowCreatedCallback", oInit.fnCreatedRow, "user"), _fnCallbackReg(oSettings, "aoHeaderCallback", oInit.fnHeaderCallback, "user"), _fnCallbackReg(oSettings, "aoFooterCallback", oInit.fnFooterCallback, "user"), _fnCallbackReg(oSettings, "aoInitComplete", oInit.fnInitComplete, "user"), _fnCallbackReg(oSettings, "aoPreDrawCallback", oInit.fnPreDrawCallback, "user"), oSettings.rowIdFn = _fnGetObjectDataFn(oInit.rowId), _fnBrowserDetect(oSettings);
                                var oClasses = oSettings.oClasses;
                                if ($.extend(oClasses, DataTable.ext.classes, oInit.oClasses), $this.addClass(oClasses.sTable), oSettings.iInitDisplayStart === undefined && (oSettings.iInitDisplayStart = oInit.iDisplayStart, oSettings._iDisplayStart = oInit.iDisplayStart), null !== oInit.iDeferLoading) {
                                    oSettings.bDeferLoading = !0;
                                    var tmp = $.isArray(oInit.iDeferLoading);
                                    oSettings._iRecordsDisplay = tmp ? oInit.iDeferLoading[0] : oInit.iDeferLoading, oSettings._iRecordsTotal = tmp ? oInit.iDeferLoading[1] : oInit.iDeferLoading
                                }
                                var oLanguage = oSettings.oLanguage;
                                $.extend(!0, oLanguage, oInit.oLanguage), oLanguage.sUrl && ($.ajax({
                                    dataType: "json",
                                    url: oLanguage.sUrl,
                                    success: function(json) {
                                        _fnLanguageCompat(json), _fnCamelToHungarian(defaults.oLanguage, json), $.extend(!0, oLanguage, json), _fnInitialise(oSettings)
                                    },
                                    error: function() {
                                        _fnInitialise(oSettings)
                                    }
                                }), bInitHandedOff = !0), null === oInit.asStripeClasses && (oSettings.asStripeClasses = [oClasses.sStripeOdd, oClasses.sStripeEven]);
                                var stripeClasses = oSettings.asStripeClasses,
                                    rowOne = $this.children("tbody").find("tr").eq(0); - 1 !== $.inArray(!0, $.map(stripeClasses, (function(el, i) {
                                    return rowOne.hasClass(el)
                                }))) && ($("tbody tr", this).removeClass(stripeClasses.join(" ")), oSettings.asDestroyStripes = stripeClasses.slice());
                                var aoColumnsInit, anThs = [],
                                    nThead = this.getElementsByTagName("thead");
                                if (0 !== nThead.length && (_fnDetectHeader(oSettings.aoHeader, nThead[0]), anThs = _fnGetUniqueThs(oSettings)), null === oInit.aoColumns)
                                    for (aoColumnsInit = [], i = 0, iLen = anThs.length; i < iLen; i++) aoColumnsInit.push(null);
                                else aoColumnsInit = oInit.aoColumns;
                                for (i = 0, iLen = aoColumnsInit.length; i < iLen; i++) _fnAddColumn(oSettings, anThs ? anThs[i] : null);
                                if (_fnApplyColumnDefs(oSettings, oInit.aoColumnDefs, aoColumnsInit, (function(iCol, oDef) {
                                        _fnColumnOptions(oSettings, iCol, oDef)
                                    })), rowOne.length) {
                                    var a = function(cell, name) {
                                        return null !== cell.getAttribute("data-" + name) ? name : null
                                    };
                                    $(rowOne[0]).children("th, td").each((function(i, cell) {
                                        var col = oSettings.aoColumns[i];
                                        if (col.mData === i) {
                                            var sort = a(cell, "sort") || a(cell, "order"),
                                                filter = a(cell, "filter") || a(cell, "search");
                                            null === sort && null === filter || (col.mData = {
                                                _: i + ".display",
                                                sort: null !== sort ? i + ".@data-" + sort : undefined,
                                                type: null !== sort ? i + ".@data-" + sort : undefined,
                                                filter: null !== filter ? i + ".@data-" + filter : undefined
                                            }, _fnColumnOptions(oSettings, i))
                                        }
                                    }))
                                }
                                var features = oSettings.oFeatures,
                                    loadedInit = function() {
                                        if (oInit.aaSorting === undefined) {
                                            var sorting = oSettings.aaSorting;
                                            for (i = 0, iLen = sorting.length; i < iLen; i++) sorting[i][1] = oSettings.aoColumns[i].asSorting[0]
                                        }
                                        _fnSortingClasses(oSettings), features.bSort && _fnCallbackReg(oSettings, "aoDrawCallback", (function() {
                                            if (oSettings.bSorted) {
                                                var aSort = _fnSortFlatten(oSettings),
                                                    sortedColumns = {};
                                                $.each(aSort, (function(i, val) {
                                                    sortedColumns[val.src] = val.dir
                                                })), _fnCallbackFire(oSettings, null, "order", [oSettings, aSort, sortedColumns]), _fnSortAria(oSettings)
                                            }
                                        })), _fnCallbackReg(oSettings, "aoDrawCallback", (function() {
                                            (oSettings.bSorted || "ssp" === _fnDataSource(oSettings) || features.bDeferRender) && _fnSortingClasses(oSettings)
                                        }), "sc");
                                        var captions = $this.children("caption").each((function() {
                                                this._captionSide = $(this).css("caption-side")
                                            })),
                                            thead = $this.children("thead");
                                        0 === thead.length && (thead = $("<thead/>").appendTo($this)), oSettings.nTHead = thead[0];
                                        var tbody = $this.children("tbody");
                                        0 === tbody.length && (tbody = $("<tbody/>").appendTo($this)), oSettings.nTBody = tbody[0];
                                        var tfoot = $this.children("tfoot");
                                        if (0 === tfoot.length && captions.length > 0 && ("" !== oSettings.oScroll.sX || "" !== oSettings.oScroll.sY) && (tfoot = $("<tfoot/>").appendTo($this)), 0 === tfoot.length || 0 === tfoot.children().length ? $this.addClass(oClasses.sNoFooter) : tfoot.length > 0 && (oSettings.nTFoot = tfoot[0], _fnDetectHeader(oSettings.aoFooter, oSettings.nTFoot)), oInit.aaData)
                                            for (i = 0; i < oInit.aaData.length; i++) _fnAddData(oSettings, oInit.aaData[i]);
                                        else(oSettings.bDeferLoading || "dom" == _fnDataSource(oSettings)) && _fnAddTr(oSettings, $(oSettings.nTBody).children("tr"));
                                        oSettings.aiDisplay = oSettings.aiDisplayMaster.slice(), oSettings.bInitialised = !0, !1 === bInitHandedOff && _fnInitialise(oSettings)
                                    };
                                oInit.bStateSave ? (features.bStateSave = !0, _fnCallbackReg(oSettings, "aoDrawCallback", _fnSaveState, "state_save"), _fnLoadState(oSettings, oInit, loadedInit)) : loadedInit()
                            } else _fnLog(null, 0, "Non-table node initialisation (" + this.nodeName + ")", 2)
                        })), _that = null, this
                    },
                    _re_dic = {},
                    _re_new_lines = /[\r\n]/g,
                    _re_html = /<.*?>/g,
                    _re_date = /^\d{2,4}[\.\/\-]\d{1,2}[\.\/\-]\d{1,2}([T ]{1}\d{1,2}[:\.]\d{2}([\.:]\d{2})?)?$/,
                    _re_escape_regex = new RegExp("(\\" + ["/", ".", "*", "+", "?", "|", "(", ")", "[", "]", "{", "}", "\\", "$", "^", "-"].join("|\\") + ")", "g"),
                    _re_formatted_numeric = /[',$£€¥%\u2009\u202F\u20BD\u20a9\u20BArfkɃΞ]/gi,
                    _empty = function(d) {
                        return !d || !0 === d || "-" === d
                    },
                    _intVal = function(s) {
                        var integer = parseInt(s, 10);
                        return !isNaN(integer) && isFinite(s) ? integer : null
                    },
                    _numToDecimal = function(num, decimalPoint) {
                        return _re_dic[decimalPoint] || (_re_dic[decimalPoint] = new RegExp(_fnEscapeRegex(decimalPoint), "g")), "string" == typeof num && "." !== decimalPoint ? num.replace(/\./g, "").replace(_re_dic[decimalPoint], ".") : num
                    },
                    _isNumber = function(d, decimalPoint, formatted) {
                        var strType = "string" == typeof d;
                        return !!_empty(d) || (decimalPoint && strType && (d = _numToDecimal(d, decimalPoint)), formatted && strType && (d = d.replace(_re_formatted_numeric, "")), !isNaN(parseFloat(d)) && isFinite(d))
                    },
                    _isHtml = function(d) {
                        return _empty(d) || "string" == typeof d
                    },
                    _htmlNumeric = function(d, decimalPoint, formatted) {
                        return !!_empty(d) || (_isHtml(d) && !!_isNumber(_stripHtml(d), decimalPoint, formatted) || null)
                    },
                    _pluck = function(a, prop, prop2) {
                        var out = [],
                            i = 0,
                            ien = a.length;
                        if (prop2 !== undefined)
                            for (; i < ien; i++) a[i] && a[i][prop] && out.push(a[i][prop][prop2]);
                        else
                            for (; i < ien; i++) a[i] && out.push(a[i][prop]);
                        return out
                    },
                    _pluck_order = function(a, order, prop, prop2) {
                        var out = [],
                            i = 0,
                            ien = order.length;
                        if (prop2 !== undefined)
                            for (; i < ien; i++) a[order[i]][prop] && out.push(a[order[i]][prop][prop2]);
                        else
                            for (; i < ien; i++) out.push(a[order[i]][prop]);
                        return out
                    },
                    _range = function(len, start) {
                        var end, out = [];
                        start === undefined ? (start = 0, end = len) : (end = start, start = len);
                        for (var i = start; i < end; i++) out.push(i);
                        return out
                    },
                    _removeEmpty = function(a) {
                        for (var out = [], i = 0, ien = a.length; i < ien; i++) a[i] && out.push(a[i]);
                        return out
                    },
                    _stripHtml = function(d) {
                        return d.replace(_re_html, "")
                    },
                    _areAllUnique = function(src) {
                        if (src.length < 2) return !0;
                        for (var sorted = src.slice().sort(), last = sorted[0], i = 1, ien = sorted.length; i < ien; i++) {
                            if (sorted[i] === last) return !1;
                            last = sorted[i]
                        }
                        return !0
                    },
                    _unique = function(src) {
                        if (_areAllUnique(src)) return src.slice();
                        var val, i, j, out = [],
                            ien = src.length,
                            k = 0;
                        again: for (i = 0; i < ien; i++) {
                            for (val = src[i], j = 0; j < k; j++)
                                if (out[j] === val) continue again;
                            out.push(val), k++
                        }
                        return out
                    };

                function _fnHungarianMap(o) {
                    var match, newKey, hungarian = "a aa ai ao as b fn i m o s ",
                        map = {};
                    $.each(o, (function(key, val) {
                        (match = key.match(/^([^A-Z]+?)([A-Z])/)) && -1 !== hungarian.indexOf(match[1] + " ") && (newKey = key.replace(match[0], match[2].toLowerCase()), map[newKey] = key, "o" === match[1] && _fnHungarianMap(o[key]))
                    })), o._hungarianMap = map
                }

                function _fnCamelToHungarian(src, user, force) {
                    var hungarianKey;
                    src._hungarianMap || _fnHungarianMap(src), $.each(user, (function(key, val) {
                        (hungarianKey = src._hungarianMap[key]) === undefined || !force && user[hungarianKey] !== undefined || ("o" === hungarianKey.charAt(0) ? (user[hungarianKey] || (user[hungarianKey] = {}), $.extend(!0, user[hungarianKey], user[key]), _fnCamelToHungarian(src[hungarianKey], user[hungarianKey], force)) : user[hungarianKey] = user[key])
                    }))
                }

                function _fnLanguageCompat(lang) {
                    var defaults = DataTable.defaults.oLanguage,
                        defaultDecimal = defaults.sDecimal;
                    if (defaultDecimal && _addNumericSort(defaultDecimal), lang) {
                        var zeroRecords = lang.sZeroRecords;
                        !lang.sEmptyTable && zeroRecords && "No data available in table" === defaults.sEmptyTable && _fnMap(lang, lang, "sZeroRecords", "sEmptyTable"), !lang.sLoadingRecords && zeroRecords && "Loading..." === defaults.sLoadingRecords && _fnMap(lang, lang, "sZeroRecords", "sLoadingRecords"), lang.sInfoThousands && (lang.sThousands = lang.sInfoThousands);
                        var decimal = lang.sDecimal;
                        decimal && defaultDecimal !== decimal && _addNumericSort(decimal)
                    }
                }
                DataTable.util = {
                    throttle: function(fn, freq) {
                        var last, timer, frequency = freq !== undefined ? freq : 200;
                        return function() {
                            var that = this,
                                now = +new Date,
                                args = arguments;
                            last && now < last + frequency ? (clearTimeout(timer), timer = setTimeout((function() {
                                last = undefined, fn.apply(that, args)
                            }), frequency)) : (last = now, fn.apply(that, args))
                        }
                    },
                    escapeRegex: function(val) {
                        return val.replace(_re_escape_regex, "\\$1")
                    }
                };
                var _fnCompatMap = function(o, knew, old) {
                    o[knew] !== undefined && (o[old] = o[knew])
                };

                function _fnCompatOpts(init) {
                    _fnCompatMap(init, "ordering", "bSort"), _fnCompatMap(init, "orderMulti", "bSortMulti"), _fnCompatMap(init, "orderClasses", "bSortClasses"), _fnCompatMap(init, "orderCellsTop", "bSortCellsTop"), _fnCompatMap(init, "order", "aaSorting"), _fnCompatMap(init, "orderFixed", "aaSortingFixed"), _fnCompatMap(init, "paging", "bPaginate"), _fnCompatMap(init, "pagingType", "sPaginationType"), _fnCompatMap(init, "pageLength", "iDisplayLength"), _fnCompatMap(init, "searching", "bFilter"), "boolean" == typeof init.sScrollX && (init.sScrollX = init.sScrollX ? "100%" : ""), "boolean" == typeof init.scrollX && (init.scrollX = init.scrollX ? "100%" : "");
                    var searchCols = init.aoSearchCols;
                    if (searchCols)
                        for (var i = 0, ien = searchCols.length; i < ien; i++) searchCols[i] && _fnCamelToHungarian(DataTable.models.oSearch, searchCols[i])
                }

                function _fnCompatCols(init) {
                    _fnCompatMap(init, "orderable", "bSortable"), _fnCompatMap(init, "orderData", "aDataSort"), _fnCompatMap(init, "orderSequence", "asSorting"), _fnCompatMap(init, "orderDataType", "sortDataType");
                    var dataSort = init.aDataSort;
                    "number" != typeof dataSort || $.isArray(dataSort) || (init.aDataSort = [dataSort])
                }

                function _fnBrowserDetect(settings) {
                    if (!DataTable.__browser) {
                        var browser = {};
                        DataTable.__browser = browser;
                        var n = $("<div/>").css({
                                position: "fixed",
                                top: 0,
                                left: -1 * $(window).scrollLeft(),
                                height: 1,
                                width: 1,
                                overflow: "hidden"
                            }).append($("<div/>").css({
                                position: "absolute",
                                top: 1,
                                left: 1,
                                width: 100,
                                overflow: "scroll"
                            }).append($("<div/>").css({
                                width: "100%",
                                height: 10
                            }))).appendTo("body"),
                            outer = n.children(),
                            inner = outer.children();
                        browser.barWidth = outer[0].offsetWidth - outer[0].clientWidth, browser.bScrollOversize = 100 === inner[0].offsetWidth && 100 !== outer[0].clientWidth, browser.bScrollbarLeft = 1 !== Math.round(inner.offset().left), browser.bBounding = !!n[0].getBoundingClientRect().width, n.remove()
                    }
                    $.extend(settings.oBrowser, DataTable.__browser), settings.oScroll.iBarWidth = DataTable.__browser.barWidth
                }

                function _fnReduce(that, fn, init, start, end, inc) {
                    var value, i = start,
                        isSet = !1;
                    for (init !== undefined && (value = init, isSet = !0); i !== end;) that.hasOwnProperty(i) && (value = isSet ? fn(value, that[i], i, that) : that[i], isSet = !0, i += inc);
                    return value
                }

                function _fnAddColumn(oSettings, nTh) {
                    var oDefaults = DataTable.defaults.column,
                        iCol = oSettings.aoColumns.length,
                        oCol = $.extend({}, DataTable.models.oColumn, oDefaults, {
                            nTh: nTh || document.createElement("th"),
                            sTitle: oDefaults.sTitle ? oDefaults.sTitle : nTh ? nTh.innerHTML : "",
                            aDataSort: oDefaults.aDataSort ? oDefaults.aDataSort : [iCol],
                            mData: oDefaults.mData ? oDefaults.mData : iCol,
                            idx: iCol
                        });
                    oSettings.aoColumns.push(oCol);
                    var searchCols = oSettings.aoPreSearchCols;
                    searchCols[iCol] = $.extend({}, DataTable.models.oSearch, searchCols[iCol]), _fnColumnOptions(oSettings, iCol, $(nTh).data())
                }

                function _fnColumnOptions(oSettings, iCol, oOptions) {
                    var oCol = oSettings.aoColumns[iCol],
                        oClasses = oSettings.oClasses,
                        th = $(oCol.nTh);
                    if (!oCol.sWidthOrig) {
                        oCol.sWidthOrig = th.attr("width") || null;
                        var t = (th.attr("style") || "").match(/width:\s*(\d+[pxem%]+)/);
                        t && (oCol.sWidthOrig = t[1])
                    }
                    oOptions !== undefined && null !== oOptions && (_fnCompatCols(oOptions), _fnCamelToHungarian(DataTable.defaults.column, oOptions), oOptions.mDataProp === undefined || oOptions.mData || (oOptions.mData = oOptions.mDataProp), oOptions.sType && (oCol._sManualType = oOptions.sType), oOptions.className && !oOptions.sClass && (oOptions.sClass = oOptions.className), oOptions.sClass && th.addClass(oOptions.sClass), $.extend(oCol, oOptions), _fnMap(oCol, oOptions, "sWidth", "sWidthOrig"), oOptions.iDataSort !== undefined && (oCol.aDataSort = [oOptions.iDataSort]), _fnMap(oCol, oOptions, "aDataSort"));
                    var mDataSrc = oCol.mData,
                        mData = _fnGetObjectDataFn(mDataSrc),
                        mRender = oCol.mRender ? _fnGetObjectDataFn(oCol.mRender) : null,
                        attrTest = function(src) {
                            return "string" == typeof src && -1 !== src.indexOf("@")
                        };
                    oCol._bAttrSrc = $.isPlainObject(mDataSrc) && (attrTest(mDataSrc.sort) || attrTest(mDataSrc.type) || attrTest(mDataSrc.filter)), oCol._setter = null, oCol.fnGetData = function(rowData, type, meta) {
                        var innerData = mData(rowData, type, undefined, meta);
                        return mRender && type ? mRender(innerData, type, rowData, meta) : innerData
                    }, oCol.fnSetData = function(rowData, val, meta) {
                        return _fnSetObjectDataFn(mDataSrc)(rowData, val, meta)
                    }, "number" != typeof mDataSrc && (oSettings._rowReadObject = !0), oSettings.oFeatures.bSort || (oCol.bSortable = !1, th.addClass(oClasses.sSortableNone));
                    var bAsc = -1 !== $.inArray("asc", oCol.asSorting),
                        bDesc = -1 !== $.inArray("desc", oCol.asSorting);
                    oCol.bSortable && (bAsc || bDesc) ? bAsc && !bDesc ? (oCol.sSortingClass = oClasses.sSortableAsc, oCol.sSortingClassJUI = oClasses.sSortJUIAscAllowed) : !bAsc && bDesc ? (oCol.sSortingClass = oClasses.sSortableDesc, oCol.sSortingClassJUI = oClasses.sSortJUIDescAllowed) : (oCol.sSortingClass = oClasses.sSortable, oCol.sSortingClassJUI = oClasses.sSortJUI) : (oCol.sSortingClass = oClasses.sSortableNone, oCol.sSortingClassJUI = "")
                }

                function _fnAdjustColumnSizing(settings) {
                    if (!1 !== settings.oFeatures.bAutoWidth) {
                        var columns = settings.aoColumns;
                        _fnCalculateColumnWidths(settings);
                        for (var i = 0, iLen = columns.length; i < iLen; i++) columns[i].nTh.style.width = columns[i].sWidth
                    }
                    var scroll = settings.oScroll;
                    "" === scroll.sY && "" === scroll.sX || _fnScrollDraw(settings), _fnCallbackFire(settings, null, "column-sizing", [settings])
                }

                function _fnVisibleToColumnIndex(oSettings, iMatch) {
                    var aiVis = _fnGetColumns(oSettings, "bVisible");
                    return "number" == typeof aiVis[iMatch] ? aiVis[iMatch] : null
                }

                function _fnColumnIndexToVisible(oSettings, iMatch) {
                    var aiVis = _fnGetColumns(oSettings, "bVisible"),
                        iPos = $.inArray(iMatch, aiVis);
                    return -1 !== iPos ? iPos : null
                }

                function _fnVisbleColumns(oSettings) {
                    var vis = 0;
                    return $.each(oSettings.aoColumns, (function(i, col) {
                        col.bVisible && "none" !== $(col.nTh).css("display") && vis++
                    })), vis
                }

                function _fnGetColumns(oSettings, sParam) {
                    var a = [];
                    return $.map(oSettings.aoColumns, (function(val, i) {
                        val[sParam] && a.push(i)
                    })), a
                }

                function _fnColumnTypes(settings) {
                    var i, ien, j, jen, k, ken, col, detectedType, cache, columns = settings.aoColumns,
                        data = settings.aoData,
                        types = DataTable.ext.type.detect;
                    for (i = 0, ien = columns.length; i < ien; i++)
                        if (cache = [], !(col = columns[i]).sType && col._sManualType) col.sType = col._sManualType;
                        else if (!col.sType) {
                        for (j = 0, jen = types.length; j < jen; j++) {
                            for (k = 0, ken = data.length; k < ken && (cache[k] === undefined && (cache[k] = _fnGetCellData(settings, k, i, "type")), (detectedType = types[j](cache[k], settings)) || j === types.length - 1) && "html" !== detectedType; k++);
                            if (detectedType) {
                                col.sType = detectedType;
                                break
                            }
                        }
                        col.sType || (col.sType = "string")
                    }
                }

                function _fnApplyColumnDefs(oSettings, aoColDefs, aoCols, fn) {
                    var i, iLen, j, jLen, k, kLen, def, columns = oSettings.aoColumns;
                    if (aoColDefs)
                        for (i = aoColDefs.length - 1; i >= 0; i--) {
                            var aTargets = (def = aoColDefs[i]).targets !== undefined ? def.targets : def.aTargets;
                            for ($.isArray(aTargets) || (aTargets = [aTargets]), j = 0, jLen = aTargets.length; j < jLen; j++)
                                if ("number" == typeof aTargets[j] && aTargets[j] >= 0) {
                                    for (; columns.length <= aTargets[j];) _fnAddColumn(oSettings);
                                    fn(aTargets[j], def)
                                } else if ("number" == typeof aTargets[j] && aTargets[j] < 0) fn(columns.length + aTargets[j], def);
                            else if ("string" == typeof aTargets[j])
                                for (k = 0, kLen = columns.length; k < kLen; k++)("_all" == aTargets[j] || $(columns[k].nTh).hasClass(aTargets[j])) && fn(k, def)
                        }
                    if (aoCols)
                        for (i = 0, iLen = aoCols.length; i < iLen; i++) fn(i, aoCols[i])
                }

                function _fnAddData(oSettings, aDataIn, nTr, anTds) {
                    var iRow = oSettings.aoData.length,
                        oData = $.extend(!0, {}, DataTable.models.oRow, {
                            src: nTr ? "dom" : "data",
                            idx: iRow
                        });
                    oData._aData = aDataIn, oSettings.aoData.push(oData);
                    for (var columns = oSettings.aoColumns, i = 0, iLen = columns.length; i < iLen; i++) columns[i].sType = null;
                    oSettings.aiDisplayMaster.push(iRow);
                    var id = oSettings.rowIdFn(aDataIn);
                    return id !== undefined && (oSettings.aIds[id] = oData), !nTr && oSettings.oFeatures.bDeferRender || _fnCreateTr(oSettings, iRow, nTr, anTds), iRow
                }

                function _fnAddTr(settings, trs) {
                    var row;
                    return trs instanceof $ || (trs = $(trs)), trs.map((function(i, el) {
                        return row = _fnGetRowElements(settings, el), _fnAddData(settings, row.data, el, row.cells)
                    }))
                }

                function _fnNodeToDataIndex(oSettings, n) {
                    return n._DT_RowIndex !== undefined ? n._DT_RowIndex : null
                }

                function _fnNodeToColumnIndex(oSettings, iRow, n) {
                    return $.inArray(n, oSettings.aoData[iRow].anCells)
                }

                function _fnGetCellData(settings, rowIdx, colIdx, type) {
                    var draw = settings.iDraw,
                        col = settings.aoColumns[colIdx],
                        rowData = settings.aoData[rowIdx]._aData,
                        defaultContent = col.sDefaultContent,
                        cellData = col.fnGetData(rowData, type, {
                            settings: settings,
                            row: rowIdx,
                            col: colIdx
                        });
                    if (cellData === undefined) return settings.iDrawError != draw && null === defaultContent && (_fnLog(settings, 0, "Requested unknown parameter " + ("function" == typeof col.mData ? "{function}" : "'" + col.mData + "'") + " for row " + rowIdx + ", column " + colIdx, 4), settings.iDrawError = draw), defaultContent;
                    if (cellData !== rowData && null !== cellData || null === defaultContent || type === undefined) {
                        if ("function" == typeof cellData) return cellData.call(rowData)
                    } else cellData = defaultContent;
                    return null === cellData && "display" == type ? "" : cellData
                }

                function _fnSetCellData(settings, rowIdx, colIdx, val) {
                    var col = settings.aoColumns[colIdx],
                        rowData = settings.aoData[rowIdx]._aData;
                    col.fnSetData(rowData, val, {
                        settings: settings,
                        row: rowIdx,
                        col: colIdx
                    })
                }
                var __reArray = /\[.*?\]$/,
                    __reFn = /\(\)$/;

                function _fnSplitObjNotation(str) {
                    return $.map(str.match(/(\\.|[^\.])+/g) || [""], (function(s) {
                        return s.replace(/\\\./g, ".")
                    }))
                }

                function _fnGetObjectDataFn(mSource) {
                    if ($.isPlainObject(mSource)) {
                        var o = {};
                        return $.each(mSource, (function(key, val) {
                                val && (o[key] = _fnGetObjectDataFn(val))
                            })),
                            function(data, type, row, meta) {
                                var t = o[type] || o._;
                                return t !== undefined ? t(data, type, row, meta) : data
                            }
                    }
                    if (null === mSource) return function(data) {
                        return data
                    };
                    if ("function" == typeof mSource) return function(data, type, row, meta) {
                        return mSource(data, type, row, meta)
                    };
                    if ("string" != typeof mSource || -1 === mSource.indexOf(".") && -1 === mSource.indexOf("[") && -1 === mSource.indexOf("(")) return function(data, type) {
                        return data[mSource]
                    };
                    var fetchData = function(data, type, src) {
                        var arrayNotation, funcNotation, out, innerSrc;
                        if ("" !== src)
                            for (var a = _fnSplitObjNotation(src), i = 0, iLen = a.length; i < iLen; i++) {
                                if (arrayNotation = a[i].match(__reArray), funcNotation = a[i].match(__reFn), arrayNotation) {
                                    if (a[i] = a[i].replace(__reArray, ""), "" !== a[i] && (data = data[a[i]]), out = [], a.splice(0, i + 1), innerSrc = a.join("."), $.isArray(data))
                                        for (var j = 0, jLen = data.length; j < jLen; j++) out.push(fetchData(data[j], type, innerSrc));
                                    var join = arrayNotation[0].substring(1, arrayNotation[0].length - 1);
                                    data = "" === join ? out : out.join(join);
                                    break
                                }
                                if (funcNotation) a[i] = a[i].replace(__reFn, ""), data = data[a[i]]();
                                else {
                                    if (null === data || data[a[i]] === undefined) return undefined;
                                    data = data[a[i]]
                                }
                            }
                        return data
                    };
                    return function(data, type) {
                        return fetchData(data, type, mSource)
                    }
                }

                function _fnSetObjectDataFn(mSource) {
                    if ($.isPlainObject(mSource)) return _fnSetObjectDataFn(mSource._);
                    if (null === mSource) return function() {};
                    if ("function" == typeof mSource) return function(data, val, meta) {
                        mSource(data, "set", val, meta)
                    };
                    if ("string" != typeof mSource || -1 === mSource.indexOf(".") && -1 === mSource.indexOf("[") && -1 === mSource.indexOf("(")) return function(data, val) {
                        data[mSource] = val
                    };
                    var setData = function(data, val, src) {
                        for (var b, arrayNotation, funcNotation, o, innerSrc, a = _fnSplitObjNotation(src), aLast = a[a.length - 1], i = 0, iLen = a.length - 1; i < iLen; i++) {
                            if (arrayNotation = a[i].match(__reArray), funcNotation = a[i].match(__reFn), arrayNotation) {
                                if (a[i] = a[i].replace(__reArray, ""), data[a[i]] = [], (b = a.slice()).splice(0, i + 1), innerSrc = b.join("."), $.isArray(val))
                                    for (var j = 0, jLen = val.length; j < jLen; j++) setData(o = {}, val[j], innerSrc), data[a[i]].push(o);
                                else data[a[i]] = val;
                                return
                            }
                            funcNotation && (a[i] = a[i].replace(__reFn, ""), data = data[a[i]](val)), null !== data[a[i]] && data[a[i]] !== undefined || (data[a[i]] = {}), data = data[a[i]]
                        }
                        aLast.match(__reFn) ? data = data[aLast.replace(__reFn, "")](val) : data[aLast.replace(__reArray, "")] = val
                    };
                    return function(data, val) {
                        return setData(data, val, mSource)
                    }
                }

                function _fnGetDataMaster(settings) {
                    return _pluck(settings.aoData, "_aData")
                }

                function _fnClearTable(settings) {
                    settings.aoData.length = 0, settings.aiDisplayMaster.length = 0, settings.aiDisplay.length = 0, settings.aIds = {}
                }

                function _fnDeleteIndex(a, iTarget, splice) {
                    for (var iTargetIndex = -1, i = 0, iLen = a.length; i < iLen; i++) a[i] == iTarget ? iTargetIndex = i : a[i] > iTarget && a[i]--; - 1 != iTargetIndex && splice === undefined && a.splice(iTargetIndex, 1)
                }

                function _fnInvalidate(settings, rowIdx, src, colIdx) {
                    var i, ien, row = settings.aoData[rowIdx],
                        cellWrite = function(cell, col) {
                            for (; cell.childNodes.length;) cell.removeChild(cell.firstChild);
                            cell.innerHTML = _fnGetCellData(settings, rowIdx, col, "display")
                        };
                    if ("dom" !== src && (src && "auto" !== src || "dom" !== row.src)) {
                        var cells = row.anCells;
                        if (cells)
                            if (colIdx !== undefined) cellWrite(cells[colIdx], colIdx);
                            else
                                for (i = 0, ien = cells.length; i < ien; i++) cellWrite(cells[i], i)
                    } else row._aData = _fnGetRowElements(settings, row, colIdx, colIdx === undefined ? undefined : row._aData).data;
                    row._aSortData = null, row._aFilterData = null;
                    var cols = settings.aoColumns;
                    if (colIdx !== undefined) cols[colIdx].sType = null;
                    else {
                        for (i = 0, ien = cols.length; i < ien; i++) cols[i].sType = null;
                        _fnRowAttributes(settings, row)
                    }
                }

                function _fnGetRowElements(settings, row, colIdx, d) {
                    var name, col, contents, tds = [],
                        td = row.firstChild,
                        i = 0,
                        columns = settings.aoColumns,
                        objectRead = settings._rowReadObject;
                    d = d !== undefined ? d : objectRead ? {} : [];
                    var attr = function(str, td) {
                            if ("string" == typeof str) {
                                var idx = str.indexOf("@");
                                if (-1 !== idx) {
                                    var attr = str.substring(idx + 1);
                                    _fnSetObjectDataFn(str)(d, td.getAttribute(attr))
                                }
                            }
                        },
                        cellProcess = function(cell) {
                            colIdx !== undefined && colIdx !== i || (col = columns[i], contents = $.trim(cell.innerHTML), col && col._bAttrSrc ? (_fnSetObjectDataFn(col.mData._)(d, contents), attr(col.mData.sort, cell), attr(col.mData.type, cell), attr(col.mData.filter, cell)) : objectRead ? (col._setter || (col._setter = _fnSetObjectDataFn(col.mData)), col._setter(d, contents)) : d[i] = contents);
                            i++
                        };
                    if (td)
                        for (; td;) "TD" != (name = td.nodeName.toUpperCase()) && "TH" != name || (cellProcess(td), tds.push(td)), td = td.nextSibling;
                    else
                        for (var j = 0, jen = (tds = row.anCells).length; j < jen; j++) cellProcess(tds[j]);
                    var rowNode = row.firstChild ? row : row.nTr;
                    if (rowNode) {
                        var id = rowNode.getAttribute("id");
                        id && _fnSetObjectDataFn(settings.rowId)(d, id)
                    }
                    return {
                        data: d,
                        cells: tds
                    }
                }

                function _fnCreateTr(oSettings, iRow, nTrIn, anTds) {
                    var nTr, nTd, oCol, i, iLen, row = oSettings.aoData[iRow],
                        rowData = row._aData,
                        cells = [];
                    if (null === row.nTr) {
                        for (nTr = nTrIn || document.createElement("tr"), row.nTr = nTr, row.anCells = cells, nTr._DT_RowIndex = iRow, _fnRowAttributes(oSettings, row), i = 0, iLen = oSettings.aoColumns.length; i < iLen; i++) oCol = oSettings.aoColumns[i], (nTd = nTrIn ? anTds[i] : document.createElement(oCol.sCellType))._DT_CellIndex = {
                            row: iRow,
                            column: i
                        }, cells.push(nTd), nTrIn && !oCol.mRender && oCol.mData === i || $.isPlainObject(oCol.mData) && oCol.mData._ === i + ".display" || (nTd.innerHTML = _fnGetCellData(oSettings, iRow, i, "display")), oCol.sClass && (nTd.className += " " + oCol.sClass), oCol.bVisible && !nTrIn ? nTr.appendChild(nTd) : !oCol.bVisible && nTrIn && nTd.parentNode.removeChild(nTd), oCol.fnCreatedCell && oCol.fnCreatedCell.call(oSettings.oInstance, nTd, _fnGetCellData(oSettings, iRow, i), rowData, iRow, i);
                        _fnCallbackFire(oSettings, "aoRowCreatedCallback", null, [nTr, rowData, iRow, cells])
                    }
                    row.nTr.setAttribute("role", "row")
                }

                function _fnRowAttributes(settings, row) {
                    var tr = row.nTr,
                        data = row._aData;
                    if (tr) {
                        var id = settings.rowIdFn(data);
                        if (id && (tr.id = id), data.DT_RowClass) {
                            var a = data.DT_RowClass.split(" ");
                            row.__rowc = row.__rowc ? _unique(row.__rowc.concat(a)) : a, $(tr).removeClass(row.__rowc.join(" ")).addClass(data.DT_RowClass)
                        }
                        data.DT_RowAttr && $(tr).attr(data.DT_RowAttr), data.DT_RowData && $(tr).data(data.DT_RowData)
                    }
                }

                function _fnBuildHead(oSettings) {
                    var i, ien, cell, row, column, thead = oSettings.nTHead,
                        tfoot = oSettings.nTFoot,
                        createHeader = 0 === $("th, td", thead).length,
                        classes = oSettings.oClasses,
                        columns = oSettings.aoColumns;
                    for (createHeader && (row = $("<tr/>").appendTo(thead)), i = 0, ien = columns.length; i < ien; i++) column = columns[i], cell = $(column.nTh).addClass(column.sClass), createHeader && cell.appendTo(row), oSettings.oFeatures.bSort && (cell.addClass(column.sSortingClass), !1 !== column.bSortable && (cell.attr("tabindex", oSettings.iTabIndex).attr("aria-controls", oSettings.sTableId), _fnSortAttachListener(oSettings, column.nTh, i))), column.sTitle != cell[0].innerHTML && cell.html(column.sTitle), _fnRenderer(oSettings, "header")(oSettings, cell, column, classes);
                    if (createHeader && _fnDetectHeader(oSettings.aoHeader, thead), $(thead).find(">tr").attr("role", "row"), $(thead).find(">tr>th, >tr>td").addClass(classes.sHeaderTH), $(tfoot).find(">tr>th, >tr>td").addClass(classes.sFooterTH), null !== tfoot) {
                        var cells = oSettings.aoFooter[0];
                        for (i = 0, ien = cells.length; i < ien; i++)(column = columns[i]).nTf = cells[i].cell, column.sClass && $(column.nTf).addClass(column.sClass)
                    }
                }

                function _fnDrawHead(oSettings, aoSource, bIncludeHidden) {
                    var i, iLen, j, jLen, k, n, nLocalTr, iRowspan, iColspan, aoLocal = [],
                        aApplied = [],
                        iColumns = oSettings.aoColumns.length;
                    if (aoSource) {
                        for (bIncludeHidden === undefined && (bIncludeHidden = !1), i = 0, iLen = aoSource.length; i < iLen; i++) {
                            for (aoLocal[i] = aoSource[i].slice(), aoLocal[i].nTr = aoSource[i].nTr, j = iColumns - 1; j >= 0; j--) oSettings.aoColumns[j].bVisible || bIncludeHidden || aoLocal[i].splice(j, 1);
                            aApplied.push([])
                        }
                        for (i = 0, iLen = aoLocal.length; i < iLen; i++) {
                            if (nLocalTr = aoLocal[i].nTr)
                                for (; n = nLocalTr.firstChild;) nLocalTr.removeChild(n);
                            for (j = 0, jLen = aoLocal[i].length; j < jLen; j++)
                                if (iRowspan = 1, iColspan = 1, aApplied[i][j] === undefined) {
                                    for (nLocalTr.appendChild(aoLocal[i][j].cell), aApplied[i][j] = 1; aoLocal[i + iRowspan] !== undefined && aoLocal[i][j].cell == aoLocal[i + iRowspan][j].cell;) aApplied[i + iRowspan][j] = 1, iRowspan++;
                                    for (; aoLocal[i][j + iColspan] !== undefined && aoLocal[i][j].cell == aoLocal[i][j + iColspan].cell;) {
                                        for (k = 0; k < iRowspan; k++) aApplied[i + k][j + iColspan] = 1;
                                        iColspan++
                                    }
                                    $(aoLocal[i][j].cell).attr("rowspan", iRowspan).attr("colspan", iColspan)
                                }
                        }
                    }
                }

                function _fnDraw(oSettings) {
                    var aPreDraw = _fnCallbackFire(oSettings, "aoPreDrawCallback", "preDraw", [oSettings]);
                    if (-1 === $.inArray(!1, aPreDraw)) {
                        var anRows = [],
                            iRowCount = 0,
                            asStripeClasses = oSettings.asStripeClasses,
                            iStripes = asStripeClasses.length,
                            oLang = (oSettings.aoOpenRows.length, oSettings.oLanguage),
                            iInitDisplayStart = oSettings.iInitDisplayStart,
                            bServerSide = "ssp" == _fnDataSource(oSettings),
                            aiDisplay = oSettings.aiDisplay;
                        oSettings.bDrawing = !0, iInitDisplayStart !== undefined && -1 !== iInitDisplayStart && (oSettings._iDisplayStart = bServerSide ? iInitDisplayStart : iInitDisplayStart >= oSettings.fnRecordsDisplay() ? 0 : iInitDisplayStart, oSettings.iInitDisplayStart = -1);
                        var iDisplayStart = oSettings._iDisplayStart,
                            iDisplayEnd = oSettings.fnDisplayEnd();
                        if (oSettings.bDeferLoading) oSettings.bDeferLoading = !1, oSettings.iDraw++, _fnProcessingDisplay(oSettings, !1);
                        else if (bServerSide) {
                            if (!oSettings.bDestroying && !_fnAjaxUpdate(oSettings)) return
                        } else oSettings.iDraw++;
                        if (0 !== aiDisplay.length)
                            for (var iStart = bServerSide ? 0 : iDisplayStart, iEnd = bServerSide ? oSettings.aoData.length : iDisplayEnd, j = iStart; j < iEnd; j++) {
                                var iDataIndex = aiDisplay[j],
                                    aoData = oSettings.aoData[iDataIndex];
                                null === aoData.nTr && _fnCreateTr(oSettings, iDataIndex);
                                var nRow = aoData.nTr;
                                if (0 !== iStripes) {
                                    var sStripe = asStripeClasses[iRowCount % iStripes];
                                    aoData._sRowStripe != sStripe && ($(nRow).removeClass(aoData._sRowStripe).addClass(sStripe), aoData._sRowStripe = sStripe)
                                }
                                _fnCallbackFire(oSettings, "aoRowCallback", null, [nRow, aoData._aData, iRowCount, j, iDataIndex]), anRows.push(nRow), iRowCount++
                            } else {
                                var sZero = oLang.sZeroRecords;
                                1 == oSettings.iDraw && "ajax" == _fnDataSource(oSettings) ? sZero = oLang.sLoadingRecords : oLang.sEmptyTable && 0 === oSettings.fnRecordsTotal() && (sZero = oLang.sEmptyTable), anRows[0] = $("<tr/>", {
                                    class: iStripes ? asStripeClasses[0] : ""
                                }).append($("<td />", {
                                    valign: "top",
                                    colSpan: _fnVisbleColumns(oSettings),
                                    class: oSettings.oClasses.sRowEmpty
                                }).html(sZero))[0]
                            }
                        _fnCallbackFire(oSettings, "aoHeaderCallback", "header", [$(oSettings.nTHead).children("tr")[0], _fnGetDataMaster(oSettings), iDisplayStart, iDisplayEnd, aiDisplay]), _fnCallbackFire(oSettings, "aoFooterCallback", "footer", [$(oSettings.nTFoot).children("tr")[0], _fnGetDataMaster(oSettings), iDisplayStart, iDisplayEnd, aiDisplay]);
                        var body = $(oSettings.nTBody);
                        body.children().detach(), body.append($(anRows)), _fnCallbackFire(oSettings, "aoDrawCallback", "draw", [oSettings]), oSettings.bSorted = !1, oSettings.bFiltered = !1, oSettings.bDrawing = !1
                    } else _fnProcessingDisplay(oSettings, !1)
                }

                function _fnReDraw(settings, holdPosition) {
                    var features = settings.oFeatures,
                        sort = features.bSort,
                        filter = features.bFilter;
                    sort && _fnSort(settings), filter ? _fnFilterComplete(settings, settings.oPreviousSearch) : settings.aiDisplay = settings.aiDisplayMaster.slice(), !0 !== holdPosition && (settings._iDisplayStart = 0), settings._drawHold = holdPosition, _fnDraw(settings), settings._drawHold = !1
                }

                function _fnAddOptionsHtml(oSettings) {
                    var classes = oSettings.oClasses,
                        table = $(oSettings.nTable),
                        holding = $("<div/>").insertBefore(table),
                        features = oSettings.oFeatures,
                        insert = $("<div/>", {
                            id: oSettings.sTableId + "_wrapper",
                            class: classes.sWrapper + (oSettings.nTFoot ? "" : " " + classes.sNoFooter)
                        });
                    oSettings.nHolding = holding[0], oSettings.nTableWrapper = insert[0], oSettings.nTableReinsertBefore = oSettings.nTable.nextSibling;
                    for (var featureNode, cOption, nNewNode, cNext, sAttr, j, aDom = oSettings.sDom.split(""), i = 0; i < aDom.length; i++) {
                        if (featureNode = null, "<" == (cOption = aDom[i])) {
                            if (nNewNode = $("<div/>")[0], "'" == (cNext = aDom[i + 1]) || '"' == cNext) {
                                for (sAttr = "", j = 2; aDom[i + j] != cNext;) sAttr += aDom[i + j], j++;
                                if ("H" == sAttr ? sAttr = classes.sJUIHeader : "F" == sAttr && (sAttr = classes.sJUIFooter), -1 != sAttr.indexOf(".")) {
                                    var aSplit = sAttr.split(".");
                                    nNewNode.id = aSplit[0].substr(1, aSplit[0].length - 1), nNewNode.className = aSplit[1]
                                } else "#" == sAttr.charAt(0) ? nNewNode.id = sAttr.substr(1, sAttr.length - 1) : nNewNode.className = sAttr;
                                i += j
                            }
                            insert.append(nNewNode), insert = $(nNewNode)
                        } else if (">" == cOption) insert = insert.parent();
                        else if ("l" == cOption && features.bPaginate && features.bLengthChange) featureNode = _fnFeatureHtmlLength(oSettings);
                        else if ("f" == cOption && features.bFilter) featureNode = _fnFeatureHtmlFilter(oSettings);
                        else if ("r" == cOption && features.bProcessing) featureNode = _fnFeatureHtmlProcessing(oSettings);
                        else if ("t" == cOption) featureNode = _fnFeatureHtmlTable(oSettings);
                        else if ("i" == cOption && features.bInfo) featureNode = _fnFeatureHtmlInfo(oSettings);
                        else if ("p" == cOption && features.bPaginate) featureNode = _fnFeatureHtmlPaginate(oSettings);
                        else if (0 !== DataTable.ext.feature.length)
                            for (var aoFeatures = DataTable.ext.feature, k = 0, kLen = aoFeatures.length; k < kLen; k++)
                                if (cOption == aoFeatures[k].cFeature) {
                                    featureNode = aoFeatures[k].fnInit(oSettings);
                                    break
                                }
                        if (featureNode) {
                            var aanFeatures = oSettings.aanFeatures;
                            aanFeatures[cOption] || (aanFeatures[cOption] = []), aanFeatures[cOption].push(featureNode), insert.append(featureNode)
                        }
                    }
                    holding.replaceWith(insert), oSettings.nHolding = null
                }

                function _fnDetectHeader(aLayout, nThead) {
                    var nTr, nCell, i, k, l, iLen, iColShifted, iColumn, iColspan, iRowspan, bUnique, nTrs = $(nThead).children("tr"),
                        fnShiftCol = function(a, i, j) {
                            for (var k = a[i]; k[j];) j++;
                            return j
                        };
                    for (aLayout.splice(0, aLayout.length), i = 0, iLen = nTrs.length; i < iLen; i++) aLayout.push([]);
                    for (i = 0, iLen = nTrs.length; i < iLen; i++)
                        for (iColumn = 0, nCell = (nTr = nTrs[i]).firstChild; nCell;) {
                            if ("TD" == nCell.nodeName.toUpperCase() || "TH" == nCell.nodeName.toUpperCase())
                                for (iColspan = (iColspan = 1 * nCell.getAttribute("colspan")) && 0 !== iColspan && 1 !== iColspan ? iColspan : 1, iRowspan = (iRowspan = 1 * nCell.getAttribute("rowspan")) && 0 !== iRowspan && 1 !== iRowspan ? iRowspan : 1, iColShifted = fnShiftCol(aLayout, i, iColumn), bUnique = 1 === iColspan, l = 0; l < iColspan; l++)
                                    for (k = 0; k < iRowspan; k++) aLayout[i + k][iColShifted + l] = {
                                        cell: nCell,
                                        unique: bUnique
                                    }, aLayout[i + k].nTr = nTr;
                            nCell = nCell.nextSibling
                        }
                }

                function _fnGetUniqueThs(oSettings, nHeader, aLayout) {
                    var aReturn = [];
                    aLayout || (aLayout = oSettings.aoHeader, nHeader && _fnDetectHeader(aLayout = [], nHeader));
                    for (var i = 0, iLen = aLayout.length; i < iLen; i++)
                        for (var j = 0, jLen = aLayout[i].length; j < jLen; j++) !aLayout[i][j].unique || aReturn[j] && oSettings.bSortCellsTop || (aReturn[j] = aLayout[i][j].cell);
                    return aReturn
                }

                function _fnBuildAjax(oSettings, data, fn) {
                    if (_fnCallbackFire(oSettings, "aoServerParams", "serverParams", [data]), data && $.isArray(data)) {
                        var tmp = {},
                            rbracket = /(.*?)\[\]$/;
                        $.each(data, (function(key, val) {
                            var match = val.name.match(rbracket);
                            if (match) {
                                var name = match[0];
                                tmp[name] || (tmp[name] = []), tmp[name].push(val.value)
                            } else tmp[val.name] = val.value
                        })), data = tmp
                    }
                    var ajaxData, ajax = oSettings.ajax,
                        instance = oSettings.oInstance,
                        callback = function(json) {
                            _fnCallbackFire(oSettings, null, "xhr", [oSettings, json, oSettings.jqXHR]), fn(json)
                        };
                    if ($.isPlainObject(ajax) && ajax.data) {
                        var newData = "function" == typeof(ajaxData = ajax.data) ? ajaxData(data, oSettings) : ajaxData;
                        data = "function" == typeof ajaxData && newData ? newData : $.extend(!0, data, newData), delete ajax.data
                    }
                    var baseAjax = {
                        data: data,
                        success: function(json) {
                            var error = json.error || json.sError;
                            error && _fnLog(oSettings, 0, error), oSettings.json = json, callback(json)
                        },
                        dataType: "json",
                        cache: !1,
                        type: oSettings.sServerMethod,
                        error: function(xhr, error, thrown) {
                            var ret = _fnCallbackFire(oSettings, null, "xhr", [oSettings, null, oSettings.jqXHR]); - 1 === $.inArray(!0, ret) && ("parsererror" == error ? _fnLog(oSettings, 0, "Invalid JSON response", 1) : 4 === xhr.readyState && _fnLog(oSettings, 0, "Ajax error", 7)), _fnProcessingDisplay(oSettings, !1)
                        }
                    };
                    oSettings.oAjaxData = data, _fnCallbackFire(oSettings, null, "preXhr", [oSettings, data]), oSettings.fnServerData ? oSettings.fnServerData.call(instance, oSettings.sAjaxSource, $.map(data, (function(val, key) {
                        return {
                            name: key,
                            value: val
                        }
                    })), callback, oSettings) : oSettings.sAjaxSource || "string" == typeof ajax ? oSettings.jqXHR = $.ajax($.extend(baseAjax, {
                        url: ajax || oSettings.sAjaxSource
                    })) : "function" == typeof ajax ? oSettings.jqXHR = ajax.call(instance, data, callback, oSettings) : (oSettings.jqXHR = $.ajax($.extend(baseAjax, ajax)), ajax.data = ajaxData)
                }

                function _fnAjaxUpdate(settings) {
                    return !settings.bAjaxDataGet || (settings.iDraw++, _fnProcessingDisplay(settings, !0), _fnBuildAjax(settings, _fnAjaxParameters(settings), (function(json) {
                        _fnAjaxUpdateDraw(settings, json)
                    })), !1)
                }

                function _fnAjaxParameters(settings) {
                    var i, dataProp, column, columnSearch, columns = settings.aoColumns,
                        columnCount = columns.length,
                        features = settings.oFeatures,
                        preSearch = settings.oPreviousSearch,
                        preColSearch = settings.aoPreSearchCols,
                        data = [],
                        sort = _fnSortFlatten(settings),
                        displayStart = settings._iDisplayStart,
                        displayLength = !1 !== features.bPaginate ? settings._iDisplayLength : -1,
                        param = function(name, value) {
                            data.push({
                                name: name,
                                value: value
                            })
                        };
                    param("sEcho", settings.iDraw), param("iColumns", columnCount), param("sColumns", _pluck(columns, "sName").join(",")), param("iDisplayStart", displayStart), param("iDisplayLength", displayLength);
                    var d = {
                        draw: settings.iDraw,
                        columns: [],
                        order: [],
                        start: displayStart,
                        length: displayLength,
                        search: {
                            value: preSearch.sSearch,
                            regex: preSearch.bRegex
                        }
                    };
                    for (i = 0; i < columnCount; i++) column = columns[i], columnSearch = preColSearch[i], dataProp = "function" == typeof column.mData ? "function" : column.mData, d.columns.push({
                        data: dataProp,
                        name: column.sName,
                        searchable: column.bSearchable,
                        orderable: column.bSortable,
                        search: {
                            value: columnSearch.sSearch,
                            regex: columnSearch.bRegex
                        }
                    }), param("mDataProp_" + i, dataProp), features.bFilter && (param("sSearch_" + i, columnSearch.sSearch), param("bRegex_" + i, columnSearch.bRegex), param("bSearchable_" + i, column.bSearchable)), features.bSort && param("bSortable_" + i, column.bSortable);
                    features.bFilter && (param("sSearch", preSearch.sSearch), param("bRegex", preSearch.bRegex)), features.bSort && ($.each(sort, (function(i, val) {
                        d.order.push({
                            column: val.col,
                            dir: val.dir
                        }), param("iSortCol_" + i, val.col), param("sSortDir_" + i, val.dir)
                    })), param("iSortingCols", sort.length));
                    var legacy = DataTable.ext.legacy.ajax;
                    return null === legacy ? settings.sAjaxSource ? data : d : legacy ? data : d
                }

                function _fnAjaxUpdateDraw(settings, json) {
                    var compat = function(old, modern) {
                            return json[old] !== undefined ? json[old] : json[modern]
                        },
                        data = _fnAjaxDataSrc(settings, json),
                        draw = compat("sEcho", "draw"),
                        recordsTotal = compat("iTotalRecords", "recordsTotal"),
                        recordsFiltered = compat("iTotalDisplayRecords", "recordsFiltered");
                    if (draw) {
                        if (1 * draw < settings.iDraw) return;
                        settings.iDraw = 1 * draw
                    }
                    _fnClearTable(settings), settings._iRecordsTotal = parseInt(recordsTotal, 10), settings._iRecordsDisplay = parseInt(recordsFiltered, 10);
                    for (var i = 0, ien = data.length; i < ien; i++) _fnAddData(settings, data[i]);
                    settings.aiDisplay = settings.aiDisplayMaster.slice(), settings.bAjaxDataGet = !1, _fnDraw(settings), settings._bInitComplete || _fnInitComplete(settings, json), settings.bAjaxDataGet = !0, _fnProcessingDisplay(settings, !1)
                }

                function _fnAjaxDataSrc(oSettings, json) {
                    var dataSrc = $.isPlainObject(oSettings.ajax) && oSettings.ajax.dataSrc !== undefined ? oSettings.ajax.dataSrc : oSettings.sAjaxDataProp;
                    return "data" === dataSrc ? json.aaData || json[dataSrc] : "" !== dataSrc ? _fnGetObjectDataFn(dataSrc)(json) : json
                }

                function _fnFeatureHtmlFilter(settings) {
                    var classes = settings.oClasses,
                        tableId = settings.sTableId,
                        language = settings.oLanguage,
                        previousSearch = settings.oPreviousSearch,
                        features = settings.aanFeatures,
                        input = '<input type="search" class="' + classes.sFilterInput + '"/>',
                        str = language.sSearch;
                    str = str.match(/_INPUT_/) ? str.replace("_INPUT_", input) : str + input;
                    var filter = $("<div/>", {
                            id: features.f ? null : tableId + "_filter",
                            class: classes.sFilter
                        }).append($("<label/>").append(str)),
                        searchFn = function() {
                            features.f;
                            var val = this.value ? this.value : "";
                            val != previousSearch.sSearch && (_fnFilterComplete(settings, {
                                sSearch: val,
                                bRegex: previousSearch.bRegex,
                                bSmart: previousSearch.bSmart,
                                bCaseInsensitive: previousSearch.bCaseInsensitive
                            }), settings._iDisplayStart = 0, _fnDraw(settings))
                        },
                        searchDelay = null !== settings.searchDelay ? settings.searchDelay : "ssp" === _fnDataSource(settings) ? 400 : 0,
                        jqFilter = $("input", filter).val(previousSearch.sSearch).attr("placeholder", language.sSearchPlaceholder).on("keyup.DT search.DT input.DT paste.DT cut.DT", searchDelay ? _fnThrottle(searchFn, searchDelay) : searchFn).on("keypress.DT", (function(e) {
                            if (13 == e.keyCode) return !1
                        })).attr("aria-controls", tableId);
                    return $(settings.nTable).on("search.dt.DT", (function(ev, s) {
                        if (settings === s) try {
                            jqFilter[0] !== document.activeElement && jqFilter.val(previousSearch.sSearch)
                        } catch (e) {}
                    })), filter[0]
                }

                function _fnFilterComplete(oSettings, oInput, iForce) {
                    var oPrevSearch = oSettings.oPreviousSearch,
                        aoPrevSearch = oSettings.aoPreSearchCols,
                        fnSaveFilter = function(oFilter) {
                            oPrevSearch.sSearch = oFilter.sSearch, oPrevSearch.bRegex = oFilter.bRegex, oPrevSearch.bSmart = oFilter.bSmart, oPrevSearch.bCaseInsensitive = oFilter.bCaseInsensitive
                        },
                        fnRegex = function(o) {
                            return o.bEscapeRegex !== undefined ? !o.bEscapeRegex : o.bRegex
                        };
                    if (_fnColumnTypes(oSettings), "ssp" != _fnDataSource(oSettings)) {
                        _fnFilter(oSettings, oInput.sSearch, iForce, fnRegex(oInput), oInput.bSmart, oInput.bCaseInsensitive), fnSaveFilter(oInput);
                        for (var i = 0; i < aoPrevSearch.length; i++) _fnFilterColumn(oSettings, aoPrevSearch[i].sSearch, i, fnRegex(aoPrevSearch[i]), aoPrevSearch[i].bSmart, aoPrevSearch[i].bCaseInsensitive);
                        _fnFilterCustom(oSettings)
                    } else fnSaveFilter(oInput);
                    oSettings.bFiltered = !0, _fnCallbackFire(oSettings, null, "search", [oSettings])
                }

                function _fnFilterCustom(settings) {
                    for (var row, rowIdx, filters = DataTable.ext.search, displayRows = settings.aiDisplay, i = 0, ien = filters.length; i < ien; i++) {
                        for (var rows = [], j = 0, jen = displayRows.length; j < jen; j++) rowIdx = displayRows[j], row = settings.aoData[rowIdx], filters[i](settings, row._aFilterData, rowIdx, row._aData, j) && rows.push(rowIdx);
                        displayRows.length = 0, $.merge(displayRows, rows)
                    }
                }

                function _fnFilterColumn(settings, searchStr, colIdx, regex, smart, caseInsensitive) {
                    if ("" !== searchStr) {
                        for (var data, out = [], display = settings.aiDisplay, rpSearch = _fnFilterCreateSearch(searchStr, regex, smart, caseInsensitive), i = 0; i < display.length; i++) data = settings.aoData[display[i]]._aFilterData[colIdx], rpSearch.test(data) && out.push(display[i]);
                        settings.aiDisplay = out
                    }
                }

                function _fnFilter(settings, input, force, regex, smart, caseInsensitive) {
                    var display, invalidated, i, rpSearch = _fnFilterCreateSearch(input, regex, smart, caseInsensitive),
                        prevSearch = settings.oPreviousSearch.sSearch,
                        displayMaster = settings.aiDisplayMaster,
                        filtered = [];
                    if (0 !== DataTable.ext.search.length && (force = !0), invalidated = _fnFilterData(settings), input.length <= 0) settings.aiDisplay = displayMaster.slice();
                    else {
                        for ((invalidated || force || prevSearch.length > input.length || 0 !== input.indexOf(prevSearch) || settings.bSorted) && (settings.aiDisplay = displayMaster.slice()), display = settings.aiDisplay, i = 0; i < display.length; i++) rpSearch.test(settings.aoData[display[i]]._sFilterRow) && filtered.push(display[i]);
                        settings.aiDisplay = filtered
                    }
                }

                function _fnFilterCreateSearch(search, regex, smart, caseInsensitive) {
                    if (search = regex ? search : _fnEscapeRegex(search), smart) {
                        var a = $.map(search.match(/"[^"]+"|[^ ]+/g) || [""], (function(word) {
                            if ('"' === word.charAt(0)) {
                                var m = word.match(/^"(.*)"$/);
                                word = m ? m[1] : word
                            }
                            return word.replace('"', "")
                        }));
                        search = "^(?=.*?" + a.join(")(?=.*?") + ").*$"
                    }
                    return new RegExp(search, caseInsensitive ? "i" : "")
                }
                var _fnEscapeRegex = DataTable.util.escapeRegex,
                    __filter_div = $("<div>")[0],
                    __filter_div_textContent = __filter_div.textContent !== undefined;

                function _fnFilterData(settings) {
                    var column, i, j, ien, jen, filterData, cellData, row, columns = settings.aoColumns,
                        fomatters = DataTable.ext.type.search,
                        wasInvalidated = !1;
                    for (i = 0, ien = settings.aoData.length; i < ien; i++)
                        if (!(row = settings.aoData[i])._aFilterData) {
                            for (filterData = [], j = 0, jen = columns.length; j < jen; j++)(column = columns[j]).bSearchable ? (cellData = _fnGetCellData(settings, i, j, "filter"), fomatters[column.sType] && (cellData = fomatters[column.sType](cellData)), null === cellData && (cellData = ""), "string" != typeof cellData && cellData.toString && (cellData = cellData.toString())) : cellData = "", cellData.indexOf && -1 !== cellData.indexOf("&") && (__filter_div.innerHTML = cellData, cellData = __filter_div_textContent ? __filter_div.textContent : __filter_div.innerText), cellData.replace && (cellData = cellData.replace(/[\r\n]/g, "")), filterData.push(cellData);
                            row._aFilterData = filterData, row._sFilterRow = filterData.join("  "), wasInvalidated = !0
                        }
                    return wasInvalidated
                }

                function _fnSearchToCamel(obj) {
                    return {
                        search: obj.sSearch,
                        smart: obj.bSmart,
                        regex: obj.bRegex,
                        caseInsensitive: obj.bCaseInsensitive
                    }
                }

                function _fnSearchToHung(obj) {
                    return {
                        sSearch: obj.search,
                        bSmart: obj.smart,
                        bRegex: obj.regex,
                        bCaseInsensitive: obj.caseInsensitive
                    }
                }

                function _fnFeatureHtmlInfo(settings) {
                    var tid = settings.sTableId,
                        nodes = settings.aanFeatures.i,
                        n = $("<div/>", {
                            class: settings.oClasses.sInfo,
                            id: nodes ? null : tid + "_info"
                        });
                    return nodes || (settings.aoDrawCallback.push({
                        fn: _fnUpdateInfo,
                        sName: "information"
                    }), n.attr("role", "status").attr("aria-live", "polite"), $(settings.nTable).attr("aria-describedby", tid + "_info")), n[0]
                }

                function _fnUpdateInfo(settings) {
                    var nodes = settings.aanFeatures.i;
                    if (0 !== nodes.length) {
                        var lang = settings.oLanguage,
                            start = settings._iDisplayStart + 1,
                            end = settings.fnDisplayEnd(),
                            max = settings.fnRecordsTotal(),
                            total = settings.fnRecordsDisplay(),
                            out = total ? lang.sInfo : lang.sInfoEmpty;
                        total !== max && (out += " " + lang.sInfoFiltered), out = _fnInfoMacros(settings, out += lang.sInfoPostFix);
                        var callback = lang.fnInfoCallback;
                        null !== callback && (out = callback.call(settings.oInstance, settings, start, end, max, total, out)), $(nodes).html(out)
                    }
                }

                function _fnInfoMacros(settings, str) {
                    var formatter = settings.fnFormatNumber,
                        start = settings._iDisplayStart + 1,
                        len = settings._iDisplayLength,
                        vis = settings.fnRecordsDisplay(),
                        all = -1 === len;
                    return str.replace(/_START_/g, formatter.call(settings, start)).replace(/_END_/g, formatter.call(settings, settings.fnDisplayEnd())).replace(/_MAX_/g, formatter.call(settings, settings.fnRecordsTotal())).replace(/_TOTAL_/g, formatter.call(settings, vis)).replace(/_PAGE_/g, formatter.call(settings, all ? 1 : Math.ceil(start / len))).replace(/_PAGES_/g, formatter.call(settings, all ? 1 : Math.ceil(vis / len)))
                }

                function _fnInitialise(settings) {
                    var i, iLen, column, iAjaxStart = settings.iInitDisplayStart,
                        columns = settings.aoColumns,
                        features = settings.oFeatures,
                        deferLoading = settings.bDeferLoading;
                    if (settings.bInitialised) {
                        for (_fnAddOptionsHtml(settings), _fnBuildHead(settings), _fnDrawHead(settings, settings.aoHeader), _fnDrawHead(settings, settings.aoFooter), _fnProcessingDisplay(settings, !0), features.bAutoWidth && _fnCalculateColumnWidths(settings), i = 0, iLen = columns.length; i < iLen; i++)(column = columns[i]).sWidth && (column.nTh.style.width = _fnStringToCss(column.sWidth));
                        _fnCallbackFire(settings, null, "preInit", [settings]), _fnReDraw(settings);
                        var dataSrc = _fnDataSource(settings);
                        ("ssp" != dataSrc || deferLoading) && ("ajax" == dataSrc ? _fnBuildAjax(settings, [], (function(json) {
                            var aData = _fnAjaxDataSrc(settings, json);
                            for (i = 0; i < aData.length; i++) _fnAddData(settings, aData[i]);
                            settings.iInitDisplayStart = iAjaxStart, _fnReDraw(settings), _fnProcessingDisplay(settings, !1), _fnInitComplete(settings, json)
                        }), settings) : (_fnProcessingDisplay(settings, !1), _fnInitComplete(settings)))
                    } else setTimeout((function() {
                        _fnInitialise(settings)
                    }), 200)
                }

                function _fnInitComplete(settings, json) {
                    settings._bInitComplete = !0, (json || settings.oInit.aaData) && _fnAdjustColumnSizing(settings), _fnCallbackFire(settings, null, "plugin-init", [settings, json]), _fnCallbackFire(settings, "aoInitComplete", "init", [settings, json])
                }

                function _fnLengthChange(settings, val) {
                    var len = parseInt(val, 10);
                    settings._iDisplayLength = len, _fnLengthOverflow(settings), _fnCallbackFire(settings, null, "length", [settings, len])
                }

                function _fnFeatureHtmlLength(settings) {
                    for (var classes = settings.oClasses, tableId = settings.sTableId, menu = settings.aLengthMenu, d2 = $.isArray(menu[0]), lengths = d2 ? menu[0] : menu, language = d2 ? menu[1] : menu, select = $("<select/>", {
                            name: tableId + "_length",
                            "aria-controls": tableId,
                            class: classes.sLengthSelect
                        }), i = 0, ien = lengths.length; i < ien; i++) select[0][i] = new Option("number" == typeof language[i] ? settings.fnFormatNumber(language[i]) : language[i], lengths[i]);
                    var div = $("<div><label/></div>").addClass(classes.sLength);
                    return settings.aanFeatures.l || (div[0].id = tableId + "_length"), div.children().append(settings.oLanguage.sLengthMenu.replace("_MENU_", select[0].outerHTML)), $("select", div).val(settings._iDisplayLength).on("change.DT", (function(e) {
                        _fnLengthChange(settings, $(this).val()), _fnDraw(settings)
                    })), $(settings.nTable).on("length.dt.DT", (function(e, s, len) {
                        settings === s && $("select", div).val(len)
                    })), div[0]
                }

                function _fnFeatureHtmlPaginate(settings) {
                    var type = settings.sPaginationType,
                        plugin = DataTable.ext.pager[type],
                        modern = "function" == typeof plugin,
                        redraw = function(settings) {
                            _fnDraw(settings)
                        },
                        node = $("<div/>").addClass(settings.oClasses.sPaging + type)[0],
                        features = settings.aanFeatures;
                    return modern || plugin.fnInit(settings, node, redraw), features.p || (node.id = settings.sTableId + "_paginate", settings.aoDrawCallback.push({
                        fn: function(settings) {
                            if (modern) {
                                var i, ien, start = settings._iDisplayStart,
                                    len = settings._iDisplayLength,
                                    visRecords = settings.fnRecordsDisplay(),
                                    all = -1 === len,
                                    page = all ? 0 : Math.ceil(start / len),
                                    pages = all ? 1 : Math.ceil(visRecords / len),
                                    buttons = plugin(page, pages);
                                for (i = 0, ien = features.p.length; i < ien; i++) _fnRenderer(settings, "pageButton")(settings, features.p[i], i, buttons, page, pages)
                            } else plugin.fnUpdate(settings, redraw)
                        },
                        sName: "pagination"
                    })), node
                }

                function _fnPageChange(settings, action, redraw) {
                    var start = settings._iDisplayStart,
                        len = settings._iDisplayLength,
                        records = settings.fnRecordsDisplay();
                    0 === records || -1 === len ? start = 0 : "number" == typeof action ? (start = action * len) > records && (start = 0) : "first" == action ? start = 0 : "previous" == action ? (start = len >= 0 ? start - len : 0) < 0 && (start = 0) : "next" == action ? start + len < records && (start += len) : "last" == action ? start = Math.floor((records - 1) / len) * len : _fnLog(settings, 0, "Unknown paging action: " + action, 5);
                    var changed = settings._iDisplayStart !== start;
                    return settings._iDisplayStart = start, changed && (_fnCallbackFire(settings, null, "page", [settings]), redraw && _fnDraw(settings)), changed
                }

                function _fnFeatureHtmlProcessing(settings) {
                    return $("<div/>", {
                        id: settings.aanFeatures.r ? null : settings.sTableId + "_processing",
                        class: settings.oClasses.sProcessing
                    }).html(settings.oLanguage.sProcessing).insertBefore(settings.nTable)[0]
                }

                function _fnProcessingDisplay(settings, show) {
                    settings.oFeatures.bProcessing && $(settings.aanFeatures.r).css("display", show ? "block" : "none"), _fnCallbackFire(settings, null, "processing", [settings, show])
                }

                function _fnFeatureHtmlTable(settings) {
                    var table = $(settings.nTable);
                    table.attr("role", "grid");
                    var scroll = settings.oScroll;
                    if ("" === scroll.sX && "" === scroll.sY) return settings.nTable;
                    var scrollX = scroll.sX,
                        scrollY = scroll.sY,
                        classes = settings.oClasses,
                        caption = table.children("caption"),
                        captionSide = caption.length ? caption[0]._captionSide : null,
                        headerClone = $(table[0].cloneNode(!1)),
                        footerClone = $(table[0].cloneNode(!1)),
                        footer = table.children("tfoot"),
                        _div = "<div/>",
                        size = function(s) {
                            return s ? _fnStringToCss(s) : null
                        };
                    footer.length || (footer = null);
                    var scroller = $(_div, {
                        class: classes.sScrollWrapper
                    }).append($(_div, {
                        class: classes.sScrollHead
                    }).css({
                        overflow: "hidden",
                        position: "relative",
                        border: 0,
                        width: scrollX ? size(scrollX) : "100%"
                    }).append($(_div, {
                        class: classes.sScrollHeadInner
                    }).css({
                        "box-sizing": "content-box",
                        width: scroll.sXInner || "100%"
                    }).append(headerClone.removeAttr("id").css("margin-left", 0).append("top" === captionSide ? caption : null).append(table.children("thead"))))).append($(_div, {
                        class: classes.sScrollBody
                    }).css({
                        position: "relative",
                        overflow: "auto",
                        width: size(scrollX)
                    }).append(table));
                    footer && scroller.append($(_div, {
                        class: classes.sScrollFoot
                    }).css({
                        overflow: "hidden",
                        border: 0,
                        width: scrollX ? size(scrollX) : "100%"
                    }).append($(_div, {
                        class: classes.sScrollFootInner
                    }).append(footerClone.removeAttr("id").css("margin-left", 0).append("bottom" === captionSide ? caption : null).append(table.children("tfoot")))));
                    var children = scroller.children(),
                        scrollHead = children[0],
                        scrollBody = children[1],
                        scrollFoot = footer ? children[2] : null;
                    return scrollX && $(scrollBody).on("scroll.DT", (function(e) {
                        var scrollLeft = this.scrollLeft;
                        scrollHead.scrollLeft = scrollLeft, footer && (scrollFoot.scrollLeft = scrollLeft)
                    })), $(scrollBody).css(scrollY && scroll.bCollapse ? "max-height" : "height", scrollY), settings.nScrollHead = scrollHead, settings.nScrollBody = scrollBody, settings.nScrollFoot = scrollFoot, settings.aoDrawCallback.push({
                        fn: _fnScrollDraw,
                        sName: "scrolling"
                    }), scroller[0]
                }

                function _fnScrollDraw(settings) {
                    var headerTrgEls, footerTrgEls, headerSrcEls, footerSrcEls, headerCopy, footerCopy, idx, correction, sanityWidth, scroll = settings.oScroll,
                        scrollX = scroll.sX,
                        scrollXInner = scroll.sXInner,
                        scrollY = scroll.sY,
                        barWidth = scroll.iBarWidth,
                        divHeader = $(settings.nScrollHead),
                        divHeaderStyle = divHeader[0].style,
                        divHeaderInner = divHeader.children("div"),
                        divHeaderInnerStyle = divHeaderInner[0].style,
                        divHeaderTable = divHeaderInner.children("table"),
                        divBodyEl = settings.nScrollBody,
                        divBody = $(divBodyEl),
                        divBodyStyle = divBodyEl.style,
                        divFooterInner = $(settings.nScrollFoot).children("div"),
                        divFooterTable = divFooterInner.children("table"),
                        header = $(settings.nTHead),
                        table = $(settings.nTable),
                        tableEl = table[0],
                        tableStyle = tableEl.style,
                        footer = settings.nTFoot ? $(settings.nTFoot) : null,
                        browser = settings.oBrowser,
                        ie67 = browser.bScrollOversize,
                        dtHeaderCells = _pluck(settings.aoColumns, "nTh"),
                        headerWidths = [],
                        footerWidths = [],
                        headerContent = [],
                        footerContent = [],
                        zeroOut = function(nSizer) {
                            var style = nSizer.style;
                            style.paddingTop = "0", style.paddingBottom = "0", style.borderTopWidth = "0", style.borderBottomWidth = "0", style.height = 0
                        },
                        scrollBarVis = divBodyEl.scrollHeight > divBodyEl.clientHeight;
                    if (settings.scrollBarVis !== scrollBarVis && settings.scrollBarVis !== undefined) return settings.scrollBarVis = scrollBarVis, void _fnAdjustColumnSizing(settings);
                    settings.scrollBarVis = scrollBarVis, table.children("thead, tfoot").remove(), footer && (footerCopy = footer.clone().prependTo(table), footerTrgEls = footer.find("tr"), footerSrcEls = footerCopy.find("tr")), headerCopy = header.clone().prependTo(table), headerTrgEls = header.find("tr"), headerSrcEls = headerCopy.find("tr"), headerCopy.find("th, td").removeAttr("tabindex"), scrollX || (divBodyStyle.width = "100%", divHeader[0].style.width = "100%"), $.each(_fnGetUniqueThs(settings, headerCopy), (function(i, el) {
                        idx = _fnVisibleToColumnIndex(settings, i), el.style.width = settings.aoColumns[idx].sWidth
                    })), footer && _fnApplyToChildren((function(n) {
                        n.style.width = ""
                    }), footerSrcEls), sanityWidth = table.outerWidth(), "" === scrollX ? (tableStyle.width = "100%", ie67 && (table.find("tbody").height() > divBodyEl.offsetHeight || "scroll" == divBody.css("overflow-y")) && (tableStyle.width = _fnStringToCss(table.outerWidth() - barWidth)), sanityWidth = table.outerWidth()) : "" !== scrollXInner && (tableStyle.width = _fnStringToCss(scrollXInner), sanityWidth = table.outerWidth()), _fnApplyToChildren(zeroOut, headerSrcEls), _fnApplyToChildren((function(nSizer) {
                        headerContent.push(nSizer.innerHTML), headerWidths.push(_fnStringToCss($(nSizer).css("width")))
                    }), headerSrcEls), _fnApplyToChildren((function(nToSize, i) {
                        -1 !== $.inArray(nToSize, dtHeaderCells) && (nToSize.style.width = headerWidths[i])
                    }), headerTrgEls), $(headerSrcEls).height(0), footer && (_fnApplyToChildren(zeroOut, footerSrcEls), _fnApplyToChildren((function(nSizer) {
                        footerContent.push(nSizer.innerHTML), footerWidths.push(_fnStringToCss($(nSizer).css("width")))
                    }), footerSrcEls), _fnApplyToChildren((function(nToSize, i) {
                        nToSize.style.width = footerWidths[i]
                    }), footerTrgEls), $(footerSrcEls).height(0)), _fnApplyToChildren((function(nSizer, i) {
                        nSizer.innerHTML = '<div class="dataTables_sizing">' + headerContent[i] + "</div>", nSizer.childNodes[0].style.height = "0", nSizer.childNodes[0].style.overflow = "hidden", nSizer.style.width = headerWidths[i]
                    }), headerSrcEls), footer && _fnApplyToChildren((function(nSizer, i) {
                        nSizer.innerHTML = '<div class="dataTables_sizing">' + footerContent[i] + "</div>", nSizer.childNodes[0].style.height = "0", nSizer.childNodes[0].style.overflow = "hidden", nSizer.style.width = footerWidths[i]
                    }), footerSrcEls), table.outerWidth() < sanityWidth ? (correction = divBodyEl.scrollHeight > divBodyEl.offsetHeight || "scroll" == divBody.css("overflow-y") ? sanityWidth + barWidth : sanityWidth, ie67 && (divBodyEl.scrollHeight > divBodyEl.offsetHeight || "scroll" == divBody.css("overflow-y")) && (tableStyle.width = _fnStringToCss(correction - barWidth)), "" !== scrollX && "" === scrollXInner || _fnLog(settings, 1, "Possible column misalignment", 6)) : correction = "100%", divBodyStyle.width = _fnStringToCss(correction), divHeaderStyle.width = _fnStringToCss(correction), footer && (settings.nScrollFoot.style.width = _fnStringToCss(correction)), scrollY || ie67 && (divBodyStyle.height = _fnStringToCss(tableEl.offsetHeight + barWidth));
                    var iOuterWidth = table.outerWidth();
                    divHeaderTable[0].style.width = _fnStringToCss(iOuterWidth), divHeaderInnerStyle.width = _fnStringToCss(iOuterWidth);
                    var bScrolling = table.height() > divBodyEl.clientHeight || "scroll" == divBody.css("overflow-y"),
                        padding = "padding" + (browser.bScrollbarLeft ? "Left" : "Right");
                    divHeaderInnerStyle[padding] = bScrolling ? barWidth + "px" : "0px", footer && (divFooterTable[0].style.width = _fnStringToCss(iOuterWidth), divFooterInner[0].style.width = _fnStringToCss(iOuterWidth), divFooterInner[0].style[padding] = bScrolling ? barWidth + "px" : "0px"), table.children("colgroup").insertBefore(table.children("thead")), divBody.scroll(), !settings.bSorted && !settings.bFiltered || settings._drawHold || (divBodyEl.scrollTop = 0)
                }

                function _fnApplyToChildren(fn, an1, an2) {
                    for (var nNode1, nNode2, index = 0, i = 0, iLen = an1.length; i < iLen;) {
                        for (nNode1 = an1[i].firstChild, nNode2 = an2 ? an2[i].firstChild : null; nNode1;) 1 === nNode1.nodeType && (an2 ? fn(nNode1, nNode2, index) : fn(nNode1, index), index++), nNode1 = nNode1.nextSibling, nNode2 = an2 ? nNode2.nextSibling : null;
                        i++
                    }
                }
                var __re_html_remove = /<.*?>/g;

                function _fnCalculateColumnWidths(oSettings) {
                    var i, column, columnIdx, table = oSettings.nTable,
                        columns = oSettings.aoColumns,
                        scroll = oSettings.oScroll,
                        scrollY = scroll.sY,
                        scrollX = scroll.sX,
                        scrollXInner = scroll.sXInner,
                        columnCount = columns.length,
                        visibleColumns = _fnGetColumns(oSettings, "bVisible"),
                        headerCells = $("th", oSettings.nTHead),
                        tableWidthAttr = table.getAttribute("width"),
                        tableContainer = table.parentNode,
                        userInputs = !1,
                        browser = oSettings.oBrowser,
                        ie67 = browser.bScrollOversize,
                        styleWidth = table.style.width;
                    for (styleWidth && -1 !== styleWidth.indexOf("%") && (tableWidthAttr = styleWidth), i = 0; i < visibleColumns.length; i++) null !== (column = columns[visibleColumns[i]]).sWidth && (column.sWidth = _fnConvertToWidth(column.sWidthOrig, tableContainer), userInputs = !0);
                    if (ie67 || !userInputs && !scrollX && !scrollY && columnCount == _fnVisbleColumns(oSettings) && columnCount == headerCells.length)
                        for (i = 0; i < columnCount; i++) {
                            var colIdx = _fnVisibleToColumnIndex(oSettings, i);
                            null !== colIdx && (columns[colIdx].sWidth = _fnStringToCss(headerCells.eq(i).width()))
                        } else {
                            var tmpTable = $(table).clone().css("visibility", "hidden").removeAttr("id");
                            tmpTable.find("tbody tr").remove();
                            var tr = $("<tr/>").appendTo(tmpTable.find("tbody"));
                            for (tmpTable.find("thead, tfoot").remove(), tmpTable.append($(oSettings.nTHead).clone()).append($(oSettings.nTFoot).clone()), tmpTable.find("tfoot th, tfoot td").css("width", ""), headerCells = _fnGetUniqueThs(oSettings, tmpTable.find("thead")[0]), i = 0; i < visibleColumns.length; i++) column = columns[visibleColumns[i]], headerCells[i].style.width = null !== column.sWidthOrig && "" !== column.sWidthOrig ? _fnStringToCss(column.sWidthOrig) : "", column.sWidthOrig && scrollX && $(headerCells[i]).append($("<div/>").css({
                                width: column.sWidthOrig,
                                margin: 0,
                                padding: 0,
                                border: 0,
                                height: 1
                            }));
                            if (oSettings.aoData.length)
                                for (i = 0; i < visibleColumns.length; i++) column = columns[columnIdx = visibleColumns[i]], $(_fnGetWidestNode(oSettings, columnIdx)).clone(!1).append(column.sContentPadding).appendTo(tr);
                            $("[name]", tmpTable).removeAttr("name");
                            var holder = $("<div/>").css(scrollX || scrollY ? {
                                position: "absolute",
                                top: 0,
                                left: 0,
                                height: 1,
                                right: 0,
                                overflow: "hidden"
                            } : {}).append(tmpTable).appendTo(tableContainer);
                            scrollX && scrollXInner ? tmpTable.width(scrollXInner) : scrollX ? (tmpTable.css("width", "auto"), tmpTable.removeAttr("width"), tmpTable.width() < tableContainer.clientWidth && tableWidthAttr && tmpTable.width(tableContainer.clientWidth)) : scrollY ? tmpTable.width(tableContainer.clientWidth) : tableWidthAttr && tmpTable.width(tableWidthAttr);
                            var total = 0;
                            for (i = 0; i < visibleColumns.length; i++) {
                                var cell = $(headerCells[i]),
                                    border = cell.outerWidth() - cell.width(),
                                    bounding = browser.bBounding ? Math.ceil(headerCells[i].getBoundingClientRect().width) : cell.outerWidth();
                                total += bounding, columns[visibleColumns[i]].sWidth = _fnStringToCss(bounding - border)
                            }
                            table.style.width = _fnStringToCss(total), holder.remove()
                        }
                    if (tableWidthAttr && (table.style.width = _fnStringToCss(tableWidthAttr)), (tableWidthAttr || scrollX) && !oSettings._reszEvt) {
                        var bindResize = function() {
                            $(window).on("resize.DT-" + oSettings.sInstance, _fnThrottle((function() {
                                _fnAdjustColumnSizing(oSettings)
                            })))
                        };
                        ie67 ? setTimeout(bindResize, 1e3) : bindResize(), oSettings._reszEvt = !0
                    }
                }
                var _fnThrottle = DataTable.util.throttle;

                function _fnConvertToWidth(width, parent) {
                    if (!width) return 0;
                    var n = $("<div/>").css("width", _fnStringToCss(width)).appendTo(parent || document.body),
                        val = n[0].offsetWidth;
                    return n.remove(), val
                }

                function _fnGetWidestNode(settings, colIdx) {
                    var idx = _fnGetMaxLenString(settings, colIdx);
                    if (idx < 0) return null;
                    var data = settings.aoData[idx];
                    return data.nTr ? data.anCells[colIdx] : $("<td/>").html(_fnGetCellData(settings, idx, colIdx, "display"))[0]
                }

                function _fnGetMaxLenString(settings, colIdx) {
                    for (var s, max = -1, maxIdx = -1, i = 0, ien = settings.aoData.length; i < ien; i++)(s = (s = (s = _fnGetCellData(settings, i, colIdx, "display") + "").replace(__re_html_remove, "")).replace(/&nbsp;/g, " ")).length > max && (max = s.length, maxIdx = i);
                    return maxIdx
                }

                function _fnStringToCss(s) {
                    return null === s ? "0px" : "number" == typeof s ? s < 0 ? "0px" : s + "px" : s.match(/\d$/) ? s + "px" : s
                }

                function _fnSortFlatten(settings) {
                    var i, k, kLen, aDataSort, iCol, sType, srcCol, aSort = [],
                        aoColumns = settings.aoColumns,
                        fixed = settings.aaSortingFixed,
                        fixedObj = $.isPlainObject(fixed),
                        nestedSort = [],
                        add = function(a) {
                            a.length && !$.isArray(a[0]) ? nestedSort.push(a) : $.merge(nestedSort, a)
                        };
                    for ($.isArray(fixed) && add(fixed), fixedObj && fixed.pre && add(fixed.pre), add(settings.aaSorting), fixedObj && fixed.post && add(fixed.post), i = 0; i < nestedSort.length; i++)
                        for (k = 0, kLen = (aDataSort = aoColumns[srcCol = nestedSort[i][0]].aDataSort).length; k < kLen; k++) sType = aoColumns[iCol = aDataSort[k]].sType || "string", nestedSort[i]._idx === undefined && (nestedSort[i]._idx = $.inArray(nestedSort[i][1], aoColumns[iCol].asSorting)), aSort.push({
                            src: srcCol,
                            col: iCol,
                            dir: nestedSort[i][1],
                            index: nestedSort[i]._idx,
                            type: sType,
                            formatter: DataTable.ext.type.order[sType + "-pre"]
                        });
                    return aSort
                }

                function _fnSort(oSettings) {
                    var i, ien, iLen, sortCol, aSort, aiOrig = [],
                        oExtSort = DataTable.ext.type.order,
                        aoData = oSettings.aoData,
                        formatters = (oSettings.aoColumns, 0),
                        displayMaster = oSettings.aiDisplayMaster;
                    for (_fnColumnTypes(oSettings), i = 0, ien = (aSort = _fnSortFlatten(oSettings)).length; i < ien; i++)(sortCol = aSort[i]).formatter && formatters++, _fnSortData(oSettings, sortCol.col);
                    if ("ssp" != _fnDataSource(oSettings) && 0 !== aSort.length) {
                        for (i = 0, iLen = displayMaster.length; i < iLen; i++) aiOrig[displayMaster[i]] = i;
                        formatters === aSort.length ? displayMaster.sort((function(a, b) {
                            var x, y, k, test, sort, len = aSort.length,
                                dataA = aoData[a]._aSortData,
                                dataB = aoData[b]._aSortData;
                            for (k = 0; k < len; k++)
                                if (0 !== (test = (x = dataA[(sort = aSort[k]).col]) < (y = dataB[sort.col]) ? -1 : x > y ? 1 : 0)) return "asc" === sort.dir ? test : -test;
                            return (x = aiOrig[a]) < (y = aiOrig[b]) ? -1 : x > y ? 1 : 0
                        })) : displayMaster.sort((function(a, b) {
                            var x, y, k, test, sort, len = aSort.length,
                                dataA = aoData[a]._aSortData,
                                dataB = aoData[b]._aSortData;
                            for (k = 0; k < len; k++)
                                if (x = dataA[(sort = aSort[k]).col], y = dataB[sort.col], 0 !== (test = (oExtSort[sort.type + "-" + sort.dir] || oExtSort["string-" + sort.dir])(x, y))) return test;
                            return (x = aiOrig[a]) < (y = aiOrig[b]) ? -1 : x > y ? 1 : 0
                        }))
                    }
                    oSettings.bSorted = !0
                }

                function _fnSortAria(settings) {
                    for (var label, nextSort, columns = settings.aoColumns, aSort = _fnSortFlatten(settings), oAria = settings.oLanguage.oAria, i = 0, iLen = columns.length; i < iLen; i++) {
                        var col = columns[i],
                            asSorting = col.asSorting,
                            sTitle = col.sTitle.replace(/<.*?>/g, ""),
                            th = col.nTh;
                        th.removeAttribute("aria-sort"), col.bSortable ? (aSort.length > 0 && aSort[0].col == i ? (th.setAttribute("aria-sort", "asc" == aSort[0].dir ? "ascending" : "descending"), nextSort = asSorting[aSort[0].index + 1] || asSorting[0]) : nextSort = asSorting[0], label = sTitle + ("asc" === nextSort ? oAria.sSortAscending : oAria.sSortDescending)) : label = sTitle, th.setAttribute("aria-label", label)
                    }
                }

                function _fnSortListener(settings, colIdx, append, callback) {
                    var nextSortIdx, col = settings.aoColumns[colIdx],
                        sorting = settings.aaSorting,
                        asSorting = col.asSorting,
                        next = function(a, overflow) {
                            var idx = a._idx;
                            return idx === undefined && (idx = $.inArray(a[1], asSorting)), idx + 1 < asSorting.length ? idx + 1 : overflow ? null : 0
                        };
                    if ("number" == typeof sorting[0] && (sorting = settings.aaSorting = [sorting]), append && settings.oFeatures.bSortMulti) {
                        var sortIdx = $.inArray(colIdx, _pluck(sorting, "0")); - 1 !== sortIdx ? (null === (nextSortIdx = next(sorting[sortIdx], !0)) && 1 === sorting.length && (nextSortIdx = 0), null === nextSortIdx ? sorting.splice(sortIdx, 1) : (sorting[sortIdx][1] = asSorting[nextSortIdx], sorting[sortIdx]._idx = nextSortIdx)) : (sorting.push([colIdx, asSorting[0], 0]), sorting[sorting.length - 1]._idx = 0)
                    } else sorting.length && sorting[0][0] == colIdx ? (nextSortIdx = next(sorting[0]), sorting.length = 1, sorting[0][1] = asSorting[nextSortIdx], sorting[0]._idx = nextSortIdx) : (sorting.length = 0, sorting.push([colIdx, asSorting[0]]), sorting[0]._idx = 0);
                    _fnReDraw(settings), "function" == typeof callback && callback(settings)
                }

                function _fnSortAttachListener(settings, attachTo, colIdx, callback) {
                    var col = settings.aoColumns[colIdx];
                    _fnBindAction(attachTo, {}, (function(e) {
                        !1 !== col.bSortable && (settings.oFeatures.bProcessing ? (_fnProcessingDisplay(settings, !0), setTimeout((function() {
                            _fnSortListener(settings, colIdx, e.shiftKey, callback), "ssp" !== _fnDataSource(settings) && _fnProcessingDisplay(settings, !1)
                        }), 0)) : _fnSortListener(settings, colIdx, e.shiftKey, callback))
                    }))
                }

                function _fnSortingClasses(settings) {
                    var i, ien, colIdx, oldSort = settings.aLastSort,
                        sortClass = settings.oClasses.sSortColumn,
                        sort = _fnSortFlatten(settings),
                        features = settings.oFeatures;
                    if (features.bSort && features.bSortClasses) {
                        for (i = 0, ien = oldSort.length; i < ien; i++) colIdx = oldSort[i].src, $(_pluck(settings.aoData, "anCells", colIdx)).removeClass(sortClass + (i < 2 ? i + 1 : 3));
                        for (i = 0, ien = sort.length; i < ien; i++) colIdx = sort[i].src, $(_pluck(settings.aoData, "anCells", colIdx)).addClass(sortClass + (i < 2 ? i + 1 : 3))
                    }
                    settings.aLastSort = sort
                }

                function _fnSortData(settings, idx) {
                    var customData, row, cellData, column = settings.aoColumns[idx],
                        customSort = DataTable.ext.order[column.sSortDataType];
                    customSort && (customData = customSort.call(settings.oInstance, settings, idx, _fnColumnIndexToVisible(settings, idx)));
                    for (var formatter = DataTable.ext.type.order[column.sType + "-pre"], i = 0, ien = settings.aoData.length; i < ien; i++)(row = settings.aoData[i])._aSortData || (row._aSortData = []), row._aSortData[idx] && !customSort || (cellData = customSort ? customData[i] : _fnGetCellData(settings, i, idx, "sort"), row._aSortData[idx] = formatter ? formatter(cellData) : cellData)
                }

                function _fnSaveState(settings) {
                    if (settings.oFeatures.bStateSave && !settings.bDestroying) {
                        var state = {
                            time: +new Date,
                            start: settings._iDisplayStart,
                            length: settings._iDisplayLength,
                            order: $.extend(!0, [], settings.aaSorting),
                            search: _fnSearchToCamel(settings.oPreviousSearch),
                            columns: $.map(settings.aoColumns, (function(col, i) {
                                return {
                                    visible: col.bVisible,
                                    search: _fnSearchToCamel(settings.aoPreSearchCols[i])
                                }
                            }))
                        };
                        _fnCallbackFire(settings, "aoStateSaveParams", "stateSaveParams", [settings, state]), settings.oSavedState = state, settings.fnStateSaveCallback.call(settings.oInstance, settings, state)
                    }
                }

                function _fnLoadState(settings, oInit, callback) {
                    var i, ien, columns = settings.aoColumns,
                        loaded = function(s) {
                            if (s && s.time) {
                                var abStateLoad = _fnCallbackFire(settings, "aoStateLoadParams", "stateLoadParams", [settings, s]);
                                if (-1 === $.inArray(!1, abStateLoad)) {
                                    var duration = settings.iStateDuration;
                                    if (duration > 0 && s.time < +new Date - 1e3 * duration) callback();
                                    else if (s.columns && columns.length !== s.columns.length) callback();
                                    else {
                                        if (settings.oLoadedState = $.extend(!0, {}, s), s.start !== undefined && (settings._iDisplayStart = s.start, settings.iInitDisplayStart = s.start), s.length !== undefined && (settings._iDisplayLength = s.length), s.order !== undefined && (settings.aaSorting = [], $.each(s.order, (function(i, col) {
                                                settings.aaSorting.push(col[0] >= columns.length ? [0, col[1]] : col)
                                            }))), s.search !== undefined && $.extend(settings.oPreviousSearch, _fnSearchToHung(s.search)), s.columns)
                                            for (i = 0, ien = s.columns.length; i < ien; i++) {
                                                var col = s.columns[i];
                                                col.visible !== undefined && (columns[i].bVisible = col.visible), col.search !== undefined && $.extend(settings.aoPreSearchCols[i], _fnSearchToHung(col.search))
                                            }
                                        _fnCallbackFire(settings, "aoStateLoaded", "stateLoaded", [settings, s]), callback()
                                    }
                                } else callback()
                            } else callback()
                        };
                    if (settings.oFeatures.bStateSave) {
                        var state = settings.fnStateLoadCallback.call(settings.oInstance, settings, loaded);
                        state !== undefined && loaded(state)
                    } else callback()
                }

                function _fnSettingsFromNode(table) {
                    var settings = DataTable.settings,
                        idx = $.inArray(table, _pluck(settings, "nTable"));
                    return -1 !== idx ? settings[idx] : null
                }

                function _fnLog(settings, level, msg, tn) {
                    if (msg = "DataTables warning: " + (settings ? "table id=" + settings.sTableId + " - " : "") + msg, tn && (msg += ". For more information about this error, please see http://datatables.net/tn/" + tn), level) window.console && console.log && console.log(msg);
                    else {
                        var ext = DataTable.ext,
                            type = ext.sErrMode || ext.errMode;
                        if (settings && _fnCallbackFire(settings, null, "error", [settings, tn, msg]), "alert" == type) alert(msg);
                        else {
                            if ("throw" == type) throw new Error(msg);
                            "function" == typeof type && type(settings, tn, msg)
                        }
                    }
                }

                function _fnMap(ret, src, name, mappedName) {
                    $.isArray(name) ? $.each(name, (function(i, val) {
                        $.isArray(val) ? _fnMap(ret, src, val[0], val[1]) : _fnMap(ret, src, val)
                    })) : (mappedName === undefined && (mappedName = name), src[name] !== undefined && (ret[mappedName] = src[name]))
                }

                function _fnExtend(out, extender, breakRefs) {
                    var val;
                    for (var prop in extender) extender.hasOwnProperty(prop) && (val = extender[prop], $.isPlainObject(val) ? ($.isPlainObject(out[prop]) || (out[prop] = {}), $.extend(!0, out[prop], val)) : breakRefs && "data" !== prop && "aaData" !== prop && $.isArray(val) ? out[prop] = val.slice() : out[prop] = val);
                    return out
                }

                function _fnBindAction(n, oData, fn) {
                    $(n).on("click.DT", oData, (function(e) {
                        $(n).blur(), fn(e)
                    })).on("keypress.DT", oData, (function(e) {
                        13 === e.which && (e.preventDefault(), fn(e))
                    })).on("selectstart.DT", (function() {
                        return !1
                    }))
                }

                function _fnCallbackReg(oSettings, sStore, fn, sName) {
                    fn && oSettings[sStore].push({
                        fn: fn,
                        sName: sName
                    })
                }

                function _fnCallbackFire(settings, callbackArr, eventName, args) {
                    var ret = [];
                    if (callbackArr && (ret = $.map(settings[callbackArr].slice().reverse(), (function(val, i) {
                            return val.fn.apply(settings.oInstance, args)
                        }))), null !== eventName) {
                        var e = $.Event(eventName + ".dt");
                        $(settings.nTable).trigger(e, args), ret.push(e.result)
                    }
                    return ret
                }

                function _fnLengthOverflow(settings) {
                    var start = settings._iDisplayStart,
                        end = settings.fnDisplayEnd(),
                        len = settings._iDisplayLength;
                    start >= end && (start = end - len), start -= start % len, (-1 === len || start < 0) && (start = 0), settings._iDisplayStart = start
                }

                function _fnRenderer(settings, type) {
                    var renderer = settings.renderer,
                        host = DataTable.ext.renderer[type];
                    return $.isPlainObject(renderer) && renderer[type] ? host[renderer[type]] || host._ : "string" == typeof renderer && host[renderer] || host._
                }

                function _fnDataSource(settings) {
                    return settings.oFeatures.bServerSide ? "ssp" : settings.ajax || settings.sAjaxSource ? "ajax" : "dom"
                }
                var __apiStruct = [],
                    __arrayProto = Array.prototype,
                    _toSettings = function(mixed) {
                        var idx, jq, settings = DataTable.settings,
                            tables = $.map(settings, (function(el, i) {
                                return el.nTable
                            }));
                        return mixed ? mixed.nTable && mixed.oApi ? [mixed] : mixed.nodeName && "table" === mixed.nodeName.toLowerCase() ? -1 !== (idx = $.inArray(mixed, tables)) ? [settings[idx]] : null : mixed && "function" == typeof mixed.settings ? mixed.settings().toArray() : ("string" == typeof mixed ? jq = $(mixed) : mixed instanceof $ && (jq = mixed), jq ? jq.map((function(i) {
                            return -1 !== (idx = $.inArray(this, tables)) ? settings[idx] : null
                        })).toArray() : void 0) : []
                    };
                _Api = function(context, data) {
                    if (!(this instanceof _Api)) return new _Api(context, data);
                    var settings = [],
                        ctxSettings = function(o) {
                            var a = _toSettings(o);
                            a && (settings = settings.concat(a))
                        };
                    if ($.isArray(context))
                        for (var i = 0, ien = context.length; i < ien; i++) ctxSettings(context[i]);
                    else ctxSettings(context);
                    this.context = _unique(settings), data && $.merge(this, data), this.selector = {
                        rows: null,
                        cols: null,
                        opts: null
                    }, _Api.extend(this, this, __apiStruct)
                }, DataTable.Api = _Api, $.extend(_Api.prototype, {
                    any: function() {
                        return 0 !== this.count()
                    },
                    concat: __arrayProto.concat,
                    context: [],
                    count: function() {
                        return this.flatten().length
                    },
                    each: function(fn) {
                        for (var i = 0, ien = this.length; i < ien; i++) fn.call(this, this[i], i, this);
                        return this
                    },
                    eq: function(idx) {
                        var ctx = this.context;
                        return ctx.length > idx ? new _Api(ctx[idx], this[idx]) : null
                    },
                    filter: function(fn) {
                        var a = [];
                        if (__arrayProto.filter) a = __arrayProto.filter.call(this, fn, this);
                        else
                            for (var i = 0, ien = this.length; i < ien; i++) fn.call(this, this[i], i, this) && a.push(this[i]);
                        return new _Api(this.context, a)
                    },
                    flatten: function() {
                        var a = [];
                        return new _Api(this.context, a.concat.apply(a, this.toArray()))
                    },
                    join: __arrayProto.join,
                    indexOf: __arrayProto.indexOf || function(obj, start) {
                        for (var i = start || 0, ien = this.length; i < ien; i++)
                            if (this[i] === obj) return i;
                        return -1
                    },
                    iterator: function(flatten, type, fn, alwaysNew) {
                        var ret, i, ien, j, jen, rows, items, item, a = [],
                            context = this.context,
                            selector = this.selector;
                        for ("string" == typeof flatten && (alwaysNew = fn, fn = type, type = flatten, flatten = !1), i = 0, ien = context.length; i < ien; i++) {
                            var apiInst = new _Api(context[i]);
                            if ("table" === type)(ret = fn.call(apiInst, context[i], i)) !== undefined && a.push(ret);
                            else if ("columns" === type || "rows" === type)(ret = fn.call(apiInst, context[i], this[i], i)) !== undefined && a.push(ret);
                            else if ("column" === type || "column-rows" === type || "row" === type || "cell" === type)
                                for (items = this[i], "column-rows" === type && (rows = _selector_row_indexes(context[i], selector.opts)), j = 0, jen = items.length; j < jen; j++) item = items[j], (ret = "cell" === type ? fn.call(apiInst, context[i], item.row, item.column, i, j) : fn.call(apiInst, context[i], item, i, j, rows)) !== undefined && a.push(ret)
                        }
                        if (a.length || alwaysNew) {
                            var api = new _Api(context, flatten ? a.concat.apply([], a) : a),
                                apiSelector = api.selector;
                            return apiSelector.rows = selector.rows, apiSelector.cols = selector.cols, apiSelector.opts = selector.opts, api
                        }
                        return this
                    },
                    lastIndexOf: __arrayProto.lastIndexOf || function(obj, start) {
                        return this.indexOf.apply(this.toArray.reverse(), arguments)
                    },
                    length: 0,
                    map: function(fn) {
                        var a = [];
                        if (__arrayProto.map) a = __arrayProto.map.call(this, fn, this);
                        else
                            for (var i = 0, ien = this.length; i < ien; i++) a.push(fn.call(this, this[i], i));
                        return new _Api(this.context, a)
                    },
                    pluck: function(prop) {
                        return this.map((function(el) {
                            return el[prop]
                        }))
                    },
                    pop: __arrayProto.pop,
                    push: __arrayProto.push,
                    reduce: __arrayProto.reduce || function(fn, init) {
                        return _fnReduce(this, fn, init, 0, this.length, 1)
                    },
                    reduceRight: __arrayProto.reduceRight || function(fn, init) {
                        return _fnReduce(this, fn, init, this.length - 1, -1, -1)
                    },
                    reverse: __arrayProto.reverse,
                    selector: null,
                    shift: __arrayProto.shift,
                    slice: function() {
                        return new _Api(this.context, this)
                    },
                    sort: __arrayProto.sort,
                    splice: __arrayProto.splice,
                    toArray: function() {
                        return __arrayProto.slice.call(this)
                    },
                    to$: function() {
                        return $(this)
                    },
                    toJQuery: function() {
                        return $(this)
                    },
                    unique: function() {
                        return new _Api(this.context, _unique(this))
                    },
                    unshift: __arrayProto.unshift
                }), _Api.extend = function(scope, obj, ext) {
                    if (ext.length && obj && (obj instanceof _Api || obj.__dt_wrapper)) {
                        var i, ien, struct, methodScoping = function(scope, fn, struc) {
                            return function() {
                                var ret = fn.apply(scope, arguments);
                                return _Api.extend(ret, ret, struc.methodExt), ret
                            }
                        };
                        for (i = 0, ien = ext.length; i < ien; i++) obj[(struct = ext[i]).name] = "function" == typeof struct.val ? methodScoping(scope, struct.val, struct) : $.isPlainObject(struct.val) ? {} : struct.val, obj[struct.name].__dt_wrapper = !0, _Api.extend(scope, obj[struct.name], struct.propExt)
                    }
                }, _Api.register = _api_register = function(name, val) {
                    if ($.isArray(name))
                        for (var j = 0, jen = name.length; j < jen; j++) _Api.register(name[j], val);
                    else {
                        var i, ien, key, method, heir = name.split("."),
                            struct = __apiStruct,
                            find = function(src, name) {
                                for (var i = 0, ien = src.length; i < ien; i++)
                                    if (src[i].name === name) return src[i];
                                return null
                            };
                        for (i = 0, ien = heir.length; i < ien; i++) {
                            var src = find(struct, key = (method = -1 !== heir[i].indexOf("()")) ? heir[i].replace("()", "") : heir[i]);
                            src || (src = {
                                name: key,
                                val: {},
                                methodExt: [],
                                propExt: []
                            }, struct.push(src)), i === ien - 1 ? src.val = val : struct = method ? src.methodExt : src.propExt
                        }
                    }
                }, _Api.registerPlural = _api_registerPlural = function(pluralName, singularName, val) {
                    _Api.register(pluralName, val), _Api.register(singularName, (function() {
                        var ret = val.apply(this, arguments);
                        return ret === this ? this : ret instanceof _Api ? ret.length ? $.isArray(ret[0]) ? new _Api(ret.context, ret[0]) : ret[0] : undefined : ret
                    }))
                };
                var __table_selector = function(selector, a) {
                    if ("number" == typeof selector) return [a[selector]];
                    var nodes = $.map(a, (function(el, i) {
                        return el.nTable
                    }));
                    return $(nodes).filter(selector).map((function(i) {
                        var idx = $.inArray(this, nodes);
                        return a[idx]
                    })).toArray()
                };
                _api_register("tables()", (function(selector) {
                    return selector ? new _Api(__table_selector(selector, this.context)) : this
                })), _api_register("table()", (function(selector) {
                    var tables = this.tables(selector),
                        ctx = tables.context;
                    return ctx.length ? new _Api(ctx[0]) : tables
                })), _api_registerPlural("tables().nodes()", "table().node()", (function() {
                    return this.iterator("table", (function(ctx) {
                        return ctx.nTable
                    }), 1)
                })), _api_registerPlural("tables().body()", "table().body()", (function() {
                    return this.iterator("table", (function(ctx) {
                        return ctx.nTBody
                    }), 1)
                })), _api_registerPlural("tables().header()", "table().header()", (function() {
                    return this.iterator("table", (function(ctx) {
                        return ctx.nTHead
                    }), 1)
                })), _api_registerPlural("tables().footer()", "table().footer()", (function() {
                    return this.iterator("table", (function(ctx) {
                        return ctx.nTFoot
                    }), 1)
                })), _api_registerPlural("tables().containers()", "table().container()", (function() {
                    return this.iterator("table", (function(ctx) {
                        return ctx.nTableWrapper
                    }), 1)
                })), _api_register("draw()", (function(paging) {
                    return this.iterator("table", (function(settings) {
                        "page" === paging ? _fnDraw(settings) : ("string" == typeof paging && (paging = "full-hold" !== paging), _fnReDraw(settings, !1 === paging))
                    }))
                })), _api_register("page()", (function(action) {
                    return action === undefined ? this.page.info().page : this.iterator("table", (function(settings) {
                        _fnPageChange(settings, action)
                    }))
                })), _api_register("page.info()", (function(action) {
                    if (0 === this.context.length) return undefined;
                    var settings = this.context[0],
                        start = settings._iDisplayStart,
                        len = settings.oFeatures.bPaginate ? settings._iDisplayLength : -1,
                        visRecords = settings.fnRecordsDisplay(),
                        all = -1 === len;
                    return {
                        page: all ? 0 : Math.floor(start / len),
                        pages: all ? 1 : Math.ceil(visRecords / len),
                        start: start,
                        end: settings.fnDisplayEnd(),
                        length: len,
                        recordsTotal: settings.fnRecordsTotal(),
                        recordsDisplay: visRecords,
                        serverSide: "ssp" === _fnDataSource(settings)
                    }
                })), _api_register("page.len()", (function(len) {
                    return len === undefined ? 0 !== this.context.length ? this.context[0]._iDisplayLength : undefined : this.iterator("table", (function(settings) {
                        _fnLengthChange(settings, len)
                    }))
                }));
                var __reload = function(settings, holdPosition, callback) {
                    if (callback) {
                        var api = new _Api(settings);
                        api.one("draw", (function() {
                            callback(api.ajax.json())
                        }))
                    }
                    if ("ssp" == _fnDataSource(settings)) _fnReDraw(settings, holdPosition);
                    else {
                        _fnProcessingDisplay(settings, !0);
                        var xhr = settings.jqXHR;
                        xhr && 4 !== xhr.readyState && xhr.abort(), _fnBuildAjax(settings, [], (function(json) {
                            _fnClearTable(settings);
                            for (var data = _fnAjaxDataSrc(settings, json), i = 0, ien = data.length; i < ien; i++) _fnAddData(settings, data[i]);
                            _fnReDraw(settings, holdPosition), _fnProcessingDisplay(settings, !1)
                        }))
                    }
                };
                _api_register("ajax.json()", (function() {
                    var ctx = this.context;
                    if (ctx.length > 0) return ctx[0].json
                })), _api_register("ajax.params()", (function() {
                    var ctx = this.context;
                    if (ctx.length > 0) return ctx[0].oAjaxData
                })), _api_register("ajax.reload()", (function(callback, resetPaging) {
                    return this.iterator("table", (function(settings) {
                        __reload(settings, !1 === resetPaging, callback)
                    }))
                })), _api_register("ajax.url()", (function(url) {
                    var ctx = this.context;
                    return url === undefined ? 0 === ctx.length ? undefined : (ctx = ctx[0]).ajax ? $.isPlainObject(ctx.ajax) ? ctx.ajax.url : ctx.ajax : ctx.sAjaxSource : this.iterator("table", (function(settings) {
                        $.isPlainObject(settings.ajax) ? settings.ajax.url = url : settings.ajax = url
                    }))
                })), _api_register("ajax.url().load()", (function(callback, resetPaging) {
                    return this.iterator("table", (function(ctx) {
                        __reload(ctx, !1 === resetPaging, callback)
                    }))
                }));
                var _selector_run = function(type, selector, selectFn, settings, opts) {
                        var res, a, i, ien, j, jen, out = [],
                            selectorType = typeof selector;
                        for (selector && "string" !== selectorType && "function" !== selectorType && selector.length !== undefined || (selector = [selector]), i = 0, ien = selector.length; i < ien; i++)
                            for (j = 0, jen = (a = selector[i] && selector[i].split && !selector[i].match(/[\[\(:]/) ? selector[i].split(",") : [selector[i]]).length; j < jen; j++)(res = selectFn("string" == typeof a[j] ? $.trim(a[j]) : a[j])) && res.length && (out = out.concat(res));
                        var ext = _ext.selector[type];
                        if (ext.length)
                            for (i = 0, ien = ext.length; i < ien; i++) out = ext[i](settings, opts, out);
                        return _unique(out)
                    },
                    _selector_opts = function(opts) {
                        return opts || (opts = {}), opts.filter && opts.search === undefined && (opts.search = opts.filter), $.extend({
                            search: "none",
                            order: "current",
                            page: "all"
                        }, opts)
                    },
                    _selector_first = function(inst) {
                        for (var i = 0, ien = inst.length; i < ien; i++)
                            if (inst[i].length > 0) return inst[0] = inst[i], inst[0].length = 1, inst.length = 1, inst.context = [inst.context[i]], inst;
                        return inst.length = 0, inst
                    },
                    _selector_row_indexes = function(settings, opts) {
                        var tmp, a = [],
                            displayFiltered = settings.aiDisplay,
                            displayMaster = settings.aiDisplayMaster,
                            search = opts.search,
                            order = opts.order,
                            page = opts.page;
                        if ("ssp" == _fnDataSource(settings)) return "removed" === search ? [] : _range(0, displayMaster.length);
                        if ("current" == page)
                            for (i = settings._iDisplayStart, ien = settings.fnDisplayEnd(); i < ien; i++) a.push(displayFiltered[i]);
                        else if ("current" == order || "applied" == order) {
                            if ("none" == search) a = displayMaster.slice();
                            else if ("applied" == search) a = displayFiltered.slice();
                            else if ("removed" == search) {
                                for (var displayFilteredMap = {}, i = 0, ien = displayFiltered.length; i < ien; i++) displayFilteredMap[displayFiltered[i]] = null;
                                a = $.map(displayMaster, (function(el) {
                                    return displayFilteredMap.hasOwnProperty(el) ? null : el
                                }))
                            }
                        } else if ("index" == order || "original" == order)
                            for (i = 0, ien = settings.aoData.length; i < ien; i++)("none" == search || -1 === (tmp = $.inArray(i, displayFiltered)) && "removed" == search || tmp >= 0 && "applied" == search) && a.push(i);
                        return a
                    },
                    __row_selector = function(settings, selector, opts) {
                        var rows;
                        return _selector_run("row", selector, (function(sel) {
                            var selInt = _intVal(sel),
                                aoData = settings.aoData;
                            if (null !== selInt && !opts) return [selInt];
                            if (rows || (rows = _selector_row_indexes(settings, opts)), null !== selInt && -1 !== $.inArray(selInt, rows)) return [selInt];
                            if (null === sel || sel === undefined || "" === sel) return rows;
                            if ("function" == typeof sel) return $.map(rows, (function(idx) {
                                var row = aoData[idx];
                                return sel(idx, row._aData, row.nTr) ? idx : null
                            }));
                            if (sel.nodeName) {
                                var rowIdx = sel._DT_RowIndex,
                                    cellIdx = sel._DT_CellIndex;
                                if (rowIdx !== undefined) return aoData[rowIdx] && aoData[rowIdx].nTr === sel ? [rowIdx] : [];
                                if (cellIdx) return aoData[cellIdx.row] && aoData[cellIdx.row].nTr === sel ? [cellIdx.row] : [];
                                var host = $(sel).closest("*[data-dt-row]");
                                return host.length ? [host.data("dt-row")] : []
                            }
                            if ("string" == typeof sel && "#" === sel.charAt(0)) {
                                var rowObj = settings.aIds[sel.replace(/^#/, "")];
                                if (rowObj !== undefined) return [rowObj.idx]
                            }
                            var nodes = _removeEmpty(_pluck_order(settings.aoData, rows, "nTr"));
                            return $(nodes).filter(sel).map((function() {
                                return this._DT_RowIndex
                            })).toArray()
                        }), settings, opts)
                    };
                _api_register("rows()", (function(selector, opts) {
                    selector === undefined ? selector = "" : $.isPlainObject(selector) && (opts = selector, selector = ""), opts = _selector_opts(opts);
                    var inst = this.iterator("table", (function(settings) {
                        return __row_selector(settings, selector, opts)
                    }), 1);
                    return inst.selector.rows = selector, inst.selector.opts = opts, inst
                })), _api_register("rows().nodes()", (function() {
                    return this.iterator("row", (function(settings, row) {
                        return settings.aoData[row].nTr || undefined
                    }), 1)
                })), _api_register("rows().data()", (function() {
                    return this.iterator(!0, "rows", (function(settings, rows) {
                        return _pluck_order(settings.aoData, rows, "_aData")
                    }), 1)
                })), _api_registerPlural("rows().cache()", "row().cache()", (function(type) {
                    return this.iterator("row", (function(settings, row) {
                        var r = settings.aoData[row];
                        return "search" === type ? r._aFilterData : r._aSortData
                    }), 1)
                })), _api_registerPlural("rows().invalidate()", "row().invalidate()", (function(src) {
                    return this.iterator("row", (function(settings, row) {
                        _fnInvalidate(settings, row, src)
                    }))
                })), _api_registerPlural("rows().indexes()", "row().index()", (function() {
                    return this.iterator("row", (function(settings, row) {
                        return row
                    }), 1)
                })), _api_registerPlural("rows().ids()", "row().id()", (function(hash) {
                    for (var a = [], context = this.context, i = 0, ien = context.length; i < ien; i++)
                        for (var j = 0, jen = this[i].length; j < jen; j++) {
                            var id = context[i].rowIdFn(context[i].aoData[this[i][j]]._aData);
                            a.push((!0 === hash ? "#" : "") + id)
                        }
                    return new _Api(context, a)
                })), _api_registerPlural("rows().remove()", "row().remove()", (function() {
                    var that = this;
                    return this.iterator("row", (function(settings, row, thatIdx) {
                        var i, ien, j, jen, loopRow, loopCells, data = settings.aoData,
                            rowData = data[row];
                        for (data.splice(row, 1), i = 0, ien = data.length; i < ien; i++)
                            if (loopCells = (loopRow = data[i]).anCells, null !== loopRow.nTr && (loopRow.nTr._DT_RowIndex = i), null !== loopCells)
                                for (j = 0, jen = loopCells.length; j < jen; j++) loopCells[j]._DT_CellIndex.row = i;
                        _fnDeleteIndex(settings.aiDisplayMaster, row), _fnDeleteIndex(settings.aiDisplay, row), _fnDeleteIndex(that[thatIdx], row, !1), settings._iRecordsDisplay > 0 && settings._iRecordsDisplay--, _fnLengthOverflow(settings);
                        var id = settings.rowIdFn(rowData._aData);
                        id !== undefined && delete settings.aIds[id]
                    })), this.iterator("table", (function(settings) {
                        for (var i = 0, ien = settings.aoData.length; i < ien; i++) settings.aoData[i].idx = i
                    })), this
                })), _api_register("rows.add()", (function(rows) {
                    var newRows = this.iterator("table", (function(settings) {
                            var row, i, ien, out = [];
                            for (i = 0, ien = rows.length; i < ien; i++)(row = rows[i]).nodeName && "TR" === row.nodeName.toUpperCase() ? out.push(_fnAddTr(settings, row)[0]) : out.push(_fnAddData(settings, row));
                            return out
                        }), 1),
                        modRows = this.rows(-1);
                    return modRows.pop(), $.merge(modRows, newRows), modRows
                })), _api_register("row()", (function(selector, opts) {
                    return _selector_first(this.rows(selector, opts))
                })), _api_register("row().data()", (function(data) {
                    var ctx = this.context;
                    if (data === undefined) return ctx.length && this.length ? ctx[0].aoData[this[0]]._aData : undefined;
                    var row = ctx[0].aoData[this[0]];
                    return row._aData = data, $.isArray(data) && row.nTr.id && _fnSetObjectDataFn(ctx[0].rowId)(data, row.nTr.id), _fnInvalidate(ctx[0], this[0], "data"), this
                })), _api_register("row().node()", (function() {
                    var ctx = this.context;
                    return ctx.length && this.length && ctx[0].aoData[this[0]].nTr || null
                })), _api_register("row.add()", (function(row) {
                    row instanceof $ && row.length && (row = row[0]);
                    var rows = this.iterator("table", (function(settings) {
                        return row.nodeName && "TR" === row.nodeName.toUpperCase() ? _fnAddTr(settings, row)[0] : _fnAddData(settings, row)
                    }));
                    return this.row(rows[0])
                }));
                var __details_add = function(ctx, row, data, klass) {
                        var rows = [],
                            addRow = function(r, k) {
                                if ($.isArray(r) || r instanceof $)
                                    for (var i = 0, ien = r.length; i < ien; i++) addRow(r[i], k);
                                else if (r.nodeName && "tr" === r.nodeName.toLowerCase()) rows.push(r);
                                else {
                                    var created = $("<tr><td/></tr>").addClass(k);
                                    $("td", created).addClass(k).html(r)[0].colSpan = _fnVisbleColumns(ctx), rows.push(created[0])
                                }
                            };
                        addRow(data, klass), row._details && row._details.detach(), row._details = $(rows), row._detailsShow && row._details.insertAfter(row.nTr)
                    },
                    __details_remove = function(api, idx) {
                        var ctx = api.context;
                        if (ctx.length) {
                            var row = ctx[0].aoData[idx !== undefined ? idx : api[0]];
                            row && row._details && (row._details.remove(), row._detailsShow = undefined, row._details = undefined)
                        }
                    },
                    __details_display = function(api, show) {
                        var ctx = api.context;
                        if (ctx.length && api.length) {
                            var row = ctx[0].aoData[api[0]];
                            row._details && (row._detailsShow = show, show ? row._details.insertAfter(row.nTr) : row._details.detach(), __details_events(ctx[0]))
                        }
                    },
                    __details_events = function(settings) {
                        var api = new _Api(settings),
                            namespace = ".dt.DT_details",
                            drawEvent = "draw" + namespace,
                            colvisEvent = "column-visibility" + namespace,
                            destroyEvent = "destroy" + namespace,
                            data = settings.aoData;
                        api.off(drawEvent + " " + colvisEvent + " " + destroyEvent), _pluck(data, "_details").length > 0 && (api.on(drawEvent, (function(e, ctx) {
                            settings === ctx && api.rows({
                                page: "current"
                            }).eq(0).each((function(idx) {
                                var row = data[idx];
                                row._detailsShow && row._details.insertAfter(row.nTr)
                            }))
                        })), api.on(colvisEvent, (function(e, ctx, idx, vis) {
                            if (settings === ctx)
                                for (var row, visible = _fnVisbleColumns(ctx), i = 0, ien = data.length; i < ien; i++)(row = data[i])._details && row._details.children("td[colspan]").attr("colspan", visible)
                        })), api.on(destroyEvent, (function(e, ctx) {
                            if (settings === ctx)
                                for (var i = 0, ien = data.length; i < ien; i++) data[i]._details && __details_remove(api, i)
                        })))
                    },
                    _child_obj = "row().child",
                    _child_mth = _child_obj + "()";
                _api_register(_child_mth, (function(data, klass) {
                    var ctx = this.context;
                    return data === undefined ? ctx.length && this.length ? ctx[0].aoData[this[0]]._details : undefined : (!0 === data ? this.child.show() : !1 === data ? __details_remove(this) : ctx.length && this.length && __details_add(ctx[0], ctx[0].aoData[this[0]], data, klass), this)
                })), _api_register([_child_obj + ".show()", _child_mth + ".show()"], (function(show) {
                    return __details_display(this, !0), this
                })), _api_register([_child_obj + ".hide()", _child_mth + ".hide()"], (function() {
                    return __details_display(this, !1), this
                })), _api_register([_child_obj + ".remove()", _child_mth + ".remove()"], (function() {
                    return __details_remove(this), this
                })), _api_register(_child_obj + ".isShown()", (function() {
                    var ctx = this.context;
                    return ctx.length && this.length && ctx[0].aoData[this[0]]._detailsShow || !1
                }));
                var __re_column_selector = /^([^:]+):(name|visIdx|visible)$/,
                    __columnData = function(settings, column, r1, r2, rows) {
                        for (var a = [], row = 0, ien = rows.length; row < ien; row++) a.push(_fnGetCellData(settings, rows[row], column));
                        return a
                    },
                    __column_selector = function(settings, selector, opts) {
                        var columns = settings.aoColumns,
                            names = _pluck(columns, "sName"),
                            nodes = _pluck(columns, "nTh");
                        return _selector_run("column", selector, (function(s) {
                            var selInt = _intVal(s);
                            if ("" === s) return _range(columns.length);
                            if (null !== selInt) return [selInt >= 0 ? selInt : columns.length + selInt];
                            if ("function" == typeof s) {
                                var rows = _selector_row_indexes(settings, opts);
                                return $.map(columns, (function(col, idx) {
                                    return s(idx, __columnData(settings, idx, 0, 0, rows), nodes[idx]) ? idx : null
                                }))
                            }
                            var match = "string" == typeof s ? s.match(__re_column_selector) : "";
                            if (match) switch (match[2]) {
                                case "visIdx":
                                case "visible":
                                    var idx = parseInt(match[1], 10);
                                    if (idx < 0) {
                                        var visColumns = $.map(columns, (function(col, i) {
                                            return col.bVisible ? i : null
                                        }));
                                        return [visColumns[visColumns.length + idx]]
                                    }
                                    return [_fnVisibleToColumnIndex(settings, idx)];
                                case "name":
                                    return $.map(names, (function(name, i) {
                                        return name === match[1] ? i : null
                                    }));
                                default:
                                    return []
                            }
                            if (s.nodeName && s._DT_CellIndex) return [s._DT_CellIndex.column];
                            var jqResult = $(nodes).filter(s).map((function() {
                                return $.inArray(this, nodes)
                            })).toArray();
                            if (jqResult.length || !s.nodeName) return jqResult;
                            var host = $(s).closest("*[data-dt-column]");
                            return host.length ? [host.data("dt-column")] : []
                        }), settings, opts)
                    },
                    __setColumnVis = function(settings, column, vis) {
                        var cells, i, ien, tr, cols = settings.aoColumns,
                            col = cols[column],
                            data = settings.aoData;
                        if (vis === undefined) return col.bVisible;
                        if (col.bVisible !== vis) {
                            if (vis) {
                                var insertBefore = $.inArray(!0, _pluck(cols, "bVisible"), column + 1);
                                for (i = 0, ien = data.length; i < ien; i++) tr = data[i].nTr, cells = data[i].anCells, tr && tr.insertBefore(cells[column], cells[insertBefore] || null)
                            } else $(_pluck(settings.aoData, "anCells", column)).detach();
                            col.bVisible = vis, _fnDrawHead(settings, settings.aoHeader), _fnDrawHead(settings, settings.aoFooter), settings.aiDisplay.length || $(settings.nTBody).find("td[colspan]").attr("colspan", _fnVisbleColumns(settings)), _fnSaveState(settings)
                        }
                    };
                _api_register("columns()", (function(selector, opts) {
                    selector === undefined ? selector = "" : $.isPlainObject(selector) && (opts = selector, selector = ""), opts = _selector_opts(opts);
                    var inst = this.iterator("table", (function(settings) {
                        return __column_selector(settings, selector, opts)
                    }), 1);
                    return inst.selector.cols = selector, inst.selector.opts = opts, inst
                })), _api_registerPlural("columns().header()", "column().header()", (function(selector, opts) {
                    return this.iterator("column", (function(settings, column) {
                        return settings.aoColumns[column].nTh
                    }), 1)
                })), _api_registerPlural("columns().footer()", "column().footer()", (function(selector, opts) {
                    return this.iterator("column", (function(settings, column) {
                        return settings.aoColumns[column].nTf
                    }), 1)
                })), _api_registerPlural("columns().data()", "column().data()", (function() {
                    return this.iterator("column-rows", __columnData, 1)
                })), _api_registerPlural("columns().dataSrc()", "column().dataSrc()", (function() {
                    return this.iterator("column", (function(settings, column) {
                        return settings.aoColumns[column].mData
                    }), 1)
                })), _api_registerPlural("columns().cache()", "column().cache()", (function(type) {
                    return this.iterator("column-rows", (function(settings, column, i, j, rows) {
                        return _pluck_order(settings.aoData, rows, "search" === type ? "_aFilterData" : "_aSortData", column)
                    }), 1)
                })), _api_registerPlural("columns().nodes()", "column().nodes()", (function() {
                    return this.iterator("column-rows", (function(settings, column, i, j, rows) {
                        return _pluck_order(settings.aoData, rows, "anCells", column)
                    }), 1)
                })), _api_registerPlural("columns().visible()", "column().visible()", (function(vis, calc) {
                    var ret = this.iterator("column", (function(settings, column) {
                        if (vis === undefined) return settings.aoColumns[column].bVisible;
                        __setColumnVis(settings, column, vis)
                    }));
                    return vis !== undefined && (this.iterator("column", (function(settings, column) {
                        _fnCallbackFire(settings, null, "column-visibility", [settings, column, vis, calc])
                    })), (calc === undefined || calc) && this.columns.adjust()), ret
                })), _api_registerPlural("columns().indexes()", "column().index()", (function(type) {
                    return this.iterator("column", (function(settings, column) {
                        return "visible" === type ? _fnColumnIndexToVisible(settings, column) : column
                    }), 1)
                })), _api_register("columns.adjust()", (function() {
                    return this.iterator("table", (function(settings) {
                        _fnAdjustColumnSizing(settings)
                    }), 1)
                })), _api_register("column.index()", (function(type, idx) {
                    if (0 !== this.context.length) {
                        var ctx = this.context[0];
                        if ("fromVisible" === type || "toData" === type) return _fnVisibleToColumnIndex(ctx, idx);
                        if ("fromData" === type || "toVisible" === type) return _fnColumnIndexToVisible(ctx, idx)
                    }
                })), _api_register("column()", (function(selector, opts) {
                    return _selector_first(this.columns(selector, opts))
                }));
                var __cell_selector = function(settings, selector, opts) {
                    var row, a, i, ien, j, o, host, data = settings.aoData,
                        rows = _selector_row_indexes(settings, opts),
                        cells = _removeEmpty(_pluck_order(data, rows, "anCells")),
                        allCells = $([].concat.apply([], cells)),
                        columns = settings.aoColumns.length;
                    return _selector_run("cell", selector, (function(s) {
                        var fnSelector = "function" == typeof s;
                        if (null === s || s === undefined || fnSelector) {
                            for (a = [], i = 0, ien = rows.length; i < ien; i++)
                                for (row = rows[i], j = 0; j < columns; j++) o = {
                                    row: row,
                                    column: j
                                }, fnSelector ? (host = data[row], s(o, _fnGetCellData(settings, row, j), host.anCells ? host.anCells[j] : null) && a.push(o)) : a.push(o);
                            return a
                        }
                        if ($.isPlainObject(s)) return s.column !== undefined && s.row !== undefined && -1 !== $.inArray(s.row, rows) ? [s] : [];
                        var jqResult = allCells.filter(s).map((function(i, el) {
                            return {
                                row: el._DT_CellIndex.row,
                                column: el._DT_CellIndex.column
                            }
                        })).toArray();
                        return jqResult.length || !s.nodeName ? jqResult : (host = $(s).closest("*[data-dt-row]")).length ? [{
                            row: host.data("dt-row"),
                            column: host.data("dt-column")
                        }] : []
                    }), settings, opts)
                };
                _api_register("cells()", (function(rowSelector, columnSelector, opts) {
                    if ($.isPlainObject(rowSelector) && (rowSelector.row === undefined ? (opts = rowSelector, rowSelector = null) : (opts = columnSelector, columnSelector = null)), $.isPlainObject(columnSelector) && (opts = columnSelector, columnSelector = null), null === columnSelector || columnSelector === undefined) return this.iterator("table", (function(settings) {
                        return __cell_selector(settings, rowSelector, _selector_opts(opts))
                    }));
                    var a, i, ien, j, jen, columns = this.columns(columnSelector),
                        rows = this.rows(rowSelector);
                    this.iterator("table", (function(settings, idx) {
                        for (a = [], i = 0, ien = rows[idx].length; i < ien; i++)
                            for (j = 0, jen = columns[idx].length; j < jen; j++) a.push({
                                row: rows[idx][i],
                                column: columns[idx][j]
                            })
                    }), 1);
                    var cells = this.cells(a, opts);
                    return $.extend(cells.selector, {
                        cols: columnSelector,
                        rows: rowSelector,
                        opts: opts
                    }), cells
                })), _api_registerPlural("cells().nodes()", "cell().node()", (function() {
                    return this.iterator("cell", (function(settings, row, column) {
                        var data = settings.aoData[row];
                        return data && data.anCells ? data.anCells[column] : undefined
                    }), 1)
                })), _api_register("cells().data()", (function() {
                    return this.iterator("cell", (function(settings, row, column) {
                        return _fnGetCellData(settings, row, column)
                    }), 1)
                })), _api_registerPlural("cells().cache()", "cell().cache()", (function(type) {
                    return type = "search" === type ? "_aFilterData" : "_aSortData", this.iterator("cell", (function(settings, row, column) {
                        return settings.aoData[row][type][column]
                    }), 1)
                })), _api_registerPlural("cells().render()", "cell().render()", (function(type) {
                    return this.iterator("cell", (function(settings, row, column) {
                        return _fnGetCellData(settings, row, column, type)
                    }), 1)
                })), _api_registerPlural("cells().indexes()", "cell().index()", (function() {
                    return this.iterator("cell", (function(settings, row, column) {
                        return {
                            row: row,
                            column: column,
                            columnVisible: _fnColumnIndexToVisible(settings, column)
                        }
                    }), 1)
                })), _api_registerPlural("cells().invalidate()", "cell().invalidate()", (function(src) {
                    return this.iterator("cell", (function(settings, row, column) {
                        _fnInvalidate(settings, row, src, column)
                    }))
                })), _api_register("cell()", (function(rowSelector, columnSelector, opts) {
                    return _selector_first(this.cells(rowSelector, columnSelector, opts))
                })), _api_register("cell().data()", (function(data) {
                    var ctx = this.context,
                        cell = this[0];
                    return data === undefined ? ctx.length && cell.length ? _fnGetCellData(ctx[0], cell[0].row, cell[0].column) : undefined : (_fnSetCellData(ctx[0], cell[0].row, cell[0].column, data), _fnInvalidate(ctx[0], cell[0].row, "data", cell[0].column), this)
                })), _api_register("order()", (function(order, dir) {
                    var ctx = this.context;
                    return order === undefined ? 0 !== ctx.length ? ctx[0].aaSorting : undefined : ("number" == typeof order ? order = [
                        [order, dir]
                    ] : order.length && !$.isArray(order[0]) && (order = Array.prototype.slice.call(arguments)), this.iterator("table", (function(settings) {
                        settings.aaSorting = order.slice()
                    })))
                })), _api_register("order.listener()", (function(node, column, callback) {
                    return this.iterator("table", (function(settings) {
                        _fnSortAttachListener(settings, node, column, callback)
                    }))
                })), _api_register("order.fixed()", (function(set) {
                    if (!set) {
                        var ctx = this.context,
                            fixed = ctx.length ? ctx[0].aaSortingFixed : undefined;
                        return $.isArray(fixed) ? {
                            pre: fixed
                        } : fixed
                    }
                    return this.iterator("table", (function(settings) {
                        settings.aaSortingFixed = $.extend(!0, {}, set)
                    }))
                })), _api_register(["columns().order()", "column().order()"], (function(dir) {
                    var that = this;
                    return this.iterator("table", (function(settings, i) {
                        var sort = [];
                        $.each(that[i], (function(j, col) {
                            sort.push([col, dir])
                        })), settings.aaSorting = sort
                    }))
                })), _api_register("search()", (function(input, regex, smart, caseInsen) {
                    var ctx = this.context;
                    return input === undefined ? 0 !== ctx.length ? ctx[0].oPreviousSearch.sSearch : undefined : this.iterator("table", (function(settings) {
                        settings.oFeatures.bFilter && _fnFilterComplete(settings, $.extend({}, settings.oPreviousSearch, {
                            sSearch: input + "",
                            bRegex: null !== regex && regex,
                            bSmart: null === smart || smart,
                            bCaseInsensitive: null === caseInsen || caseInsen
                        }), 1)
                    }))
                })), _api_registerPlural("columns().search()", "column().search()", (function(input, regex, smart, caseInsen) {
                    return this.iterator("column", (function(settings, column) {
                        var preSearch = settings.aoPreSearchCols;
                        if (input === undefined) return preSearch[column].sSearch;
                        settings.oFeatures.bFilter && ($.extend(preSearch[column], {
                            sSearch: input + "",
                            bRegex: null !== regex && regex,
                            bSmart: null === smart || smart,
                            bCaseInsensitive: null === caseInsen || caseInsen
                        }), _fnFilterComplete(settings, settings.oPreviousSearch, 1))
                    }))
                })), _api_register("state()", (function() {
                    return this.context.length ? this.context[0].oSavedState : null
                })), _api_register("state.clear()", (function() {
                    return this.iterator("table", (function(settings) {
                        settings.fnStateSaveCallback.call(settings.oInstance, settings, {})
                    }))
                })), _api_register("state.loaded()", (function() {
                    return this.context.length ? this.context[0].oLoadedState : null
                })), _api_register("state.save()", (function() {
                    return this.iterator("table", (function(settings) {
                        _fnSaveState(settings)
                    }))
                })), DataTable.versionCheck = DataTable.fnVersionCheck = function(version) {
                    for (var iThis, iThat, aThis = DataTable.version.split("."), aThat = version.split("."), i = 0, iLen = aThat.length; i < iLen; i++)
                        if ((iThis = parseInt(aThis[i], 10) || 0) !== (iThat = parseInt(aThat[i], 10) || 0)) return iThis > iThat;
                    return !0
                }, DataTable.isDataTable = DataTable.fnIsDataTable = function(table) {
                    var t = $(table).get(0),
                        is = !1;
                    return table instanceof DataTable.Api || ($.each(DataTable.settings, (function(i, o) {
                        var head = o.nScrollHead ? $("table", o.nScrollHead)[0] : null,
                            foot = o.nScrollFoot ? $("table", o.nScrollFoot)[0] : null;
                        o.nTable !== t && head !== t && foot !== t || (is = !0)
                    })), is)
                }, DataTable.tables = DataTable.fnTables = function(visible) {
                    var api = !1;
                    $.isPlainObject(visible) && (api = visible.api, visible = visible.visible);
                    var a = $.map(DataTable.settings, (function(o) {
                        if (!visible || visible && $(o.nTable).is(":visible")) return o.nTable
                    }));
                    return api ? new _Api(a) : a
                }, DataTable.camelToHungarian = _fnCamelToHungarian, _api_register("$()", (function(selector, opts) {
                    var rows = this.rows(opts).nodes(),
                        jqRows = $(rows);
                    return $([].concat(jqRows.filter(selector).toArray(), jqRows.find(selector).toArray()))
                })), $.each(["on", "one", "off"], (function(i, key) {
                    _api_register(key + "()", (function() {
                        var args = Array.prototype.slice.call(arguments);
                        args[0] = $.map(args[0].split(/\s/), (function(e) {
                            return e.match(/\.dt\b/) ? e : e + ".dt"
                        })).join(" ");
                        var inst = $(this.tables().nodes());
                        return inst[key].apply(inst, args), this
                    }))
                })), _api_register("clear()", (function() {
                    return this.iterator("table", (function(settings) {
                        _fnClearTable(settings)
                    }))
                })), _api_register("settings()", (function() {
                    return new _Api(this.context, this.context)
                })), _api_register("init()", (function() {
                    var ctx = this.context;
                    return ctx.length ? ctx[0].oInit : null
                })), _api_register("data()", (function() {
                    return this.iterator("table", (function(settings) {
                        return _pluck(settings.aoData, "_aData")
                    })).flatten()
                })), _api_register("destroy()", (function(remove) {
                    return remove = remove || !1, this.iterator("table", (function(settings) {
                        var ien, orig = settings.nTableWrapper.parentNode,
                            classes = settings.oClasses,
                            table = settings.nTable,
                            tbody = settings.nTBody,
                            thead = settings.nTHead,
                            tfoot = settings.nTFoot,
                            jqTable = $(table),
                            jqTbody = $(tbody),
                            jqWrapper = $(settings.nTableWrapper),
                            rows = $.map(settings.aoData, (function(r) {
                                return r.nTr
                            }));
                        settings.bDestroying = !0, _fnCallbackFire(settings, "aoDestroyCallback", "destroy", [settings]), remove || new _Api(settings).columns().visible(!0), jqWrapper.off(".DT").find(":not(tbody *)").off(".DT"), $(window).off(".DT-" + settings.sInstance), table != thead.parentNode && (jqTable.children("thead").detach(), jqTable.append(thead)), tfoot && table != tfoot.parentNode && (jqTable.children("tfoot").detach(), jqTable.append(tfoot)), settings.aaSorting = [], settings.aaSortingFixed = [], _fnSortingClasses(settings), $(rows).removeClass(settings.asStripeClasses.join(" ")), $("th, td", thead).removeClass(classes.sSortable + " " + classes.sSortableAsc + " " + classes.sSortableDesc + " " + classes.sSortableNone), jqTbody.children().detach(), jqTbody.append(rows);
                        var removedMethod = remove ? "remove" : "detach";
                        jqTable[removedMethod](), jqWrapper[removedMethod](), !remove && orig && (orig.insertBefore(table, settings.nTableReinsertBefore), jqTable.css("width", settings.sDestroyWidth).removeClass(classes.sTable), (ien = settings.asDestroyStripes.length) && jqTbody.children().each((function(i) {
                            $(this).addClass(settings.asDestroyStripes[i % ien])
                        })));
                        var idx = $.inArray(settings, DataTable.settings); - 1 !== idx && DataTable.settings.splice(idx, 1)
                    }))
                })), $.each(["column", "row", "cell"], (function(i, type) {
                    _api_register(type + "s().every()", (function(fn) {
                        var opts = this.selector.opts,
                            api = this;
                        return this.iterator(type, (function(settings, arg1, arg2, arg3, arg4) {
                            fn.call(api[type](arg1, "cell" === type ? arg2 : opts, "cell" === type ? opts : undefined), arg1, arg2, arg3, arg4)
                        }))
                    }))
                })), _api_register("i18n()", (function(token, def, plural) {
                    var ctx = this.context[0],
                        resolved = _fnGetObjectDataFn(token)(ctx.oLanguage);
                    return resolved === undefined && (resolved = def), plural !== undefined && $.isPlainObject(resolved) && (resolved = resolved[plural] !== undefined ? resolved[plural] : resolved._), resolved.replace("%d", plural)
                })), DataTable.version = "1.10.18", DataTable.settings = [], DataTable.models = {}, DataTable.models.oSearch = {
                    bCaseInsensitive: !0,
                    sSearch: "",
                    bRegex: !1,
                    bSmart: !0
                }, DataTable.models.oRow = {
                    nTr: null,
                    anCells: null,
                    _aData: [],
                    _aSortData: null,
                    _aFilterData: null,
                    _sFilterRow: null,
                    _sRowStripe: "",
                    src: null,
                    idx: -1
                }, DataTable.models.oColumn = {
                    idx: null,
                    aDataSort: null,
                    asSorting: null,
                    bSearchable: null,
                    bSortable: null,
                    bVisible: null,
                    _sManualType: null,
                    _bAttrSrc: !1,
                    fnCreatedCell: null,
                    fnGetData: null,
                    fnSetData: null,
                    mData: null,
                    mRender: null,
                    nTh: null,
                    nTf: null,
                    sClass: null,
                    sContentPadding: null,
                    sDefaultContent: null,
                    sName: null,
                    sSortDataType: "std",
                    sSortingClass: null,
                    sSortingClassJUI: null,
                    sTitle: null,
                    sType: null,
                    sWidth: null,
                    sWidthOrig: null
                }, DataTable.defaults = {
                    aaData: null,
                    aaSorting: [
                        [0, "asc"]
                    ],
                    aaSortingFixed: [],
                    ajax: null,
                    aLengthMenu: [10, 25, 50, 100],
                    aoColumns: null,
                    aoColumnDefs: null,
                    aoSearchCols: [],
                    asStripeClasses: null,
                    bAutoWidth: !0,
                    bDeferRender: !1,
                    bDestroy: !1,
                    bFilter: !0,
                    bInfo: !0,
                    bLengthChange: !0,
                    bPaginate: !0,
                    bProcessing: !1,
                    bRetrieve: !1,
                    bScrollCollapse: !1,
                    bServerSide: !1,
                    bSort: !0,
                    bSortMulti: !0,
                    bSortCellsTop: !1,
                    bSortClasses: !0,
                    bStateSave: !1,
                    fnCreatedRow: null,
                    fnDrawCallback: null,
                    fnFooterCallback: null,
                    fnFormatNumber: function(toFormat) {
                        return toFormat.toString().replace(/\B(?=(\d{3})+(?!\d))/g, this.oLanguage.sThousands)
                    },
                    fnHeaderCallback: null,
                    fnInfoCallback: null,
                    fnInitComplete: null,
                    fnPreDrawCallback: null,
                    fnRowCallback: null,
                    fnServerData: null,
                    fnServerParams: null,
                    fnStateLoadCallback: function(settings) {
                        try {
                            return JSON.parse((-1 === settings.iStateDuration ? sessionStorage : localStorage).getItem("DataTables_" + settings.sInstance + "_" + location.pathname))
                        } catch (e) {}
                    },
                    fnStateLoadParams: null,
                    fnStateLoaded: null,
                    fnStateSaveCallback: function(settings, data) {
                        try {
                            (-1 === settings.iStateDuration ? sessionStorage : localStorage).setItem("DataTables_" + settings.sInstance + "_" + location.pathname, JSON.stringify(data))
                        } catch (e) {}
                    },
                    fnStateSaveParams: null,
                    iStateDuration: 7200,
                    iDeferLoading: null,
                    iDisplayLength: 10,
                    iDisplayStart: 0,
                    iTabIndex: 0,
                    oClasses: {},
                    oLanguage: {
                        oAria: {
                            sSortAscending: ": activate to sort column ascending",
                            sSortDescending: ": activate to sort column descending"
                        },
                        oPaginate: {
                            sFirst: "First",
                            sLast: "Last",
                            sNext: "Next",
                            sPrevious: "Previous"
                        },
                        sEmptyTable: "No data available in table",
                        sInfo: "Showing _START_ to _END_ of _TOTAL_ entries",
                        sInfoEmpty: "Showing 0 to 0 of 0 entries",
                        sInfoFiltered: "(filtered from _MAX_ total entries)",
                        sInfoPostFix: "",
                        sDecimal: "",
                        sThousands: ",",
                        sLengthMenu: "Show _MENU_ entries",
                        sLoadingRecords: "Loading...",
                        sProcessing: "Processing...",
                        sSearch: "Search:",
                        sSearchPlaceholder: "",
                        sUrl: "",
                        sZeroRecords: "No matching records found"
                    },
                    oSearch: $.extend({}, DataTable.models.oSearch),
                    sAjaxDataProp: "data",
                    sAjaxSource: null,
                    sDom: "lfrtip",
                    searchDelay: null,
                    sPaginationType: "simple_numbers",
                    sScrollX: "",
                    sScrollXInner: "",
                    sScrollY: "",
                    sServerMethod: "GET",
                    renderer: null,
                    rowId: "DT_RowId"
                }, _fnHungarianMap(DataTable.defaults), DataTable.defaults.column = {
                    aDataSort: null,
                    iDataSort: -1,
                    asSorting: ["asc", "desc"],
                    bSearchable: !0,
                    bSortable: !0,
                    bVisible: !0,
                    fnCreatedCell: null,
                    mData: null,
                    mRender: null,
                    sCellType: "td",
                    sClass: "",
                    sContentPadding: "",
                    sDefaultContent: null,
                    sName: "",
                    sSortDataType: "std",
                    sTitle: null,
                    sType: null,
                    sWidth: null
                }, _fnHungarianMap(DataTable.defaults.column), DataTable.models.oSettings = {
                    oFeatures: {
                        bAutoWidth: null,
                        bDeferRender: null,
                        bFilter: null,
                        bInfo: null,
                        bLengthChange: null,
                        bPaginate: null,
                        bProcessing: null,
                        bServerSide: null,
                        bSort: null,
                        bSortMulti: null,
                        bSortClasses: null,
                        bStateSave: null
                    },
                    oScroll: {
                        bCollapse: null,
                        iBarWidth: 0,
                        sX: null,
                        sXInner: null,
                        sY: null
                    },
                    oLanguage: {
                        fnInfoCallback: null
                    },
                    oBrowser: {
                        bScrollOversize: !1,
                        bScrollbarLeft: !1,
                        bBounding: !1,
                        barWidth: 0
                    },
                    ajax: null,
                    aanFeatures: [],
                    aoData: [],
                    aiDisplay: [],
                    aiDisplayMaster: [],
                    aIds: {},
                    aoColumns: [],
                    aoHeader: [],
                    aoFooter: [],
                    oPreviousSearch: {},
                    aoPreSearchCols: [],
                    aaSorting: null,
                    aaSortingFixed: [],
                    asStripeClasses: null,
                    asDestroyStripes: [],
                    sDestroyWidth: 0,
                    aoRowCallback: [],
                    aoHeaderCallback: [],
                    aoFooterCallback: [],
                    aoDrawCallback: [],
                    aoRowCreatedCallback: [],
                    aoPreDrawCallback: [],
                    aoInitComplete: [],
                    aoStateSaveParams: [],
                    aoStateLoadParams: [],
                    aoStateLoaded: [],
                    sTableId: "",
                    nTable: null,
                    nTHead: null,
                    nTFoot: null,
                    nTBody: null,
                    nTableWrapper: null,
                    bDeferLoading: !1,
                    bInitialised: !1,
                    aoOpenRows: [],
                    sDom: null,
                    searchDelay: null,
                    sPaginationType: "two_button",
                    iStateDuration: 0,
                    aoStateSave: [],
                    aoStateLoad: [],
                    oSavedState: null,
                    oLoadedState: null,
                    sAjaxSource: null,
                    sAjaxDataProp: null,
                    bAjaxDataGet: !0,
                    jqXHR: null,
                    json: undefined,
                    oAjaxData: undefined,
                    fnServerData: null,
                    aoServerParams: [],
                    sServerMethod: null,
                    fnFormatNumber: null,
                    aLengthMenu: null,
                    iDraw: 0,
                    bDrawing: !1,
                    iDrawError: -1,
                    _iDisplayLength: 10,
                    _iDisplayStart: 0,
                    _iRecordsTotal: 0,
                    _iRecordsDisplay: 0,
                    oClasses: {},
                    bFiltered: !1,
                    bSorted: !1,
                    bSortCellsTop: null,
                    oInit: null,
                    aoDestroyCallback: [],
                    fnRecordsTotal: function() {
                        return "ssp" == _fnDataSource(this) ? 1 * this._iRecordsTotal : this.aiDisplayMaster.length
                    },
                    fnRecordsDisplay: function() {
                        return "ssp" == _fnDataSource(this) ? 1 * this._iRecordsDisplay : this.aiDisplay.length
                    },
                    fnDisplayEnd: function() {
                        var len = this._iDisplayLength,
                            start = this._iDisplayStart,
                            calc = start + len,
                            records = this.aiDisplay.length,
                            features = this.oFeatures,
                            paginate = features.bPaginate;
                        return features.bServerSide ? !1 === paginate || -1 === len ? start + records : Math.min(start + len, this._iRecordsDisplay) : !paginate || calc > records || -1 === len ? records : calc
                    },
                    oInstance: null,
                    sInstance: null,
                    iTabIndex: 0,
                    nScrollHead: null,
                    nScrollFoot: null,
                    aLastSort: [],
                    oPlugins: {},
                    rowIdFn: null,
                    rowId: null
                }, DataTable.ext = _ext = {
                    buttons: {},
                    classes: {},
                    builder: "-source-",
                    errMode: "alert",
                    feature: [],
                    search: [],
                    selector: {
                        cell: [],
                        column: [],
                        row: []
                    },
                    internal: {},
                    legacy: {
                        ajax: null
                    },
                    pager: {},
                    renderer: {
                        pageButton: {},
                        header: {}
                    },
                    order: {},
                    type: {
                        detect: [],
                        search: {},
                        order: {}
                    },
                    _unique: 0,
                    fnVersionCheck: DataTable.fnVersionCheck,
                    iApiIndex: 0,
                    oJUIClasses: {},
                    sVersion: DataTable.version
                }, $.extend(_ext, {
                    afnFiltering: _ext.search,
                    aTypes: _ext.type.detect,
                    ofnSearch: _ext.type.search,
                    oSort: _ext.type.order,
                    afnSortData: _ext.order,
                    aoFeatures: _ext.feature,
                    oApi: _ext.internal,
                    oStdClasses: _ext.classes,
                    oPagination: _ext.pager
                }), $.extend(DataTable.ext.classes, {
                    sTable: "dataTable",
                    sNoFooter: "no-footer",
                    sPageButton: "paginate_button",
                    sPageButtonActive: "current",
                    sPageButtonDisabled: "disabled",
                    sStripeOdd: "odd",
                    sStripeEven: "even",
                    sRowEmpty: "dataTables_empty",
                    sWrapper: "dataTables_wrapper",
                    sFilter: "dataTables_filter",
                    sInfo: "dataTables_info",
                    sPaging: "dataTables_paginate paging_",
                    sLength: "dataTables_length",
                    sProcessing: "dataTables_processing",
                    sSortAsc: "sorting_asc",
                    sSortDesc: "sorting_desc",
                    sSortable: "sorting",
                    sSortableAsc: "sorting_asc_disabled",
                    sSortableDesc: "sorting_desc_disabled",
                    sSortableNone: "sorting_disabled",
                    sSortColumn: "sorting_",
                    sFilterInput: "",
                    sLengthSelect: "",
                    sScrollWrapper: "dataTables_scroll",
                    sScrollHead: "dataTables_scrollHead",
                    sScrollHeadInner: "dataTables_scrollHeadInner",
                    sScrollBody: "dataTables_scrollBody",
                    sScrollFoot: "dataTables_scrollFoot",
                    sScrollFootInner: "dataTables_scrollFootInner",
                    sHeaderTH: "",
                    sFooterTH: "",
                    sSortJUIAsc: "",
                    sSortJUIDesc: "",
                    sSortJUI: "",
                    sSortJUIAscAllowed: "",
                    sSortJUIDescAllowed: "",
                    sSortJUIWrapper: "",
                    sSortIcon: "",
                    sJUIHeader: "",
                    sJUIFooter: ""
                });
                var extPagination = DataTable.ext.pager;

                function _numbers(page, pages) {
                    var numbers = [],
                        buttons = extPagination.numbers_length,
                        half = Math.floor(buttons / 2);
                    return pages <= buttons ? numbers = _range(0, pages) : page <= half ? ((numbers = _range(0, buttons - 2)).push("ellipsis"), numbers.push(pages - 1)) : page >= pages - 1 - half ? ((numbers = _range(pages - (buttons - 2), pages)).splice(0, 0, "ellipsis"), numbers.splice(0, 0, 0)) : ((numbers = _range(page - half + 2, page + half - 1)).push("ellipsis"), numbers.push(pages - 1), numbers.splice(0, 0, "ellipsis"), numbers.splice(0, 0, 0)), numbers.DT_el = "span", numbers
                }
                $.extend(extPagination, {
                    simple: function(page, pages) {
                        return ["previous", "next"]
                    },
                    full: function(page, pages) {
                        return ["first", "previous", "next", "last"]
                    },
                    numbers: function(page, pages) {
                        return [_numbers(page, pages)]
                    },
                    simple_numbers: function(page, pages) {
                        return ["previous", _numbers(page, pages), "next"]
                    },
                    full_numbers: function(page, pages) {
                        return ["first", "previous", _numbers(page, pages), "next", "last"]
                    },
                    first_last_numbers: function(page, pages) {
                        return ["first", _numbers(page, pages), "last"]
                    },
                    _numbers: _numbers,
                    numbers_length: 7
                }), $.extend(!0, DataTable.ext.renderer, {
                    pageButton: {
                        _: function(settings, host, idx, buttons, page, pages) {
                            var btnDisplay, btnClass, activeEl, classes = settings.oClasses,
                                lang = settings.oLanguage.oPaginate,
                                aria = settings.oLanguage.oAria.paginate || {},
                                counter = 0,
                                attach = function(container, buttons) {
                                    var i, ien, button, clickHandler = function(e) {
                                        _fnPageChange(settings, e.data.action, !0)
                                    };
                                    for (i = 0, ien = buttons.length; i < ien; i++)
                                        if (button = buttons[i], $.isArray(button)) {
                                            var inner = $("<" + (button.DT_el || "div") + "/>").appendTo(container);
                                            attach(inner, button)
                                        } else {
                                            switch (btnDisplay = null, btnClass = "", button) {
                                                case "ellipsis":
                                                    container.append('<span class="ellipsis">&#x2026;</span>');
                                                    break;
                                                case "first":
                                                    btnDisplay = lang.sFirst, btnClass = button + (page > 0 ? "" : " " + classes.sPageButtonDisabled);
                                                    break;
                                                case "previous":
                                                    btnDisplay = lang.sPrevious, btnClass = button + (page > 0 ? "" : " " + classes.sPageButtonDisabled);
                                                    break;
                                                case "next":
                                                    btnDisplay = lang.sNext, btnClass = button + (page < pages - 1 ? "" : " " + classes.sPageButtonDisabled);
                                                    break;
                                                case "last":
                                                    btnDisplay = lang.sLast, btnClass = button + (page < pages - 1 ? "" : " " + classes.sPageButtonDisabled);
                                                    break;
                                                default:
                                                    btnDisplay = button + 1, btnClass = page === button ? classes.sPageButtonActive : ""
                                            }
                                            null !== btnDisplay && (_fnBindAction($("<a>", {
                                                class: classes.sPageButton + " " + btnClass,
                                                "aria-controls": settings.sTableId,
                                                "aria-label": aria[button],
                                                "data-dt-idx": counter,
                                                tabindex: settings.iTabIndex,
                                                id: 0 === idx && "string" == typeof button ? settings.sTableId + "_" + button : null
                                            }).html(btnDisplay).appendTo(container), {
                                                action: button
                                            }, clickHandler), counter++)
                                        }
                                };
                            try {
                                activeEl = $(host).find(document.activeElement).data("dt-idx")
                            } catch (e) {}
                            attach($(host).empty(), buttons), activeEl !== undefined && $(host).find("[data-dt-idx=" + activeEl + "]").focus()
                        }
                    }
                }), $.extend(DataTable.ext.type.detect, [function(d, settings) {
                    var decimal = settings.oLanguage.sDecimal;
                    return _isNumber(d, decimal) ? "num" + decimal : null
                }, function(d, settings) {
                    if (d && !(d instanceof Date) && !_re_date.test(d)) return null;
                    var parsed = Date.parse(d);
                    return null !== parsed && !isNaN(parsed) || _empty(d) ? "date" : null
                }, function(d, settings) {
                    var decimal = settings.oLanguage.sDecimal;
                    return _isNumber(d, decimal, !0) ? "num-fmt" + decimal : null
                }, function(d, settings) {
                    var decimal = settings.oLanguage.sDecimal;
                    return _htmlNumeric(d, decimal) ? "html-num" + decimal : null
                }, function(d, settings) {
                    var decimal = settings.oLanguage.sDecimal;
                    return _htmlNumeric(d, decimal, !0) ? "html-num-fmt" + decimal : null
                }, function(d, settings) {
                    return _empty(d) || "string" == typeof d && -1 !== d.indexOf("<") ? "html" : null
                }]), $.extend(DataTable.ext.type.search, {
                    html: function(data) {
                        return _empty(data) ? data : "string" == typeof data ? data.replace(_re_new_lines, " ").replace(_re_html, "") : ""
                    },
                    string: function(data) {
                        return _empty(data) ? data : "string" == typeof data ? data.replace(_re_new_lines, " ") : data
                    }
                });
                var __numericReplace = function(d, decimalPlace, re1, re2) {
                    return 0 === d || d && "-" !== d ? (decimalPlace && (d = _numToDecimal(d, decimalPlace)), d.replace && (re1 && (d = d.replace(re1, "")), re2 && (d = d.replace(re2, ""))), 1 * d) : -1 / 0
                };

                function _addNumericSort(decimalPlace) {
                    $.each({
                        num: function(d) {
                            return __numericReplace(d, decimalPlace)
                        },
                        "num-fmt": function(d) {
                            return __numericReplace(d, decimalPlace, _re_formatted_numeric)
                        },
                        "html-num": function(d) {
                            return __numericReplace(d, decimalPlace, _re_html)
                        },
                        "html-num-fmt": function(d) {
                            return __numericReplace(d, decimalPlace, _re_html, _re_formatted_numeric)
                        }
                    }, (function(key, fn) {
                        _ext.type.order[key + decimalPlace + "-pre"] = fn, key.match(/^html\-/) && (_ext.type.search[key + decimalPlace] = _ext.type.search.html)
                    }))
                }
                $.extend(_ext.type.order, {
                    "date-pre": function(d) {
                        var ts = Date.parse(d);
                        return isNaN(ts) ? -1 / 0 : ts
                    },
                    "html-pre": function(a) {
                        return _empty(a) ? "" : a.replace ? a.replace(/<.*?>/g, "").toLowerCase() : a + ""
                    },
                    "string-pre": function(a) {
                        return _empty(a) ? "" : "string" == typeof a ? a.toLowerCase() : a.toString ? a.toString() : ""
                    },
                    "string-asc": function(x, y) {
                        return x < y ? -1 : x > y ? 1 : 0
                    },
                    "string-desc": function(x, y) {
                        return x < y ? 1 : x > y ? -1 : 0
                    }
                }), _addNumericSort(""), $.extend(!0, DataTable.ext.renderer, {
                    header: {
                        _: function(settings, cell, column, classes) {
                            $(settings.nTable).on("order.dt.DT", (function(e, ctx, sorting, columns) {
                                if (settings === ctx) {
                                    var colIdx = column.idx;
                                    cell.removeClass(column.sSortingClass + " " + classes.sSortAsc + " " + classes.sSortDesc).addClass("asc" == columns[colIdx] ? classes.sSortAsc : "desc" == columns[colIdx] ? classes.sSortDesc : column.sSortingClass)
                                }
                            }))
                        },
                        jqueryui: function(settings, cell, column, classes) {
                            $("<div/>").addClass(classes.sSortJUIWrapper).append(cell.contents()).append($("<span/>").addClass(classes.sSortIcon + " " + column.sSortingClassJUI)).appendTo(cell), $(settings.nTable).on("order.dt.DT", (function(e, ctx, sorting, columns) {
                                if (settings === ctx) {
                                    var colIdx = column.idx;
                                    cell.removeClass(classes.sSortAsc + " " + classes.sSortDesc).addClass("asc" == columns[colIdx] ? classes.sSortAsc : "desc" == columns[colIdx] ? classes.sSortDesc : column.sSortingClass), cell.find("span." + classes.sSortIcon).removeClass(classes.sSortJUIAsc + " " + classes.sSortJUIDesc + " " + classes.sSortJUI + " " + classes.sSortJUIAscAllowed + " " + classes.sSortJUIDescAllowed).addClass("asc" == columns[colIdx] ? classes.sSortJUIAsc : "desc" == columns[colIdx] ? classes.sSortJUIDesc : column.sSortingClassJUI)
                                }
                            }))
                        }
                    }
                });
                var __htmlEscapeEntities = function(d) {
                    return "string" == typeof d ? d.replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;") : d
                };

                function _fnExternApiFunc(fn) {
                    return function() {
                        var args = [_fnSettingsFromNode(this[DataTable.ext.iApiIndex])].concat(Array.prototype.slice.call(arguments));
                        return DataTable.ext.internal[fn].apply(this, args)
                    }
                }
                return DataTable.render = {
                    number: function(thousands, decimal, precision, prefix, postfix) {
                        return {
                            display: function(d) {
                                if ("number" != typeof d && "string" != typeof d) return d;
                                var negative = d < 0 ? "-" : "",
                                    flo = parseFloat(d);
                                if (isNaN(flo)) return __htmlEscapeEntities(d);
                                flo = flo.toFixed(precision), d = Math.abs(flo);
                                var intPart = parseInt(d, 10),
                                    floatPart = precision ? decimal + (d - intPart).toFixed(precision).substring(2) : "";
                                return negative + (prefix || "") + intPart.toString().replace(/\B(?=(\d{3})+(?!\d))/g, thousands) + floatPart + (postfix || "")
                            }
                        }
                    },
                    text: function() {
                        return {
                            display: __htmlEscapeEntities
                        }
                    }
                }, $.extend(DataTable.ext.internal, {
                    _fnExternApiFunc: _fnExternApiFunc,
                    _fnBuildAjax: _fnBuildAjax,
                    _fnAjaxUpdate: _fnAjaxUpdate,
                    _fnAjaxParameters: _fnAjaxParameters,
                    _fnAjaxUpdateDraw: _fnAjaxUpdateDraw,
                    _fnAjaxDataSrc: _fnAjaxDataSrc,
                    _fnAddColumn: _fnAddColumn,
                    _fnColumnOptions: _fnColumnOptions,
                    _fnAdjustColumnSizing: _fnAdjustColumnSizing,
                    _fnVisibleToColumnIndex: _fnVisibleToColumnIndex,
                    _fnColumnIndexToVisible: _fnColumnIndexToVisible,
                    _fnVisbleColumns: _fnVisbleColumns,
                    _fnGetColumns: _fnGetColumns,
                    _fnColumnTypes: _fnColumnTypes,
                    _fnApplyColumnDefs: _fnApplyColumnDefs,
                    _fnHungarianMap: _fnHungarianMap,
                    _fnCamelToHungarian: _fnCamelToHungarian,
                    _fnLanguageCompat: _fnLanguageCompat,
                    _fnBrowserDetect: _fnBrowserDetect,
                    _fnAddData: _fnAddData,
                    _fnAddTr: _fnAddTr,
                    _fnNodeToDataIndex: _fnNodeToDataIndex,
                    _fnNodeToColumnIndex: _fnNodeToColumnIndex,
                    _fnGetCellData: _fnGetCellData,
                    _fnSetCellData: _fnSetCellData,
                    _fnSplitObjNotation: _fnSplitObjNotation,
                    _fnGetObjectDataFn: _fnGetObjectDataFn,
                    _fnSetObjectDataFn: _fnSetObjectDataFn,
                    _fnGetDataMaster: _fnGetDataMaster,
                    _fnClearTable: _fnClearTable,
                    _fnDeleteIndex: _fnDeleteIndex,
                    _fnInvalidate: _fnInvalidate,
                    _fnGetRowElements: _fnGetRowElements,
                    _fnCreateTr: _fnCreateTr,
                    _fnBuildHead: _fnBuildHead,
                    _fnDrawHead: _fnDrawHead,
                    _fnDraw: _fnDraw,
                    _fnReDraw: _fnReDraw,
                    _fnAddOptionsHtml: _fnAddOptionsHtml,
                    _fnDetectHeader: _fnDetectHeader,
                    _fnGetUniqueThs: _fnGetUniqueThs,
                    _fnFeatureHtmlFilter: _fnFeatureHtmlFilter,
                    _fnFilterComplete: _fnFilterComplete,
                    _fnFilterCustom: _fnFilterCustom,
                    _fnFilterColumn: _fnFilterColumn,
                    _fnFilter: _fnFilter,
                    _fnFilterCreateSearch: _fnFilterCreateSearch,
                    _fnEscapeRegex: _fnEscapeRegex,
                    _fnFilterData: _fnFilterData,
                    _fnFeatureHtmlInfo: _fnFeatureHtmlInfo,
                    _fnUpdateInfo: _fnUpdateInfo,
                    _fnInfoMacros: _fnInfoMacros,
                    _fnInitialise: _fnInitialise,
                    _fnInitComplete: _fnInitComplete,
                    _fnLengthChange: _fnLengthChange,
                    _fnFeatureHtmlLength: _fnFeatureHtmlLength,
                    _fnFeatureHtmlPaginate: _fnFeatureHtmlPaginate,
                    _fnPageChange: _fnPageChange,
                    _fnFeatureHtmlProcessing: _fnFeatureHtmlProcessing,
                    _fnProcessingDisplay: _fnProcessingDisplay,
                    _fnFeatureHtmlTable: _fnFeatureHtmlTable,
                    _fnScrollDraw: _fnScrollDraw,
                    _fnApplyToChildren: _fnApplyToChildren,
                    _fnCalculateColumnWidths: _fnCalculateColumnWidths,
                    _fnThrottle: _fnThrottle,
                    _fnConvertToWidth: _fnConvertToWidth,
                    _fnGetWidestNode: _fnGetWidestNode,
                    _fnGetMaxLenString: _fnGetMaxLenString,
                    _fnStringToCss: _fnStringToCss,
                    _fnSortFlatten: _fnSortFlatten,
                    _fnSort: _fnSort,
                    _fnSortAria: _fnSortAria,
                    _fnSortListener: _fnSortListener,
                    _fnSortAttachListener: _fnSortAttachListener,
                    _fnSortingClasses: _fnSortingClasses,
                    _fnSortData: _fnSortData,
                    _fnSaveState: _fnSaveState,
                    _fnLoadState: _fnLoadState,
                    _fnSettingsFromNode: _fnSettingsFromNode,
                    _fnLog: _fnLog,
                    _fnMap: _fnMap,
                    _fnBindAction: _fnBindAction,
                    _fnCallbackReg: _fnCallbackReg,
                    _fnCallbackFire: _fnCallbackFire,
                    _fnLengthOverflow: _fnLengthOverflow,
                    _fnRenderer: _fnRenderer,
                    _fnDataSource: _fnDataSource,
                    _fnRowAttributes: _fnRowAttributes,
                    _fnExtend: _fnExtend,
                    _fnCalculateEnd: function() {}
                }), $.fn.dataTable = DataTable, DataTable.$ = $, $.fn.dataTableSettings = DataTable.settings, $.fn.dataTableExt = DataTable.ext, $.fn.DataTable = function(opts) {
                    return $(this).dataTable(opts).api()
                }, $.each(DataTable, (function(prop, val) {
                    $.fn.DataTable[prop] = val
                })), $.fn.dataTable
            }($, window, document)
        }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)
    }()
}, function(module, exports) {
    ! function(window) {
        "use strict";
        var minErrConfig = {
            objectMaxDepth: 5,
            urlErrorParamsEnabled: !0
        };

        function errorHandlingConfig(config) {
            if (!isObject(config)) return minErrConfig;
            isDefined(config.objectMaxDepth) && (minErrConfig.objectMaxDepth = isValidObjectMaxDepth(config.objectMaxDepth) ? config.objectMaxDepth : NaN), isDefined(config.urlErrorParamsEnabled) && isBoolean(config.urlErrorParamsEnabled) && (minErrConfig.urlErrorParamsEnabled = config.urlErrorParamsEnabled)
        }

        function isValidObjectMaxDepth(maxDepth) {
            return isNumber(maxDepth) && maxDepth > 0
        }

        function minErr(module, ErrorConstructor) {
            ErrorConstructor = ErrorConstructor || Error;
            var url = "https://errors.angularjs.org/1.8.2/",
                regex = url.replace(".", "\\.") + "[\\s\\S]*",
                errRegExp = new RegExp(regex, "g");
            return function() {
                var paramPrefix, i, code = arguments[0],
                    template = arguments[1],
                    message = "[" + (module ? module + ":" : "") + code + "] ",
                    templateArgs = sliceArgs(arguments, 2).map((function(arg) {
                        return toDebugString(arg, minErrConfig.objectMaxDepth)
                    }));
                if (message += template.replace(/\{\d+\}/g, (function(match) {
                        var index = +match.slice(1, -1);
                        return index < templateArgs.length ? templateArgs[index].replace(errRegExp, "") : match
                    })), message += "\n" + url + (module ? module + "/" : "") + code, minErrConfig.urlErrorParamsEnabled)
                    for (i = 0, paramPrefix = "?"; i < templateArgs.length; i++, paramPrefix = "&") message += paramPrefix + "p" + i + "=" + encodeURIComponent(templateArgs[i]);
                return new ErrorConstructor(message)
            }
        }
        var msie, jqLite, jQuery, angularModule, REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/,
            hasOwnProperty = Object.prototype.hasOwnProperty,
            lowercase = function(string) {
                return isString(string) ? string.toLowerCase() : string
            },
            uppercase = function(string) {
                return isString(string) ? string.toUpperCase() : string
            },
            slice = [].slice,
            splice = [].splice,
            push = [].push,
            toString = Object.prototype.toString,
            getPrototypeOf = Object.getPrototypeOf,
            ngMinErr = minErr("ng"),
            angular = window.angular || (window.angular = {}),
            uid = 0;

        function isArrayLike(obj) {
            if (null == obj || isWindow(obj)) return !1;
            if (isArray(obj) || isString(obj) || jqLite && obj instanceof jqLite) return !0;
            var length = "length" in Object(obj) && obj.length;
            return isNumber(length) && (length >= 0 && length - 1 in obj || "function" == typeof obj.item)
        }

        function forEach(obj, iterator, context) {
            var key, length;
            if (obj)
                if (isFunction(obj))
                    for (key in obj) "prototype" !== key && "length" !== key && "name" !== key && obj.hasOwnProperty(key) && iterator.call(context, obj[key], key, obj);
                else if (isArray(obj) || isArrayLike(obj)) {
                var isPrimitive = "object" != typeof obj;
                for (key = 0, length = obj.length; key < length; key++)(isPrimitive || key in obj) && iterator.call(context, obj[key], key, obj)
            } else if (obj.forEach && obj.forEach !== forEach) obj.forEach(iterator, context, obj);
            else if (isBlankObject(obj))
                for (key in obj) iterator.call(context, obj[key], key, obj);
            else if ("function" == typeof obj.hasOwnProperty)
                for (key in obj) obj.hasOwnProperty(key) && iterator.call(context, obj[key], key, obj);
            else
                for (key in obj) hasOwnProperty.call(obj, key) && iterator.call(context, obj[key], key, obj);
            return obj
        }

        function forEachSorted(obj, iterator, context) {
            for (var keys = Object.keys(obj).sort(), i = 0; i < keys.length; i++) iterator.call(context, obj[keys[i]], keys[i]);
            return keys
        }

        function reverseParams(iteratorFn) {
            return function(value, key) {
                iteratorFn(key, value)
            }
        }

        function nextUid() {
            return ++uid
        }

        function setHashKey(obj, h) {
            h ? obj.$$hashKey = h : delete obj.$$hashKey
        }

        function baseExtend(dst, objs, deep) {
            for (var h = dst.$$hashKey, i = 0, ii = objs.length; i < ii; ++i) {
                var obj = objs[i];
                if (isObject(obj) || isFunction(obj))
                    for (var keys = Object.keys(obj), j = 0, jj = keys.length; j < jj; j++) {
                        var key = keys[j],
                            src = obj[key];
                        deep && isObject(src) ? isDate(src) ? dst[key] = new Date(src.valueOf()) : isRegExp(src) ? dst[key] = new RegExp(src) : src.nodeName ? dst[key] = src.cloneNode(!0) : isElement(src) ? dst[key] = src.clone() : "__proto__" !== key && (isObject(dst[key]) || (dst[key] = isArray(src) ? [] : {}), baseExtend(dst[key], [src], !0)) : dst[key] = src
                    }
            }
            return setHashKey(dst, h), dst
        }

        function extend(dst) {
            return baseExtend(dst, slice.call(arguments, 1), !1)
        }

        function merge(dst) {
            return baseExtend(dst, slice.call(arguments, 1), !0)
        }

        function toInt(str) {
            return parseInt(str, 10)
        }
        msie = window.document.documentMode;
        var isNumberNaN = Number.isNaN || function(num) {
            return num != num
        };

        function inherit(parent, extra) {
            return extend(Object.create(parent), extra)
        }

        function noop() {}

        function identity($) {
            return $
        }

        function valueFn(value) {
            return function() {
                return value
            }
        }

        function hasCustomToString(obj) {
            return isFunction(obj.toString) && obj.toString !== toString
        }

        function isUndefined(value) {
            return void 0 === value
        }

        function isDefined(value) {
            return void 0 !== value
        }

        function isObject(value) {
            return null !== value && "object" == typeof value
        }

        function isBlankObject(value) {
            return null !== value && "object" == typeof value && !getPrototypeOf(value)
        }

        function isString(value) {
            return "string" == typeof value
        }

        function isNumber(value) {
            return "number" == typeof value
        }

        function isDate(value) {
            return "[object Date]" === toString.call(value)
        }

        function isArray(arr) {
            return Array.isArray(arr) || arr instanceof Array
        }

        function isError(value) {
            switch (toString.call(value)) {
                case "[object Error]":
                case "[object Exception]":
                case "[object DOMException]":
                    return !0;
                default:
                    return value instanceof Error
            }
        }

        function isFunction(value) {
            return "function" == typeof value
        }

        function isRegExp(value) {
            return "[object RegExp]" === toString.call(value)
        }

        function isWindow(obj) {
            return obj && obj.window === obj
        }

        function isScope(obj) {
            return obj && obj.$evalAsync && obj.$watch
        }

        function isBoolean(value) {
            return "boolean" == typeof value
        }

        function isPromiseLike(obj) {
            return obj && isFunction(obj.then)
        }
        noop.$inject = [], identity.$inject = [];
        var TYPED_ARRAY_REGEXP = /^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array]$/;
        var trim = function(value) {
                return isString(value) ? value.trim() : value
            },
            escapeForRegexp = function(s) {
                return s.replace(/([-()[\]{}+?*.$^|,:#<!\\])/g, "\\$1").replace(/\x08/g, "\\x08")
            };

        function isElement(node) {
            return !(!node || !(node.nodeName || node.prop && node.attr && node.find))
        }

        function nodeName_(element) {
            return lowercase(element.nodeName || element[0] && element[0].nodeName)
        }

        function includes(array, obj) {
            return -1 !== Array.prototype.indexOf.call(array, obj)
        }

        function arrayRemove(array, value) {
            var index = array.indexOf(value);
            return index >= 0 && array.splice(index, 1), index
        }

        function copy(source, destination, maxDepth) {
            var obj, value, stackSource = [],
                stackDest = [];
            if (maxDepth = isValidObjectMaxDepth(maxDepth) ? maxDepth : NaN, destination) {
                if ((value = destination) && isNumber(value.length) && TYPED_ARRAY_REGEXP.test(toString.call(value)) || (obj = destination, "[object ArrayBuffer]" === toString.call(obj))) throw ngMinErr("cpta", "Can't copy! TypedArray destination cannot be mutated.");
                if (source === destination) throw ngMinErr("cpi", "Can't copy! Source and destination are identical.");
                return isArray(destination) ? destination.length = 0 : forEach(destination, (function(value, key) {
                    "$$hashKey" !== key && delete destination[key]
                })), stackSource.push(source), stackDest.push(destination), copyRecurse(source, destination, maxDepth)
            }
            return copyElement(source, maxDepth);

            function copyRecurse(source, destination, maxDepth) {
                if (--maxDepth < 0) return "...";
                var key, h = destination.$$hashKey;
                if (isArray(source))
                    for (var i = 0, ii = source.length; i < ii; i++) destination.push(copyElement(source[i], maxDepth));
                else if (isBlankObject(source))
                    for (key in source) destination[key] = copyElement(source[key], maxDepth);
                else if (source && "function" == typeof source.hasOwnProperty)
                    for (key in source) source.hasOwnProperty(key) && (destination[key] = copyElement(source[key], maxDepth));
                else
                    for (key in source) hasOwnProperty.call(source, key) && (destination[key] = copyElement(source[key], maxDepth));
                return setHashKey(destination, h), destination
            }

            function copyElement(source, maxDepth) {
                if (!isObject(source)) return source;
                var index = stackSource.indexOf(source);
                if (-1 !== index) return stackDest[index];
                if (isWindow(source) || isScope(source)) throw ngMinErr("cpws", "Can't copy! Making copies of Window or Scope instances is not supported.");
                var needsRecurse = !1,
                    destination = function(source) {
                        switch (toString.call(source)) {
                            case "[object Int8Array]":
                            case "[object Int16Array]":
                            case "[object Int32Array]":
                            case "[object Float32Array]":
                            case "[object Float64Array]":
                            case "[object Uint8Array]":
                            case "[object Uint8ClampedArray]":
                            case "[object Uint16Array]":
                            case "[object Uint32Array]":
                                return new source.constructor(copyElement(source.buffer), source.byteOffset, source.length);
                            case "[object ArrayBuffer]":
                                if (!source.slice) {
                                    var copied = new ArrayBuffer(source.byteLength);
                                    return new Uint8Array(copied).set(new Uint8Array(source)), copied
                                }
                                return source.slice(0);
                            case "[object Boolean]":
                            case "[object Number]":
                            case "[object String]":
                            case "[object Date]":
                                return new source.constructor(source.valueOf());
                            case "[object RegExp]":
                                var re = new RegExp(source.source, source.toString().match(/[^/]*$/)[0]);
                                return re.lastIndex = source.lastIndex, re;
                            case "[object Blob]":
                                return new source.constructor([source], {
                                    type: source.type
                                })
                        }
                        if (isFunction(source.cloneNode)) return source.cloneNode(!0)
                    }(source);
                return void 0 === destination && (destination = isArray(source) ? [] : Object.create(getPrototypeOf(source)), needsRecurse = !0), stackSource.push(source), stackDest.push(destination), needsRecurse ? copyRecurse(source, destination, maxDepth) : destination
            }
        }

        function simpleCompare(a, b) {
            return a === b || a != a && b != b
        }

        function equals(o1, o2) {
            if (o1 === o2) return !0;
            if (null === o1 || null === o2) return !1;
            if (o1 != o1 && o2 != o2) return !0;
            var length, key, keySet, t1 = typeof o1;
            if (t1 === typeof o2 && "object" === t1) {
                if (!isArray(o1)) {
                    if (isDate(o1)) return !!isDate(o2) && simpleCompare(o1.getTime(), o2.getTime());
                    if (isRegExp(o1)) return !!isRegExp(o2) && o1.toString() === o2.toString();
                    if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2) || isDate(o2) || isRegExp(o2)) return !1;
                    for (key in keySet = createMap(), o1)
                        if ("$" !== key.charAt(0) && !isFunction(o1[key])) {
                            if (!equals(o1[key], o2[key])) return !1;
                            keySet[key] = !0
                        }
                    for (key in o2)
                        if (!(key in keySet) && "$" !== key.charAt(0) && isDefined(o2[key]) && !isFunction(o2[key])) return !1;
                    return !0
                }
                if (!isArray(o2)) return !1;
                if ((length = o1.length) === o2.length) {
                    for (key = 0; key < length; key++)
                        if (!equals(o1[key], o2[key])) return !1;
                    return !0
                }
            }
            return !1
        }
        var csp = function() {
                if (!isDefined(csp.rules)) {
                    var ngCspElement = window.document.querySelector("[ng-csp]") || window.document.querySelector("[data-ng-csp]");
                    if (ngCspElement) {
                        var ngCspAttribute = ngCspElement.getAttribute("ng-csp") || ngCspElement.getAttribute("data-ng-csp");
                        csp.rules = {
                            noUnsafeEval: !ngCspAttribute || -1 !== ngCspAttribute.indexOf("no-unsafe-eval"),
                            noInlineStyle: !ngCspAttribute || -1 !== ngCspAttribute.indexOf("no-inline-style")
                        }
                    } else csp.rules = {
                        noUnsafeEval: function() {
                            try {
                                return new Function(""), !1
                            } catch (e) {
                                return !0
                            }
                        }(),
                        noInlineStyle: !1
                    }
                }
                return csp.rules
            },
            jq = function() {
                if (isDefined(jq.name_)) return jq.name_;
                var el, i, prefix, name, ii = ngAttrPrefixes.length;
                for (i = 0; i < ii; ++i)
                    if (prefix = ngAttrPrefixes[i], el = window.document.querySelector("[" + prefix.replace(":", "\\:") + "jq]")) {
                        name = el.getAttribute(prefix + "jq");
                        break
                    }
                return jq.name_ = name
            };

        function concat(array1, array2, index) {
            return array1.concat(slice.call(array2, index))
        }

        function sliceArgs(args, startIndex) {
            return slice.call(args, startIndex || 0)
        }

        function bind(self, fn) {
            var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
            return !isFunction(fn) || fn instanceof RegExp ? fn : curryArgs.length ? function() {
                return arguments.length ? fn.apply(self, concat(curryArgs, arguments, 0)) : fn.apply(self, curryArgs)
            } : function() {
                return arguments.length ? fn.apply(self, arguments) : fn.call(self)
            }
        }

        function toJsonReplacer(key, value) {
            var val = value;
            return "string" == typeof key && "$" === key.charAt(0) && "$" === key.charAt(1) ? val = void 0 : isWindow(value) ? val = "$WINDOW" : value && window.document === value ? val = "$DOCUMENT" : isScope(value) && (val = "$SCOPE"), val
        }

        function toJson(obj, pretty) {
            if (!isUndefined(obj)) return isNumber(pretty) || (pretty = pretty ? 2 : null), JSON.stringify(obj, toJsonReplacer, pretty)
        }

        function fromJson(json) {
            return isString(json) ? JSON.parse(json) : json
        }
        var ALL_COLONS = /:/g;

        function timezoneToOffset(timezone, fallback) {
            timezone = timezone.replace(ALL_COLONS, "");
            var requestedTimezoneOffset = Date.parse("Jan 01, 1970 00:00:00 " + timezone) / 6e4;
            return isNumberNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset
        }

        function addDateMinutes(date, minutes) {
            return (date = new Date(date.getTime())).setMinutes(date.getMinutes() + minutes), date
        }

        function convertTimezoneToLocal(date, timezone, reverse) {
            reverse = reverse ? -1 : 1;
            var dateTimezoneOffset = date.getTimezoneOffset();
            return addDateMinutes(date, reverse * (timezoneToOffset(timezone, dateTimezoneOffset) - dateTimezoneOffset))
        }

        function startingTag(element) {
            element = jqLite(element).clone().empty();
            var elemHtml = jqLite("<div></div>").append(element).html();
            try {
                return element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w-]+)/, (function(match, nodeName) {
                    return "<" + lowercase(nodeName)
                }))
            } catch (e) {
                return lowercase(elemHtml)
            }
        }

        function tryDecodeURIComponent(value) {
            try {
                return decodeURIComponent(value)
            } catch (e) {}
        }

        function parseKeyValue(keyValue) {
            var obj = {};
            return forEach((keyValue || "").split("&"), (function(keyValue) {
                var splitPoint, key, val;
                keyValue && (key = keyValue = keyValue.replace(/\+/g, "%20"), -1 !== (splitPoint = keyValue.indexOf("=")) && (key = keyValue.substring(0, splitPoint), val = keyValue.substring(splitPoint + 1)), isDefined(key = tryDecodeURIComponent(key)) && (val = !isDefined(val) || tryDecodeURIComponent(val), hasOwnProperty.call(obj, key) ? isArray(obj[key]) ? obj[key].push(val) : obj[key] = [obj[key], val] : obj[key] = val))
            })), obj
        }

        function encodeUriSegment(val) {
            return encodeUriQuery(val, !0).replace(/%26/gi, "&").replace(/%3D/gi, "=").replace(/%2B/gi, "+")
        }

        function encodeUriQuery(val, pctEncodeSpaces) {
            return encodeURIComponent(val).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%3B/gi, ";").replace(/%20/g, pctEncodeSpaces ? "%20" : "+")
        }
        var ngAttrPrefixes = ["ng-", "data-ng-", "ng:", "x-ng-"];
        var isAutoBootstrapAllowed = function(document) {
            var script = document.currentScript;
            if (!script) return !0;
            if (!(script instanceof window.HTMLScriptElement || script instanceof window.SVGScriptElement)) return !1;
            var attributes = script.attributes;
            return [attributes.getNamedItem("src"), attributes.getNamedItem("href"), attributes.getNamedItem("xlink:href")].every((function(src) {
                if (!src) return !0;
                if (!src.value) return !1;
                var link = document.createElement("a");
                if (link.href = src.value, document.location.origin === link.origin) return !0;
                switch (link.protocol) {
                    case "http:":
                    case "https:":
                    case "ftp:":
                    case "blob:":
                    case "file:":
                    case "data:":
                        return !0;
                    default:
                        return !1
                }
            }))
        }(window.document);

        function angularInit(element, bootstrap) {
            var appElement, module, config = {};
            if (forEach(ngAttrPrefixes, (function(prefix) {
                    var name = prefix + "app";
                    !appElement && element.hasAttribute && element.hasAttribute(name) && (appElement = element, module = element.getAttribute(name))
                })), forEach(ngAttrPrefixes, (function(prefix) {
                    var candidate, name = prefix + "app";
                    !appElement && (candidate = element.querySelector("[" + name.replace(":", "\\:") + "]")) && (appElement = candidate, module = candidate.getAttribute(name))
                })), appElement) {
                if (!isAutoBootstrapAllowed) return void window.console.error("AngularJS: disabling automatic bootstrap. <script> protocol indicates an extension, document.location.href does not match.");
                config.strictDi = null !== function(element, ngAttr) {
                    var attr, i, ii = ngAttrPrefixes.length;
                    for (i = 0; i < ii; ++i)
                        if (attr = ngAttrPrefixes[i] + ngAttr, isString(attr = element.getAttribute(attr))) return attr;
                    return null
                }(appElement, "strict-di"), bootstrap(appElement, module ? [module] : [], config)
            }
        }

        function bootstrap(element, modules, config) {
            isObject(config) || (config = {});
            config = extend({
                strictDi: !1
            }, config);
            var doBootstrap = function() {
                    if ((element = jqLite(element)).injector()) {
                        var tag = element[0] === window.document ? "document" : startingTag(element);
                        throw ngMinErr("btstrpd", "App already bootstrapped with this element '{0}'", tag.replace(/</, "&lt;").replace(/>/, "&gt;"))
                    }(modules = modules || []).unshift(["$provide", function($provide) {
                        $provide.value("$rootElement", element)
                    }]), config.debugInfoEnabled && modules.push(["$compileProvider", function($compileProvider) {
                        $compileProvider.debugInfoEnabled(!0)
                    }]), modules.unshift("ng");
                    var injector = createInjector(modules, config.strictDi);
                    return injector.invoke(["$rootScope", "$rootElement", "$compile", "$injector", function(scope, element, compile, injector) {
                        scope.$apply((function() {
                            element.data("$injector", injector), compile(element)(scope)
                        }))
                    }]), injector
                },
                NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/,
                NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
            if (window && NG_ENABLE_DEBUG_INFO.test(window.name) && (config.debugInfoEnabled = !0, window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, "")), window && !NG_DEFER_BOOTSTRAP.test(window.name)) return doBootstrap();
            window.name = window.name.replace(NG_DEFER_BOOTSTRAP, ""), angular.resumeBootstrap = function(extraModules) {
                return forEach(extraModules, (function(module) {
                    modules.push(module)
                })), doBootstrap()
            }, isFunction(angular.resumeDeferredBootstrap) && angular.resumeDeferredBootstrap()
        }

        function reloadWithDebugInfo() {
            window.name = "NG_ENABLE_DEBUG_INFO!" + window.name, window.location.reload()
        }

        function getTestability(rootElement) {
            var injector = angular.element(rootElement).injector();
            if (!injector) throw ngMinErr("test", "no injector found for element argument to getTestability");
            return injector.get("$$testability")
        }
        var SNAKE_CASE_REGEXP = /[A-Z]/g;

        function snake_case(name, separator) {
            return separator = separator || "_", name.replace(SNAKE_CASE_REGEXP, (function(letter, pos) {
                return (pos ? separator : "") + letter.toLowerCase()
            }))
        }
        var bindJQueryFired = !1;

        function UNSAFE_restoreLegacyJqLiteXHTMLReplacement() {
            JQLite.legacyXHTMLReplacement = !0
        }

        function assertArg(arg, name, reason) {
            if (!arg) throw ngMinErr("areq", "Argument '{0}' is {1}", name || "?", reason || "required");
            return arg
        }

        function assertArgFn(arg, name, acceptArrayAnnotation) {
            return acceptArrayAnnotation && isArray(arg) && (arg = arg[arg.length - 1]), assertArg(isFunction(arg), name, "not a function, got " + (arg && "object" == typeof arg ? arg.constructor.name || "Object" : typeof arg)), arg
        }

        function assertNotHasOwnProperty(name, context) {
            if ("hasOwnProperty" === name) throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context)
        }

        function getBlockNodes(nodes) {
            for (var blockNodes, node = nodes[0], endNode = nodes[nodes.length - 1], i = 1; node !== endNode && (node = node.nextSibling); i++)(blockNodes || nodes[i] !== node) && (blockNodes || (blockNodes = jqLite(slice.call(nodes, 0, i))), blockNodes.push(node));
            return blockNodes || nodes
        }

        function createMap() {
            return Object.create(null)
        }

        function stringify(value) {
            if (null == value) return "";
            switch (typeof value) {
                case "string":
                    break;
                case "number":
                    value = "" + value;
                    break;
                default:
                    value = !hasCustomToString(value) || isArray(value) || isDate(value) ? toJson(value) : value.toString()
            }
            return value
        }
        var NODE_TYPE_TEXT = 3;

        function shallowCopy(src, dst) {
            if (isArray(src)) {
                dst = dst || [];
                for (var i = 0, ii = src.length; i < ii; i++) dst[i] = src[i]
            } else if (isObject(src))
                for (var key in dst = dst || {}, src) "$" === key.charAt(0) && "$" === key.charAt(1) || (dst[key] = src[key]);
            return dst || src
        }

        function toDebugString(obj, maxDepth) {
            return "function" == typeof obj ? obj.toString().replace(/ \{[\s\S]*$/, "") : isUndefined(obj) ? "undefined" : "string" != typeof obj ? function(obj, maxDepth) {
                var seen = [];
                return isValidObjectMaxDepth(maxDepth) && (obj = angular.copy(obj, null, maxDepth)), JSON.stringify(obj, (function(key, val) {
                    if (isObject(val = toJsonReplacer(key, val))) {
                        if (seen.indexOf(val) >= 0) return "...";
                        seen.push(val)
                    }
                    return val
                }))
            }(obj, maxDepth) : obj
        }
        var version = {
            full: "1.8.2",
            major: 1,
            minor: 8,
            dot: 2,
            codeName: "meteoric-mining"
        };
        JQLite.expando = "ng339";
        var jqCache = JQLite.cache = {},
            jqId = 1;
        JQLite._data = function(node) {
            return this.cache[node[this.expando]] || {}
        };
        var DASH_LOWERCASE_REGEXP = /-([a-z])/g,
            MS_HACK_REGEXP = /^-ms-/,
            MOUSE_EVENT_MAP = {
                mouseleave: "mouseout",
                mouseenter: "mouseover"
            },
            jqLiteMinErr = minErr("jqLite");

        function fnCamelCaseReplace(all, letter) {
            return letter.toUpperCase()
        }

        function kebabToCamel(name) {
            return name.replace(DASH_LOWERCASE_REGEXP, fnCamelCaseReplace)
        }
        var SINGLE_TAG_REGEXP = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/,
            HTML_REGEXP = /<|&#?\w+;/,
            TAG_NAME_REGEXP = /<([\w:-]+)/,
            XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,
            wrapMap = {
                thead: ["table"],
                col: ["colgroup", "table"],
                tr: ["tbody", "table"],
                td: ["tr", "tbody", "table"]
            };
        wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead, wrapMap.th = wrapMap.td;
        var wrapMapIE9 = {
            option: [1, '<select multiple="multiple">', "</select>"],
            _default: [0, "", ""]
        };
        for (var key in wrapMap) {
            var wrapMapValueClosing = wrapMap[key],
                wrapMapValue = wrapMapValueClosing.slice().reverse();
            wrapMapIE9[key] = [wrapMapValue.length, "<" + wrapMapValue.join("><") + ">", "</" + wrapMapValueClosing.join("></") + ">"]
        }

        function jqLiteIsTextNode(html) {
            return !HTML_REGEXP.test(html)
        }

        function jqLiteAcceptsData(node) {
            var nodeType = node.nodeType;
            return 1 === nodeType || !nodeType || 9 === nodeType
        }

        function jqLiteBuildFragment(html, context) {
            var tmp, tag, wrap, finalHtml, i, fragment = context.createDocumentFragment(),
                nodes = [];
            if (jqLiteIsTextNode(html)) nodes.push(context.createTextNode(html));
            else {
                if (tmp = fragment.appendChild(context.createElement("div")), tag = (TAG_NAME_REGEXP.exec(html) || ["", ""])[1].toLowerCase(), finalHtml = JQLite.legacyXHTMLReplacement ? html.replace(XHTML_TAG_REGEXP, "<$1></$2>") : html, msie < 10)
                    for (wrap = wrapMapIE9[tag] || wrapMapIE9._default, tmp.innerHTML = wrap[1] + finalHtml + wrap[2], i = wrap[0]; i--;) tmp = tmp.firstChild;
                else {
                    for (i = (wrap = wrapMap[tag] || []).length; --i > -1;) tmp.appendChild(window.document.createElement(wrap[i])), tmp = tmp.firstChild;
                    tmp.innerHTML = finalHtml
                }
                nodes = concat(nodes, tmp.childNodes), (tmp = fragment.firstChild).textContent = ""
            }
            return fragment.textContent = "", fragment.innerHTML = "", forEach(nodes, (function(node) {
                fragment.appendChild(node)
            })), fragment
        }
        wrapMapIE9.optgroup = wrapMapIE9.option;
        var jqLiteContains = window.Node.prototype.contains || function(arg) {
            return !!(16 & this.compareDocumentPosition(arg))
        };

        function JQLite(element) {
            if (element instanceof JQLite) return element;
            var argIsString, html, context, parsed;
            if (isString(element) && (element = trim(element), argIsString = !0), !(this instanceof JQLite)) {
                if (argIsString && "<" !== element.charAt(0)) throw jqLiteMinErr("nosel", "Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element");
                return new JQLite(element)
            }
            argIsString ? jqLiteAddNodes(this, (html = element, context = context || window.document, (parsed = SINGLE_TAG_REGEXP.exec(html)) ? [context.createElement(parsed[1])] : (parsed = jqLiteBuildFragment(html, context)) ? parsed.childNodes : [])) : isFunction(element) ? jqLiteReady(element) : jqLiteAddNodes(this, element)
        }

        function jqLiteClone(element) {
            return element.cloneNode(!0)
        }

        function jqLiteDealoc(element, onlyDescendants) {
            !onlyDescendants && jqLiteAcceptsData(element) && jqLite.cleanData([element]), element.querySelectorAll && jqLite.cleanData(element.querySelectorAll("*"))
        }

        function isEmptyObject(obj) {
            var name;
            for (name in obj) return !1;
            return !0
        }

        function removeIfEmptyData(element) {
            var expandoId = element.ng339,
                expandoStore = expandoId && jqCache[expandoId],
                events = expandoStore && expandoStore.events,
                data = expandoStore && expandoStore.data;
            data && !isEmptyObject(data) || events && !isEmptyObject(events) || (delete jqCache[expandoId], element.ng339 = void 0)
        }

        function jqLiteOff(element, type, fn, unsupported) {
            if (isDefined(unsupported)) throw jqLiteMinErr("offargs", "jqLite#off() does not support the `selector` argument");
            var expandoStore = jqLiteExpandoStore(element),
                events = expandoStore && expandoStore.events,
                handle = expandoStore && expandoStore.handle;
            if (handle) {
                if (type) {
                    var removeHandler = function(type) {
                        var listenerFns = events[type];
                        isDefined(fn) && arrayRemove(listenerFns || [], fn), isDefined(fn) && listenerFns && listenerFns.length > 0 || (element.removeEventListener(type, handle), delete events[type])
                    };
                    forEach(type.split(" "), (function(type) {
                        removeHandler(type), MOUSE_EVENT_MAP[type] && removeHandler(MOUSE_EVENT_MAP[type])
                    }))
                } else
                    for (type in events) "$destroy" !== type && element.removeEventListener(type, handle), delete events[type];
                removeIfEmptyData(element)
            }
        }

        function jqLiteRemoveData(element, name) {
            var expandoId = element.ng339,
                expandoStore = expandoId && jqCache[expandoId];
            expandoStore && (name ? delete expandoStore.data[name] : expandoStore.data = {}, removeIfEmptyData(element))
        }

        function jqLiteExpandoStore(element, createIfNecessary) {
            var expandoId = element.ng339,
                expandoStore = expandoId && jqCache[expandoId];
            return createIfNecessary && !expandoStore && (element.ng339 = expandoId = ++jqId, expandoStore = jqCache[expandoId] = {
                events: {},
                data: {},
                handle: void 0
            }), expandoStore
        }

        function jqLiteData(element, key, value) {
            if (jqLiteAcceptsData(element)) {
                var prop, isSimpleSetter = isDefined(value),
                    isSimpleGetter = !isSimpleSetter && key && !isObject(key),
                    massGetter = !key,
                    expandoStore = jqLiteExpandoStore(element, !isSimpleGetter),
                    data = expandoStore && expandoStore.data;
                if (isSimpleSetter) data[kebabToCamel(key)] = value;
                else {
                    if (massGetter) return data;
                    if (isSimpleGetter) return data && data[kebabToCamel(key)];
                    for (prop in key) data[kebabToCamel(prop)] = key[prop]
                }
            }
        }

        function jqLiteHasClass(element, selector) {
            return !!element.getAttribute && (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").indexOf(" " + selector + " ") > -1
        }

        function jqLiteRemoveClass(element, cssClasses) {
            if (cssClasses && element.setAttribute) {
                var existingClasses = (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " "),
                    newClasses = existingClasses;
                forEach(cssClasses.split(" "), (function(cssClass) {
                    cssClass = trim(cssClass), newClasses = newClasses.replace(" " + cssClass + " ", " ")
                })), newClasses !== existingClasses && element.setAttribute("class", trim(newClasses))
            }
        }

        function jqLiteAddClass(element, cssClasses) {
            if (cssClasses && element.setAttribute) {
                var existingClasses = (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " "),
                    newClasses = existingClasses;
                forEach(cssClasses.split(" "), (function(cssClass) {
                    cssClass = trim(cssClass), -1 === newClasses.indexOf(" " + cssClass + " ") && (newClasses += cssClass + " ")
                })), newClasses !== existingClasses && element.setAttribute("class", trim(newClasses))
            }
        }

        function jqLiteAddNodes(root, elements) {
            if (elements)
                if (elements.nodeType) root[root.length++] = elements;
                else {
                    var length = elements.length;
                    if ("number" == typeof length && elements.window !== elements) {
                        if (length)
                            for (var i = 0; i < length; i++) root[root.length++] = elements[i]
                    } else root[root.length++] = elements
                }
        }

        function jqLiteController(element, name) {
            return jqLiteInheritedData(element, "$" + (name || "ngController") + "Controller")
        }

        function jqLiteInheritedData(element, name, value) {
            9 === element.nodeType && (element = element.documentElement);
            for (var names = isArray(name) ? name : [name]; element;) {
                for (var i = 0, ii = names.length; i < ii; i++)
                    if (isDefined(value = jqLite.data(element, names[i]))) return value;
                element = element.parentNode || 11 === element.nodeType && element.host
            }
        }

        function jqLiteEmpty(element) {
            for (jqLiteDealoc(element, !0); element.firstChild;) element.removeChild(element.firstChild)
        }

        function jqLiteRemove(element, keepData) {
            keepData || jqLiteDealoc(element);
            var parent = element.parentNode;
            parent && parent.removeChild(element)
        }

        function jqLiteReady(fn) {
            function trigger() {
                window.document.removeEventListener("DOMContentLoaded", trigger), window.removeEventListener("load", trigger), fn()
            }
            "complete" === window.document.readyState ? window.setTimeout(fn) : (window.document.addEventListener("DOMContentLoaded", trigger), window.addEventListener("load", trigger))
        }
        var JQLitePrototype = JQLite.prototype = {
                ready: jqLiteReady,
                toString: function() {
                    var value = [];
                    return forEach(this, (function(e) {
                        value.push("" + e)
                    })), "[" + value.join(", ") + "]"
                },
                eq: function(index) {
                    return jqLite(index >= 0 ? this[index] : this[this.length + index])
                },
                length: 0,
                push: push,
                sort: [].sort,
                splice: [].splice
            },
            BOOLEAN_ATTR = {};
        forEach("multiple,selected,checked,disabled,readOnly,required,open".split(","), (function(value) {
            BOOLEAN_ATTR[lowercase(value)] = value
        }));
        var BOOLEAN_ELEMENTS = {};
        forEach("input,select,option,textarea,button,form,details".split(","), (function(value) {
            BOOLEAN_ELEMENTS[value] = !0
        }));
        var ALIASED_ATTR = {
            ngMinlength: "minlength",
            ngMaxlength: "maxlength",
            ngMin: "min",
            ngMax: "max",
            ngPattern: "pattern",
            ngStep: "step"
        };

        function getBooleanAttrName(element, name) {
            var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
            return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element)] && booleanAttr
        }

        function defaultHandlerWrapper(element, event, handler) {
            handler.call(element, event)
        }

        function specialMouseHandlerWrapper(target, event, handler) {
            var related = event.relatedTarget;
            related && (related === target || jqLiteContains.call(target, related)) || handler.call(target, event)
        }

        function $$jqLiteProvider() {
            this.$get = function() {
                return extend(JQLite, {
                    hasClass: function(node, classes) {
                        return node.attr && (node = node[0]), jqLiteHasClass(node, classes)
                    },
                    addClass: function(node, classes) {
                        return node.attr && (node = node[0]), jqLiteAddClass(node, classes)
                    },
                    removeClass: function(node, classes) {
                        return node.attr && (node = node[0]), jqLiteRemoveClass(node, classes)
                    }
                })
            }
        }

        function hashKey(obj, nextUidFn) {
            var key = obj && obj.$$hashKey;
            if (key) return "function" == typeof key && (key = obj.$$hashKey()), key;
            var objType = typeof obj;
            return key = "function" === objType || "object" === objType && null !== obj ? obj.$$hashKey = objType + ":" + (nextUidFn || nextUid)() : objType + ":" + obj
        }
        forEach({
            data: jqLiteData,
            removeData: jqLiteRemoveData,
            hasData: function(node) {
                for (var key in jqCache[node.ng339]) return !0;
                return !1
            },
            cleanData: function(nodes) {
                for (var i = 0, ii = nodes.length; i < ii; i++) jqLiteRemoveData(nodes[i]), jqLiteOff(nodes[i])
            }
        }, (function(fn, name) {
            JQLite[name] = fn
        })), forEach({
            data: jqLiteData,
            inheritedData: jqLiteInheritedData,
            scope: function(element) {
                return jqLite.data(element, "$scope") || jqLiteInheritedData(element.parentNode || element, ["$isolateScope", "$scope"])
            },
            isolateScope: function(element) {
                return jqLite.data(element, "$isolateScope") || jqLite.data(element, "$isolateScopeNoTemplate")
            },
            controller: jqLiteController,
            injector: function(element) {
                return jqLiteInheritedData(element, "$injector")
            },
            removeAttr: function(element, name) {
                element.removeAttribute(name)
            },
            hasClass: jqLiteHasClass,
            css: function(element, name, value) {
                if (name = function(name) {
                        return kebabToCamel(name.replace(MS_HACK_REGEXP, "ms-"))
                    }(name), !isDefined(value)) return element.style[name];
                element.style[name] = value
            },
            attr: function(element, name, value) {
                var ret, nodeType = element.nodeType;
                if (nodeType !== NODE_TYPE_TEXT && 2 !== nodeType && 8 !== nodeType && element.getAttribute) {
                    var lowercasedName = lowercase(name),
                        isBooleanAttr = BOOLEAN_ATTR[lowercasedName];
                    if (!isDefined(value)) return ret = element.getAttribute(name), isBooleanAttr && null !== ret && (ret = lowercasedName), null === ret ? void 0 : ret;
                    null === value || !1 === value && isBooleanAttr ? element.removeAttribute(name) : element.setAttribute(name, isBooleanAttr ? lowercasedName : value)
                }
            },
            prop: function(element, name, value) {
                if (!isDefined(value)) return element[name];
                element[name] = value
            },
            text: function() {
                return getText.$dv = "", getText;

                function getText(element, value) {
                    if (isUndefined(value)) {
                        var nodeType = element.nodeType;
                        return 1 === nodeType || nodeType === NODE_TYPE_TEXT ? element.textContent : ""
                    }
                    element.textContent = value
                }
            }(),
            val: function(element, value) {
                if (isUndefined(value)) {
                    if (element.multiple && "select" === nodeName_(element)) {
                        var result = [];
                        return forEach(element.options, (function(option) {
                            option.selected && result.push(option.value || option.text)
                        })), result
                    }
                    return element.value
                }
                element.value = value
            },
            html: function(element, value) {
                if (isUndefined(value)) return element.innerHTML;
                jqLiteDealoc(element, !0), element.innerHTML = value
            },
            empty: jqLiteEmpty
        }, (function(fn, name) {
            JQLite.prototype[name] = function(arg1, arg2) {
                var i, key, nodeCount = this.length;
                if (fn !== jqLiteEmpty && isUndefined(2 === fn.length && fn !== jqLiteHasClass && fn !== jqLiteController ? arg1 : arg2)) {
                    if (isObject(arg1)) {
                        for (i = 0; i < nodeCount; i++)
                            if (fn === jqLiteData) fn(this[i], arg1);
                            else
                                for (key in arg1) fn(this[i], key, arg1[key]);
                        return this
                    }
                    for (var value = fn.$dv, jj = isUndefined(value) ? Math.min(nodeCount, 1) : nodeCount, j = 0; j < jj; j++) {
                        var nodeValue = fn(this[j], arg1, arg2);
                        value = value ? value + nodeValue : nodeValue
                    }
                    return value
                }
                for (i = 0; i < nodeCount; i++) fn(this[i], arg1, arg2);
                return this
            }
        })), forEach({
            removeData: jqLiteRemoveData,
            on: function(element, type, fn, unsupported) {
                if (isDefined(unsupported)) throw jqLiteMinErr("onargs", "jqLite#on() does not support the `selector` or `eventData` parameters");
                if (jqLiteAcceptsData(element)) {
                    var expandoStore = jqLiteExpandoStore(element, !0),
                        events = expandoStore.events,
                        handle = expandoStore.handle;
                    handle || (handle = expandoStore.handle = function(element, events) {
                        var eventHandler = function(event, type) {
                            event.isDefaultPrevented = function() {
                                return event.defaultPrevented
                            };
                            var eventFns = events[type || event.type],
                                eventFnsLength = eventFns ? eventFns.length : 0;
                            if (eventFnsLength) {
                                if (isUndefined(event.immediatePropagationStopped)) {
                                    var originalStopImmediatePropagation = event.stopImmediatePropagation;
                                    event.stopImmediatePropagation = function() {
                                        event.immediatePropagationStopped = !0, event.stopPropagation && event.stopPropagation(), originalStopImmediatePropagation && originalStopImmediatePropagation.call(event)
                                    }
                                }
                                event.isImmediatePropagationStopped = function() {
                                    return !0 === event.immediatePropagationStopped
                                };
                                var handlerWrapper = eventFns.specialHandlerWrapper || defaultHandlerWrapper;
                                eventFnsLength > 1 && (eventFns = shallowCopy(eventFns));
                                for (var i = 0; i < eventFnsLength; i++) event.isImmediatePropagationStopped() || handlerWrapper(element, event, eventFns[i])
                            }
                        };
                        return eventHandler.elem = element, eventHandler
                    }(element, events));
                    for (var types = type.indexOf(" ") >= 0 ? type.split(" ") : [type], i = types.length, addHandler = function(type, specialHandlerWrapper, noEventListener) {
                            var eventFns = events[type];
                            eventFns || ((eventFns = events[type] = []).specialHandlerWrapper = specialHandlerWrapper, "$destroy" === type || noEventListener || element.addEventListener(type, handle)), eventFns.push(fn)
                        }; i--;) type = types[i], MOUSE_EVENT_MAP[type] ? (addHandler(MOUSE_EVENT_MAP[type], specialMouseHandlerWrapper), addHandler(type, void 0, !0)) : addHandler(type)
                }
            },
            off: jqLiteOff,
            one: function(element, type, fn) {
                (element = jqLite(element)).on(type, (function onFn() {
                    element.off(type, fn), element.off(type, onFn)
                })), element.on(type, fn)
            },
            replaceWith: function(element, replaceNode) {
                var index, parent = element.parentNode;
                jqLiteDealoc(element), forEach(new JQLite(replaceNode), (function(node) {
                    index ? parent.insertBefore(node, index.nextSibling) : parent.replaceChild(node, element), index = node
                }))
            },
            children: function(element) {
                var children = [];
                return forEach(element.childNodes, (function(element) {
                    1 === element.nodeType && children.push(element)
                })), children
            },
            contents: function(element) {
                return element.contentDocument || element.childNodes || []
            },
            append: function(element, node) {
                var nodeType = element.nodeType;
                if (1 === nodeType || 11 === nodeType)
                    for (var i = 0, ii = (node = new JQLite(node)).length; i < ii; i++) {
                        var child = node[i];
                        element.appendChild(child)
                    }
            },
            prepend: function(element, node) {
                if (1 === element.nodeType) {
                    var index = element.firstChild;
                    forEach(new JQLite(node), (function(child) {
                        element.insertBefore(child, index)
                    }))
                }
            },
            wrap: function(element, wrapNode) {
                var node, wrapper, parent;
                node = element, wrapper = jqLite(wrapNode).eq(0).clone()[0], (parent = node.parentNode) && parent.replaceChild(wrapper, node), wrapper.appendChild(node)
            },
            remove: jqLiteRemove,
            detach: function(element) {
                jqLiteRemove(element, !0)
            },
            after: function(element, newElement) {
                var index = element,
                    parent = element.parentNode;
                if (parent)
                    for (var i = 0, ii = (newElement = new JQLite(newElement)).length; i < ii; i++) {
                        var node = newElement[i];
                        parent.insertBefore(node, index.nextSibling), index = node
                    }
            },
            addClass: jqLiteAddClass,
            removeClass: jqLiteRemoveClass,
            toggleClass: function(element, selector, condition) {
                selector && forEach(selector.split(" "), (function(className) {
                    var classCondition = condition;
                    isUndefined(classCondition) && (classCondition = !jqLiteHasClass(element, className)), (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className)
                }))
            },
            parent: function(element) {
                var parent = element.parentNode;
                return parent && 11 !== parent.nodeType ? parent : null
            },
            next: function(element) {
                return element.nextElementSibling
            },
            find: function(element, selector) {
                return element.getElementsByTagName ? element.getElementsByTagName(selector) : []
            },
            clone: jqLiteClone,
            triggerHandler: function(element, event, extraParameters) {
                var dummyEvent, eventFnsCopy, handlerArgs, eventName = event.type || event,
                    expandoStore = jqLiteExpandoStore(element),
                    events = expandoStore && expandoStore.events,
                    eventFns = events && events[eventName];
                eventFns && (dummyEvent = {
                    preventDefault: function() {
                        this.defaultPrevented = !0
                    },
                    isDefaultPrevented: function() {
                        return !0 === this.defaultPrevented
                    },
                    stopImmediatePropagation: function() {
                        this.immediatePropagationStopped = !0
                    },
                    isImmediatePropagationStopped: function() {
                        return !0 === this.immediatePropagationStopped
                    },
                    stopPropagation: noop,
                    type: eventName,
                    target: element
                }, event.type && (dummyEvent = extend(dummyEvent, event)), eventFnsCopy = shallowCopy(eventFns), handlerArgs = extraParameters ? [dummyEvent].concat(extraParameters) : [dummyEvent], forEach(eventFnsCopy, (function(fn) {
                    dummyEvent.isImmediatePropagationStopped() || fn.apply(element, handlerArgs)
                })))
            }
        }, (function(fn, name) {
            JQLite.prototype[name] = function(arg1, arg2, arg3) {
                for (var value, i = 0, ii = this.length; i < ii; i++) isUndefined(value) ? isDefined(value = fn(this[i], arg1, arg2, arg3)) && (value = jqLite(value)) : jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
                return isDefined(value) ? value : this
            }
        })), JQLite.prototype.bind = JQLite.prototype.on, JQLite.prototype.unbind = JQLite.prototype.off;
        var nanKey = Object.create(null);

        function NgMapShim() {
            this._keys = [], this._values = [], this._lastKey = NaN, this._lastIndex = -1
        }
        NgMapShim.prototype = {
            _idx: function(key) {
                return key !== this._lastKey && (this._lastKey = key, this._lastIndex = this._keys.indexOf(key)), this._lastIndex
            },
            _transformKey: function(key) {
                return isNumberNaN(key) ? nanKey : key
            },
            get: function(key) {
                key = this._transformKey(key);
                var idx = this._idx(key);
                if (-1 !== idx) return this._values[idx]
            },
            has: function(key) {
                return key = this._transformKey(key), -1 !== this._idx(key)
            },
            set: function(key, value) {
                key = this._transformKey(key);
                var idx = this._idx(key); - 1 === idx && (idx = this._lastIndex = this._keys.length), this._keys[idx] = key, this._values[idx] = value
            },
            delete: function(key) {
                key = this._transformKey(key);
                var idx = this._idx(key);
                return -1 !== idx && (this._keys.splice(idx, 1), this._values.splice(idx, 1), this._lastKey = NaN, this._lastIndex = -1, !0)
            }
        };
        var NgMap = NgMapShim,
            $$MapProvider = [function() {
                this.$get = [function() {
                    return NgMap
                }]
            }],
            ARROW_ARG = /^([^(]+?)=>/,
            FN_ARGS = /^[^(]*\(\s*([^)]*)\)/m,
            FN_ARG_SPLIT = /,/,
            FN_ARG = /^\s*(_?)(\S+?)\1\s*$/,
            STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm,
            $injectorMinErr = minErr("$injector");

        function stringifyFn(fn) {
            return Function.prototype.toString.call(fn)
        }

        function extractArgs(fn) {
            var fnText = stringifyFn(fn).replace(STRIP_COMMENTS, "");
            return fnText.match(ARROW_ARG) || fnText.match(FN_ARGS)
        }

        function createInjector(modulesToLoad, strictDi) {
            strictDi = !0 === strictDi;
            var INSTANTIATING = {},
                path = [],
                loadedModules = new NgMap,
                providerCache = {
                    $provide: {
                        provider: supportObject(provider),
                        factory: supportObject(factory),
                        service: supportObject((function(name, constructor) {
                            return factory(name, ["$injector", function($injector) {
                                return $injector.instantiate(constructor)
                            }])
                        })),
                        value: supportObject((function(name, val) {
                            return factory(name, valueFn(val), !1)
                        })),
                        constant: supportObject((function(name, value) {
                            assertNotHasOwnProperty(name, "constant"), providerCache[name] = value, instanceCache[name] = value
                        })),
                        decorator: function(serviceName, decorFn) {
                            var origProvider = providerInjector.get(serviceName + "Provider"),
                                orig$get = origProvider.$get;
                            origProvider.$get = function() {
                                var origInstance = instanceInjector.invoke(orig$get, origProvider);
                                return instanceInjector.invoke(decorFn, null, {
                                    $delegate: origInstance
                                })
                            }
                        }
                    }
                },
                providerInjector = providerCache.$injector = createInternalInjector(providerCache, (function(serviceName, caller) {
                    throw angular.isString(caller) && path.push(caller), $injectorMinErr("unpr", "Unknown provider: {0}", path.join(" <- "))
                })),
                instanceCache = {},
                protoInstanceInjector = createInternalInjector(instanceCache, (function(serviceName, caller) {
                    var provider = providerInjector.get(serviceName + "Provider", caller);
                    return instanceInjector.invoke(provider.$get, provider, void 0, serviceName)
                })),
                instanceInjector = protoInstanceInjector;
            providerCache.$injectorProvider = {
                $get: valueFn(protoInstanceInjector)
            }, instanceInjector.modules = providerInjector.modules = createMap();
            var runBlocks = loadModules(modulesToLoad);
            return (instanceInjector = protoInstanceInjector.get("$injector")).strictDi = strictDi, forEach(runBlocks, (function(fn) {
                fn && instanceInjector.invoke(fn)
            })), instanceInjector.loadNewModules = function(mods) {
                forEach(loadModules(mods), (function(fn) {
                    fn && instanceInjector.invoke(fn)
                }))
            }, instanceInjector;

            function supportObject(delegate) {
                return function(key, value) {
                    if (!isObject(key)) return delegate(key, value);
                    forEach(key, reverseParams(delegate))
                }
            }

            function provider(name, provider_) {
                if (assertNotHasOwnProperty(name, "service"), (isFunction(provider_) || isArray(provider_)) && (provider_ = providerInjector.instantiate(provider_)), !provider_.$get) throw $injectorMinErr("pget", "Provider '{0}' must define $get factory method.", name);
                return providerCache[name + "Provider"] = provider_
            }

            function enforceReturnValue(name, factory) {
                return function() {
                    var result = instanceInjector.invoke(factory, this);
                    if (isUndefined(result)) throw $injectorMinErr("undef", "Provider '{0}' must return a value from $get factory method.", name);
                    return result
                }
            }

            function factory(name, factoryFn, enforce) {
                return provider(name, {
                    $get: !1 !== enforce ? enforceReturnValue(name, factoryFn) : factoryFn
                })
            }

            function loadModules(modulesToLoad) {
                assertArg(isUndefined(modulesToLoad) || isArray(modulesToLoad), "modulesToLoad", "not an array");
                var moduleFn, runBlocks = [];
                return forEach(modulesToLoad, (function(module) {
                    if (!loadedModules.get(module)) {
                        loadedModules.set(module, !0);
                        try {
                            isString(module) ? (moduleFn = angularModule(module), instanceInjector.modules[module] = moduleFn, runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks), runInvokeQueue(moduleFn._invokeQueue), runInvokeQueue(moduleFn._configBlocks)) : isFunction(module) || isArray(module) ? runBlocks.push(providerInjector.invoke(module)) : assertArgFn(module, "module")
                        } catch (e) {
                            throw isArray(module) && (module = module[module.length - 1]), e.message && e.stack && -1 === e.stack.indexOf(e.message) && (e = e.message + "\n" + e.stack), $injectorMinErr("modulerr", "Failed to instantiate module {0} due to:\n{1}", module, e.stack || e.message || e)
                        }
                    }

                    function runInvokeQueue(queue) {
                        var i, ii;
                        for (i = 0, ii = queue.length; i < ii; i++) {
                            var invokeArgs = queue[i],
                                provider = providerInjector.get(invokeArgs[0]);
                            provider[invokeArgs[1]].apply(provider, invokeArgs[2])
                        }
                    }
                })), runBlocks
            }

            function createInternalInjector(cache, factory) {
                function getService(serviceName, caller) {
                    if (cache.hasOwnProperty(serviceName)) {
                        if (cache[serviceName] === INSTANTIATING) throw $injectorMinErr("cdep", "Circular dependency found: {0}", serviceName + " <- " + path.join(" <- "));
                        return cache[serviceName]
                    }
                    try {
                        return path.unshift(serviceName), cache[serviceName] = INSTANTIATING, cache[serviceName] = factory(serviceName, caller), cache[serviceName]
                    } catch (err) {
                        throw cache[serviceName] === INSTANTIATING && delete cache[serviceName], err
                    } finally {
                        path.shift()
                    }
                }

                function injectionArgs(fn, locals, serviceName) {
                    for (var args = [], $inject = createInjector.$$annotate(fn, strictDi, serviceName), i = 0, length = $inject.length; i < length; i++) {
                        var key = $inject[i];
                        if ("string" != typeof key) throw $injectorMinErr("itkn", "Incorrect injection token! Expected service name as string, got {0}", key);
                        args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key, serviceName))
                    }
                    return args
                }
                return {
                    invoke: function(fn, self, locals, serviceName) {
                        "string" == typeof locals && (serviceName = locals, locals = null);
                        var args = injectionArgs(fn, locals, serviceName);
                        return isArray(fn) && (fn = fn[fn.length - 1]),
                            function(func) {
                                if (msie || "function" != typeof func) return !1;
                                var result = func.$$ngIsClass;
                                return isBoolean(result) || (result = func.$$ngIsClass = /^class\b/.test(stringifyFn(func))), result
                            }(fn) ? (args.unshift(null), new(Function.prototype.bind.apply(fn, args))) : fn.apply(self, args)
                    },
                    instantiate: function(Type, locals, serviceName) {
                        var ctor = isArray(Type) ? Type[Type.length - 1] : Type,
                            args = injectionArgs(Type, locals, serviceName);
                        return args.unshift(null), new(Function.prototype.bind.apply(ctor, args))
                    },
                    get: getService,
                    annotate: createInjector.$$annotate,
                    has: function(name) {
                        return providerCache.hasOwnProperty(name + "Provider") || cache.hasOwnProperty(name)
                    }
                }
            }
        }

        function $AnchorScrollProvider() {
            var autoScrollingEnabled = !0;
            this.disableAutoScrolling = function() {
                autoScrollingEnabled = !1
            }, this.$get = ["$window", "$location", "$rootScope", function($window, $location, $rootScope) {
                var document = $window.document;

                function scrollTo(elem) {
                    if (elem) {
                        elem.scrollIntoView();
                        var offset = function() {
                            var offset = scroll.yOffset;
                            if (isFunction(offset)) offset = offset();
                            else if (isElement(offset)) {
                                var elem = offset[0];
                                offset = "fixed" !== $window.getComputedStyle(elem).position ? 0 : elem.getBoundingClientRect().bottom
                            } else isNumber(offset) || (offset = 0);
                            return offset
                        }();
                        if (offset) {
                            var elemTop = elem.getBoundingClientRect().top;
                            $window.scrollBy(0, elemTop - offset)
                        }
                    } else $window.scrollTo(0, 0)
                }

                function scroll(hash) {
                    var elm, list, result;
                    (hash = isString(hash) ? hash : isNumber(hash) ? hash.toString() : $location.hash()) ? (elm = document.getElementById(hash)) ? scrollTo(elm): (list = document.getElementsByName(hash), result = null, Array.prototype.some.call(list, (function(element) {
                        if ("a" === nodeName_(element)) return result = element, !0
                    })), (elm = result) ? scrollTo(elm) : "top" === hash && scrollTo(null)): scrollTo(null)
                }
                return autoScrollingEnabled && $rootScope.$watch((function() {
                    return $location.hash()
                }), (function(newVal, oldVal) {
                    var action, win;
                    newVal === oldVal && "" === newVal || (action = function() {
                        $rootScope.$evalAsync(scroll)
                    }, "complete" === (win = win || window).document.readyState ? win.setTimeout(action) : jqLite(win).on("load", action))
                })), scroll
            }]
        }
        createInjector.$$annotate = function(fn, strictDi, name) {
            var $inject, last;
            if ("function" == typeof fn) {
                if (!($inject = fn.$inject)) {
                    if ($inject = [], fn.length) {
                        if (strictDi) throw isString(name) && name || (name = fn.name || function(fn) {
                            var args = extractArgs(fn);
                            return args ? "function(" + (args[1] || "").replace(/[\s\r\n]+/, " ") + ")" : "fn"
                        }(fn)), $injectorMinErr("strictdi", "{0} is not using explicit annotation and cannot be invoked in strict mode", name);
                        forEach(extractArgs(fn)[1].split(FN_ARG_SPLIT), (function(arg) {
                            arg.replace(FN_ARG, (function(all, underscore, name) {
                                $inject.push(name)
                            }))
                        }))
                    }
                    fn.$inject = $inject
                }
            } else isArray(fn) ? (assertArgFn(fn[last = fn.length - 1], "fn"), $inject = fn.slice(0, last)) : assertArgFn(fn, "fn", !0);
            return $inject
        };
        var $animateMinErr = minErr("$animate");

        function mergeClasses(a, b) {
            return a || b ? a ? b ? (isArray(a) && (a = a.join(" ")), isArray(b) && (b = b.join(" ")), a + " " + b) : a : b : ""
        }

        function prepareAnimateOptions(options) {
            return isObject(options) ? options : {}
        }
        var $$CoreAnimateJsProvider = function() {
                this.$get = noop
            },
            $$CoreAnimateQueueProvider = function() {
                var postDigestQueue = new NgMap,
                    postDigestElements = [];
                this.$get = ["$$AnimateRunner", "$rootScope", function($$AnimateRunner, $rootScope) {
                    return {
                        enabled: noop,
                        on: noop,
                        off: noop,
                        pin: noop,
                        push: function(element, event, options, domOperation) {
                            domOperation && domOperation(), (options = options || {}).from && element.css(options.from), options.to && element.css(options.to), (options.addClass || options.removeClass) && function(element, add, remove) {
                                var data = postDigestQueue.get(element) || {},
                                    classesAdded = updateData(data, add, !0),
                                    classesRemoved = updateData(data, remove, !1);
                                (classesAdded || classesRemoved) && (postDigestQueue.set(element, data), postDigestElements.push(element), 1 === postDigestElements.length && $rootScope.$$postDigest(handleCSSClassChanges))
                            }(element, options.addClass, options.removeClass);
                            var runner = new $$AnimateRunner;
                            return runner.complete(), runner
                        }
                    };

                    function updateData(data, classes, value) {
                        var changed = !1;
                        return classes && forEach(classes = isString(classes) ? classes.split(" ") : isArray(classes) ? classes : [], (function(className) {
                            className && (changed = !0, data[className] = value)
                        })), changed
                    }

                    function handleCSSClassChanges() {
                        forEach(postDigestElements, (function(element) {
                            var data = postDigestQueue.get(element);
                            if (data) {
                                var existing = function(classes) {
                                        isString(classes) && (classes = classes.split(" "));
                                        var obj = createMap();
                                        return forEach(classes, (function(klass) {
                                            klass.length && (obj[klass] = !0)
                                        })), obj
                                    }(element.attr("class")),
                                    toAdd = "",
                                    toRemove = "";
                                forEach(data, (function(status, className) {
                                    status !== !!existing[className] && (status ? toAdd += (toAdd.length ? " " : "") + className : toRemove += (toRemove.length ? " " : "") + className)
                                })), forEach(element, (function(elm) {
                                    toAdd && jqLiteAddClass(elm, toAdd), toRemove && jqLiteRemoveClass(elm, toRemove)
                                })), postDigestQueue.delete(element)
                            }
                        })), postDigestElements.length = 0
                    }
                }]
            },
            $AnimateProvider = ["$provide", function($provide) {
                var provider = this,
                    classNameFilter = null,
                    customFilter = null;
                this.$$registeredAnimations = Object.create(null), this.register = function(name, factory) {
                    if (name && "." !== name.charAt(0)) throw $animateMinErr("notcsel", "Expecting class selector starting with '.' got '{0}'.", name);
                    var key = name + "-animation";
                    provider.$$registeredAnimations[name.substr(1)] = key, $provide.factory(key, factory)
                }, this.customFilter = function(filterFn) {
                    return 1 === arguments.length && (customFilter = isFunction(filterFn) ? filterFn : null), customFilter
                }, this.classNameFilter = function(expression) {
                    if (1 === arguments.length && (classNameFilter = expression instanceof RegExp ? expression : null)) {
                        var reservedRegex = new RegExp("[(\\s|\\/)]ng-animate[(\\s|\\/)]");
                        if (reservedRegex.test(classNameFilter.toString())) throw classNameFilter = null, $animateMinErr("nongcls", '$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the "{0}" CSS class.', "ng-animate")
                    }
                    return classNameFilter
                }, this.$get = ["$$animateQueue", function($$animateQueue) {
                    function domInsert(element, parentElement, afterElement) {
                        if (afterElement) {
                            var afterNode = function(element) {
                                for (var i = 0; i < element.length; i++) {
                                    var elm = element[i];
                                    if (1 === elm.nodeType) return elm
                                }
                            }(afterElement);
                            !afterNode || afterNode.parentNode || afterNode.previousElementSibling || (afterElement = null)
                        }
                        afterElement ? afterElement.after(element) : parentElement.prepend(element)
                    }
                    return {
                        on: $$animateQueue.on,
                        off: $$animateQueue.off,
                        pin: $$animateQueue.pin,
                        enabled: $$animateQueue.enabled,
                        cancel: function(runner) {
                            runner.cancel && runner.cancel()
                        },
                        enter: function(element, parent, after, options) {
                            return parent = parent && jqLite(parent), after = after && jqLite(after), domInsert(element, parent = parent || after.parent(), after), $$animateQueue.push(element, "enter", prepareAnimateOptions(options))
                        },
                        move: function(element, parent, after, options) {
                            return parent = parent && jqLite(parent), after = after && jqLite(after), domInsert(element, parent = parent || after.parent(), after), $$animateQueue.push(element, "move", prepareAnimateOptions(options))
                        },
                        leave: function(element, options) {
                            return $$animateQueue.push(element, "leave", prepareAnimateOptions(options), (function() {
                                element.remove()
                            }))
                        },
                        addClass: function(element, className, options) {
                            return (options = prepareAnimateOptions(options)).addClass = mergeClasses(options.addclass, className), $$animateQueue.push(element, "addClass", options)
                        },
                        removeClass: function(element, className, options) {
                            return (options = prepareAnimateOptions(options)).removeClass = mergeClasses(options.removeClass, className), $$animateQueue.push(element, "removeClass", options)
                        },
                        setClass: function(element, add, remove, options) {
                            return (options = prepareAnimateOptions(options)).addClass = mergeClasses(options.addClass, add), options.removeClass = mergeClasses(options.removeClass, remove), $$animateQueue.push(element, "setClass", options)
                        },
                        animate: function(element, from, to, className, options) {
                            return (options = prepareAnimateOptions(options)).from = options.from ? extend(options.from, from) : from, options.to = options.to ? extend(options.to, to) : to, className = className || "ng-inline-animate", options.tempClasses = mergeClasses(options.tempClasses, className), $$animateQueue.push(element, "animate", options)
                        }
                    }
                }]
            }],
            $$AnimateAsyncRunFactoryProvider = function() {
                this.$get = ["$$rAF", function($$rAF) {
                    var waitQueue = [];

                    function waitForTick(fn) {
                        waitQueue.push(fn), waitQueue.length > 1 || $$rAF((function() {
                            for (var i = 0; i < waitQueue.length; i++) waitQueue[i]();
                            waitQueue = []
                        }))
                    }
                    return function() {
                        var passed = !1;
                        return waitForTick((function() {
                                passed = !0
                            })),
                            function(callback) {
                                passed ? callback() : waitForTick(callback)
                            }
                    }
                }]
            },
            $$AnimateRunnerFactoryProvider = function() {
                this.$get = ["$q", "$sniffer", "$$animateAsyncRun", "$$isDocumentHidden", "$timeout", function($q, $sniffer, $$animateAsyncRun, $$isDocumentHidden, $timeout) {
                    function AnimateRunner(host) {
                        this.setHost(host);
                        var rafTick = $$animateAsyncRun();
                        this._doneCallbacks = [], this._tick = function(fn) {
                            $$isDocumentHidden() ? function(fn) {
                                $timeout(fn, 0, !1)
                            }(fn) : rafTick(fn)
                        }, this._state = 0
                    }
                    return AnimateRunner.chain = function(chain, callback) {
                        var index = 0;
                        ! function next() {
                            if (index === chain.length) return void callback(!0);
                            chain[index]((function(response) {
                                !1 !== response ? (index++, next()) : callback(!1)
                            }))
                        }()
                    }, AnimateRunner.all = function(runners, callback) {
                        var count = 0,
                            status = !0;

                        function onProgress(response) {
                            status = status && response, ++count === runners.length && callback(status)
                        }
                        forEach(runners, (function(runner) {
                            runner.done(onProgress)
                        }))
                    }, AnimateRunner.prototype = {
                        setHost: function(host) {
                            this.host = host || {}
                        },
                        done: function(fn) {
                            2 === this._state ? fn() : this._doneCallbacks.push(fn)
                        },
                        progress: noop,
                        getPromise: function() {
                            if (!this.promise) {
                                var self = this;
                                this.promise = $q((function(resolve, reject) {
                                    self.done((function(status) {
                                        !1 === status ? reject() : resolve()
                                    }))
                                }))
                            }
                            return this.promise
                        },
                        then: function(resolveHandler, rejectHandler) {
                            return this.getPromise().then(resolveHandler, rejectHandler)
                        },
                        catch: function(handler) {
                            return this.getPromise().catch(handler)
                        },
                        finally: function(handler) {
                            return this.getPromise().finally(handler)
                        },
                        pause: function() {
                            this.host.pause && this.host.pause()
                        },
                        resume: function() {
                            this.host.resume && this.host.resume()
                        },
                        end: function() {
                            this.host.end && this.host.end(), this._resolve(!0)
                        },
                        cancel: function() {
                            this.host.cancel && this.host.cancel(), this._resolve(!1)
                        },
                        complete: function(response) {
                            var self = this;
                            0 === self._state && (self._state = 1, self._tick((function() {
                                self._resolve(response)
                            })))
                        },
                        _resolve: function(response) {
                            2 !== this._state && (forEach(this._doneCallbacks, (function(fn) {
                                fn(response)
                            })), this._doneCallbacks.length = 0, this._state = 2)
                        }
                    }, AnimateRunner
                }]
            },
            $CoreAnimateCssProvider = function() {
                this.$get = ["$$rAF", "$q", "$$AnimateRunner", function($$rAF, $q, $$AnimateRunner) {
                    return function(element, initialOptions) {
                        var options = initialOptions || {};
                        options.$$prepared || (options = copy(options)), options.cleanupStyles && (options.from = options.to = null), options.from && (element.css(options.from), options.from = null);
                        var closed, runner = new $$AnimateRunner;
                        return {
                            start: run,
                            end: run
                        };

                        function run() {
                            return $$rAF((function() {
                                ! function() {
                                    options.addClass && (element.addClass(options.addClass), options.addClass = null);
                                    options.removeClass && (element.removeClass(options.removeClass), options.removeClass = null);
                                    options.to && (element.css(options.to), options.to = null)
                                }(), closed || runner.complete(), closed = !0
                            })), runner
                        }
                    }
                }]
            };

        function Browser(window, document, $log, $sniffer, $$taskTrackerFactory) {
            var self = this,
                location = window.location,
                history = window.history,
                setTimeout = window.setTimeout,
                clearTimeout = window.clearTimeout,
                pendingDeferIds = {},
                taskTracker = $$taskTrackerFactory($log);
            self.isMock = !1, self.$$completeOutstandingRequest = taskTracker.completeTask, self.$$incOutstandingRequestCount = taskTracker.incTaskCount, self.notifyWhenNoOutstandingRequests = taskTracker.notifyWhenNoPendingTasks;
            var cachedState, lastHistoryState, lastBrowserUrl = location.href,
                baseElement = document.find("base"),
                pendingLocation = null,
                getCurrentState = $sniffer.history ? function() {
                    try {
                        return history.state
                    } catch (e) {}
                } : noop;
            cacheState(), self.url = function(url, replace, state) {
                if (isUndefined(state) && (state = null), location !== window.location && (location = window.location), history !== window.history && (history = window.history), url) {
                    var sameState = lastHistoryState === state;
                    if (url = urlResolve(url).href, lastBrowserUrl === url && (!$sniffer.history || sameState)) return self;
                    var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
                    return lastBrowserUrl = url, lastHistoryState = state, !$sniffer.history || sameBase && sameState ? (sameBase || (pendingLocation = url), replace ? location.replace(url) : sameBase ? location.hash = function(url) {
                        var index = url.indexOf("#");
                        return -1 === index ? "" : url.substr(index)
                    }(url) : location.href = url, location.href !== url && (pendingLocation = url)) : (history[replace ? "replaceState" : "pushState"](state, "", url), cacheState()), pendingLocation && (pendingLocation = url), self
                }
                return function(url) {
                    return url.replace(/#$/, "")
                }(pendingLocation || location.href)
            }, self.state = function() {
                return cachedState
            };
            var urlChangeListeners = [],
                urlChangeInit = !1;

            function cacheStateAndFireUrlChange() {
                pendingLocation = null, fireStateOrUrlChange()
            }
            var lastCachedState = null;

            function cacheState() {
                equals(cachedState = isUndefined(cachedState = getCurrentState()) ? null : cachedState, lastCachedState) && (cachedState = lastCachedState), lastCachedState = cachedState, lastHistoryState = cachedState
            }

            function fireStateOrUrlChange() {
                var prevLastHistoryState = lastHistoryState;
                cacheState(), lastBrowserUrl === self.url() && prevLastHistoryState === cachedState || (lastBrowserUrl = self.url(), lastHistoryState = cachedState, forEach(urlChangeListeners, (function(listener) {
                    listener(self.url(), cachedState)
                })))
            }
            self.onUrlChange = function(callback) {
                return urlChangeInit || ($sniffer.history && jqLite(window).on("popstate", cacheStateAndFireUrlChange), jqLite(window).on("hashchange", cacheStateAndFireUrlChange), urlChangeInit = !0), urlChangeListeners.push(callback), callback
            }, self.$$applicationDestroyed = function() {
                jqLite(window).off("hashchange popstate", cacheStateAndFireUrlChange)
            }, self.$$checkUrlChange = fireStateOrUrlChange, self.baseHref = function() {
                var href = baseElement.attr("href");
                return href ? href.replace(/^(https?:)?\/\/[^/]*/, "") : ""
            }, self.defer = function(fn, delay, taskType) {
                var timeoutId;
                return delay = delay || 0, taskType = taskType || taskTracker.DEFAULT_TASK_TYPE, taskTracker.incTaskCount(taskType), timeoutId = setTimeout((function() {
                    delete pendingDeferIds[timeoutId], taskTracker.completeTask(fn, taskType)
                }), delay), pendingDeferIds[timeoutId] = taskType, timeoutId
            }, self.defer.cancel = function(deferId) {
                if (pendingDeferIds.hasOwnProperty(deferId)) {
                    var taskType = pendingDeferIds[deferId];
                    return delete pendingDeferIds[deferId], clearTimeout(deferId), taskTracker.completeTask(noop, taskType), !0
                }
                return !1
            }
        }

        function $BrowserProvider() {
            this.$get = ["$window", "$log", "$sniffer", "$document", "$$taskTrackerFactory", function($window, $log, $sniffer, $document, $$taskTrackerFactory) {
                return new Browser($window, $document, $log, $sniffer, $$taskTrackerFactory)
            }]
        }

        function $CacheFactoryProvider() {
            this.$get = function() {
                var caches = {};

                function cacheFactory(cacheId, options) {
                    if (cacheId in caches) throw minErr("$cacheFactory")("iid", "CacheId '{0}' is already taken!", cacheId);
                    var size = 0,
                        stats = extend({}, options, {
                            id: cacheId
                        }),
                        data = createMap(),
                        capacity = options && options.capacity || Number.MAX_VALUE,
                        lruHash = createMap(),
                        freshEnd = null,
                        staleEnd = null;
                    return caches[cacheId] = {
                        put: function(key, value) {
                            if (!isUndefined(value)) {
                                if (capacity < Number.MAX_VALUE) refresh(lruHash[key] || (lruHash[key] = {
                                    key: key
                                }));
                                return key in data || size++, data[key] = value, size > capacity && this.remove(staleEnd.key), value
                            }
                        },
                        get: function(key) {
                            if (capacity < Number.MAX_VALUE) {
                                var lruEntry = lruHash[key];
                                if (!lruEntry) return;
                                refresh(lruEntry)
                            }
                            return data[key]
                        },
                        remove: function(key) {
                            if (capacity < Number.MAX_VALUE) {
                                var lruEntry = lruHash[key];
                                if (!lruEntry) return;
                                lruEntry === freshEnd && (freshEnd = lruEntry.p), lruEntry === staleEnd && (staleEnd = lruEntry.n), link(lruEntry.n, lruEntry.p), delete lruHash[key]
                            }
                            key in data && (delete data[key], size--)
                        },
                        removeAll: function() {
                            data = createMap(), size = 0, lruHash = createMap(), freshEnd = staleEnd = null
                        },
                        destroy: function() {
                            data = null, stats = null, lruHash = null, delete caches[cacheId]
                        },
                        info: function() {
                            return extend({}, stats, {
                                size: size
                            })
                        }
                    };

                    function refresh(entry) {
                        entry !== freshEnd && (staleEnd ? staleEnd === entry && (staleEnd = entry.n) : staleEnd = entry, link(entry.n, entry.p), link(entry, freshEnd), (freshEnd = entry).n = null)
                    }

                    function link(nextEntry, prevEntry) {
                        nextEntry !== prevEntry && (nextEntry && (nextEntry.p = prevEntry), prevEntry && (prevEntry.n = nextEntry))
                    }
                }
                return cacheFactory.info = function() {
                    var info = {};
                    return forEach(caches, (function(cache, cacheId) {
                        info[cacheId] = cache.info()
                    })), info
                }, cacheFactory.get = function(cacheId) {
                    return caches[cacheId]
                }, cacheFactory
            }
        }

        function $TemplateCacheProvider() {
            this.$get = ["$cacheFactory", function($cacheFactory) {
                return $cacheFactory("templates")
            }]
        }
        var $compileMinErr = minErr("$compile");
        var _UNINITIALIZED_VALUE = new function() {};

        function $CompileProvider($provide, $$sanitizeUriProvider) {
            var hasDirectives = {},
                COMMENT_DIRECTIVE_REGEXP = /^\s*directive:\s*([\w-]+)\s+(.*)$/,
                CLASS_DIRECTIVE_REGEXP = /(([\w-]+)(?::([^;]+))?;?)/,
                ALL_OR_NOTHING_ATTRS = function(str) {
                    var i, obj = {},
                        items = str.split(",");
                    for (i = 0; i < items.length; i++) obj[items[i]] = !0;
                    return obj
                }("ngSrc,ngSrcset,src,srcset"),
                REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/,
                EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/,
                bindingCache = createMap();

            function parseIsolateBindings(scope, directiveName, isController) {
                var LOCAL_REGEXP = /^([@&]|[=<](\*?))(\??)\s*([\w$]*)$/,
                    bindings = createMap();
                return forEach(scope, (function(definition, scopeName) {
                    if ((definition = definition.trim()) in bindingCache) bindings[scopeName] = bindingCache[definition];
                    else {
                        var match = definition.match(LOCAL_REGEXP);
                        if (!match) throw $compileMinErr("iscp", "Invalid {3} for directive '{0}'. Definition: {... {1}: '{2}' ...}", directiveName, scopeName, definition, isController ? "controller bindings definition" : "isolate scope definition");
                        bindings[scopeName] = {
                            mode: match[1][0],
                            collection: "*" === match[2],
                            optional: "?" === match[3],
                            attrName: match[4] || scopeName
                        }, match[4] && (bindingCache[definition] = bindings[scopeName])
                    }
                })), bindings
            }

            function parseDirectiveBindings(directive, directiveName) {
                var bindings = {
                    isolateScope: null,
                    bindToController: null
                };
                if (isObject(directive.scope) && (!0 === directive.bindToController ? (bindings.bindToController = parseIsolateBindings(directive.scope, directiveName, !0), bindings.isolateScope = {}) : bindings.isolateScope = parseIsolateBindings(directive.scope, directiveName, !1)), isObject(directive.bindToController) && (bindings.bindToController = parseIsolateBindings(directive.bindToController, directiveName, !0)), bindings.bindToController && !directive.controller) throw $compileMinErr("noctrl", "Cannot bind to controller without directive '{0}'s controller.", directiveName);
                return bindings
            }
            this.directive = function registerDirective(name, directiveFactory) {
                return assertArg(name, "name"), assertNotHasOwnProperty(name, "directive"), isString(name) ? (! function(name) {
                    var letter = name.charAt(0);
                    if (!letter || letter !== lowercase(letter)) throw $compileMinErr("baddir", "Directive/Component name '{0}' is invalid. The first character must be a lowercase letter", name);
                    if (name !== name.trim()) throw $compileMinErr("baddir", "Directive/Component name '{0}' is invalid. The name should not contain leading or trailing whitespaces", name)
                }(name), assertArg(directiveFactory, "directiveFactory"), hasDirectives.hasOwnProperty(name) || (hasDirectives[name] = [], $provide.factory(name + "Directive", ["$injector", "$exceptionHandler", function($injector, $exceptionHandler) {
                    var directives = [];
                    return forEach(hasDirectives[name], (function(directiveFactory, index) {
                        try {
                            var directive = $injector.invoke(directiveFactory);
                            isFunction(directive) ? directive = {
                                compile: valueFn(directive)
                            } : !directive.compile && directive.link && (directive.compile = valueFn(directive.link)), directive.priority = directive.priority || 0, directive.index = index, directive.name = directive.name || name, directive.require = function(directive) {
                                var require = directive.require || directive.controller && directive.name;
                                return !isArray(require) && isObject(require) && forEach(require, (function(value, key) {
                                    var match = value.match(REQUIRE_PREFIX_REGEXP);
                                    value.substring(match[0].length) || (require[key] = match[0] + key)
                                })), require
                            }(directive), directive.restrict = function(restrict, name) {
                                if (restrict && (!isString(restrict) || !/[EACM]/.test(restrict))) throw $compileMinErr("badrestrict", "Restrict property '{0}' of directive '{1}' is invalid", restrict, name);
                                return restrict || "EA"
                            }(directive.restrict, name), directive.$$moduleName = directiveFactory.$$moduleName, directives.push(directive)
                        } catch (e) {
                            $exceptionHandler(e)
                        }
                    })), directives
                }])), hasDirectives[name].push(directiveFactory)) : forEach(name, reverseParams(registerDirective)), this
            }, this.component = function registerComponent(name, options) {
                if (!isString(name)) return forEach(name, reverseParams(bind(this, registerComponent))), this;
                var controller = options.controller || function() {};

                function factory($injector) {
                    function makeInjectable(fn) {
                        return isFunction(fn) || isArray(fn) ? function(tElement, tAttrs) {
                            return $injector.invoke(fn, this, {
                                $element: tElement,
                                $attrs: tAttrs
                            })
                        } : fn
                    }
                    var template = options.template || options.templateUrl ? options.template : "",
                        ddo = {
                            controller: controller,
                            controllerAs: identifierForController(options.controller) || options.controllerAs || "$ctrl",
                            template: makeInjectable(template),
                            templateUrl: makeInjectable(options.templateUrl),
                            transclude: options.transclude,
                            scope: {},
                            bindToController: options.bindings || {},
                            restrict: "E",
                            require: options.require
                        };
                    return forEach(options, (function(val, key) {
                        "$" === key.charAt(0) && (ddo[key] = val)
                    })), ddo
                }
                return forEach(options, (function(val, key) {
                    "$" === key.charAt(0) && (factory[key] = val, isFunction(controller) && (controller[key] = val))
                })), factory.$inject = ["$injector"], this.directive(name, factory)
            }, this.aHrefSanitizationTrustedUrlList = function(regexp) {
                return isDefined(regexp) ? ($$sanitizeUriProvider.aHrefSanitizationTrustedUrlList(regexp), this) : $$sanitizeUriProvider.aHrefSanitizationTrustedUrlList()
            }, Object.defineProperty(this, "aHrefSanitizationWhitelist", {
                get: function() {
                    return this.aHrefSanitizationTrustedUrlList
                },
                set: function(value) {
                    this.aHrefSanitizationTrustedUrlList = value
                }
            }), this.imgSrcSanitizationTrustedUrlList = function(regexp) {
                return isDefined(regexp) ? ($$sanitizeUriProvider.imgSrcSanitizationTrustedUrlList(regexp), this) : $$sanitizeUriProvider.imgSrcSanitizationTrustedUrlList()
            }, Object.defineProperty(this, "imgSrcSanitizationWhitelist", {
                get: function() {
                    return this.imgSrcSanitizationTrustedUrlList
                },
                set: function(value) {
                    this.imgSrcSanitizationTrustedUrlList = value
                }
            });
            var debugInfoEnabled = !0;
            this.debugInfoEnabled = function(enabled) {
                return isDefined(enabled) ? (debugInfoEnabled = enabled, this) : debugInfoEnabled
            };
            var strictComponentBindingsEnabled = !1;
            this.strictComponentBindingsEnabled = function(enabled) {
                return isDefined(enabled) ? (strictComponentBindingsEnabled = enabled, this) : strictComponentBindingsEnabled
            };
            var TTL = 10;
            this.onChangesTtl = function(value) {
                return arguments.length ? (TTL = value, this) : TTL
            };
            var commentDirectivesEnabledConfig = !0;
            this.commentDirectivesEnabled = function(value) {
                return arguments.length ? (commentDirectivesEnabledConfig = value, this) : commentDirectivesEnabledConfig
            };
            var cssClassDirectivesEnabledConfig = !0;
            this.cssClassDirectivesEnabled = function(value) {
                return arguments.length ? (cssClassDirectivesEnabledConfig = value, this) : cssClassDirectivesEnabledConfig
            };
            var PROP_CONTEXTS = createMap();
            this.addPropertySecurityContext = function(elementName, propertyName, ctx) {
                    var key = elementName.toLowerCase() + "|" + propertyName.toLowerCase();
                    if (key in PROP_CONTEXTS && PROP_CONTEXTS[key] !== ctx) throw $compileMinErr("ctxoverride", "Property context '{0}.{1}' already set to '{2}', cannot override to '{3}'.", elementName, propertyName, PROP_CONTEXTS[key], ctx);
                    return PROP_CONTEXTS[key] = ctx, this
                },
                function() {
                    function registerContext(ctx, values) {
                        forEach(values, (function(v) {
                            PROP_CONTEXTS[v.toLowerCase()] = ctx
                        }))
                    }
                    registerContext(SCE_CONTEXTS.HTML, ["iframe|srcdoc", "*|innerHTML", "*|outerHTML"]), registerContext(SCE_CONTEXTS.CSS, ["*|style"]), registerContext(SCE_CONTEXTS.URL, ["area|href", "area|ping", "a|href", "a|ping", "blockquote|cite", "body|background", "del|cite", "input|src", "ins|cite", "q|cite"]), registerContext(SCE_CONTEXTS.MEDIA_URL, ["audio|src", "img|src", "img|srcset", "source|src", "source|srcset", "track|src", "video|src", "video|poster"]), registerContext(SCE_CONTEXTS.RESOURCE_URL, ["*|formAction", "applet|code", "applet|codebase", "base|href", "embed|src", "frame|src", "form|action", "head|profile", "html|manifest", "iframe|src", "link|href", "media|src", "object|codebase", "object|data", "script|src"])
                }(), this.$get = ["$injector", "$interpolate", "$exceptionHandler", "$templateRequest", "$parse", "$controller", "$rootScope", "$sce", "$animate", function($injector, $interpolate, $exceptionHandler, $templateRequest, $parse, $controller, $rootScope, $sce, $animate) {
                    var onChangesQueue, SIMPLE_ATTR_NAME = /^\w/,
                        specialAttrHolder = window.document.createElement("div"),
                        commentDirectivesEnabled = commentDirectivesEnabledConfig,
                        cssClassDirectivesEnabled = cssClassDirectivesEnabledConfig,
                        onChangesTtl = TTL;

                    function flushOnChangesQueue() {
                        try {
                            if (!--onChangesTtl) throw onChangesQueue = void 0, $compileMinErr("infchng", "{0} $onChanges() iterations reached. Aborting!\n", TTL);
                            $rootScope.$apply((function() {
                                for (var i = 0, ii = onChangesQueue.length; i < ii; ++i) try {
                                    onChangesQueue[i]()
                                } catch (e) {
                                    $exceptionHandler(e)
                                }
                                onChangesQueue = void 0
                            }))
                        } finally {
                            onChangesTtl++
                        }
                    }

                    function sanitizeSrcset(value, invokeType) {
                        if (!value) return value;
                        if (!isString(value)) throw $compileMinErr("srcset", 'Can\'t pass trusted values to `{0}`: "{1}"', invokeType, value.toString());
                        for (var result = "", trimmedSrcset = trim(value), pattern = /\s/.test(trimmedSrcset) ? /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/ : /(,)/, rawUris = trimmedSrcset.split(pattern), nbrUrisWith2parts = Math.floor(rawUris.length / 2), i = 0; i < nbrUrisWith2parts; i++) {
                            var innerIdx = 2 * i;
                            result += $sce.getTrustedMediaUrl(trim(rawUris[innerIdx])), result += " " + trim(rawUris[innerIdx + 1])
                        }
                        var lastTuple = trim(rawUris[2 * i]).split(/\s/);
                        return result += $sce.getTrustedMediaUrl(trim(lastTuple[0])), 2 === lastTuple.length && (result += " " + trim(lastTuple[1])), result
                    }

                    function Attributes(element, attributesToCopy) {
                        if (attributesToCopy) {
                            var i, l, key, keys = Object.keys(attributesToCopy);
                            for (i = 0, l = keys.length; i < l; i++) this[key = keys[i]] = attributesToCopy[key]
                        } else this.$attr = {};
                        this.$$element = element
                    }

                    function safeAddClass($element, className) {
                        try {
                            $element.addClass(className)
                        } catch (e) {}
                    }
                    Attributes.prototype = {
                        $normalize: directiveNormalize,
                        $addClass: function(classVal) {
                            classVal && classVal.length > 0 && $animate.addClass(this.$$element, classVal)
                        },
                        $removeClass: function(classVal) {
                            classVal && classVal.length > 0 && $animate.removeClass(this.$$element, classVal)
                        },
                        $updateClass: function(newClasses, oldClasses) {
                            var toAdd = tokenDifference(newClasses, oldClasses);
                            toAdd && toAdd.length && $animate.addClass(this.$$element, toAdd);
                            var toRemove = tokenDifference(oldClasses, newClasses);
                            toRemove && toRemove.length && $animate.removeClass(this.$$element, toRemove)
                        },
                        $set: function(key, value, writeAttr, attrName) {
                            var booleanKey = getBooleanAttrName(this.$$element[0], key),
                                aliasedKey = ALIASED_ATTR[key],
                                observer = key;
                            booleanKey ? (this.$$element.prop(key, value), attrName = booleanKey) : aliasedKey && (this[aliasedKey] = value, observer = aliasedKey), this[key] = value, attrName ? this.$attr[key] = attrName : (attrName = this.$attr[key]) || (this.$attr[key] = attrName = snake_case(key, "-")), "img" === nodeName_(this.$$element) && "srcset" === key && (this[key] = value = sanitizeSrcset(value, "$set('srcset', value)")), !1 !== writeAttr && (null === value || isUndefined(value) ? this.$$element.removeAttr(attrName) : SIMPLE_ATTR_NAME.test(attrName) ? booleanKey && !1 === value ? this.$$element.removeAttr(attrName) : this.$$element.attr(attrName, value) : function(element, attrName, value) {
                                specialAttrHolder.innerHTML = "<span " + attrName + ">";
                                var attributes = specialAttrHolder.firstChild.attributes,
                                    attribute = attributes[0];
                                attributes.removeNamedItem(attribute.name), attribute.value = value, element.attributes.setNamedItem(attribute)
                            }(this.$$element[0], attrName, value));
                            var $$observers = this.$$observers;
                            $$observers && forEach($$observers[observer], (function(fn) {
                                try {
                                    fn(value)
                                } catch (e) {
                                    $exceptionHandler(e)
                                }
                            }))
                        },
                        $observe: function(key, fn) {
                            var attrs = this,
                                $$observers = attrs.$$observers || (attrs.$$observers = createMap()),
                                listeners = $$observers[key] || ($$observers[key] = []);
                            return listeners.push(fn), $rootScope.$evalAsync((function() {
                                    listeners.$$inter || !attrs.hasOwnProperty(key) || isUndefined(attrs[key]) || fn(attrs[key])
                                })),
                                function() {
                                    arrayRemove(listeners, fn)
                                }
                        }
                    };
                    var startSymbol = $interpolate.startSymbol(),
                        endSymbol = $interpolate.endSymbol(),
                        denormalizeTemplate = "{{" === startSymbol && "}}" === endSymbol ? identity : function(template) {
                            return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol)
                        },
                        NG_PREFIX_BINDING = /^ng(Attr|Prop|On)([A-Z].*)$/,
                        MULTI_ELEMENT_DIR_RE = /^(.+)Start$/;
                    return compile.$$addBindingInfo = debugInfoEnabled ? function($element, binding) {
                        var bindings = $element.data("$binding") || [];
                        isArray(binding) ? bindings = bindings.concat(binding) : bindings.push(binding), $element.data("$binding", bindings)
                    } : noop, compile.$$addBindingClass = debugInfoEnabled ? function($element) {
                        safeAddClass($element, "ng-binding")
                    } : noop, compile.$$addScopeInfo = debugInfoEnabled ? function($element, scope, isolated, noTemplate) {
                        var dataName = isolated ? noTemplate ? "$isolateScopeNoTemplate" : "$isolateScope" : "$scope";
                        $element.data(dataName, scope)
                    } : noop, compile.$$addScopeClass = debugInfoEnabled ? function($element, isolated) {
                        safeAddClass($element, isolated ? "ng-isolate-scope" : "ng-scope")
                    } : noop, compile.$$createComment = function(directiveName, comment) {
                        var content = "";
                        return debugInfoEnabled && (content = " " + (directiveName || "") + ": ", comment && (content += comment + " ")), window.document.createComment(content)
                    }, compile;

                    function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                        $compileNodes instanceof jqLite || ($compileNodes = jqLite($compileNodes));
                        var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
                        compile.$$addScopeClass($compileNodes);
                        var namespace = null;
                        return function(scope, cloneConnectFn, options) {
                            if (!$compileNodes) throw $compileMinErr("multilink", "This element has already been linked.");
                            assertArg(scope, "scope"), previousCompileContext && previousCompileContext.needsNewScope && (scope = scope.$parent.$new());
                            var parentElement, node, $linkNode, parentBoundTranscludeFn = (options = options || {}).parentBoundTranscludeFn,
                                transcludeControllers = options.transcludeControllers,
                                futureParentElement = options.futureParentElement;
                            if (parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude && (parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude), namespace || (node = (parentElement = futureParentElement) && parentElement[0], namespace = node && "foreignobject" !== nodeName_(node) && toString.call(node).match(/SVG/) ? "svg" : "html"), $linkNode = "html" !== namespace ? jqLite(wrapTemplate(namespace, jqLite("<div></div>").append($compileNodes).html())) : cloneConnectFn ? JQLitePrototype.clone.call($compileNodes) : $compileNodes, transcludeControllers)
                                for (var controllerName in transcludeControllers) $linkNode.data("$" + controllerName + "Controller", transcludeControllers[controllerName].instance);
                            return compile.$$addScopeInfo($linkNode, scope), cloneConnectFn && cloneConnectFn($linkNode, scope), compositeLinkFn && compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn), cloneConnectFn || ($compileNodes = compositeLinkFn = null), $linkNode
                        }
                    }

                    function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
                        for (var attrs, directives, nodeLinkFn, childNodes, childLinkFn, linkFnFound, nodeLinkFnFound, linkFns = [], notLiveList = isArray(nodeList) || nodeList instanceof jqLite, i = 0; i < nodeList.length; i++) attrs = new Attributes, 11 === msie && mergeConsecutiveTextNodes(nodeList, i, notLiveList), (nodeLinkFn = (directives = collectDirectives(nodeList[i], [], attrs, 0 === i ? maxPriority : void 0, ignoreDirective)).length ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null) && nodeLinkFn.scope && compile.$$addScopeClass(attrs.$$element), childLinkFn = nodeLinkFn && nodeLinkFn.terminal || !(childNodes = nodeList[i].childNodes) || !childNodes.length ? null : compileNodes(childNodes, nodeLinkFn ? (nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) && nodeLinkFn.transclude : transcludeFn), (nodeLinkFn || childLinkFn) && (linkFns.push(i, nodeLinkFn, childLinkFn), linkFnFound = !0, nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn), previousCompileContext = null;
                        return linkFnFound ? function(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
                            var nodeLinkFn, childLinkFn, node, childScope, i, ii, idx, childBoundTranscludeFn, stableNodeList;
                            if (nodeLinkFnFound) {
                                var nodeListLength = nodeList.length;
                                for (stableNodeList = new Array(nodeListLength), i = 0; i < linkFns.length; i += 3) idx = linkFns[i], stableNodeList[idx] = nodeList[idx]
                            } else stableNodeList = nodeList;
                            for (i = 0, ii = linkFns.length; i < ii;) node = stableNodeList[linkFns[i++]], nodeLinkFn = linkFns[i++], childLinkFn = linkFns[i++], nodeLinkFn ? (nodeLinkFn.scope ? (childScope = scope.$new(), compile.$$addScopeInfo(jqLite(node), childScope)) : childScope = scope, childBoundTranscludeFn = nodeLinkFn.transcludeOnThisElement ? createBoundTranscludeFn(scope, nodeLinkFn.transclude, parentBoundTranscludeFn) : !nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn ? parentBoundTranscludeFn : !parentBoundTranscludeFn && transcludeFn ? createBoundTranscludeFn(scope, transcludeFn) : null, nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn)) : childLinkFn && childLinkFn(scope, node.childNodes, void 0, parentBoundTranscludeFn)
                        } : null
                    }

                    function mergeConsecutiveTextNodes(nodeList, idx, notLiveList) {
                        var sibling, node = nodeList[idx],
                            parent = node.parentNode;
                        if (node.nodeType === NODE_TYPE_TEXT)
                            for (;
                                (sibling = parent ? node.nextSibling : nodeList[idx + 1]) && sibling.nodeType === NODE_TYPE_TEXT;) node.nodeValue = node.nodeValue + sibling.nodeValue, sibling.parentNode && sibling.parentNode.removeChild(sibling), notLiveList && sibling === nodeList[idx + 1] && nodeList.splice(idx + 1, 1)
                    }

                    function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) {
                        function boundTranscludeFn(transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {
                            return transcludedScope || ((transcludedScope = scope.$new(!1, containingScope)).$$transcluded = !0), transcludeFn(transcludedScope, cloneFn, {
                                parentBoundTranscludeFn: previousBoundTranscludeFn,
                                transcludeControllers: controllers,
                                futureParentElement: futureParentElement
                            })
                        }
                        var boundSlots = boundTranscludeFn.$$slots = createMap();
                        for (var slotName in transcludeFn.$$slots) transcludeFn.$$slots[slotName] ? boundSlots[slotName] = createBoundTranscludeFn(scope, transcludeFn.$$slots[slotName], previousBoundTranscludeFn) : boundSlots[slotName] = null;
                        return boundTranscludeFn
                    }

                    function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
                        var match, nodeName, className, nodeType = node.nodeType,
                            attrsMap = attrs.$attr;
                        switch (nodeType) {
                            case 1:
                                addDirective(directives, directiveNormalize(nodeName = nodeName_(node)), "E", maxPriority, ignoreDirective);
                                for (var attr, name, nName, value, ngPrefixMatch, nAttrs = node.attributes, j = 0, jj = nAttrs && nAttrs.length; j < jj; j++) {
                                    var multiElementMatch, attrStartName = !1,
                                        attrEndName = !1,
                                        isNgAttr = !1,
                                        isNgProp = !1,
                                        isNgEvent = !1;
                                    name = (attr = nAttrs[j]).name, value = attr.value, (ngPrefixMatch = (nName = directiveNormalize(name.toLowerCase())).match(NG_PREFIX_BINDING)) ? (isNgAttr = "Attr" === ngPrefixMatch[1], isNgProp = "Prop" === ngPrefixMatch[1], isNgEvent = "On" === ngPrefixMatch[1], name = name.replace(PREFIX_REGEXP, "").toLowerCase().substr(4 + ngPrefixMatch[1].length).replace(/_(.)/g, (function(match, letter) {
                                        return letter.toUpperCase()
                                    }))) : (multiElementMatch = nName.match(MULTI_ELEMENT_DIR_RE)) && directiveIsMultiElement(multiElementMatch[1]) && (attrStartName = name, attrEndName = name.substr(0, name.length - 5) + "end", name = name.substr(0, name.length - 6)), isNgProp || isNgEvent ? (attrs[nName] = value, attrsMap[nName] = attr.name, isNgProp ? addPropertyDirective(node, directives, nName, name) : addEventDirective(directives, nName, name)) : (attrsMap[nName = directiveNormalize(name.toLowerCase())] = name, !isNgAttr && attrs.hasOwnProperty(nName) || (attrs[nName] = value, getBooleanAttrName(node, nName) && (attrs[nName] = !0)), addAttrInterpolateDirective(node, directives, value, nName, isNgAttr), addDirective(directives, nName, "A", maxPriority, ignoreDirective, attrStartName, attrEndName))
                                }
                                if ("input" === nodeName && "hidden" === node.getAttribute("type") && node.setAttribute("autocomplete", "off"), !cssClassDirectivesEnabled) break;
                                if (isObject(className = node.className) && (className = className.animVal), isString(className) && "" !== className)
                                    for (; match = CLASS_DIRECTIVE_REGEXP.exec(className);) addDirective(directives, nName = directiveNormalize(match[2]), "C", maxPriority, ignoreDirective) && (attrs[nName] = trim(match[3])), className = className.substr(match.index + match[0].length);
                                break;
                            case NODE_TYPE_TEXT:
                                ! function(directives, text) {
                                    var interpolateFn = $interpolate(text, !0);
                                    interpolateFn && directives.push({
                                        priority: 0,
                                        compile: function(templateNode) {
                                            var templateNodeParent = templateNode.parent(),
                                                hasCompileParent = !!templateNodeParent.length;
                                            return hasCompileParent && compile.$$addBindingClass(templateNodeParent),
                                                function(scope, node) {
                                                    var parent = node.parent();
                                                    hasCompileParent || compile.$$addBindingClass(parent), compile.$$addBindingInfo(parent, interpolateFn.expressions), scope.$watch(interpolateFn, (function(value) {
                                                        node[0].nodeValue = value
                                                    }))
                                                }
                                        }
                                    })
                                }(directives, node.nodeValue);
                                break;
                            case 8:
                                if (!commentDirectivesEnabled) break;
                                ! function(node, directives, attrs, maxPriority, ignoreDirective) {
                                    try {
                                        var match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
                                        if (match) {
                                            var nName = directiveNormalize(match[1]);
                                            addDirective(directives, nName, "M", maxPriority, ignoreDirective) && (attrs[nName] = trim(match[2]))
                                        }
                                    } catch (e) {}
                                }(node, directives, attrs, maxPriority, ignoreDirective)
                        }
                        return directives.sort(byPriority), directives
                    }

                    function groupScan(node, attrStart, attrEnd) {
                        var nodes = [],
                            depth = 0;
                        if (attrStart && node.hasAttribute && node.hasAttribute(attrStart))
                            do {
                                if (!node) throw $compileMinErr("uterdir", "Unterminated attribute, found '{0}' but no matching '{1}' found.", attrStart, attrEnd);
                                1 === node.nodeType && (node.hasAttribute(attrStart) && depth++, node.hasAttribute(attrEnd) && depth--), nodes.push(node), node = node.nextSibling
                            } while (depth > 0);
                        else nodes.push(node);
                        return jqLite(nodes)
                    }

                    function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
                        return function(scope, element, attrs, controllers, transcludeFn) {
                            return element = groupScan(element[0], attrStart, attrEnd), linkFn(scope, element, attrs, controllers, transcludeFn)
                        }
                    }

                    function compilationGenerator(eager, $compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                        var compiled;
                        return eager ? compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) : function() {
                            return compiled || (compiled = compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext), $compileNodes = transcludeFn = previousCompileContext = null), compiled.apply(this, arguments)
                        }
                    }

                    function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
                        previousCompileContext = previousCompileContext || {};
                        for (var directive, directiveName, $template, linkFn, directiveValue, terminalPriority = -Number.MAX_VALUE, newScopeDirective = previousCompileContext.newScopeDirective, controllerDirectives = previousCompileContext.controllerDirectives, newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective, templateDirective = previousCompileContext.templateDirective, nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective, hasTranscludeDirective = !1, hasTemplate = !1, hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective, $compileNode = templateAttrs.$$element = jqLite(compileNode), replaceDirective = originalReplaceDirective, childTranscludeFn = transcludeFn, didScanForMultipleTransclusion = !1, mightHaveMultipleTransclusionError = !1, i = 0, ii = directives.length; i < ii; i++) {
                            var attrStart = (directive = directives[i]).$$start,
                                attrEnd = directive.$$end;
                            if (attrStart && ($compileNode = groupScan(compileNode, attrStart, attrEnd)), $template = void 0, terminalPriority > directive.priority) break;
                            if ((directiveValue = directive.scope) && (directive.templateUrl || (isObject(directiveValue) ? (assertNoDuplicate("new/isolated scope", newIsolateScopeDirective || newScopeDirective, directive, $compileNode), newIsolateScopeDirective = directive) : assertNoDuplicate("new/isolated scope", newIsolateScopeDirective, directive, $compileNode)), newScopeDirective = newScopeDirective || directive), directiveName = directive.name, !didScanForMultipleTransclusion && (directive.replace && (directive.templateUrl || directive.template) || directive.transclude && !directive.$$tlb)) {
                                for (var candidateDirective, scanningIndex = i + 1; candidateDirective = directives[scanningIndex++];)
                                    if (candidateDirective.transclude && !candidateDirective.$$tlb || candidateDirective.replace && (candidateDirective.templateUrl || candidateDirective.template)) {
                                        mightHaveMultipleTransclusionError = !0;
                                        break
                                    }
                                didScanForMultipleTransclusion = !0
                            }
                            if (!directive.templateUrl && directive.controller && (controllerDirectives = controllerDirectives || createMap(), assertNoDuplicate("'" + directiveName + "' controller", controllerDirectives[directiveName], directive, $compileNode), controllerDirectives[directiveName] = directive), directiveValue = directive.transclude)
                                if (hasTranscludeDirective = !0, directive.$$tlb || (assertNoDuplicate("transclusion", nonTlbTranscludeDirective, directive, $compileNode), nonTlbTranscludeDirective = directive), "element" === directiveValue) hasElementTranscludeDirective = !0, terminalPriority = directive.priority, $template = $compileNode, $compileNode = templateAttrs.$$element = jqLite(compile.$$createComment(directiveName, templateAttrs[directiveName])), compileNode = $compileNode[0], replaceWith(jqCollection, sliceArgs($template), compileNode), childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, {
                                    nonTlbTranscludeDirective: nonTlbTranscludeDirective
                                });
                                else {
                                    var slots = createMap();
                                    if (isObject(directiveValue)) {
                                        $template = window.document.createDocumentFragment();
                                        var slotMap = createMap(),
                                            filledSlots = createMap();
                                        for (var slotName in forEach(directiveValue, (function(elementSelector, slotName) {
                                                var optional = "?" === elementSelector.charAt(0);
                                                elementSelector = optional ? elementSelector.substring(1) : elementSelector, slotMap[elementSelector] = slotName, slots[slotName] = null, filledSlots[slotName] = optional
                                            })), forEach($compileNode.contents(), (function(node) {
                                                var slotName = slotMap[directiveNormalize(nodeName_(node))];
                                                slotName ? (filledSlots[slotName] = !0, slots[slotName] = slots[slotName] || window.document.createDocumentFragment(), slots[slotName].appendChild(node)) : $template.appendChild(node)
                                            })), forEach(filledSlots, (function(filled, slotName) {
                                                if (!filled) throw $compileMinErr("reqslot", "Required transclusion slot `{0}` was not filled.", slotName)
                                            })), slots)
                                            if (slots[slotName]) {
                                                var slotCompileNodes = jqLite(slots[slotName].childNodes);
                                                slots[slotName] = compilationGenerator(mightHaveMultipleTransclusionError, slotCompileNodes, transcludeFn)
                                            }
                                        $template = jqLite($template.childNodes)
                                    } else $template = jqLite(jqLiteClone(compileNode)).contents();
                                    $compileNode.empty(), (childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, void 0, void 0, {
                                        needsNewScope: directive.$$isolateScope || directive.$$newScope
                                    })).$$slots = slots
                                }
                            if (directive.template)
                                if (hasTemplate = !0, assertNoDuplicate("template", templateDirective, directive, $compileNode), templateDirective = directive, directiveValue = isFunction(directive.template) ? directive.template($compileNode, templateAttrs) : directive.template, directiveValue = denormalizeTemplate(directiveValue), directive.replace) {
                                    if (replaceDirective = directive, $template = jqLiteIsTextNode(directiveValue) ? [] : removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue))), compileNode = $template[0], 1 !== $template.length || 1 !== compileNode.nodeType) throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", directiveName, "");
                                    replaceWith(jqCollection, $compileNode, compileNode);
                                    var newTemplateAttrs = {
                                            $attr: {}
                                        },
                                        templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs),
                                        unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
                                    (newIsolateScopeDirective || newScopeDirective) && markDirectiveScope(templateDirectives, newIsolateScopeDirective, newScopeDirective), directives = directives.concat(templateDirectives).concat(unprocessedDirectives), mergeTemplateAttributes(templateAttrs, newTemplateAttrs), ii = directives.length
                                } else $compileNode.html(directiveValue);
                            if (directive.templateUrl) hasTemplate = !0, assertNoDuplicate("template", templateDirective, directive, $compileNode), templateDirective = directive, directive.replace && (replaceDirective = directive), nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
                                controllerDirectives: controllerDirectives,
                                newScopeDirective: newScopeDirective !== directive && newScopeDirective,
                                newIsolateScopeDirective: newIsolateScopeDirective,
                                templateDirective: templateDirective,
                                nonTlbTranscludeDirective: nonTlbTranscludeDirective
                            }), ii = directives.length;
                            else if (directive.compile) try {
                                linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
                                var context = directive.$$originalDirective || directive;
                                isFunction(linkFn) ? addLinkFns(null, bind(context, linkFn), attrStart, attrEnd) : linkFn && addLinkFns(bind(context, linkFn.pre), bind(context, linkFn.post), attrStart, attrEnd)
                            } catch (e) {
                                $exceptionHandler(e, startingTag($compileNode))
                            }
                            directive.terminal && (nodeLinkFn.terminal = !0, terminalPriority = Math.max(terminalPriority, directive.priority))
                        }
                        return nodeLinkFn.scope = newScopeDirective && !0 === newScopeDirective.scope, nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective, nodeLinkFn.templateOnThisElement = hasTemplate, nodeLinkFn.transclude = childTranscludeFn, previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective, nodeLinkFn;

                        function addLinkFns(pre, post, attrStart, attrEnd) {
                            pre && (attrStart && (pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd)), pre.require = directive.require, pre.directiveName = directiveName, (newIsolateScopeDirective === directive || directive.$$isolateScope) && (pre = cloneAndAnnotateFn(pre, {
                                isolateScope: !0
                            })), preLinkFns.push(pre)), post && (attrStart && (post = groupElementsLinkFnWrapper(post, attrStart, attrEnd)), post.require = directive.require, post.directiveName = directiveName, (newIsolateScopeDirective === directive || directive.$$isolateScope) && (post = cloneAndAnnotateFn(post, {
                                isolateScope: !0
                            })), postLinkFns.push(post))
                        }

                        function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
                            var i, ii, linkFn, isolateScope, controllerScope, elementControllers, transcludeFn, $element, attrs, scopeBindingInfo;
                            for (var name in compileNode === linkNode ? (attrs = templateAttrs, $element = templateAttrs.$$element) : attrs = new Attributes($element = jqLite(linkNode), templateAttrs), controllerScope = scope, newIsolateScopeDirective ? isolateScope = scope.$new(!0) : newScopeDirective && (controllerScope = scope.$parent), boundTranscludeFn && ((transcludeFn = function(scope, cloneAttachFn, futureParentElement, slotName) {
                                    var transcludeControllers;
                                    isScope(scope) || (slotName = futureParentElement, futureParentElement = cloneAttachFn, cloneAttachFn = scope, scope = void 0);
                                    hasElementTranscludeDirective && (transcludeControllers = elementControllers);
                                    futureParentElement || (futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element);
                                    if (!slotName) return boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                                    var slotTranscludeFn = boundTranscludeFn.$$slots[slotName];
                                    if (slotTranscludeFn) return slotTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                                    if (isUndefined(slotTranscludeFn)) throw $compileMinErr("noslot", 'No parent directive that requires a transclusion with slot name "{0}". Element: {1}', slotName, startingTag($element))
                                }).$$boundTransclude = boundTranscludeFn, transcludeFn.isSlotFilled = function(slotName) {
                                    return !!boundTranscludeFn.$$slots[slotName]
                                }), controllerDirectives && (elementControllers = function($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective) {
                                    var elementControllers = createMap();
                                    for (var controllerKey in controllerDirectives) {
                                        var directive = controllerDirectives[controllerKey],
                                            locals = {
                                                $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
                                                $element: $element,
                                                $attrs: attrs,
                                                $transclude: transcludeFn
                                            },
                                            controller = directive.controller;
                                        "@" === controller && (controller = attrs[directive.name]);
                                        var controllerInstance = $controller(controller, locals, !0, directive.controllerAs);
                                        elementControllers[directive.name] = controllerInstance, $element.data("$" + directive.name + "Controller", controllerInstance.instance)
                                    }
                                    return elementControllers
                                }($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective)), newIsolateScopeDirective && (compile.$$addScopeInfo($element, isolateScope, !0, !(templateDirective && (templateDirective === newIsolateScopeDirective || templateDirective === newIsolateScopeDirective.$$originalDirective))), compile.$$addScopeClass($element, !0), isolateScope.$$isolateBindings = newIsolateScopeDirective.$$isolateBindings, (scopeBindingInfo = initializeDirectiveBindings(scope, attrs, isolateScope, isolateScope.$$isolateBindings, newIsolateScopeDirective)).removeWatches && isolateScope.$on("$destroy", scopeBindingInfo.removeWatches)), elementControllers) {
                                var controllerDirective = controllerDirectives[name],
                                    controller = elementControllers[name],
                                    bindings = controllerDirective.$$bindings.bindToController;
                                controller.instance = controller(), $element.data("$" + controllerDirective.name + "Controller", controller.instance), controller.bindingInfo = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective)
                            }
                            for (forEach(controllerDirectives, (function(controllerDirective, name) {
                                    var require = controllerDirective.require;
                                    controllerDirective.bindToController && !isArray(require) && isObject(require) && extend(elementControllers[name].instance, getControllers(name, require, $element, elementControllers))
                                })), forEach(elementControllers, (function(controller) {
                                    var controllerInstance = controller.instance;
                                    if (isFunction(controllerInstance.$onChanges)) try {
                                        controllerInstance.$onChanges(controller.bindingInfo.initialChanges)
                                    } catch (e) {
                                        $exceptionHandler(e)
                                    }
                                    if (isFunction(controllerInstance.$onInit)) try {
                                        controllerInstance.$onInit()
                                    } catch (e) {
                                        $exceptionHandler(e)
                                    }
                                    isFunction(controllerInstance.$doCheck) && (controllerScope.$watch((function() {
                                        controllerInstance.$doCheck()
                                    })), controllerInstance.$doCheck()), isFunction(controllerInstance.$onDestroy) && controllerScope.$on("$destroy", (function() {
                                        controllerInstance.$onDestroy()
                                    }))
                                })), i = 0, ii = preLinkFns.length; i < ii; i++) invokeLinkFn(linkFn = preLinkFns[i], linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                            var scopeToChild = scope;
                            for (newIsolateScopeDirective && (newIsolateScopeDirective.template || null === newIsolateScopeDirective.templateUrl) && (scopeToChild = isolateScope), childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, void 0, boundTranscludeFn), i = postLinkFns.length - 1; i >= 0; i--) invokeLinkFn(linkFn = postLinkFns[i], linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                            forEach(elementControllers, (function(controller) {
                                var controllerInstance = controller.instance;
                                isFunction(controllerInstance.$postLink) && controllerInstance.$postLink()
                            }))
                        }
                    }

                    function getControllers(directiveName, require, $element, elementControllers) {
                        var value;
                        if (isString(require)) {
                            var match = require.match(REQUIRE_PREFIX_REGEXP),
                                name = require.substring(match[0].length),
                                inheritType = match[1] || match[3],
                                optional = "?" === match[2];
                            if ("^^" === inheritType ? $element = $element.parent() : value = (value = elementControllers && elementControllers[name]) && value.instance, !value) {
                                var dataName = "$" + name + "Controller";
                                value = "^^" === inheritType && $element[0] && 9 === $element[0].nodeType ? null : inheritType ? $element.inheritedData(dataName) : $element.data(dataName)
                            }
                            if (!value && !optional) throw $compileMinErr("ctreq", "Controller '{0}', required by directive '{1}', can't be found!", name, directiveName)
                        } else if (isArray(require)) {
                            value = [];
                            for (var i = 0, ii = require.length; i < ii; i++) value[i] = getControllers(directiveName, require[i], $element, elementControllers)
                        } else isObject(require) && (value = {}, forEach(require, (function(controller, property) {
                            value[property] = getControllers(directiveName, controller, $element, elementControllers)
                        })));
                        return value || null
                    }

                    function markDirectiveScope(directives, isolateScope, newScope) {
                        for (var j = 0, jj = directives.length; j < jj; j++) directives[j] = inherit(directives[j], {
                            $$isolateScope: isolateScope,
                            $$newScope: newScope
                        })
                    }

                    function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
                        if (name === ignoreDirective) return null;
                        var match = null;
                        if (hasDirectives.hasOwnProperty(name))
                            for (var directive, directives = $injector.get(name + "Directive"), i = 0, ii = directives.length; i < ii; i++)
                                if (directive = directives[i], (isUndefined(maxPriority) || maxPriority > directive.priority) && -1 !== directive.restrict.indexOf(location)) {
                                    if (startAttrName && (directive = inherit(directive, {
                                            $$start: startAttrName,
                                            $$end: endAttrName
                                        })), !directive.$$bindings) {
                                        var bindings = directive.$$bindings = parseDirectiveBindings(directive, directive.name);
                                        isObject(bindings.isolateScope) && (directive.$$isolateBindings = bindings.isolateScope)
                                    }
                                    tDirectives.push(directive), match = directive
                                }
                        return match
                    }

                    function directiveIsMultiElement(name) {
                        if (hasDirectives.hasOwnProperty(name))
                            for (var directives = $injector.get(name + "Directive"), i = 0, ii = directives.length; i < ii; i++)
                                if (directives[i].multiElement) return !0;
                        return !1
                    }

                    function mergeTemplateAttributes(dst, src) {
                        var srcAttr = src.$attr,
                            dstAttr = dst.$attr;
                        forEach(dst, (function(value, key) {
                            "$" !== key.charAt(0) && (src[key] && src[key] !== value && (value.length ? value += ("style" === key ? ";" : " ") + src[key] : value = src[key]), dst.$set(key, value, !0, srcAttr[key]))
                        })), forEach(src, (function(value, key) {
                            dst.hasOwnProperty(key) || "$" === key.charAt(0) || (dst[key] = value, "class" !== key && "style" !== key && (dstAttr[key] = srcAttr[key]))
                        }))
                    }

                    function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
                        var afterTemplateNodeLinkFn, afterTemplateChildLinkFn, linkQueue = [],
                            beforeTemplateCompileNode = $compileNode[0],
                            origAsyncDirective = directives.shift(),
                            derivedSyncDirective = inherit(origAsyncDirective, {
                                templateUrl: null,
                                transclude: null,
                                replace: null,
                                $$originalDirective: origAsyncDirective
                            }),
                            templateUrl = isFunction(origAsyncDirective.templateUrl) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl,
                            templateNamespace = origAsyncDirective.templateNamespace;
                        return $compileNode.empty(), $templateRequest(templateUrl).then((function(content) {
                                var compileNode, tempTemplateAttrs, $template, childBoundTranscludeFn;
                                if (content = denormalizeTemplate(content), origAsyncDirective.replace) {
                                    if ($template = jqLiteIsTextNode(content) ? [] : removeComments(wrapTemplate(templateNamespace, trim(content))), compileNode = $template[0], 1 !== $template.length || 1 !== compileNode.nodeType) throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", origAsyncDirective.name, templateUrl);
                                    tempTemplateAttrs = {
                                        $attr: {}
                                    }, replaceWith($rootElement, $compileNode, compileNode);
                                    var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
                                    isObject(origAsyncDirective.scope) && markDirectiveScope(templateDirectives, !0), directives = templateDirectives.concat(directives), mergeTemplateAttributes(tAttrs, tempTemplateAttrs)
                                } else compileNode = beforeTemplateCompileNode, $compileNode.html(content);
                                for (directives.unshift(derivedSyncDirective), afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext), forEach($rootElement, (function(node, i) {
                                        node === compileNode && ($rootElement[i] = $compileNode[0])
                                    })), afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn); linkQueue.length;) {
                                    var scope = linkQueue.shift(),
                                        beforeTemplateLinkNode = linkQueue.shift(),
                                        linkRootElement = linkQueue.shift(),
                                        boundTranscludeFn = linkQueue.shift(),
                                        linkNode = $compileNode[0];
                                    if (!scope.$$destroyed) {
                                        if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                                            var oldClasses = beforeTemplateLinkNode.className;
                                            previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace || (linkNode = jqLiteClone(compileNode)), replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode), safeAddClass(jqLite(linkNode), oldClasses)
                                        }
                                        childBoundTranscludeFn = afterTemplateNodeLinkFn.transcludeOnThisElement ? createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn) : boundTranscludeFn, afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn)
                                    }
                                }
                                linkQueue = null
                            })).catch((function(error) {
                                isError(error) && $exceptionHandler(error)
                            })),
                            function(ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
                                var childBoundTranscludeFn = boundTranscludeFn;
                                scope.$$destroyed || (linkQueue ? linkQueue.push(scope, node, rootElement, childBoundTranscludeFn) : (afterTemplateNodeLinkFn.transcludeOnThisElement && (childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn)), afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn)))
                            }
                    }

                    function byPriority(a, b) {
                        var diff = b.priority - a.priority;
                        return 0 !== diff ? diff : a.name !== b.name ? a.name < b.name ? -1 : 1 : a.index - b.index
                    }

                    function assertNoDuplicate(what, previousDirective, directive, element) {
                        function wrapModuleNameIfDefined(moduleName) {
                            return moduleName ? " (module: " + moduleName + ")" : ""
                        }
                        if (previousDirective) throw $compileMinErr("multidir", "Multiple directives [{0}{1}, {2}{3}] asking for {4} on: {5}", previousDirective.name, wrapModuleNameIfDefined(previousDirective.$$moduleName), directive.name, wrapModuleNameIfDefined(directive.$$moduleName), what, startingTag(element))
                    }

                    function wrapTemplate(type, template) {
                        switch (type = lowercase(type || "html")) {
                            case "svg":
                            case "math":
                                var wrapper = window.document.createElement("div");
                                return wrapper.innerHTML = "<" + type + ">" + template + "</" + type + ">", wrapper.childNodes[0].childNodes;
                            default:
                                return template
                        }
                    }

                    function sanitizeSrcsetPropertyValue(value) {
                        return sanitizeSrcset($sce.valueOf(value), "ng-prop-srcset")
                    }

                    function addPropertyDirective(node, directives, attrName, propName) {
                        if (EVENT_HANDLER_ATTR_REGEXP.test(propName)) throw $compileMinErr("nodomevents", "Property bindings for HTML DOM event properties are disallowed");
                        var nodeName = nodeName_(node),
                            trustedContext = function(nodeName, propNormalizedName) {
                                var prop = propNormalizedName.toLowerCase();
                                return PROP_CONTEXTS[nodeName + "|" + prop] || PROP_CONTEXTS["*|" + prop]
                            }(nodeName, propName),
                            sanitizer = identity;
                        "srcset" !== propName || "img" !== nodeName && "source" !== nodeName ? trustedContext && (sanitizer = $sce.getTrusted.bind($sce, trustedContext)) : sanitizer = sanitizeSrcsetPropertyValue, directives.push({
                            priority: 100,
                            compile: function(_, attr) {
                                var ngPropGetter = $parse(attr[attrName]),
                                    ngPropWatch = $parse(attr[attrName], (function(val) {
                                        return $sce.valueOf(val)
                                    }));
                                return {
                                    pre: function(scope, $element) {
                                        function applyPropValue() {
                                            var propValue = ngPropGetter(scope);
                                            $element[0][propName] = sanitizer(propValue)
                                        }
                                        applyPropValue(), scope.$watch(ngPropWatch, applyPropValue)
                                    }
                                }
                            }
                        })
                    }

                    function addEventDirective(directives, attrName, eventName) {
                        directives.push(createEventDirective($parse, $rootScope, $exceptionHandler, attrName, eventName, !1))
                    }

                    function addAttrInterpolateDirective(node, directives, value, name, isNgAttr) {
                        var nodeName = nodeName_(node),
                            trustedContext = function(nodeName, attrNormalizedName) {
                                return "srcdoc" === attrNormalizedName ? $sce.HTML : "src" === attrNormalizedName || "ngSrc" === attrNormalizedName ? -1 === ["img", "video", "audio", "source", "track"].indexOf(nodeName) ? $sce.RESOURCE_URL : $sce.MEDIA_URL : "xlinkHref" === attrNormalizedName ? "image" === nodeName ? $sce.MEDIA_URL : "a" === nodeName ? $sce.URL : $sce.RESOURCE_URL : "form" === nodeName && "action" === attrNormalizedName || "base" === nodeName && "href" === attrNormalizedName || "link" === nodeName && "href" === attrNormalizedName ? $sce.RESOURCE_URL : "a" !== nodeName || "href" !== attrNormalizedName && "ngHref" !== attrNormalizedName ? void 0 : $sce.URL
                            }(nodeName, name),
                            mustHaveExpression = !isNgAttr,
                            allOrNothing = ALL_OR_NOTHING_ATTRS[name] || isNgAttr,
                            interpolateFn = $interpolate(value, mustHaveExpression, trustedContext, allOrNothing);
                        if (interpolateFn) {
                            if ("multiple" === name && "select" === nodeName) throw $compileMinErr("selmulti", "Binding to the 'multiple' attribute is not supported. Element: {0}", startingTag(node));
                            if (EVENT_HANDLER_ATTR_REGEXP.test(name)) throw $compileMinErr("nodomevents", "Interpolations for HTML DOM event attributes are disallowed");
                            directives.push({
                                priority: 100,
                                compile: function() {
                                    return {
                                        pre: function(scope, element, attr) {
                                            var $$observers = attr.$$observers || (attr.$$observers = createMap()),
                                                newValue = attr[name];
                                            newValue !== value && (interpolateFn = newValue && $interpolate(newValue, !0, trustedContext, allOrNothing), value = newValue), interpolateFn && (attr[name] = interpolateFn(scope), ($$observers[name] || ($$observers[name] = [])).$$inter = !0, (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, (function(newValue, oldValue) {
                                                "class" === name && newValue !== oldValue ? attr.$updateClass(newValue, oldValue) : attr.$set(name, newValue)
                                            })))
                                        }
                                    }
                                }
                            })
                        }
                    }

                    function replaceWith($rootElement, elementsToRemove, newNode) {
                        var i, ii, firstElementToRemove = elementsToRemove[0],
                            removeCount = elementsToRemove.length,
                            parent = firstElementToRemove.parentNode;
                        if ($rootElement)
                            for (i = 0, ii = $rootElement.length; i < ii; i++)
                                if ($rootElement[i] === firstElementToRemove) {
                                    $rootElement[i++] = newNode;
                                    for (var j = i, j2 = j + removeCount - 1, jj = $rootElement.length; j < jj; j++, j2++) j2 < jj ? $rootElement[j] = $rootElement[j2] : delete $rootElement[j];
                                    $rootElement.length -= removeCount - 1, $rootElement.context === firstElementToRemove && ($rootElement.context = newNode);
                                    break
                                }
                        parent && parent.replaceChild(newNode, firstElementToRemove);
                        var fragment = window.document.createDocumentFragment();
                        for (i = 0; i < removeCount; i++) fragment.appendChild(elementsToRemove[i]);
                        for (jqLite.hasData(firstElementToRemove) && (jqLite.data(newNode, jqLite.data(firstElementToRemove)), jqLite(firstElementToRemove).off("$destroy")), jqLite.cleanData(fragment.querySelectorAll("*")), i = 1; i < removeCount; i++) delete elementsToRemove[i];
                        elementsToRemove[0] = newNode, elementsToRemove.length = 1
                    }

                    function cloneAndAnnotateFn(fn, annotation) {
                        return extend((function() {
                            return fn.apply(null, arguments)
                        }), fn, annotation)
                    }

                    function invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {
                        try {
                            linkFn(scope, $element, attrs, controllers, transcludeFn)
                        } catch (e) {
                            $exceptionHandler(e, startingTag($element))
                        }
                    }

                    function strictBindingsCheck(attrName, directiveName) {
                        if (strictComponentBindingsEnabled) throw $compileMinErr("missingattr", "Attribute '{0}' of '{1}' is non-optional and must be set!", attrName, directiveName)
                    }

                    function initializeDirectiveBindings(scope, attrs, destination, bindings, directive) {
                        var changes, removeWatchCollection = [],
                            initialChanges = {};

                        function recordChanges(key, currentValue, previousValue) {
                            isFunction(destination.$onChanges) && !simpleCompare(currentValue, previousValue) && (onChangesQueue || (scope.$$postDigest(flushOnChangesQueue), onChangesQueue = []), changes || (changes = {}, onChangesQueue.push(triggerOnChangesHook)), changes[key] && (previousValue = changes[key].previousValue), changes[key] = new SimpleChange(previousValue, currentValue))
                        }

                        function triggerOnChangesHook() {
                            destination.$onChanges(changes), changes = void 0
                        }
                        return forEach(bindings, (function(definition, scopeName) {
                            var lastValue, parentGet, parentSet, compare, removeWatch, attrName = definition.attrName,
                                optional = definition.optional;
                            switch (definition.mode) {
                                case "@":
                                    optional || hasOwnProperty.call(attrs, attrName) || (strictBindingsCheck(attrName, directive.name), destination[scopeName] = attrs[attrName] = void 0), removeWatch = attrs.$observe(attrName, (function(value) {
                                        if (isString(value) || isBoolean(value)) {
                                            var oldValue = destination[scopeName];
                                            recordChanges(scopeName, value, oldValue), destination[scopeName] = value
                                        }
                                    })), attrs.$$observers[attrName].$$scope = scope, isString(lastValue = attrs[attrName]) ? destination[scopeName] = $interpolate(lastValue)(scope) : isBoolean(lastValue) && (destination[scopeName] = lastValue), initialChanges[scopeName] = new SimpleChange(_UNINITIALIZED_VALUE, destination[scopeName]), removeWatchCollection.push(removeWatch);
                                    break;
                                case "=":
                                    if (!hasOwnProperty.call(attrs, attrName)) {
                                        if (optional) break;
                                        strictBindingsCheck(attrName, directive.name), attrs[attrName] = void 0
                                    }
                                    if (optional && !attrs[attrName]) break;
                                    parentGet = $parse(attrs[attrName]), compare = parentGet.literal ? equals : simpleCompare, parentSet = parentGet.assign || function() {
                                        throw lastValue = destination[scopeName] = parentGet(scope), $compileMinErr("nonassign", "Expression '{0}' in attribute '{1}' used with directive '{2}' is non-assignable!", attrs[attrName], attrName, directive.name)
                                    }, lastValue = destination[scopeName] = parentGet(scope);
                                    var parentValueWatch = function(parentValue) {
                                        return compare(parentValue, destination[scopeName]) || (compare(parentValue, lastValue) ? parentSet(scope, parentValue = destination[scopeName]) : destination[scopeName] = parentValue), lastValue = parentValue
                                    };
                                    parentValueWatch.$stateful = !0, removeWatch = definition.collection ? scope.$watchCollection(attrs[attrName], parentValueWatch) : scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal), removeWatchCollection.push(removeWatch);
                                    break;
                                case "<":
                                    if (!hasOwnProperty.call(attrs, attrName)) {
                                        if (optional) break;
                                        strictBindingsCheck(attrName, directive.name), attrs[attrName] = void 0
                                    }
                                    if (optional && !attrs[attrName]) break;
                                    var isLiteral = (parentGet = $parse(attrs[attrName])).literal,
                                        initialValue = destination[scopeName] = parentGet(scope);
                                    initialChanges[scopeName] = new SimpleChange(_UNINITIALIZED_VALUE, destination[scopeName]), removeWatch = scope[definition.collection ? "$watchCollection" : "$watch"](parentGet, (function(newValue, oldValue) {
                                        if (oldValue === newValue) {
                                            if (oldValue === initialValue || isLiteral && equals(oldValue, initialValue)) return;
                                            oldValue = initialValue
                                        }
                                        recordChanges(scopeName, newValue, oldValue), destination[scopeName] = newValue
                                    })), removeWatchCollection.push(removeWatch);
                                    break;
                                case "&":
                                    if (optional || hasOwnProperty.call(attrs, attrName) || strictBindingsCheck(attrName, directive.name), (parentGet = attrs.hasOwnProperty(attrName) ? $parse(attrs[attrName]) : noop) === noop && optional) break;
                                    destination[scopeName] = function(locals) {
                                        return parentGet(scope, locals)
                                    }
                            }
                        })), {
                            initialChanges: initialChanges,
                            removeWatches: removeWatchCollection.length && function() {
                                for (var i = 0, ii = removeWatchCollection.length; i < ii; ++i) removeWatchCollection[i]()
                            }
                        }
                    }
                }]
        }

        function SimpleChange(previous, current) {
            this.previousValue = previous, this.currentValue = current
        }
        $CompileProvider.$inject = ["$provide", "$$sanitizeUriProvider"], SimpleChange.prototype.isFirstChange = function() {
            return this.previousValue === _UNINITIALIZED_VALUE
        };
        var PREFIX_REGEXP = /^((?:x|data)[:\-_])/i,
            SPECIAL_CHARS_REGEXP = /[:\-_]+(.)/g;

        function directiveNormalize(name) {
            return name.replace(PREFIX_REGEXP, "").replace(SPECIAL_CHARS_REGEXP, (function(_, letter, offset) {
                return offset ? letter.toUpperCase() : letter
            }))
        }

        function tokenDifference(str1, str2) {
            var values = "",
                tokens1 = str1.split(/\s+/),
                tokens2 = str2.split(/\s+/);
            outer: for (var i = 0; i < tokens1.length; i++) {
                for (var token = tokens1[i], j = 0; j < tokens2.length; j++)
                    if (token === tokens2[j]) continue outer;
                values += (values.length > 0 ? " " : "") + token
            }
            return values
        }

        function removeComments(jqNodes) {
            var i = (jqNodes = jqLite(jqNodes)).length;
            if (i <= 1) return jqNodes;
            for (; i--;) {
                var node = jqNodes[i];
                (8 === node.nodeType || node.nodeType === NODE_TYPE_TEXT && "" === node.nodeValue.trim()) && splice.call(jqNodes, i, 1)
            }
            return jqNodes
        }
        var $controllerMinErr = minErr("$controller"),
            CNTRL_REG = /^(\S+)(\s+as\s+([\w$]+))?$/;

        function identifierForController(controller, ident) {
            if (ident && isString(ident)) return ident;
            if (isString(controller)) {
                var match = CNTRL_REG.exec(controller);
                if (match) return match[3]
            }
        }

        function $ControllerProvider() {
            var controllers = {};
            this.has = function(name) {
                return controllers.hasOwnProperty(name)
            }, this.register = function(name, constructor) {
                assertNotHasOwnProperty(name, "controller"), isObject(name) ? extend(controllers, name) : controllers[name] = constructor
            }, this.$get = ["$injector", function($injector) {
                return function(expression, locals, later, ident) {
                    var instance, match, constructor, identifier;
                    if (later = !0 === later, ident && isString(ident) && (identifier = ident), isString(expression)) {
                        if (!(match = expression.match(CNTRL_REG))) throw $controllerMinErr("ctrlfmt", "Badly formed controller string '{0}'. Must match `__name__ as __id__` or `__name__`.", expression);
                        if (constructor = match[1], identifier = identifier || match[3], !(expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : function(obj, path, bindFnToScope) {
                                if (!path) return obj;
                                for (var key, keys = path.split("."), lastInstance = obj, len = keys.length, i = 0; i < len; i++) key = keys[i], obj && (obj = (lastInstance = obj)[key]);
                                return !bindFnToScope && isFunction(obj) ? bind(lastInstance, obj) : obj
                            }(locals.$scope, constructor, !0))) throw $controllerMinErr("ctrlreg", "The controller with the name '{0}' is not registered.", constructor);
                        assertArgFn(expression, constructor, !0)
                    }
                    if (later) {
                        var controllerPrototype = (isArray(expression) ? expression[expression.length - 1] : expression).prototype;
                        return instance = Object.create(controllerPrototype || null), identifier && addIdentifier(locals, identifier, instance, constructor || expression.name), extend((function() {
                            var result = $injector.invoke(expression, instance, locals, constructor);
                            return result !== instance && (isObject(result) || isFunction(result)) && (instance = result, identifier && addIdentifier(locals, identifier, instance, constructor || expression.name)), instance
                        }), {
                            instance: instance,
                            identifier: identifier
                        })
                    }
                    return instance = $injector.instantiate(expression, locals, constructor), identifier && addIdentifier(locals, identifier, instance, constructor || expression.name), instance
                };

                function addIdentifier(locals, identifier, instance, name) {
                    if (!locals || !isObject(locals.$scope)) throw minErr("$controller")("noscp", "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.", name, identifier);
                    locals.$scope[identifier] = instance
                }
            }]
        }

        function $DocumentProvider() {
            this.$get = ["$window", function(window) {
                return jqLite(window.document)
            }]
        }

        function $$IsDocumentHiddenProvider() {
            this.$get = ["$document", "$rootScope", function($document, $rootScope) {
                var doc = $document[0],
                    hidden = doc && doc.hidden;

                function changeListener() {
                    hidden = doc.hidden
                }
                return $document.on("visibilitychange", changeListener), $rootScope.$on("$destroy", (function() {
                        $document.off("visibilitychange", changeListener)
                    })),
                    function() {
                        return hidden
                    }
            }]
        }

        function $ExceptionHandlerProvider() {
            this.$get = ["$log", function($log) {
                return function(exception, cause) {
                    $log.error.apply($log, arguments)
                }
            }]
        }
        var $$ForceReflowProvider = function() {
                this.$get = ["$document", function($document) {
                    return function(domNode) {
                        return domNode ? !domNode.nodeType && domNode instanceof jqLite && (domNode = domNode[0]) : domNode = $document[0].body, domNode.offsetWidth + 1
                    }
                }]
            },
            CONTENT_TYPE_APPLICATION_JSON = {
                "Content-Type": "application/json;charset=utf-8"
            },
            JSON_START = /^\[|^\{(?!\{)/,
            JSON_ENDS = {
                "[": /]$/,
                "{": /}$/
            },
            JSON_PROTECTION_PREFIX = /^\)]\}',?\n/,
            $httpMinErr = minErr("$http");

        function serializeValue(v) {
            return isObject(v) ? isDate(v) ? v.toISOString() : toJson(v) : v
        }

        function $HttpParamSerializerProvider() {
            this.$get = function() {
                return function(params) {
                    if (!params) return "";
                    var parts = [];
                    return forEachSorted(params, (function(value, key) {
                        null === value || isUndefined(value) || isFunction(value) || (isArray(value) ? forEach(value, (function(v) {
                            parts.push(encodeUriQuery(key) + "=" + encodeUriQuery(serializeValue(v)))
                        })) : parts.push(encodeUriQuery(key) + "=" + encodeUriQuery(serializeValue(value))))
                    })), parts.join("&")
                }
            }
        }

        function $HttpParamSerializerJQLikeProvider() {
            this.$get = function() {
                return function(params) {
                    if (!params) return "";
                    var parts = [];
                    return function serialize(toSerialize, prefix, topLevel) {
                        isArray(toSerialize) ? forEach(toSerialize, (function(value, index) {
                            serialize(value, prefix + "[" + (isObject(value) ? index : "") + "]")
                        })) : isObject(toSerialize) && !isDate(toSerialize) ? forEachSorted(toSerialize, (function(value, key) {
                            serialize(value, prefix + (topLevel ? "" : "[") + key + (topLevel ? "" : "]"))
                        })) : (isFunction(toSerialize) && (toSerialize = toSerialize()), parts.push(encodeUriQuery(prefix) + "=" + (null == toSerialize ? "" : encodeUriQuery(serializeValue(toSerialize)))))
                    }(params, "", !0), parts.join("&")
                }
            }
        }

        function defaultHttpResponseTransform(data, headers) {
            if (isString(data)) {
                var tempData = data.replace(JSON_PROTECTION_PREFIX, "").trim();
                if (tempData) {
                    var contentType = headers("Content-Type"),
                        hasJsonContentType = contentType && 0 === contentType.indexOf("application/json");
                    if (hasJsonContentType || (jsonStart = (str = tempData).match(JSON_START)) && JSON_ENDS[jsonStart[0]].test(str)) try {
                        data = fromJson(tempData)
                    } catch (e) {
                        if (!hasJsonContentType) return data;
                        throw $httpMinErr("baddata", 'Data must be a valid JSON object. Received: "{0}". Parse error: "{1}"', data, e)
                    }
                }
            }
            var str, jsonStart;
            return data
        }

        function parseHeaders(headers) {
            var i, parsed = createMap();

            function fillInParsed(key, val) {
                key && (parsed[key] = parsed[key] ? parsed[key] + ", " + val : val)
            }
            return isString(headers) ? forEach(headers.split("\n"), (function(line) {
                i = line.indexOf(":"), fillInParsed(lowercase(trim(line.substr(0, i))), trim(line.substr(i + 1)))
            })) : isObject(headers) && forEach(headers, (function(headerVal, headerKey) {
                fillInParsed(lowercase(headerKey), trim(headerVal))
            })), parsed
        }

        function headersGetter(headers) {
            var headersObj;
            return function(name) {
                if (headersObj || (headersObj = parseHeaders(headers)), name) {
                    var value = headersObj[lowercase(name)];
                    return void 0 === value && (value = null), value
                }
                return headersObj
            }
        }

        function transformData(data, headers, status, fns) {
            return isFunction(fns) ? fns(data, headers, status) : (forEach(fns, (function(fn) {
                data = fn(data, headers, status)
            })), data)
        }

        function isSuccess(status) {
            return 200 <= status && status < 300
        }

        function $HttpProvider() {
            var defaults = this.defaults = {
                    transformResponse: [defaultHttpResponseTransform],
                    transformRequest: [function(d) {
                        return !isObject(d) || (obj = d, "[object File]" === toString.call(obj)) || function(obj) {
                            return "[object Blob]" === toString.call(obj)
                        }(d) || function(obj) {
                            return "[object FormData]" === toString.call(obj)
                        }(d) ? d : toJson(d);
                        var obj
                    }],
                    headers: {
                        common: {
                            Accept: "application/json, text/plain, */*"
                        },
                        post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                        put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                        patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
                    },
                    xsrfCookieName: "XSRF-TOKEN",
                    xsrfHeaderName: "X-XSRF-TOKEN",
                    paramSerializer: "$httpParamSerializer",
                    jsonpCallbackParam: "callback"
                },
                useApplyAsync = !1;
            this.useApplyAsync = function(value) {
                return isDefined(value) ? (useApplyAsync = !!value, this) : useApplyAsync
            };
            var interceptorFactories = this.interceptors = [],
                xsrfTrustedOrigins = this.xsrfTrustedOrigins = [];
            Object.defineProperty(this, "xsrfWhitelistedOrigins", {
                get: function() {
                    return this.xsrfTrustedOrigins
                },
                set: function(origins) {
                    this.xsrfTrustedOrigins = origins
                }
            }), this.$get = ["$browser", "$httpBackend", "$$cookieReader", "$cacheFactory", "$rootScope", "$q", "$injector", "$sce", function($browser, $httpBackend, $$cookieReader, $cacheFactory, $rootScope, $q, $injector, $sce) {
                var defaultCache = $cacheFactory("$http");
                defaults.paramSerializer = isString(defaults.paramSerializer) ? $injector.get(defaults.paramSerializer) : defaults.paramSerializer;
                var reversedInterceptors = [];
                forEach(interceptorFactories, (function(interceptorFactory) {
                    reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory))
                }));
                var parsedAllowedOriginUrls, urlIsAllowedOrigin = (parsedAllowedOriginUrls = [originUrl].concat(xsrfTrustedOrigins.map(urlResolve)), function(requestUrl) {
                    var parsedUrl = urlResolve(requestUrl);
                    return parsedAllowedOriginUrls.some(urlsAreSameOrigin.bind(null, parsedUrl))
                });

                function $http(requestConfig) {
                    if (!isObject(requestConfig)) throw minErr("$http")("badreq", "Http request configuration must be an object.  Received: {0}", requestConfig);
                    if (!isString($sce.valueOf(requestConfig.url))) throw minErr("$http")("badreq", "Http request configuration url must be a string or a $sce trusted object.  Received: {0}", requestConfig.url);
                    var config = extend({
                        method: "get",
                        transformRequest: defaults.transformRequest,
                        transformResponse: defaults.transformResponse,
                        paramSerializer: defaults.paramSerializer,
                        jsonpCallbackParam: defaults.jsonpCallbackParam
                    }, requestConfig);
                    config.headers = function(config) {
                        var defHeaderName, lowercaseDefHeaderName, reqHeaderName, defHeaders = defaults.headers,
                            reqHeaders = extend({}, config.headers);
                        defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
                        defaultHeadersIteration: for (defHeaderName in defHeaders) {
                            for (reqHeaderName in lowercaseDefHeaderName = lowercase(defHeaderName), reqHeaders)
                                if (lowercase(reqHeaderName) === lowercaseDefHeaderName) continue defaultHeadersIteration;
                            reqHeaders[defHeaderName] = defHeaders[defHeaderName]
                        }
                        return function(headers, config) {
                            var headerContent, processedHeaders = {};
                            return forEach(headers, (function(headerFn, header) {
                                isFunction(headerFn) ? null != (headerContent = headerFn(config)) && (processedHeaders[header] = headerContent) : processedHeaders[header] = headerFn
                            })), processedHeaders
                        }(reqHeaders, shallowCopy(config))
                    }(requestConfig), config.method = uppercase(config.method), config.paramSerializer = isString(config.paramSerializer) ? $injector.get(config.paramSerializer) : config.paramSerializer, $browser.$$incOutstandingRequestCount("$http");
                    var requestInterceptors = [],
                        responseInterceptors = [],
                        promise = $q.resolve(config);
                    return forEach(reversedInterceptors, (function(interceptor) {
                        (interceptor.request || interceptor.requestError) && requestInterceptors.unshift(interceptor.request, interceptor.requestError), (interceptor.response || interceptor.responseError) && responseInterceptors.push(interceptor.response, interceptor.responseError)
                    })), promise = chainInterceptors(promise, requestInterceptors), promise = (promise = chainInterceptors(promise = promise.then((function(config) {
                        var headers = config.headers,
                            reqData = transformData(config.data, headersGetter(headers), void 0, config.transformRequest);
                        isUndefined(reqData) && forEach(headers, (function(value, header) {
                            "content-type" === lowercase(header) && delete headers[header]
                        }));
                        isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials) && (config.withCredentials = defaults.withCredentials);
                        return function(config, reqData) {
                            var cache, cachedResp, deferred = $q.defer(),
                                promise = deferred.promise,
                                reqHeaders = config.headers,
                                isJsonp = "jsonp" === lowercase(config.method),
                                url = config.url;
                            isJsonp ? url = $sce.getTrustedResourceUrl(url) : isString(url) || (url = $sce.valueOf(url));
                            url = function(url, serializedParams) {
                                serializedParams.length > 0 && (url += (-1 === url.indexOf("?") ? "?" : "&") + serializedParams);
                                return url
                            }(url, config.paramSerializer(config.params)), isJsonp && (url = function(url, cbKey) {
                                var parts = url.split("?");
                                if (parts.length > 2) throw $httpMinErr("badjsonp", 'Illegal use more than one "?", in url, "{1}"', url);
                                return forEach(parseKeyValue(parts[1]), (function(value, key) {
                                    if ("JSON_CALLBACK" === value) throw $httpMinErr("badjsonp", 'Illegal use of JSON_CALLBACK in url, "{0}"', url);
                                    if (key === cbKey) throw $httpMinErr("badjsonp", 'Illegal use of callback param, "{0}", in url, "{1}"', cbKey, url)
                                })), url += (-1 === url.indexOf("?") ? "?" : "&") + cbKey + "=JSON_CALLBACK"
                            }(url, config.jsonpCallbackParam));
                            $http.pendingRequests.push(config), promise.then(removePendingReq, removePendingReq), !config.cache && !defaults.cache || !1 === config.cache || "GET" !== config.method && "JSONP" !== config.method || (cache = isObject(config.cache) ? config.cache : isObject(defaults.cache) ? defaults.cache : defaultCache);
                            cache && (isDefined(cachedResp = cache.get(url)) ? isPromiseLike(cachedResp) ? cachedResp.then(resolvePromiseWithResult, resolvePromiseWithResult) : isArray(cachedResp) ? resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3], cachedResp[4]) : resolvePromise(cachedResp, 200, {}, "OK", "complete") : cache.put(url, promise));
                            if (isUndefined(cachedResp)) {
                                var xsrfValue = urlIsAllowedOrigin(config.url) ? $$cookieReader()[config.xsrfCookieName || defaults.xsrfCookieName] : void 0;
                                xsrfValue && (reqHeaders[config.xsrfHeaderName || defaults.xsrfHeaderName] = xsrfValue), $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials, config.responseType, createApplyHandlers(config.eventHandlers), createApplyHandlers(config.uploadEventHandlers))
                            }
                            return promise;

                            function createApplyHandlers(eventHandlers) {
                                if (eventHandlers) {
                                    var applyHandlers = {};
                                    return forEach(eventHandlers, (function(eventHandler, key) {
                                        applyHandlers[key] = function(event) {
                                            function callEventHandler() {
                                                eventHandler(event)
                                            }
                                            useApplyAsync ? $rootScope.$applyAsync(callEventHandler) : $rootScope.$$phase ? callEventHandler() : $rootScope.$apply(callEventHandler)
                                        }
                                    })), applyHandlers
                                }
                            }

                            function done(status, response, headersString, statusText, xhrStatus) {
                                function resolveHttpPromise() {
                                    resolvePromise(response, status, headersString, statusText, xhrStatus)
                                }
                                cache && (isSuccess(status) ? cache.put(url, [status, response, parseHeaders(headersString), statusText, xhrStatus]) : cache.remove(url)), useApplyAsync ? $rootScope.$applyAsync(resolveHttpPromise) : (resolveHttpPromise(), $rootScope.$$phase || $rootScope.$apply())
                            }

                            function resolvePromise(response, status, headers, statusText, xhrStatus) {
                                (isSuccess(status = status >= -1 ? status : 0) ? deferred.resolve : deferred.reject)({
                                    data: response,
                                    status: status,
                                    headers: headersGetter(headers),
                                    config: config,
                                    statusText: statusText,
                                    xhrStatus: xhrStatus
                                })
                            }

                            function resolvePromiseWithResult(result) {
                                resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText, result.xhrStatus)
                            }

                            function removePendingReq() {
                                var idx = $http.pendingRequests.indexOf(config); - 1 !== idx && $http.pendingRequests.splice(idx, 1)
                            }
                        }(config, reqData).then(transformResponse, transformResponse)
                    })), responseInterceptors)).finally((function() {
                        $browser.$$completeOutstandingRequest(noop, "$http")
                    }));

                    function chainInterceptors(promise, interceptors) {
                        for (var i = 0, ii = interceptors.length; i < ii;) {
                            var thenFn = interceptors[i++],
                                rejectFn = interceptors[i++];
                            promise = promise.then(thenFn, rejectFn)
                        }
                        return interceptors.length = 0, promise
                    }

                    function transformResponse(response) {
                        var resp = extend({}, response);
                        return resp.data = transformData(response.data, response.headers, response.status, config.transformResponse), isSuccess(response.status) ? resp : $q.reject(resp)
                    }
                }
                return $http.pendingRequests = [],
                    function(names) {
                        forEach(arguments, (function(name) {
                            $http[name] = function(url, config) {
                                return $http(extend({}, config || {}, {
                                    method: name,
                                    url: url
                                }))
                            }
                        }))
                    }("get", "delete", "head", "jsonp"),
                    function(name) {
                        forEach(arguments, (function(name) {
                            $http[name] = function(url, data, config) {
                                return $http(extend({}, config || {}, {
                                    method: name,
                                    url: url,
                                    data: data
                                }))
                            }
                        }))
                    }("post", "put", "patch"), $http.defaults = defaults, $http
            }]
        }

        function $xhrFactoryProvider() {
            this.$get = function() {
                return function() {
                    return new window.XMLHttpRequest
                }
            }
        }

        function $HttpBackendProvider() {
            this.$get = ["$browser", "$jsonpCallbacks", "$document", "$xhrFactory", function($browser, $jsonpCallbacks, $document, $xhrFactory) {
                return function($browser, createXhr, $browserDefer, callbacks, rawDocument) {
                    return function(method, url, post, callback, headers, timeout, withCredentials, responseType, eventHandlers, uploadEventHandlers) {
                        if (url = url || $browser.url(), "jsonp" === lowercase(method)) var callbackPath = callbacks.createCallback(url),
                            jsonpDone = jsonpReq(url, callbackPath, (function(status, text) {
                                var response = 200 === status && callbacks.getResponse(callbackPath);
                                completeRequest(callback, status, response, "", text, "complete"), callbacks.removeCallback(callbackPath)
                            }));
                        else {
                            var xhr = createXhr(method, url),
                                abortedByTimeout = !1;
                            xhr.open(method, url, !0), forEach(headers, (function(value, key) {
                                isDefined(value) && xhr.setRequestHeader(key, value)
                            })), xhr.onload = function() {
                                var statusText = xhr.statusText || "",
                                    response = "response" in xhr ? xhr.response : xhr.responseText,
                                    status = 1223 === xhr.status ? 204 : xhr.status;
                                0 === status && (status = response ? 200 : "file" === urlResolve(url).protocol ? 404 : 0), completeRequest(callback, status, response, xhr.getAllResponseHeaders(), statusText, "complete")
                            };
                            var requestError = function() {
                                    completeRequest(callback, -1, null, null, "", "error")
                                },
                                requestAborted = function() {
                                    completeRequest(callback, -1, null, null, "", abortedByTimeout ? "timeout" : "abort")
                                },
                                requestTimeout = function() {
                                    completeRequest(callback, -1, null, null, "", "timeout")
                                };
                            if (xhr.onerror = requestError, xhr.ontimeout = requestTimeout, xhr.onabort = requestAborted, forEach(eventHandlers, (function(value, key) {
                                    xhr.addEventListener(key, value)
                                })), forEach(uploadEventHandlers, (function(value, key) {
                                    xhr.upload.addEventListener(key, value)
                                })), withCredentials && (xhr.withCredentials = !0), responseType) try {
                                xhr.responseType = responseType
                            } catch (e) {
                                if ("json" !== responseType) throw e
                            }
                            xhr.send(isUndefined(post) ? null : post)
                        }
                        if (timeout > 0) var timeoutId = $browserDefer((function() {
                            timeoutRequest("timeout")
                        }), timeout);
                        else isPromiseLike(timeout) && timeout.then((function() {
                            timeoutRequest(isDefined(timeout.$$timeoutId) ? "timeout" : "abort")
                        }));

                        function timeoutRequest(reason) {
                            abortedByTimeout = "timeout" === reason, jsonpDone && jsonpDone(), xhr && xhr.abort()
                        }

                        function completeRequest(callback, status, response, headersString, statusText, xhrStatus) {
                            isDefined(timeoutId) && $browserDefer.cancel(timeoutId), jsonpDone = xhr = null, callback(status, response, headersString, statusText, xhrStatus)
                        }
                    };

                    function jsonpReq(url, callbackPath, done) {
                        url = url.replace("JSON_CALLBACK", callbackPath);
                        var script = rawDocument.createElement("script"),
                            callback = null;
                        return script.type = "text/javascript", script.src = url, script.async = !0, callback = function(event) {
                            script.removeEventListener("load", callback), script.removeEventListener("error", callback), rawDocument.body.removeChild(script), script = null;
                            var status = -1,
                                text = "unknown";
                            event && ("load" !== event.type || callbacks.wasCalled(callbackPath) || (event = {
                                type: "error"
                            }), text = event.type, status = "error" === event.type ? 404 : 200), done && done(status, text)
                        }, script.addEventListener("load", callback), script.addEventListener("error", callback), rawDocument.body.appendChild(script), callback
                    }
                }($browser, $xhrFactory, $browser.defer, $jsonpCallbacks, $document[0])
            }]
        }
        var $interpolateMinErr = angular.$interpolateMinErr = minErr("$interpolate");

        function $InterpolateProvider() {
            var startSymbol = "{{",
                endSymbol = "}}";
            this.startSymbol = function(value) {
                return value ? (startSymbol = value, this) : startSymbol
            }, this.endSymbol = function(value) {
                return value ? (endSymbol = value, this) : endSymbol
            }, this.$get = ["$parse", "$exceptionHandler", "$sce", function($parse, $exceptionHandler, $sce) {
                var startSymbolLength = startSymbol.length,
                    endSymbolLength = endSymbol.length,
                    escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), "g"),
                    escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), "g");

                function escape(ch) {
                    return "\\\\\\" + ch
                }

                function unescapeText(text) {
                    return text.replace(escapedStartRegexp, startSymbol).replace(escapedEndRegexp, endSymbol)
                }

                function constantWatchDelegate(scope, listener, objectEquality, constantInterp) {
                    var unwatch = scope.$watch((function(scope) {
                        return unwatch(), constantInterp(scope)
                    }), listener, objectEquality);
                    return unwatch
                }

                function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {
                    var contextAllowsConcatenation = trustedContext === $sce.URL || trustedContext === $sce.MEDIA_URL;
                    if (!text.length || -1 === text.indexOf(startSymbol)) {
                        if (mustHaveExpression) return;
                        var unescapedText = unescapeText(text);
                        contextAllowsConcatenation && (unescapedText = $sce.getTrusted(trustedContext, unescapedText));
                        var constantInterp = valueFn(unescapedText);
                        return constantInterp.exp = text, constantInterp.expressions = [], constantInterp.$$watchDelegate = constantWatchDelegate, constantInterp
                    }
                    allOrNothing = !!allOrNothing;
                    for (var startIndex, endIndex, parseFns, exp, singleExpression, index = 0, expressions = [], textLength = text.length, concat = [], expressionPositions = []; index < textLength;) {
                        if (-1 === (startIndex = text.indexOf(startSymbol, index)) || -1 === (endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength))) {
                            index !== textLength && concat.push(unescapeText(text.substring(index)));
                            break
                        }
                        index !== startIndex && concat.push(unescapeText(text.substring(index, startIndex))), exp = text.substring(startIndex + startSymbolLength, endIndex), expressions.push(exp), index = endIndex + endSymbolLength, expressionPositions.push(concat.length), concat.push("")
                    }
                    singleExpression = 1 === concat.length && 1 === expressionPositions.length;
                    var interceptor = contextAllowsConcatenation && singleExpression ? void 0 : function(value) {
                        try {
                            return value = trustedContext && !contextAllowsConcatenation ? $sce.getTrusted(trustedContext, value) : $sce.valueOf(value), allOrNothing && !isDefined(value) ? value : stringify(value)
                        } catch (err) {
                            $exceptionHandler($interpolateMinErr.interr(text, err))
                        }
                    };
                    if (parseFns = expressions.map((function(exp) {
                            return $parse(exp, interceptor)
                        })), !mustHaveExpression || expressions.length) {
                        var compute = function(values) {
                            for (var i = 0, ii = expressions.length; i < ii; i++) {
                                if (allOrNothing && isUndefined(values[i])) return;
                                concat[expressionPositions[i]] = values[i]
                            }
                            return contextAllowsConcatenation ? $sce.getTrusted(trustedContext, singleExpression ? concat[0] : concat.join("")) : (trustedContext && concat.length > 1 && $interpolateMinErr.throwNoconcat(text), concat.join(""))
                        };
                        return extend((function(context) {
                            var i = 0,
                                ii = expressions.length,
                                values = new Array(ii);
                            try {
                                for (; i < ii; i++) values[i] = parseFns[i](context);
                                return compute(values)
                            } catch (err) {
                                $exceptionHandler($interpolateMinErr.interr(text, err))
                            }
                        }), {
                            exp: text,
                            expressions: expressions,
                            $$watchDelegate: function(scope, listener) {
                                var lastValue;
                                return scope.$watchGroup(parseFns, (function(values, oldValues) {
                                    var currValue = compute(values);
                                    listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope), lastValue = currValue
                                }))
                            }
                        })
                    }
                }
                return $interpolate.startSymbol = function() {
                    return startSymbol
                }, $interpolate.endSymbol = function() {
                    return endSymbol
                }, $interpolate
            }]
        }
        $interpolateMinErr.throwNoconcat = function(text) {
            throw $interpolateMinErr("noconcat", "Error while interpolating: {0}\nStrict Contextual Escaping disallows interpolations that concatenate multiple expressions when a trusted value is required.  See http://docs.angularjs.org/api/ng.$sce", text)
        }, $interpolateMinErr.interr = function(text, err) {
            return $interpolateMinErr("interr", "Can't interpolate: {0}\n{1}", text, err.toString())
        };
        var $intervalMinErr = minErr("$interval");

        function $IntervalProvider() {
            this.$get = ["$$intervalFactory", "$window", function($$intervalFactory, $window) {
                var intervals = {},
                    clearIntervalFn = function(id) {
                        $window.clearInterval(id), delete intervals[id]
                    },
                    interval = $$intervalFactory((function(tick, delay, deferred) {
                        var id = $window.setInterval(tick, delay);
                        return intervals[id] = deferred, id
                    }), clearIntervalFn);
                return interval.cancel = function(promise) {
                    if (!promise) return !1;
                    if (!promise.hasOwnProperty("$$intervalId")) throw $intervalMinErr("badprom", "`$interval.cancel()` called with a promise that was not generated by `$interval()`.");
                    if (!intervals.hasOwnProperty(promise.$$intervalId)) return !1;
                    var id = promise.$$intervalId,
                        deferred = intervals[id];
                    return markQExceptionHandled(deferred.promise), deferred.reject("canceled"), clearIntervalFn(id), !0
                }, interval
            }]
        }

        function $$IntervalFactoryProvider() {
            this.$get = ["$browser", "$q", "$$q", "$rootScope", function($browser, $q, $$q, $rootScope) {
                return function(setIntervalFn, clearIntervalFn) {
                    return function(fn, delay, count, invokeApply) {
                        var hasParams = arguments.length > 4,
                            args = hasParams ? sliceArgs(arguments, 4) : [],
                            iteration = 0,
                            skipApply = isDefined(invokeApply) && !invokeApply,
                            deferred = (skipApply ? $$q : $q).defer(),
                            promise = deferred.promise;

                        function callback() {
                            hasParams ? fn.apply(null, args) : fn(iteration)
                        }

                        function tick() {
                            skipApply ? $browser.defer(callback) : $rootScope.$evalAsync(callback), deferred.notify(iteration++), count > 0 && iteration >= count && (deferred.resolve(iteration), clearIntervalFn(promise.$$intervalId)), skipApply || $rootScope.$apply()
                        }
                        return count = isDefined(count) ? count : 0, promise.$$intervalId = setIntervalFn(tick, delay, deferred, skipApply), promise
                    }
                }
            }]
        }
        var $jsonpCallbacksProvider = function() {
                this.$get = function() {
                    var callbacks = angular.callbacks,
                        callbackMap = {};
                    return {
                        createCallback: function(url) {
                            var callbackId = "_" + (callbacks.$$counter++).toString(36),
                                callbackPath = "angular.callbacks." + callbackId,
                                callback = function(callbackId) {
                                    var callback = function(data) {
                                        callback.data = data, callback.called = !0
                                    };
                                    return callback.id = callbackId, callback
                                }(callbackId);
                            return callbackMap[callbackPath] = callbacks[callbackId] = callback, callbackPath
                        },
                        wasCalled: function(callbackPath) {
                            return callbackMap[callbackPath].called
                        },
                        getResponse: function(callbackPath) {
                            return callbackMap[callbackPath].data
                        },
                        removeCallback: function(callbackPath) {
                            var callback = callbackMap[callbackPath];
                            delete callbacks[callback.id], delete callbackMap[callbackPath]
                        }
                    }
                }
            },
            PATH_MATCH = /^([^?#]*)(\?([^#]*))?(#(.*))?$/,
            DEFAULT_PORTS = {
                http: 80,
                https: 443,
                ftp: 21
            },
            $locationMinErr = minErr("$location");

        function normalizePath(pathValue, searchValue, hashValue) {
            var parts, search = (parts = [], forEach(searchValue, (function(value, key) {
                    isArray(value) ? forEach(value, (function(arrayValue) {
                        parts.push(encodeUriQuery(key, !0) + (!0 === arrayValue ? "" : "=" + encodeUriQuery(arrayValue, !0)))
                    })) : parts.push(encodeUriQuery(key, !0) + (!0 === value ? "" : "=" + encodeUriQuery(value, !0)))
                })), parts.length ? parts.join("&") : ""),
                hash = hashValue ? "#" + encodeUriSegment(hashValue) : "";
            return function(path) {
                for (var segments = path.split("/"), i = segments.length; i--;) segments[i] = encodeUriSegment(segments[i].replace(/%2F/g, "/"));
                return segments.join("/")
            }(pathValue) + (search ? "?" + search : "") + hash
        }

        function parseAbsoluteUrl(absoluteUrl, locationObj) {
            var parsedUrl = urlResolve(absoluteUrl);
            locationObj.$$protocol = parsedUrl.protocol, locationObj.$$host = parsedUrl.hostname, locationObj.$$port = toInt(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null
        }
        var DOUBLE_SLASH_REGEX = /^\s*[\\/]{2,}/;

        function parseAppUrl(url, locationObj, html5Mode) {
            if (DOUBLE_SLASH_REGEX.test(url)) throw $locationMinErr("badpath", 'Invalid url "{0}".', url);
            var prefixed = "/" !== url.charAt(0);
            prefixed && (url = "/" + url);
            var match = urlResolve(url),
                path = prefixed && "/" === match.pathname.charAt(0) ? match.pathname.substring(1) : match.pathname;
            locationObj.$$path = function(path, html5Mode) {
                for (var segments = path.split("/"), i = segments.length; i--;) segments[i] = decodeURIComponent(segments[i]), html5Mode && (segments[i] = segments[i].replace(/\//g, "%2F"));
                return segments.join("/")
            }(path, html5Mode), locationObj.$$search = parseKeyValue(match.search), locationObj.$$hash = decodeURIComponent(match.hash), locationObj.$$path && "/" !== locationObj.$$path.charAt(0) && (locationObj.$$path = "/" + locationObj.$$path)
        }

        function startsWith(str, search) {
            return str.slice(0, search.length) === search
        }

        function stripBaseUrl(base, url) {
            if (startsWith(url, base)) return url.substr(base.length)
        }

        function stripHash(url) {
            var index = url.indexOf("#");
            return -1 === index ? url : url.substr(0, index)
        }

        function LocationHtml5Url(appBase, appBaseNoFile, basePrefix) {
            this.$$html5 = !0, basePrefix = basePrefix || "", parseAbsoluteUrl(appBase, this), this.$$parse = function(url) {
                var pathUrl = stripBaseUrl(appBaseNoFile, url);
                if (!isString(pathUrl)) throw $locationMinErr("ipthprfx", 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
                parseAppUrl(pathUrl, this, !0), this.$$path || (this.$$path = "/"), this.$$compose()
            }, this.$$normalizeUrl = function(url) {
                return appBaseNoFile + url.substr(1)
            }, this.$$parseLinkUrl = function(url, relHref) {
                return relHref && "#" === relHref[0] ? (this.hash(relHref.slice(1)), !0) : (isDefined(appUrl = stripBaseUrl(appBase, url)) ? (prevAppUrl = appUrl, rewrittenUrl = basePrefix && isDefined(appUrl = stripBaseUrl(basePrefix, appUrl)) ? appBaseNoFile + (stripBaseUrl("/", appUrl) || appUrl) : appBase + prevAppUrl) : isDefined(appUrl = stripBaseUrl(appBaseNoFile, url)) ? rewrittenUrl = appBaseNoFile + appUrl : appBaseNoFile === url + "/" && (rewrittenUrl = appBaseNoFile), rewrittenUrl && this.$$parse(rewrittenUrl), !!rewrittenUrl);
                var appUrl, prevAppUrl, rewrittenUrl
            }
        }

        function LocationHashbangUrl(appBase, appBaseNoFile, hashPrefix) {
            parseAbsoluteUrl(appBase, this), this.$$parse = function(url) {
                var withoutHashUrl, withoutBaseUrl = stripBaseUrl(appBase, url) || stripBaseUrl(appBaseNoFile, url);
                isUndefined(withoutBaseUrl) || "#" !== withoutBaseUrl.charAt(0) ? this.$$html5 ? withoutHashUrl = withoutBaseUrl : (withoutHashUrl = "", isUndefined(withoutBaseUrl) && (appBase = url, this.replace())) : isUndefined(withoutHashUrl = stripBaseUrl(hashPrefix, withoutBaseUrl)) && (withoutHashUrl = withoutBaseUrl), parseAppUrl(withoutHashUrl, this, !1), this.$$path = function(path, url, base) {
                    var firstPathSegmentMatch, windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
                    startsWith(url, base) && (url = url.replace(base, ""));
                    if (windowsFilePathExp.exec(url)) return path;
                    return (firstPathSegmentMatch = windowsFilePathExp.exec(path)) ? firstPathSegmentMatch[1] : path
                }(this.$$path, withoutHashUrl, appBase), this.$$compose()
            }, this.$$normalizeUrl = function(url) {
                return appBase + (url ? hashPrefix + url : "")
            }, this.$$parseLinkUrl = function(url, relHref) {
                return stripHash(appBase) === stripHash(url) && (this.$$parse(url), !0)
            }
        }

        function LocationHashbangInHtml5Url(appBase, appBaseNoFile, hashPrefix) {
            this.$$html5 = !0, LocationHashbangUrl.apply(this, arguments), this.$$parseLinkUrl = function(url, relHref) {
                return relHref && "#" === relHref[0] ? (this.hash(relHref.slice(1)), !0) : (appBase === stripHash(url) ? rewrittenUrl = url : (appUrl = stripBaseUrl(appBaseNoFile, url)) ? rewrittenUrl = appBase + hashPrefix + appUrl : appBaseNoFile === url + "/" && (rewrittenUrl = appBaseNoFile), rewrittenUrl && this.$$parse(rewrittenUrl), !!rewrittenUrl);
                var rewrittenUrl, appUrl
            }, this.$$normalizeUrl = function(url) {
                return appBase + hashPrefix + url
            }
        }
        var locationPrototype = {
            $$absUrl: "",
            $$html5: !1,
            $$replace: !1,
            $$compose: function() {
                this.$$url = normalizePath(this.$$path, this.$$search, this.$$hash), this.$$absUrl = this.$$normalizeUrl(this.$$url), this.$$urlUpdatedByLocation = !0
            },
            absUrl: locationGetter("$$absUrl"),
            url: function(url) {
                if (isUndefined(url)) return this.$$url;
                var match = PATH_MATCH.exec(url);
                return (match[1] || "" === url) && this.path(decodeURIComponent(match[1])), (match[2] || match[1] || "" === url) && this.search(match[3] || ""), this.hash(match[5] || ""), this
            },
            protocol: locationGetter("$$protocol"),
            host: locationGetter("$$host"),
            port: locationGetter("$$port"),
            path: locationGetterSetter("$$path", (function(path) {
                return "/" === (path = null !== path ? path.toString() : "").charAt(0) ? path : "/" + path
            })),
            search: function(search, paramValue) {
                switch (arguments.length) {
                    case 0:
                        return this.$$search;
                    case 1:
                        if (isString(search) || isNumber(search)) search = search.toString(), this.$$search = parseKeyValue(search);
                        else {
                            if (!isObject(search)) throw $locationMinErr("isrcharg", "The first argument of the `$location#search()` call must be a string or an object.");
                            forEach(search = copy(search, {}), (function(value, key) {
                                null == value && delete search[key]
                            })), this.$$search = search
                        }
                        break;
                    default:
                        isUndefined(paramValue) || null === paramValue ? delete this.$$search[search] : this.$$search[search] = paramValue
                }
                return this.$$compose(), this
            },
            hash: locationGetterSetter("$$hash", (function(hash) {
                return null !== hash ? hash.toString() : ""
            })),
            replace: function() {
                return this.$$replace = !0, this
            }
        };

        function locationGetter(property) {
            return function() {
                return this[property]
            }
        }

        function locationGetterSetter(property, preprocess) {
            return function(value) {
                return isUndefined(value) ? this[property] : (this[property] = preprocess(value), this.$$compose(), this)
            }
        }

        function $LocationProvider() {
            var hashPrefix = "!",
                html5Mode = {
                    enabled: !1,
                    requireBase: !0,
                    rewriteLinks: !0
                };
            this.hashPrefix = function(prefix) {
                return isDefined(prefix) ? (hashPrefix = prefix, this) : hashPrefix
            }, this.html5Mode = function(mode) {
                return isBoolean(mode) ? (html5Mode.enabled = mode, this) : isObject(mode) ? (isBoolean(mode.enabled) && (html5Mode.enabled = mode.enabled), isBoolean(mode.requireBase) && (html5Mode.requireBase = mode.requireBase), (isBoolean(mode.rewriteLinks) || isString(mode.rewriteLinks)) && (html5Mode.rewriteLinks = mode.rewriteLinks), this) : html5Mode
            }, this.$get = ["$rootScope", "$browser", "$sniffer", "$rootElement", "$window", function($rootScope, $browser, $sniffer, $rootElement, $window) {
                var $location, LocationMode, appBase, url, baseHref = $browser.baseHref(),
                    initialUrl = $browser.url();
                if (html5Mode.enabled) {
                    if (!baseHref && html5Mode.requireBase) throw $locationMinErr("nobase", "$location in HTML5 mode requires a <base> tag to be present!");
                    appBase = (url = initialUrl).substring(0, url.indexOf("/", url.indexOf("//") + 2)) + (baseHref || "/"), LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url
                } else appBase = stripHash(initialUrl), LocationMode = LocationHashbangUrl;
                var appBaseNoFile = function(url) {
                    return url.substr(0, stripHash(url).lastIndexOf("/") + 1)
                }(appBase);
                ($location = new LocationMode(appBase, appBaseNoFile, "#" + hashPrefix)).$$parseLinkUrl(initialUrl, initialUrl), $location.$$state = $browser.state();
                var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;

                function setBrowserUrlWithFallback(url, replace, state) {
                    var oldUrl = $location.url(),
                        oldState = $location.$$state;
                    try {
                        $browser.url(url, replace, state), $location.$$state = $browser.state()
                    } catch (e) {
                        throw $location.url(oldUrl), $location.$$state = oldState, e
                    }
                }
                $rootElement.on("click", (function(event) {
                    var rewriteLinks = html5Mode.rewriteLinks;
                    if (rewriteLinks && !event.ctrlKey && !event.metaKey && !event.shiftKey && 2 !== event.which && 2 !== event.button) {
                        for (var elm = jqLite(event.target);
                            "a" !== nodeName_(elm[0]);)
                            if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0]) return;
                        if (!isString(rewriteLinks) || !isUndefined(elm.attr(rewriteLinks))) {
                            var absHref = elm.prop("href"),
                                relHref = elm.attr("href") || elm.attr("xlink:href");
                            isObject(absHref) && "[object SVGAnimatedString]" === absHref.toString() && (absHref = urlResolve(absHref.animVal).href), IGNORE_URI_REGEXP.test(absHref) || !absHref || elm.attr("target") || event.isDefaultPrevented() || $location.$$parseLinkUrl(absHref, relHref) && (event.preventDefault(), $location.absUrl() !== $browser.url() && $rootScope.$apply())
                        }
                    }
                })), $location.absUrl() !== initialUrl && $browser.url($location.absUrl(), !0);
                var initializing = !0;
                return $browser.onUrlChange((function(newUrl, newState) {
                    startsWith(newUrl, appBaseNoFile) ? ($rootScope.$evalAsync((function() {
                        var defaultPrevented, oldUrl = $location.absUrl(),
                            oldState = $location.$$state;
                        $location.$$parse(newUrl), $location.$$state = newState, defaultPrevented = $rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl, newState, oldState).defaultPrevented, $location.absUrl() === newUrl && (defaultPrevented ? ($location.$$parse(oldUrl), $location.$$state = oldState, setBrowserUrlWithFallback(oldUrl, !1, oldState)) : (initializing = !1, afterLocationChange(oldUrl, oldState)))
                    })), $rootScope.$$phase || $rootScope.$digest()) : $window.location.href = newUrl
                })), $rootScope.$watch((function() {
                    if (initializing || $location.$$urlUpdatedByLocation) {
                        $location.$$urlUpdatedByLocation = !1;
                        var oldUrl = $browser.url(),
                            newUrl = $location.absUrl(),
                            oldState = $browser.state(),
                            currentReplace = $location.$$replace,
                            urlOrStateChanged = !((a = oldUrl) === (b = newUrl) || urlResolve(a).href === urlResolve(b).href) || $location.$$html5 && $sniffer.history && oldState !== $location.$$state;
                        (initializing || urlOrStateChanged) && (initializing = !1, $rootScope.$evalAsync((function() {
                            var newUrl = $location.absUrl(),
                                defaultPrevented = $rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl, $location.$$state, oldState).defaultPrevented;
                            $location.absUrl() === newUrl && (defaultPrevented ? ($location.$$parse(oldUrl), $location.$$state = oldState) : (urlOrStateChanged && setBrowserUrlWithFallback(newUrl, currentReplace, oldState === $location.$$state ? null : $location.$$state), afterLocationChange(oldUrl, oldState)))
                        })))
                    }
                    var a, b;
                    $location.$$replace = !1
                })), $location;

                function afterLocationChange(oldUrl, oldState) {
                    $rootScope.$broadcast("$locationChangeSuccess", $location.absUrl(), oldUrl, $location.$$state, oldState)
                }
            }]
        }

        function $LogProvider() {
            var debug = !0,
                self = this;
            this.debugEnabled = function(flag) {
                return isDefined(flag) ? (debug = flag, this) : debug
            }, this.$get = ["$window", function($window) {
                var fn, formatStackTrace = msie || /\bEdge\//.test($window.navigator && $window.navigator.userAgent);
                return {
                    log: consoleLog("log"),
                    info: consoleLog("info"),
                    warn: consoleLog("warn"),
                    error: consoleLog("error"),
                    debug: (fn = consoleLog("debug"), function() {
                        debug && fn.apply(self, arguments)
                    })
                };

                function formatError(arg) {
                    return isError(arg) && (arg.stack && formatStackTrace ? arg = arg.message && -1 === arg.stack.indexOf(arg.message) ? "Error: " + arg.message + "\n" + arg.stack : arg.stack : arg.sourceURL && (arg = arg.message + "\n" + arg.sourceURL + ":" + arg.line)), arg
                }

                function consoleLog(type) {
                    var console = $window.console || {},
                        logFn = console[type] || console.log || noop;
                    return function() {
                        var args = [];
                        return forEach(arguments, (function(arg) {
                            args.push(formatError(arg))
                        })), Function.prototype.apply.call(logFn, console, args)
                    }
                }
            }]
        }
        forEach([LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url], (function(Location) {
            Location.prototype = Object.create(locationPrototype), Location.prototype.state = function(state) {
                if (!arguments.length) return this.$$state;
                if (Location !== LocationHtml5Url || !this.$$html5) throw $locationMinErr("nostate", "History API state support is available only in HTML5 mode and only in browsers supporting HTML5 History API");
                return this.$$state = isUndefined(state) ? null : state, this.$$urlUpdatedByLocation = !0, this
            }
        }));
        var $parseMinErr = minErr("$parse"),
            objectValueOf = {}.constructor.prototype.valueOf;

        function getStringValue(name) {
            return name + ""
        }
        var OPERATORS = createMap();
        forEach("+ - * / % === !== == != < > <= >= && || ! = |".split(" "), (function(operator) {
            OPERATORS[operator] = !0
        }));
        var ESCAPE = {
                n: "\n",
                f: "\f",
                r: "\r",
                t: "\t",
                v: "\v",
                "'": "'",
                '"': '"'
            },
            Lexer = function(options) {
                this.options = options
            };
        Lexer.prototype = {
            constructor: Lexer,
            lex: function(text) {
                for (this.text = text, this.index = 0, this.tokens = []; this.index < this.text.length;) {
                    var ch = this.text.charAt(this.index);
                    if ('"' === ch || "'" === ch) this.readString(ch);
                    else if (this.isNumber(ch) || "." === ch && this.isNumber(this.peek())) this.readNumber();
                    else if (this.isIdentifierStart(this.peekMultichar())) this.readIdent();
                    else if (this.is(ch, "(){}[].,;:?")) this.tokens.push({
                        index: this.index,
                        text: ch
                    }), this.index++;
                    else if (this.isWhitespace(ch)) this.index++;
                    else {
                        var ch2 = ch + this.peek(),
                            ch3 = ch2 + this.peek(2),
                            op1 = OPERATORS[ch],
                            op2 = OPERATORS[ch2],
                            op3 = OPERATORS[ch3];
                        if (op1 || op2 || op3) {
                            var token = op3 ? ch3 : op2 ? ch2 : ch;
                            this.tokens.push({
                                index: this.index,
                                text: token,
                                operator: !0
                            }), this.index += token.length
                        } else this.throwError("Unexpected next character ", this.index, this.index + 1)
                    }
                }
                return this.tokens
            },
            is: function(ch, chars) {
                return -1 !== chars.indexOf(ch)
            },
            peek: function(i) {
                var num = i || 1;
                return this.index + num < this.text.length && this.text.charAt(this.index + num)
            },
            isNumber: function(ch) {
                return "0" <= ch && ch <= "9" && "string" == typeof ch
            },
            isWhitespace: function(ch) {
                return " " === ch || "\r" === ch || "\t" === ch || "\n" === ch || "\v" === ch || " " === ch
            },
            isIdentifierStart: function(ch) {
                return this.options.isIdentifierStart ? this.options.isIdentifierStart(ch, this.codePointAt(ch)) : this.isValidIdentifierStart(ch)
            },
            isValidIdentifierStart: function(ch) {
                return "a" <= ch && ch <= "z" || "A" <= ch && ch <= "Z" || "_" === ch || "$" === ch
            },
            isIdentifierContinue: function(ch) {
                return this.options.isIdentifierContinue ? this.options.isIdentifierContinue(ch, this.codePointAt(ch)) : this.isValidIdentifierContinue(ch)
            },
            isValidIdentifierContinue: function(ch, cp) {
                return this.isValidIdentifierStart(ch, cp) || this.isNumber(ch)
            },
            codePointAt: function(ch) {
                return 1 === ch.length ? ch.charCodeAt(0) : (ch.charCodeAt(0) << 10) + ch.charCodeAt(1) - 56613888
            },
            peekMultichar: function() {
                var ch = this.text.charAt(this.index),
                    peek = this.peek();
                if (!peek) return ch;
                var cp1 = ch.charCodeAt(0),
                    cp2 = peek.charCodeAt(0);
                return cp1 >= 55296 && cp1 <= 56319 && cp2 >= 56320 && cp2 <= 57343 ? ch + peek : ch
            },
            isExpOperator: function(ch) {
                return "-" === ch || "+" === ch || this.isNumber(ch)
            },
            throwError: function(error, start, end) {
                end = end || this.index;
                var colStr = isDefined(start) ? "s " + start + "-" + this.index + " [" + this.text.substring(start, end) + "]" : " " + end;
                throw $parseMinErr("lexerr", "Lexer Error: {0} at column{1} in expression [{2}].", error, colStr, this.text)
            },
            readNumber: function() {
                for (var number = "", start = this.index; this.index < this.text.length;) {
                    var ch = lowercase(this.text.charAt(this.index));
                    if ("." === ch || this.isNumber(ch)) number += ch;
                    else {
                        var peekCh = this.peek();
                        if ("e" === ch && this.isExpOperator(peekCh)) number += ch;
                        else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && "e" === number.charAt(number.length - 1)) number += ch;
                        else {
                            if (!this.isExpOperator(ch) || peekCh && this.isNumber(peekCh) || "e" !== number.charAt(number.length - 1)) break;
                            this.throwError("Invalid exponent")
                        }
                    }
                    this.index++
                }
                this.tokens.push({
                    index: start,
                    text: number,
                    constant: !0,
                    value: Number(number)
                })
            },
            readIdent: function() {
                var start = this.index;
                for (this.index += this.peekMultichar().length; this.index < this.text.length;) {
                    var ch = this.peekMultichar();
                    if (!this.isIdentifierContinue(ch)) break;
                    this.index += ch.length
                }
                this.tokens.push({
                    index: start,
                    text: this.text.slice(start, this.index),
                    identifier: !0
                })
            },
            readString: function(quote) {
                var start = this.index;
                this.index++;
                for (var string = "", rawString = quote, escape = !1; this.index < this.text.length;) {
                    var ch = this.text.charAt(this.index);
                    if (rawString += ch, escape) {
                        if ("u" === ch) {
                            var hex = this.text.substring(this.index + 1, this.index + 5);
                            hex.match(/[\da-f]{4}/i) || this.throwError("Invalid unicode escape [\\u" + hex + "]"), this.index += 4, string += String.fromCharCode(parseInt(hex, 16))
                        } else {
                            string += ESCAPE[ch] || ch
                        }
                        escape = !1
                    } else if ("\\" === ch) escape = !0;
                    else {
                        if (ch === quote) return this.index++, void this.tokens.push({
                            index: start,
                            text: rawString,
                            constant: !0,
                            value: string
                        });
                        string += ch
                    }
                    this.index++
                }
                this.throwError("Unterminated quote", start)
            }
        };
        var AST = function(lexer, options) {
            this.lexer = lexer, this.options = options
        };

        function ifDefined(v, d) {
            return void 0 !== v ? v : d
        }

        function plusFn(l, r) {
            return void 0 === l ? r : void 0 === r ? l : l + r
        }
        AST.Program = "Program", AST.ExpressionStatement = "ExpressionStatement", AST.AssignmentExpression = "AssignmentExpression", AST.ConditionalExpression = "ConditionalExpression", AST.LogicalExpression = "LogicalExpression", AST.BinaryExpression = "BinaryExpression", AST.UnaryExpression = "UnaryExpression", AST.CallExpression = "CallExpression", AST.MemberExpression = "MemberExpression", AST.Identifier = "Identifier", AST.Literal = "Literal", AST.ArrayExpression = "ArrayExpression", AST.Property = "Property", AST.ObjectExpression = "ObjectExpression", AST.ThisExpression = "ThisExpression", AST.LocalsExpression = "LocalsExpression", AST.NGValueParameter = "NGValueParameter", AST.prototype = {
            ast: function(text) {
                this.text = text, this.tokens = this.lexer.lex(text);
                var value = this.program();
                return 0 !== this.tokens.length && this.throwError("is an unexpected token", this.tokens[0]), value
            },
            program: function() {
                for (var body = [];;)
                    if (this.tokens.length > 0 && !this.peek("}", ")", ";", "]") && body.push(this.expressionStatement()), !this.expect(";")) return {
                        type: AST.Program,
                        body: body
                    }
            },
            expressionStatement: function() {
                return {
                    type: AST.ExpressionStatement,
                    expression: this.filterChain()
                }
            },
            filterChain: function() {
                for (var left = this.expression(); this.expect("|");) left = this.filter(left);
                return left
            },
            expression: function() {
                return this.assignment()
            },
            assignment: function() {
                var result = this.ternary();
                if (this.expect("=")) {
                    if (!isAssignable(result)) throw $parseMinErr("lval", "Trying to assign a value to a non l-value");
                    result = {
                        type: AST.AssignmentExpression,
                        left: result,
                        right: this.assignment(),
                        operator: "="
                    }
                }
                return result
            },
            ternary: function() {
                var alternate, consequent, test = this.logicalOR();
                return this.expect("?") && (alternate = this.expression(), this.consume(":")) ? (consequent = this.expression(), {
                    type: AST.ConditionalExpression,
                    test: test,
                    alternate: alternate,
                    consequent: consequent
                }) : test
            },
            logicalOR: function() {
                for (var left = this.logicalAND(); this.expect("||");) left = {
                    type: AST.LogicalExpression,
                    operator: "||",
                    left: left,
                    right: this.logicalAND()
                };
                return left
            },
            logicalAND: function() {
                for (var left = this.equality(); this.expect("&&");) left = {
                    type: AST.LogicalExpression,
                    operator: "&&",
                    left: left,
                    right: this.equality()
                };
                return left
            },
            equality: function() {
                for (var token, left = this.relational(); token = this.expect("==", "!=", "===", "!==");) left = {
                    type: AST.BinaryExpression,
                    operator: token.text,
                    left: left,
                    right: this.relational()
                };
                return left
            },
            relational: function() {
                for (var token, left = this.additive(); token = this.expect("<", ">", "<=", ">=");) left = {
                    type: AST.BinaryExpression,
                    operator: token.text,
                    left: left,
                    right: this.additive()
                };
                return left
            },
            additive: function() {
                for (var token, left = this.multiplicative(); token = this.expect("+", "-");) left = {
                    type: AST.BinaryExpression,
                    operator: token.text,
                    left: left,
                    right: this.multiplicative()
                };
                return left
            },
            multiplicative: function() {
                for (var token, left = this.unary(); token = this.expect("*", "/", "%");) left = {
                    type: AST.BinaryExpression,
                    operator: token.text,
                    left: left,
                    right: this.unary()
                };
                return left
            },
            unary: function() {
                var token;
                return (token = this.expect("+", "-", "!")) ? {
                    type: AST.UnaryExpression,
                    operator: token.text,
                    prefix: !0,
                    argument: this.unary()
                } : this.primary()
            },
            primary: function() {
                var primary, next;
                for (this.expect("(") ? (primary = this.filterChain(), this.consume(")")) : this.expect("[") ? primary = this.arrayDeclaration() : this.expect("{") ? primary = this.object() : this.selfReferential.hasOwnProperty(this.peek().text) ? primary = copy(this.selfReferential[this.consume().text]) : this.options.literals.hasOwnProperty(this.peek().text) ? primary = {
                        type: AST.Literal,
                        value: this.options.literals[this.consume().text]
                    } : this.peek().identifier ? primary = this.identifier() : this.peek().constant ? primary = this.constant() : this.throwError("not a primary expression", this.peek()); next = this.expect("(", "[", ".");) "(" === next.text ? (primary = {
                    type: AST.CallExpression,
                    callee: primary,
                    arguments: this.parseArguments()
                }, this.consume(")")) : "[" === next.text ? (primary = {
                    type: AST.MemberExpression,
                    object: primary,
                    property: this.expression(),
                    computed: !0
                }, this.consume("]")) : "." === next.text ? primary = {
                    type: AST.MemberExpression,
                    object: primary,
                    property: this.identifier(),
                    computed: !1
                } : this.throwError("IMPOSSIBLE");
                return primary
            },
            filter: function(baseExpression) {
                for (var args = [baseExpression], result = {
                        type: AST.CallExpression,
                        callee: this.identifier(),
                        arguments: args,
                        filter: !0
                    }; this.expect(":");) args.push(this.expression());
                return result
            },
            parseArguments: function() {
                var args = [];
                if (")" !== this.peekToken().text)
                    do {
                        args.push(this.filterChain())
                    } while (this.expect(","));
                return args
            },
            identifier: function() {
                var token = this.consume();
                return token.identifier || this.throwError("is not a valid identifier", token), {
                    type: AST.Identifier,
                    name: token.text
                }
            },
            constant: function() {
                return {
                    type: AST.Literal,
                    value: this.consume().value
                }
            },
            arrayDeclaration: function() {
                var elements = [];
                if ("]" !== this.peekToken().text)
                    do {
                        if (this.peek("]")) break;
                        elements.push(this.expression())
                    } while (this.expect(","));
                return this.consume("]"), {
                    type: AST.ArrayExpression,
                    elements: elements
                }
            },
            object: function() {
                var property, properties = [];
                if ("}" !== this.peekToken().text)
                    do {
                        if (this.peek("}")) break;
                        property = {
                            type: AST.Property,
                            kind: "init"
                        }, this.peek().constant ? (property.key = this.constant(), property.computed = !1, this.consume(":"), property.value = this.expression()) : this.peek().identifier ? (property.key = this.identifier(), property.computed = !1, this.peek(":") ? (this.consume(":"), property.value = this.expression()) : property.value = property.key) : this.peek("[") ? (this.consume("["), property.key = this.expression(), this.consume("]"), property.computed = !0, this.consume(":"), property.value = this.expression()) : this.throwError("invalid key", this.peek()), properties.push(property)
                    } while (this.expect(","));
                return this.consume("}"), {
                    type: AST.ObjectExpression,
                    properties: properties
                }
            },
            throwError: function(msg, token) {
                throw $parseMinErr("syntax", "Syntax Error: Token '{0}' {1} at column {2} of the expression [{3}] starting at [{4}].", token.text, msg, token.index + 1, this.text, this.text.substring(token.index))
            },
            consume: function(e1) {
                if (0 === this.tokens.length) throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
                var token = this.expect(e1);
                return token || this.throwError("is unexpected, expecting [" + e1 + "]", this.peek()), token
            },
            peekToken: function() {
                if (0 === this.tokens.length) throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
                return this.tokens[0]
            },
            peek: function(e1, e2, e3, e4) {
                return this.peekAhead(0, e1, e2, e3, e4)
            },
            peekAhead: function(i, e1, e2, e3, e4) {
                if (this.tokens.length > i) {
                    var token = this.tokens[i],
                        t = token.text;
                    if (t === e1 || t === e2 || t === e3 || t === e4 || !e1 && !e2 && !e3 && !e4) return token
                }
                return !1
            },
            expect: function(e1, e2, e3, e4) {
                var token = this.peek(e1, e2, e3, e4);
                return !!token && (this.tokens.shift(), token)
            },
            selfReferential: {
                this: {
                    type: AST.ThisExpression
                },
                $locals: {
                    type: AST.LocalsExpression
                }
            }
        };

        function findConstantAndWatchExpressions(ast, $filter, parentIsPure) {
            var allConstants, argsToWatch, isStatelessFilter, astIsPure = ast.isPure = function(node, parentIsPure) {
                switch (node.type) {
                    case AST.MemberExpression:
                        if (node.computed) return !1;
                        break;
                    case AST.UnaryExpression:
                        return 1;
                    case AST.BinaryExpression:
                        return "+" !== node.operator && 1;
                    case AST.CallExpression:
                        return !1
                }
                return void 0 === parentIsPure ? 2 : parentIsPure
            }(ast, parentIsPure);
            switch (ast.type) {
                case AST.Program:
                    allConstants = !0, forEach(ast.body, (function(expr) {
                        findConstantAndWatchExpressions(expr.expression, $filter, astIsPure), allConstants = allConstants && expr.expression.constant
                    })), ast.constant = allConstants;
                    break;
                case AST.Literal:
                    ast.constant = !0, ast.toWatch = [];
                    break;
                case AST.UnaryExpression:
                    findConstantAndWatchExpressions(ast.argument, $filter, astIsPure), ast.constant = ast.argument.constant, ast.toWatch = ast.argument.toWatch;
                    break;
                case AST.BinaryExpression:
                    findConstantAndWatchExpressions(ast.left, $filter, astIsPure), findConstantAndWatchExpressions(ast.right, $filter, astIsPure), ast.constant = ast.left.constant && ast.right.constant, ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);
                    break;
                case AST.LogicalExpression:
                    findConstantAndWatchExpressions(ast.left, $filter, astIsPure), findConstantAndWatchExpressions(ast.right, $filter, astIsPure), ast.constant = ast.left.constant && ast.right.constant, ast.toWatch = ast.constant ? [] : [ast];
                    break;
                case AST.ConditionalExpression:
                    findConstantAndWatchExpressions(ast.test, $filter, astIsPure), findConstantAndWatchExpressions(ast.alternate, $filter, astIsPure), findConstantAndWatchExpressions(ast.consequent, $filter, astIsPure), ast.constant = ast.test.constant && ast.alternate.constant && ast.consequent.constant, ast.toWatch = ast.constant ? [] : [ast];
                    break;
                case AST.Identifier:
                    ast.constant = !1, ast.toWatch = [ast];
                    break;
                case AST.MemberExpression:
                    findConstantAndWatchExpressions(ast.object, $filter, astIsPure), ast.computed && findConstantAndWatchExpressions(ast.property, $filter, astIsPure), ast.constant = ast.object.constant && (!ast.computed || ast.property.constant), ast.toWatch = ast.constant ? [] : [ast];
                    break;
                case AST.CallExpression:
                    isStatelessFilter = !!ast.filter && function($filter, filterName) {
                        return !$filter(filterName).$stateful
                    }($filter, ast.callee.name), allConstants = isStatelessFilter, argsToWatch = [], forEach(ast.arguments, (function(expr) {
                        findConstantAndWatchExpressions(expr, $filter, astIsPure), allConstants = allConstants && expr.constant, argsToWatch.push.apply(argsToWatch, expr.toWatch)
                    })), ast.constant = allConstants, ast.toWatch = isStatelessFilter ? argsToWatch : [ast];
                    break;
                case AST.AssignmentExpression:
                    findConstantAndWatchExpressions(ast.left, $filter, astIsPure), findConstantAndWatchExpressions(ast.right, $filter, astIsPure), ast.constant = ast.left.constant && ast.right.constant, ast.toWatch = [ast];
                    break;
                case AST.ArrayExpression:
                    allConstants = !0, argsToWatch = [], forEach(ast.elements, (function(expr) {
                        findConstantAndWatchExpressions(expr, $filter, astIsPure), allConstants = allConstants && expr.constant, argsToWatch.push.apply(argsToWatch, expr.toWatch)
                    })), ast.constant = allConstants, ast.toWatch = argsToWatch;
                    break;
                case AST.ObjectExpression:
                    allConstants = !0, argsToWatch = [], forEach(ast.properties, (function(property) {
                        findConstantAndWatchExpressions(property.value, $filter, astIsPure), allConstants = allConstants && property.value.constant, argsToWatch.push.apply(argsToWatch, property.value.toWatch), property.computed && (findConstantAndWatchExpressions(property.key, $filter, !1), allConstants = allConstants && property.key.constant, argsToWatch.push.apply(argsToWatch, property.key.toWatch))
                    })), ast.constant = allConstants, ast.toWatch = argsToWatch;
                    break;
                case AST.ThisExpression:
                case AST.LocalsExpression:
                    ast.constant = !1, ast.toWatch = []
            }
        }

        function getInputs(body) {
            if (1 === body.length) {
                var lastExpression = body[0].expression,
                    candidate = lastExpression.toWatch;
                return 1 !== candidate.length || candidate[0] !== lastExpression ? candidate : void 0
            }
        }

        function isAssignable(ast) {
            return ast.type === AST.Identifier || ast.type === AST.MemberExpression
        }

        function assignableAST(ast) {
            if (1 === ast.body.length && isAssignable(ast.body[0].expression)) return {
                type: AST.AssignmentExpression,
                left: ast.body[0].expression,
                right: {
                    type: AST.NGValueParameter
                },
                operator: "="
            }
        }

        function ASTCompiler($filter) {
            this.$filter = $filter
        }

        function ASTInterpreter($filter) {
            this.$filter = $filter
        }

        function Parser(lexer, $filter, options) {
            this.ast = new AST(lexer, options), this.astCompiler = options.csp ? new ASTInterpreter($filter) : new ASTCompiler($filter)
        }

        function getValueOf(value) {
            return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value)
        }

        function $ParseProvider() {
            var identStart, identContinue, cache = createMap(),
                literals = {
                    true: !0,
                    false: !1,
                    null: null,
                    undefined: void 0
                };
            this.addLiteral = function(literalName, literalValue) {
                literals[literalName] = literalValue
            }, this.setIdentifierFns = function(identifierStart, identifierContinue) {
                return identStart = identifierStart, identContinue = identifierContinue, this
            }, this.$get = ["$filter", function($filter) {
                var $parseOptions = {
                    csp: csp().noUnsafeEval,
                    literals: copy(literals),
                    isIdentifierStart: isFunction(identStart) && identStart,
                    isIdentifierContinue: isFunction(identContinue) && identContinue
                };
                return $parse.$$getAst = function(exp) {
                    return new Parser(new Lexer($parseOptions), $filter, $parseOptions).getAst(exp).ast
                }, $parse;

                function $parse(exp, interceptorFn) {
                    var parsedExpression, cacheKey;
                    switch (typeof exp) {
                        case "string":
                            if (exp = exp.trim(), !(parsedExpression = cache[cacheKey = exp])) parsedExpression = new Parser(new Lexer($parseOptions), $filter, $parseOptions).parse(exp), cache[cacheKey] = addWatchDelegate(parsedExpression);
                            return addInterceptor(parsedExpression, interceptorFn);
                        case "function":
                            return addInterceptor(exp, interceptorFn);
                        default:
                            return addInterceptor(noop, interceptorFn)
                    }
                }

                function expressionInputDirtyCheck(newValue, oldValueOfValue, compareObjectIdentity) {
                    return null == newValue || null == oldValueOfValue ? newValue === oldValueOfValue : !("object" == typeof newValue && "object" == typeof(newValue = getValueOf(newValue)) && !compareObjectIdentity) && (newValue === oldValueOfValue || newValue != newValue && oldValueOfValue != oldValueOfValue)
                }

                function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
                    var lastResult, inputExpressions = parsedExpression.inputs;
                    if (1 === inputExpressions.length) {
                        var oldInputValueOf = expressionInputDirtyCheck;
                        return inputExpressions = inputExpressions[0], scope.$watch((function(scope) {
                            var newInputValue = inputExpressions(scope);
                            return expressionInputDirtyCheck(newInputValue, oldInputValueOf, inputExpressions.isPure) || (lastResult = parsedExpression(scope, void 0, void 0, [newInputValue]), oldInputValueOf = newInputValue && getValueOf(newInputValue)), lastResult
                        }), listener, objectEquality, prettyPrintExpression)
                    }
                    for (var oldInputValueOfValues = [], oldInputValues = [], i = 0, ii = inputExpressions.length; i < ii; i++) oldInputValueOfValues[i] = expressionInputDirtyCheck, oldInputValues[i] = null;
                    return scope.$watch((function(scope) {
                        for (var changed = !1, i = 0, ii = inputExpressions.length; i < ii; i++) {
                            var newInputValue = inputExpressions[i](scope);
                            (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i], inputExpressions[i].isPure))) && (oldInputValues[i] = newInputValue, oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue))
                        }
                        return changed && (lastResult = parsedExpression(scope, void 0, void 0, oldInputValues)), lastResult
                    }), listener, objectEquality, prettyPrintExpression)
                }

                function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
                    var unwatch, lastValue, isDone = parsedExpression.literal ? isAllDefined : isDefined,
                        exp = parsedExpression.$$intercepted || parsedExpression,
                        post = parsedExpression.$$interceptor || identity,
                        useInputs = parsedExpression.inputs && !exp.inputs;
                    return oneTimeWatch.literal = parsedExpression.literal, oneTimeWatch.constant = parsedExpression.constant, oneTimeWatch.inputs = parsedExpression.inputs, addWatchDelegate(oneTimeWatch), unwatch = scope.$watch(oneTimeWatch, listener, objectEquality, prettyPrintExpression);

                    function unwatchIfDone() {
                        isDone(lastValue) && unwatch()
                    }

                    function oneTimeWatch(scope, locals, assign, inputs) {
                        return lastValue = useInputs && inputs ? inputs[0] : exp(scope, locals, assign, inputs), isDone(lastValue) && scope.$$postDigest(unwatchIfDone), post(lastValue)
                    }
                }

                function isAllDefined(value) {
                    var allDefined = !0;
                    return forEach(value, (function(val) {
                        isDefined(val) || (allDefined = !1)
                    })), allDefined
                }

                function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                    var unwatch = scope.$watch((function(scope) {
                        return unwatch(), parsedExpression(scope)
                    }), listener, objectEquality);
                    return unwatch
                }

                function addWatchDelegate(parsedExpression) {
                    return parsedExpression.constant ? parsedExpression.$$watchDelegate = constantWatchDelegate : parsedExpression.oneTime ? parsedExpression.$$watchDelegate = oneTimeWatchDelegate : parsedExpression.inputs && (parsedExpression.$$watchDelegate = inputsWatchDelegate), parsedExpression
                }

                function addInterceptor(parsedExpression, interceptorFn) {
                    if (!interceptorFn) return parsedExpression;
                    parsedExpression.$$interceptor && (interceptorFn = function(first, second) {
                        function chainedInterceptor(value) {
                            return second(first(value))
                        }
                        return chainedInterceptor.$stateful = first.$stateful || second.$stateful, chainedInterceptor.$$pure = first.$$pure && second.$$pure, chainedInterceptor
                    }(parsedExpression.$$interceptor, interceptorFn), parsedExpression = parsedExpression.$$intercepted);
                    var useInputs = !1,
                        fn = function(scope, locals, assign, inputs) {
                            var value = useInputs && inputs ? inputs[0] : parsedExpression(scope, locals, assign, inputs);
                            return interceptorFn(value)
                        };
                    return fn.$$intercepted = parsedExpression, fn.$$interceptor = interceptorFn, fn.literal = parsedExpression.literal, fn.oneTime = parsedExpression.oneTime, fn.constant = parsedExpression.constant, interceptorFn.$stateful || (useInputs = !parsedExpression.inputs, fn.inputs = parsedExpression.inputs ? parsedExpression.inputs : [parsedExpression], interceptorFn.$$pure || (fn.inputs = fn.inputs.map((function(e) {
                        return 2 === e.isPure ? function(s) {
                            return e(s)
                        } : e
                    })))), addWatchDelegate(fn)
                }
            }]
        }

        function $QProvider() {
            var errorOnUnhandledRejections = !0;
            this.$get = ["$rootScope", "$exceptionHandler", function($rootScope, $exceptionHandler) {
                return qFactory((function(callback) {
                    $rootScope.$evalAsync(callback)
                }), $exceptionHandler, errorOnUnhandledRejections)
            }], this.errorOnUnhandledRejections = function(value) {
                return isDefined(value) ? (errorOnUnhandledRejections = value, this) : errorOnUnhandledRejections
            }
        }

        function $$QProvider() {
            var errorOnUnhandledRejections = !0;
            this.$get = ["$browser", "$exceptionHandler", function($browser, $exceptionHandler) {
                return qFactory((function(callback) {
                    $browser.defer(callback)
                }), $exceptionHandler, errorOnUnhandledRejections)
            }], this.errorOnUnhandledRejections = function(value) {
                return isDefined(value) ? (errorOnUnhandledRejections = value, this) : errorOnUnhandledRejections
            }
        }

        function qFactory(nextTick, exceptionHandler, errorOnUnhandledRejections) {
            var $qMinErr = minErr("$q", TypeError),
                queueSize = 0,
                checkQueue = [];

            function defer() {
                return new Deferred
            }

            function Deferred() {
                var promise = this.promise = new Promise;
                this.resolve = function(val) {
                    resolvePromise(promise, val)
                }, this.reject = function(reason) {
                    rejectPromise(promise, reason)
                }, this.notify = function(progress) {
                    notifyPromise(promise, progress)
                }
            }

            function Promise() {
                this.$$state = {
                    status: 0
                }
            }

            function processChecks() {
                for (; !queueSize && checkQueue.length;) {
                    var toCheck = checkQueue.shift();
                    if (!isStateExceptionHandled(toCheck)) {
                        markQStateExceptionHandled(toCheck);
                        var errorMessage = "Possibly unhandled rejection: " + toDebugString(toCheck.value);
                        isError(toCheck.value) ? exceptionHandler(toCheck.value, errorMessage) : exceptionHandler(errorMessage)
                    }
                }
            }

            function scheduleProcessQueue(state) {
                !errorOnUnhandledRejections || state.pending || 2 !== state.status || isStateExceptionHandled(state) || (0 === queueSize && 0 === checkQueue.length && nextTick(processChecks), checkQueue.push(state)), !state.processScheduled && state.pending && (state.processScheduled = !0, ++queueSize, nextTick((function() {
                    ! function(state) {
                        var fn, promise, pending;
                        pending = state.pending, state.processScheduled = !1, state.pending = void 0;
                        try {
                            for (var i = 0, ii = pending.length; i < ii; ++i) {
                                markQStateExceptionHandled(state), promise = pending[i][0], fn = pending[i][state.status];
                                try {
                                    isFunction(fn) ? resolvePromise(promise, fn(state.value)) : 1 === state.status ? resolvePromise(promise, state.value) : rejectPromise(promise, state.value)
                                } catch (e) {
                                    rejectPromise(promise, e), e && !0 === e.$$passToExceptionHandler && exceptionHandler(e)
                                }
                            }
                        } finally {
                            --queueSize, errorOnUnhandledRejections && 0 === queueSize && nextTick(processChecks)
                        }
                    }(state)
                })))
            }

            function resolvePromise(promise, val) {
                promise.$$state.status || (val === promise ? $$reject(promise, $qMinErr("qcycle", "Expected promise to be resolved with value other than itself '{0}'", val)) : $$resolve(promise, val))
            }

            function $$resolve(promise, val) {
                var then, done = !1;
                try {
                    (isObject(val) || isFunction(val)) && (then = val.then), isFunction(then) ? (promise.$$state.status = -1, then.call(val, (function(val) {
                        if (done) return;
                        done = !0, $$resolve(promise, val)
                    }), doReject, (function(progress) {
                        notifyPromise(promise, progress)
                    }))) : (promise.$$state.value = val, promise.$$state.status = 1, scheduleProcessQueue(promise.$$state))
                } catch (e) {
                    doReject(e)
                }

                function doReject(val) {
                    done || (done = !0, $$reject(promise, val))
                }
            }

            function rejectPromise(promise, reason) {
                promise.$$state.status || $$reject(promise, reason)
            }

            function $$reject(promise, reason) {
                promise.$$state.value = reason, promise.$$state.status = 2, scheduleProcessQueue(promise.$$state)
            }

            function notifyPromise(promise, progress) {
                var callbacks = promise.$$state.pending;
                promise.$$state.status <= 0 && callbacks && callbacks.length && nextTick((function() {
                    for (var callback, result, i = 0, ii = callbacks.length; i < ii; i++) {
                        result = callbacks[i][0], callback = callbacks[i][3];
                        try {
                            notifyPromise(result, isFunction(callback) ? callback(progress) : progress)
                        } catch (e) {
                            exceptionHandler(e)
                        }
                    }
                }))
            }

            function reject(reason) {
                var result = new Promise;
                return rejectPromise(result, reason), result
            }

            function handleCallback(value, resolver, callback) {
                var callbackOutput = null;
                try {
                    isFunction(callback) && (callbackOutput = callback())
                } catch (e) {
                    return reject(e)
                }
                return isPromiseLike(callbackOutput) ? callbackOutput.then((function() {
                    return resolver(value)
                }), reject) : resolver(value)
            }

            function when(value, callback, errback, progressBack) {
                var result = new Promise;
                return resolvePromise(result, value), result.then(callback, errback, progressBack)
            }
            extend(Promise.prototype, {
                then: function(onFulfilled, onRejected, progressBack) {
                    if (isUndefined(onFulfilled) && isUndefined(onRejected) && isUndefined(progressBack)) return this;
                    var result = new Promise;
                    return this.$$state.pending = this.$$state.pending || [], this.$$state.pending.push([result, onFulfilled, onRejected, progressBack]), this.$$state.status > 0 && scheduleProcessQueue(this.$$state), result
                },
                catch: function(callback) {
                    return this.then(null, callback)
                },
                finally: function(callback, progressBack) {
                    return this.then((function(value) {
                        return handleCallback(value, resolve, callback)
                    }), (function(error) {
                        return handleCallback(error, reject, callback)
                    }), progressBack)
                }
            });
            var resolve = when;

            function $Q(resolver) {
                if (!isFunction(resolver)) throw $qMinErr("norslvr", "Expected resolverFn, got '{0}'", resolver);
                var promise = new Promise;
                return resolver((function(value) {
                    resolvePromise(promise, value)
                }), (function(reason) {
                    rejectPromise(promise, reason)
                })), promise
            }
            return $Q.prototype = Promise.prototype, $Q.defer = defer, $Q.reject = reject, $Q.when = when, $Q.resolve = resolve, $Q.all = function(promises) {
                var result = new Promise,
                    counter = 0,
                    results = isArray(promises) ? [] : {};
                return forEach(promises, (function(promise, key) {
                    counter++, when(promise).then((function(value) {
                        results[key] = value, --counter || resolvePromise(result, results)
                    }), (function(reason) {
                        rejectPromise(result, reason)
                    }))
                })), 0 === counter && resolvePromise(result, results), result
            }, $Q.race = function(promises) {
                var deferred = defer();
                return forEach(promises, (function(promise) {
                    when(promise).then(deferred.resolve, deferred.reject)
                })), deferred.promise
            }, $Q
        }

        function isStateExceptionHandled(state) {
            return !!state.pur
        }

        function markQStateExceptionHandled(state) {
            state.pur = !0
        }

        function markQExceptionHandled(q) {
            q.$$state && markQStateExceptionHandled(q.$$state)
        }

        function $$RAFProvider() {
            this.$get = ["$window", "$timeout", function($window, $timeout) {
                var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame,
                    cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame,
                    rafSupported = !!requestAnimationFrame,
                    raf = rafSupported ? function(fn) {
                        var id = requestAnimationFrame(fn);
                        return function() {
                            cancelAnimationFrame(id)
                        }
                    } : function(fn) {
                        var timer = $timeout(fn, 16.66, !1);
                        return function() {
                            $timeout.cancel(timer)
                        }
                    };
                return raf.supported = rafSupported, raf
            }]
        }

        function $RootScopeProvider() {
            var TTL = 10,
                $rootScopeMinErr = minErr("$rootScope"),
                lastDirtyWatch = null,
                applyAsyncId = null;
            this.digestTtl = function(value) {
                return arguments.length && (TTL = value), TTL
            }, this.$get = ["$exceptionHandler", "$parse", "$browser", function($exceptionHandler, $parse, $browser) {
                function destroyChildScope($event) {
                    $event.currentScope.$$destroyed = !0
                }

                function cleanUpScope($scope) {
                    9 === msie && ($scope.$$childHead && cleanUpScope($scope.$$childHead), $scope.$$nextSibling && cleanUpScope($scope.$$nextSibling)), $scope.$parent = $scope.$$nextSibling = $scope.$$prevSibling = $scope.$$childHead = $scope.$$childTail = $scope.$root = $scope.$$watchers = null
                }

                function Scope() {
                    this.$id = nextUid(), this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null, this.$root = this, this.$$destroyed = !1, this.$$suspended = !1, this.$$listeners = {}, this.$$listenerCount = {}, this.$$watchersCount = 0, this.$$isolateBindings = null
                }
                Scope.prototype = {
                    constructor: Scope,
                    $new: function(isolate, parent) {
                        var child;
                        return parent = parent || this, isolate ? (child = new Scope).$root = this.$root : (this.$$ChildScope || (this.$$ChildScope = function(parent) {
                            function ChildScope() {
                                this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null, this.$$listeners = {}, this.$$listenerCount = {}, this.$$watchersCount = 0, this.$id = nextUid(), this.$$ChildScope = null, this.$$suspended = !1
                            }
                            return ChildScope.prototype = parent, ChildScope
                        }(this)), child = new this.$$ChildScope), child.$parent = parent, child.$$prevSibling = parent.$$childTail, parent.$$childHead ? (parent.$$childTail.$$nextSibling = child, parent.$$childTail = child) : parent.$$childHead = parent.$$childTail = child, (isolate || parent !== this) && child.$on("$destroy", destroyChildScope), child
                    },
                    $watch: function(watchExp, listener, objectEquality, prettyPrintExpression) {
                        var get = $parse(watchExp),
                            fn = isFunction(listener) ? listener : noop;
                        if (get.$$watchDelegate) return get.$$watchDelegate(this, fn, objectEquality, get, watchExp);
                        var scope = this,
                            array = scope.$$watchers,
                            watcher = {
                                fn: fn,
                                last: initWatchVal,
                                get: get,
                                exp: prettyPrintExpression || watchExp,
                                eq: !!objectEquality
                            };
                        return lastDirtyWatch = null, array || ((array = scope.$$watchers = []).$$digestWatchIndex = -1), array.unshift(watcher), array.$$digestWatchIndex++, incrementWatchersCount(this, 1),
                            function() {
                                var index = arrayRemove(array, watcher);
                                index >= 0 && (incrementWatchersCount(scope, -1), index < array.$$digestWatchIndex && array.$$digestWatchIndex--), lastDirtyWatch = null
                            }
                    },
                    $watchGroup: function(watchExpressions, listener) {
                        var oldValues = new Array(watchExpressions.length),
                            newValues = new Array(watchExpressions.length),
                            deregisterFns = [],
                            self = this,
                            changeReactionScheduled = !1,
                            firstRun = !0;
                        if (!watchExpressions.length) {
                            var shouldCall = !0;
                            return self.$evalAsync((function() {
                                    shouldCall && listener(newValues, newValues, self)
                                })),
                                function() {
                                    shouldCall = !1
                                }
                        }
                        if (1 === watchExpressions.length) return this.$watch(watchExpressions[0], (function(value, oldValue, scope) {
                            newValues[0] = value, oldValues[0] = oldValue, listener(newValues, value === oldValue ? newValues : oldValues, scope)
                        }));

                        function watchGroupAction() {
                            changeReactionScheduled = !1;
                            try {
                                firstRun ? (firstRun = !1, listener(newValues, newValues, self)) : listener(newValues, oldValues, self)
                            } finally {
                                for (var i = 0; i < watchExpressions.length; i++) oldValues[i] = newValues[i]
                            }
                        }
                        return forEach(watchExpressions, (function(expr, i) {
                                var unwatchFn = self.$watch(expr, (function(value) {
                                    newValues[i] = value, changeReactionScheduled || (changeReactionScheduled = !0, self.$evalAsync(watchGroupAction))
                                }));
                                deregisterFns.push(unwatchFn)
                            })),
                            function() {
                                for (; deregisterFns.length;) deregisterFns.shift()()
                            }
                    },
                    $watchCollection: function(obj, listener) {
                        $watchCollectionInterceptor.$$pure = $parse(obj).literal, $watchCollectionInterceptor.$stateful = !$watchCollectionInterceptor.$$pure;
                        var newValue, oldValue, veryOldValue, self = this,
                            trackVeryOldValue = listener.length > 1,
                            changeDetected = 0,
                            changeDetector = $parse(obj, $watchCollectionInterceptor),
                            internalArray = [],
                            internalObject = {},
                            initRun = !0,
                            oldLength = 0;

                        function $watchCollectionInterceptor(_value) {
                            var newLength, key, newItem, oldItem;
                            if (!isUndefined(newValue = _value)) {
                                if (isObject(newValue))
                                    if (isArrayLike(newValue)) {
                                        oldValue !== internalArray && (oldLength = (oldValue = internalArray).length = 0, changeDetected++), newLength = newValue.length, oldLength !== newLength && (changeDetected++, oldValue.length = oldLength = newLength);
                                        for (var i = 0; i < newLength; i++) oldItem = oldValue[i], newItem = newValue[i], oldItem != oldItem && newItem != newItem || oldItem === newItem || (changeDetected++, oldValue[i] = newItem)
                                    } else {
                                        for (key in oldValue !== internalObject && (oldValue = internalObject = {}, oldLength = 0, changeDetected++), newLength = 0, newValue) hasOwnProperty.call(newValue, key) && (newLength++, newItem = newValue[key], oldItem = oldValue[key], key in oldValue ? oldItem != oldItem && newItem != newItem || oldItem === newItem || (changeDetected++, oldValue[key] = newItem) : (oldLength++, oldValue[key] = newItem, changeDetected++));
                                        if (oldLength > newLength)
                                            for (key in changeDetected++, oldValue) hasOwnProperty.call(newValue, key) || (oldLength--, delete oldValue[key])
                                    }
                                else oldValue !== newValue && (oldValue = newValue, changeDetected++);
                                return changeDetected
                            }
                        }
                        return this.$watch(changeDetector, (function() {
                            if (initRun ? (initRun = !1, listener(newValue, newValue, self)) : listener(newValue, veryOldValue, self), trackVeryOldValue)
                                if (isObject(newValue))
                                    if (isArrayLike(newValue)) {
                                        veryOldValue = new Array(newValue.length);
                                        for (var i = 0; i < newValue.length; i++) veryOldValue[i] = newValue[i]
                                    } else
                                        for (var key in veryOldValue = {}, newValue) hasOwnProperty.call(newValue, key) && (veryOldValue[key] = newValue[key]);
                            else veryOldValue = newValue
                        }))
                    },
                    $digest: function() {
                        var watch, value, last, watchers, dirty, next, current, logIdx, asyncTask, ttl = TTL,
                            target = asyncQueue.length ? $rootScope : this,
                            watchLog = [];
                        beginPhase("$digest"), $browser.$$checkUrlChange(), this === $rootScope && null !== applyAsyncId && ($browser.defer.cancel(applyAsyncId), flushApplyAsync()), lastDirtyWatch = null;
                        do {
                            dirty = !1, current = target;
                            for (var asyncQueuePosition = 0; asyncQueuePosition < asyncQueue.length; asyncQueuePosition++) {
                                try {
                                    (0, (asyncTask = asyncQueue[asyncQueuePosition]).fn)(asyncTask.scope, asyncTask.locals)
                                } catch (e) {
                                    $exceptionHandler(e)
                                }
                                lastDirtyWatch = null
                            }
                            asyncQueue.length = 0;
                            traverseScopesLoop: do {
                                if (watchers = !current.$$suspended && current.$$watchers)
                                    for (watchers.$$digestWatchIndex = watchers.length; watchers.$$digestWatchIndex--;) try {
                                        if (watch = watchers[watchers.$$digestWatchIndex])
                                            if ((value = (0, watch.get)(current)) === (last = watch.last) || (watch.eq ? equals(value, last) : isNumberNaN(value) && isNumberNaN(last))) {
                                                if (watch === lastDirtyWatch) {
                                                    dirty = !1;
                                                    break traverseScopesLoop
                                                }
                                            } else dirty = !0, lastDirtyWatch = watch, watch.last = watch.eq ? copy(value, null) : value, (0, watch.fn)(value, last === initWatchVal ? value : last, current), ttl < 5 && (watchLog[logIdx = 4 - ttl] || (watchLog[logIdx] = []), watchLog[logIdx].push({
                                                msg: isFunction(watch.exp) ? "fn: " + (watch.exp.name || watch.exp.toString()) : watch.exp,
                                                newVal: value,
                                                oldVal: last
                                            }))
                                    } catch (e) {
                                        $exceptionHandler(e)
                                    }
                                if (!(next = !current.$$suspended && current.$$watchersCount && current.$$childHead || current !== target && current.$$nextSibling))
                                    for (; current !== target && !(next = current.$$nextSibling);) current = current.$parent
                            } while (current = next);
                            if ((dirty || asyncQueue.length) && !ttl--) throw clearPhase(), $rootScopeMinErr("infdig", "{0} $digest() iterations reached. Aborting!\nWatchers fired in the last 5 iterations: {1}", TTL, watchLog)
                        } while (dirty || asyncQueue.length);
                        for (clearPhase(); postDigestQueuePosition < postDigestQueue.length;) try {
                            postDigestQueue[postDigestQueuePosition++]()
                        } catch (e) {
                            $exceptionHandler(e)
                        }
                        postDigestQueue.length = postDigestQueuePosition = 0, $browser.$$checkUrlChange()
                    },
                    $suspend: function() {
                        this.$$suspended = !0
                    },
                    $isSuspended: function() {
                        return this.$$suspended
                    },
                    $resume: function() {
                        this.$$suspended = !1
                    },
                    $destroy: function() {
                        if (!this.$$destroyed) {
                            var parent = this.$parent;
                            for (var eventName in this.$broadcast("$destroy"), this.$$destroyed = !0, this === $rootScope && $browser.$$applicationDestroyed(), incrementWatchersCount(this, -this.$$watchersCount), this.$$listenerCount) decrementListenerCount(this, this.$$listenerCount[eventName], eventName);
                            parent && parent.$$childHead === this && (parent.$$childHead = this.$$nextSibling), parent && parent.$$childTail === this && (parent.$$childTail = this.$$prevSibling), this.$$prevSibling && (this.$$prevSibling.$$nextSibling = this.$$nextSibling), this.$$nextSibling && (this.$$nextSibling.$$prevSibling = this.$$prevSibling), this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop, this.$on = this.$watch = this.$watchGroup = function() {
                                return noop
                            }, this.$$listeners = {}, this.$$nextSibling = null, cleanUpScope(this)
                        }
                    },
                    $eval: function(expr, locals) {
                        return $parse(expr)(this, locals)
                    },
                    $evalAsync: function(expr, locals) {
                        $rootScope.$$phase || asyncQueue.length || $browser.defer((function() {
                            asyncQueue.length && $rootScope.$digest()
                        }), null, "$evalAsync"), asyncQueue.push({
                            scope: this,
                            fn: $parse(expr),
                            locals: locals
                        })
                    },
                    $$postDigest: function(fn) {
                        postDigestQueue.push(fn)
                    },
                    $apply: function(expr) {
                        try {
                            beginPhase("$apply");
                            try {
                                return this.$eval(expr)
                            } finally {
                                clearPhase()
                            }
                        } catch (e) {
                            $exceptionHandler(e)
                        } finally {
                            try {
                                $rootScope.$digest()
                            } catch (e) {
                                throw $exceptionHandler(e), e
                            }
                        }
                    },
                    $applyAsync: function(expr) {
                        var scope = this;
                        expr && applyAsyncQueue.push((function() {
                            scope.$eval(expr)
                        })), expr = $parse(expr), null === applyAsyncId && (applyAsyncId = $browser.defer((function() {
                            $rootScope.$apply(flushApplyAsync)
                        }), null, "$applyAsync"))
                    },
                    $on: function(name, listener) {
                        var namedListeners = this.$$listeners[name];
                        namedListeners || (this.$$listeners[name] = namedListeners = []), namedListeners.push(listener);
                        var current = this;
                        do {
                            current.$$listenerCount[name] || (current.$$listenerCount[name] = 0), current.$$listenerCount[name]++
                        } while (current = current.$parent);
                        var self = this;
                        return function() {
                            var indexOfListener = namedListeners.indexOf(listener); - 1 !== indexOfListener && (delete namedListeners[indexOfListener], decrementListenerCount(self, 1, name))
                        }
                    },
                    $emit: function(name, args) {
                        var namedListeners, i, length, empty = [],
                            scope = this,
                            stopPropagation = !1,
                            event = {
                                name: name,
                                targetScope: scope,
                                stopPropagation: function() {
                                    stopPropagation = !0
                                },
                                preventDefault: function() {
                                    event.defaultPrevented = !0
                                },
                                defaultPrevented: !1
                            },
                            listenerArgs = concat([event], arguments, 1);
                        do {
                            for (namedListeners = scope.$$listeners[name] || empty, event.currentScope = scope, i = 0, length = namedListeners.length; i < length; i++)
                                if (namedListeners[i]) try {
                                    namedListeners[i].apply(null, listenerArgs)
                                } catch (e) {
                                    $exceptionHandler(e)
                                } else namedListeners.splice(i, 1), i--, length--;
                            if (stopPropagation) break;
                            scope = scope.$parent
                        } while (scope);
                        return event.currentScope = null, event
                    },
                    $broadcast: function(name, args) {
                        var target = this,
                            current = target,
                            next = target,
                            event = {
                                name: name,
                                targetScope: target,
                                preventDefault: function() {
                                    event.defaultPrevented = !0
                                },
                                defaultPrevented: !1
                            };
                        if (!target.$$listenerCount[name]) return event;
                        for (var listeners, i, length, listenerArgs = concat([event], arguments, 1); current = next;) {
                            for (event.currentScope = current, i = 0, length = (listeners = current.$$listeners[name] || []).length; i < length; i++)
                                if (listeners[i]) try {
                                    listeners[i].apply(null, listenerArgs)
                                } catch (e) {
                                    $exceptionHandler(e)
                                } else listeners.splice(i, 1), i--, length--;
                            if (!(next = current.$$listenerCount[name] && current.$$childHead || current !== target && current.$$nextSibling))
                                for (; current !== target && !(next = current.$$nextSibling);) current = current.$parent
                        }
                        return event.currentScope = null, event
                    }
                };
                var $rootScope = new Scope,
                    asyncQueue = $rootScope.$$asyncQueue = [],
                    postDigestQueue = $rootScope.$$postDigestQueue = [],
                    applyAsyncQueue = $rootScope.$$applyAsyncQueue = [],
                    postDigestQueuePosition = 0;
                return $rootScope;

                function beginPhase(phase) {
                    if ($rootScope.$$phase) throw $rootScopeMinErr("inprog", "{0} already in progress", $rootScope.$$phase);
                    $rootScope.$$phase = phase
                }

                function clearPhase() {
                    $rootScope.$$phase = null
                }

                function incrementWatchersCount(current, count) {
                    do {
                        current.$$watchersCount += count
                    } while (current = current.$parent)
                }

                function decrementListenerCount(current, count, name) {
                    do {
                        current.$$listenerCount[name] -= count, 0 === current.$$listenerCount[name] && delete current.$$listenerCount[name]
                    } while (current = current.$parent)
                }

                function initWatchVal() {}

                function flushApplyAsync() {
                    for (; applyAsyncQueue.length;) try {
                        applyAsyncQueue.shift()()
                    } catch (e) {
                        $exceptionHandler(e)
                    }
                    applyAsyncId = null
                }
            }]
        }

        function $$SanitizeUriProvider() {
            var aHrefSanitizationTrustedUrlList = /^\s*(https?|s?ftp|mailto|tel|file):/,
                imgSrcSanitizationTrustedUrlList = /^\s*((https?|ftp|file|blob):|data:image\/)/;
            this.aHrefSanitizationTrustedUrlList = function(regexp) {
                return isDefined(regexp) ? (aHrefSanitizationTrustedUrlList = regexp, this) : aHrefSanitizationTrustedUrlList
            }, this.imgSrcSanitizationTrustedUrlList = function(regexp) {
                return isDefined(regexp) ? (imgSrcSanitizationTrustedUrlList = regexp, this) : imgSrcSanitizationTrustedUrlList
            }, this.$get = function() {
                return function(uri, isMediaUrl) {
                    var regex = isMediaUrl ? imgSrcSanitizationTrustedUrlList : aHrefSanitizationTrustedUrlList,
                        normalizedVal = urlResolve(uri && uri.trim()).href;
                    return "" === normalizedVal || normalizedVal.match(regex) ? uri : "unsafe:" + normalizedVal
                }
            }
        }
        ASTCompiler.prototype = {
            compile: function(ast) {
                var self = this;
                this.state = {
                    nextId: 0,
                    filters: {},
                    fn: {
                        vars: [],
                        body: [],
                        own: {}
                    },
                    assign: {
                        vars: [],
                        body: [],
                        own: {}
                    },
                    inputs: []
                }, findConstantAndWatchExpressions(ast, self.$filter);
                var assignable, extra = "";
                if (this.stage = "assign", assignable = assignableAST(ast)) {
                    this.state.computing = "assign";
                    var result = this.nextId();
                    this.recurse(assignable, result), this.return_(result), extra = "fn.assign=" + this.generateFunction("assign", "s,v,l")
                }
                var toWatch = getInputs(ast.body);
                self.stage = "inputs", forEach(toWatch, (function(watch, key) {
                    var fnKey = "fn" + key;
                    self.state[fnKey] = {
                        vars: [],
                        body: [],
                        own: {}
                    }, self.state.computing = fnKey;
                    var intoId = self.nextId();
                    self.recurse(watch, intoId), self.return_(intoId), self.state.inputs.push({
                        name: fnKey,
                        isPure: watch.isPure
                    }), watch.watchId = key
                })), this.state.computing = "fn", this.stage = "main", this.recurse(ast);
                var fnString = '"' + this.USE + " " + this.STRICT + '";\n' + this.filterPrefix() + "var fn=" + this.generateFunction("fn", "s,l,a,i") + extra + this.watchFns() + "return fn;",
                    fn = new Function("$filter", "getStringValue", "ifDefined", "plus", fnString)(this.$filter, getStringValue, ifDefined, plusFn);
                return this.state = this.stage = void 0, fn
            },
            USE: "use",
            STRICT: "strict",
            watchFns: function() {
                var result = [],
                    inputs = this.state.inputs,
                    self = this;
                return forEach(inputs, (function(input) {
                    result.push("var " + input.name + "=" + self.generateFunction(input.name, "s")), input.isPure && result.push(input.name, ".isPure=" + JSON.stringify(input.isPure) + ";")
                })), inputs.length && result.push("fn.inputs=[" + inputs.map((function(i) {
                    return i.name
                })).join(",") + "];"), result.join("")
            },
            generateFunction: function(name, params) {
                return "function(" + params + "){" + this.varsPrefix(name) + this.body(name) + "};"
            },
            filterPrefix: function() {
                var parts = [],
                    self = this;
                return forEach(this.state.filters, (function(id, filter) {
                    parts.push(id + "=$filter(" + self.escape(filter) + ")")
                })), parts.length ? "var " + parts.join(",") + ";" : ""
            },
            varsPrefix: function(section) {
                return this.state[section].vars.length ? "var " + this.state[section].vars.join(",") + ";" : ""
            },
            body: function(section) {
                return this.state[section].body.join("")
            },
            recurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
                var left, right, args, expression, computed, self = this;
                if (recursionFn = recursionFn || noop, !skipWatchIdCheck && isDefined(ast.watchId)) return intoId = intoId || this.nextId(), void this.if_("i", this.lazyAssign(intoId, this.computedMember("i", ast.watchId)), this.lazyRecurse(ast, intoId, nameId, recursionFn, create, !0));
                switch (ast.type) {
                    case AST.Program:
                        forEach(ast.body, (function(expression, pos) {
                            self.recurse(expression.expression, void 0, void 0, (function(expr) {
                                right = expr
                            })), pos !== ast.body.length - 1 ? self.current().body.push(right, ";") : self.return_(right)
                        }));
                        break;
                    case AST.Literal:
                        expression = this.escape(ast.value), this.assign(intoId, expression), recursionFn(intoId || expression);
                        break;
                    case AST.UnaryExpression:
                        this.recurse(ast.argument, void 0, void 0, (function(expr) {
                            right = expr
                        })), expression = ast.operator + "(" + this.ifDefined(right, 0) + ")", this.assign(intoId, expression), recursionFn(expression);
                        break;
                    case AST.BinaryExpression:
                        this.recurse(ast.left, void 0, void 0, (function(expr) {
                            left = expr
                        })), this.recurse(ast.right, void 0, void 0, (function(expr) {
                            right = expr
                        })), expression = "+" === ast.operator ? this.plus(left, right) : "-" === ast.operator ? this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0) : "(" + left + ")" + ast.operator + "(" + right + ")", this.assign(intoId, expression), recursionFn(expression);
                        break;
                    case AST.LogicalExpression:
                        intoId = intoId || this.nextId(), self.recurse(ast.left, intoId), self.if_("&&" === ast.operator ? intoId : self.not(intoId), self.lazyRecurse(ast.right, intoId)), recursionFn(intoId);
                        break;
                    case AST.ConditionalExpression:
                        intoId = intoId || this.nextId(), self.recurse(ast.test, intoId), self.if_(intoId, self.lazyRecurse(ast.alternate, intoId), self.lazyRecurse(ast.consequent, intoId)), recursionFn(intoId);
                        break;
                    case AST.Identifier:
                        intoId = intoId || this.nextId(), nameId && (nameId.context = "inputs" === self.stage ? "s" : this.assign(this.nextId(), this.getHasOwnProperty("l", ast.name) + "?l:s"), nameId.computed = !1, nameId.name = ast.name), self.if_("inputs" === self.stage || self.not(self.getHasOwnProperty("l", ast.name)), (function() {
                            self.if_("inputs" === self.stage || "s", (function() {
                                create && 1 !== create && self.if_(self.isNull(self.nonComputedMember("s", ast.name)), self.lazyAssign(self.nonComputedMember("s", ast.name), "{}")), self.assign(intoId, self.nonComputedMember("s", ast.name))
                            }))
                        }), intoId && self.lazyAssign(intoId, self.nonComputedMember("l", ast.name))), recursionFn(intoId);
                        break;
                    case AST.MemberExpression:
                        left = nameId && (nameId.context = this.nextId()) || this.nextId(), intoId = intoId || this.nextId(), self.recurse(ast.object, left, void 0, (function() {
                            self.if_(self.notNull(left), (function() {
                                ast.computed ? (right = self.nextId(), self.recurse(ast.property, right), self.getStringValue(right), create && 1 !== create && self.if_(self.not(self.computedMember(left, right)), self.lazyAssign(self.computedMember(left, right), "{}")), expression = self.computedMember(left, right), self.assign(intoId, expression), nameId && (nameId.computed = !0, nameId.name = right)) : (create && 1 !== create && self.if_(self.isNull(self.nonComputedMember(left, ast.property.name)), self.lazyAssign(self.nonComputedMember(left, ast.property.name), "{}")), expression = self.nonComputedMember(left, ast.property.name), self.assign(intoId, expression), nameId && (nameId.computed = !1, nameId.name = ast.property.name))
                            }), (function() {
                                self.assign(intoId, "undefined")
                            })), recursionFn(intoId)
                        }), !!create);
                        break;
                    case AST.CallExpression:
                        intoId = intoId || this.nextId(), ast.filter ? (right = self.filter(ast.callee.name), args = [], forEach(ast.arguments, (function(expr) {
                            var argument = self.nextId();
                            self.recurse(expr, argument), args.push(argument)
                        })), expression = right + "(" + args.join(",") + ")", self.assign(intoId, expression), recursionFn(intoId)) : (right = self.nextId(), left = {}, args = [], self.recurse(ast.callee, right, left, (function() {
                            self.if_(self.notNull(right), (function() {
                                forEach(ast.arguments, (function(expr) {
                                    self.recurse(expr, ast.constant ? void 0 : self.nextId(), void 0, (function(argument) {
                                        args.push(argument)
                                    }))
                                })), expression = left.name ? self.member(left.context, left.name, left.computed) + "(" + args.join(",") + ")" : right + "(" + args.join(",") + ")", self.assign(intoId, expression)
                            }), (function() {
                                self.assign(intoId, "undefined")
                            })), recursionFn(intoId)
                        })));
                        break;
                    case AST.AssignmentExpression:
                        right = this.nextId(), left = {}, this.recurse(ast.left, void 0, left, (function() {
                            self.if_(self.notNull(left.context), (function() {
                                self.recurse(ast.right, right), expression = self.member(left.context, left.name, left.computed) + ast.operator + right, self.assign(intoId, expression), recursionFn(intoId || expression)
                            }))
                        }), 1);
                        break;
                    case AST.ArrayExpression:
                        args = [], forEach(ast.elements, (function(expr) {
                            self.recurse(expr, ast.constant ? void 0 : self.nextId(), void 0, (function(argument) {
                                args.push(argument)
                            }))
                        })), expression = "[" + args.join(",") + "]", this.assign(intoId, expression), recursionFn(intoId || expression);
                        break;
                    case AST.ObjectExpression:
                        args = [], computed = !1, forEach(ast.properties, (function(property) {
                            property.computed && (computed = !0)
                        })), computed ? (intoId = intoId || this.nextId(), this.assign(intoId, "{}"), forEach(ast.properties, (function(property) {
                            property.computed ? (left = self.nextId(), self.recurse(property.key, left)) : left = property.key.type === AST.Identifier ? property.key.name : "" + property.key.value, right = self.nextId(), self.recurse(property.value, right), self.assign(self.member(intoId, left, property.computed), right)
                        }))) : (forEach(ast.properties, (function(property) {
                            self.recurse(property.value, ast.constant ? void 0 : self.nextId(), void 0, (function(expr) {
                                args.push(self.escape(property.key.type === AST.Identifier ? property.key.name : "" + property.key.value) + ":" + expr)
                            }))
                        })), expression = "{" + args.join(",") + "}", this.assign(intoId, expression)), recursionFn(intoId || expression);
                        break;
                    case AST.ThisExpression:
                        this.assign(intoId, "s"), recursionFn(intoId || "s");
                        break;
                    case AST.LocalsExpression:
                        this.assign(intoId, "l"), recursionFn(intoId || "l");
                        break;
                    case AST.NGValueParameter:
                        this.assign(intoId, "v"), recursionFn(intoId || "v")
                }
            },
            getHasOwnProperty: function(element, property) {
                var key = element + "." + property,
                    own = this.current().own;
                return own.hasOwnProperty(key) || (own[key] = this.nextId(!1, element + "&&(" + this.escape(property) + " in " + element + ")")), own[key]
            },
            assign: function(id, value) {
                if (id) return this.current().body.push(id, "=", value, ";"), id
            },
            filter: function(filterName) {
                return this.state.filters.hasOwnProperty(filterName) || (this.state.filters[filterName] = this.nextId(!0)), this.state.filters[filterName]
            },
            ifDefined: function(id, defaultValue) {
                return "ifDefined(" + id + "," + this.escape(defaultValue) + ")"
            },
            plus: function(left, right) {
                return "plus(" + left + "," + right + ")"
            },
            return_: function(id) {
                this.current().body.push("return ", id, ";")
            },
            if_: function(test, alternate, consequent) {
                if (!0 === test) alternate();
                else {
                    var body = this.current().body;
                    body.push("if(", test, "){"), alternate(), body.push("}"), consequent && (body.push("else{"), consequent(), body.push("}"))
                }
            },
            not: function(expression) {
                return "!(" + expression + ")"
            },
            isNull: function(expression) {
                return expression + "==null"
            },
            notNull: function(expression) {
                return expression + "!=null"
            },
            nonComputedMember: function(left, right) {
                return /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(right) ? left + "." + right : left + '["' + right.replace(/[^$_a-zA-Z0-9]/g, this.stringEscapeFn) + '"]'
            },
            computedMember: function(left, right) {
                return left + "[" + right + "]"
            },
            member: function(left, right, computed) {
                return computed ? this.computedMember(left, right) : this.nonComputedMember(left, right)
            },
            getStringValue: function(item) {
                this.assign(item, "getStringValue(" + item + ")")
            },
            lazyRecurse: function(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
                var self = this;
                return function() {
                    self.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck)
                }
            },
            lazyAssign: function(id, value) {
                var self = this;
                return function() {
                    self.assign(id, value)
                }
            },
            stringEscapeRegex: /[^ a-zA-Z0-9]/g,
            stringEscapeFn: function(c) {
                return "\\u" + ("0000" + c.charCodeAt(0).toString(16)).slice(-4)
            },
            escape: function(value) {
                if (isString(value)) return "'" + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + "'";
                if (isNumber(value)) return value.toString();
                if (!0 === value) return "true";
                if (!1 === value) return "false";
                if (null === value) return "null";
                if (void 0 === value) return "undefined";
                throw $parseMinErr("esc", "IMPOSSIBLE")
            },
            nextId: function(skip, init) {
                var id = "v" + this.state.nextId++;
                return skip || this.current().vars.push(id + (init ? "=" + init : "")), id
            },
            current: function() {
                return this.state[this.state.computing]
            }
        }, ASTInterpreter.prototype = {
            compile: function(ast) {
                var assignable, assign, self = this;
                findConstantAndWatchExpressions(ast, self.$filter), (assignable = assignableAST(ast)) && (assign = this.recurse(assignable));
                var inputs, toWatch = getInputs(ast.body);
                toWatch && (inputs = [], forEach(toWatch, (function(watch, key) {
                    var input = self.recurse(watch);
                    input.isPure = watch.isPure, watch.input = input, inputs.push(input), watch.watchId = key
                })));
                var expressions = [];
                forEach(ast.body, (function(expression) {
                    expressions.push(self.recurse(expression.expression))
                }));
                var fn = 0 === ast.body.length ? noop : 1 === ast.body.length ? expressions[0] : function(scope, locals) {
                    var lastValue;
                    return forEach(expressions, (function(exp) {
                        lastValue = exp(scope, locals)
                    })), lastValue
                };
                return assign && (fn.assign = function(scope, value, locals) {
                    return assign(scope, locals, value)
                }), inputs && (fn.inputs = inputs), fn
            },
            recurse: function(ast, context, create) {
                var left, right, args, self = this;
                if (ast.input) return this.inputs(ast.input, ast.watchId);
                switch (ast.type) {
                    case AST.Literal:
                        return this.value(ast.value, context);
                    case AST.UnaryExpression:
                        return right = this.recurse(ast.argument), this["unary" + ast.operator](right, context);
                    case AST.BinaryExpression:
                    case AST.LogicalExpression:
                        return left = this.recurse(ast.left), right = this.recurse(ast.right), this["binary" + ast.operator](left, right, context);
                    case AST.ConditionalExpression:
                        return this["ternary?:"](this.recurse(ast.test), this.recurse(ast.alternate), this.recurse(ast.consequent), context);
                    case AST.Identifier:
                        return self.identifier(ast.name, context, create);
                    case AST.MemberExpression:
                        return left = this.recurse(ast.object, !1, !!create), ast.computed || (right = ast.property.name), ast.computed && (right = this.recurse(ast.property)), ast.computed ? this.computedMember(left, right, context, create) : this.nonComputedMember(left, right, context, create);
                    case AST.CallExpression:
                        return args = [], forEach(ast.arguments, (function(expr) {
                            args.push(self.recurse(expr))
                        })), ast.filter && (right = this.$filter(ast.callee.name)), ast.filter || (right = this.recurse(ast.callee, !0)), ast.filter ? function(scope, locals, assign, inputs) {
                            for (var values = [], i = 0; i < args.length; ++i) values.push(args[i](scope, locals, assign, inputs));
                            var value = right.apply(void 0, values, inputs);
                            return context ? {
                                context: void 0,
                                name: void 0,
                                value: value
                            } : value
                        } : function(scope, locals, assign, inputs) {
                            var value, rhs = right(scope, locals, assign, inputs);
                            if (null != rhs.value) {
                                for (var values = [], i = 0; i < args.length; ++i) values.push(args[i](scope, locals, assign, inputs));
                                value = rhs.value.apply(rhs.context, values)
                            }
                            return context ? {
                                value: value
                            } : value
                        };
                    case AST.AssignmentExpression:
                        return left = this.recurse(ast.left, !0, 1), right = this.recurse(ast.right),
                            function(scope, locals, assign, inputs) {
                                var lhs = left(scope, locals, assign, inputs),
                                    rhs = right(scope, locals, assign, inputs);
                                return lhs.context[lhs.name] = rhs, context ? {
                                    value: rhs
                                } : rhs
                            };
                    case AST.ArrayExpression:
                        return args = [], forEach(ast.elements, (function(expr) {
                                args.push(self.recurse(expr))
                            })),
                            function(scope, locals, assign, inputs) {
                                for (var value = [], i = 0; i < args.length; ++i) value.push(args[i](scope, locals, assign, inputs));
                                return context ? {
                                    value: value
                                } : value
                            };
                    case AST.ObjectExpression:
                        return args = [], forEach(ast.properties, (function(property) {
                                property.computed ? args.push({
                                    key: self.recurse(property.key),
                                    computed: !0,
                                    value: self.recurse(property.value)
                                }) : args.push({
                                    key: property.key.type === AST.Identifier ? property.key.name : "" + property.key.value,
                                    computed: !1,
                                    value: self.recurse(property.value)
                                })
                            })),
                            function(scope, locals, assign, inputs) {
                                for (var value = {}, i = 0; i < args.length; ++i) args[i].computed ? value[args[i].key(scope, locals, assign, inputs)] = args[i].value(scope, locals, assign, inputs) : value[args[i].key] = args[i].value(scope, locals, assign, inputs);
                                return context ? {
                                    value: value
                                } : value
                            };
                    case AST.ThisExpression:
                        return function(scope) {
                            return context ? {
                                value: scope
                            } : scope
                        };
                    case AST.LocalsExpression:
                        return function(scope, locals) {
                            return context ? {
                                value: locals
                            } : locals
                        };
                    case AST.NGValueParameter:
                        return function(scope, locals, assign) {
                            return context ? {
                                value: assign
                            } : assign
                        }
                }
            },
            "unary+": function(argument, context) {
                return function(scope, locals, assign, inputs) {
                    var arg = argument(scope, locals, assign, inputs);
                    return arg = isDefined(arg) ? +arg : 0, context ? {
                        value: arg
                    } : arg
                }
            },
            "unary-": function(argument, context) {
                return function(scope, locals, assign, inputs) {
                    var arg = argument(scope, locals, assign, inputs);
                    return arg = isDefined(arg) ? -arg : -0, context ? {
                        value: arg
                    } : arg
                }
            },
            "unary!": function(argument, context) {
                return function(scope, locals, assign, inputs) {
                    var arg = !argument(scope, locals, assign, inputs);
                    return context ? {
                        value: arg
                    } : arg
                }
            },
            "binary+": function(left, right, context) {
                return function(scope, locals, assign, inputs) {
                    var arg = plusFn(left(scope, locals, assign, inputs), right(scope, locals, assign, inputs));
                    return context ? {
                        value: arg
                    } : arg
                }
            },
            "binary-": function(left, right, context) {
                return function(scope, locals, assign, inputs) {
                    var lhs = left(scope, locals, assign, inputs),
                        rhs = right(scope, locals, assign, inputs),
                        arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);
                    return context ? {
                        value: arg
                    } : arg
                }
            },
            "binary*": function(left, right, context) {
                return function(scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) * right(scope, locals, assign, inputs);
                    return context ? {
                        value: arg
                    } : arg
                }
            },
            "binary/": function(left, right, context) {
                return function(scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) / right(scope, locals, assign, inputs);
                    return context ? {
                        value: arg
                    } : arg
                }
            },
            "binary%": function(left, right, context) {
                return function(scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) % right(scope, locals, assign, inputs);
                    return context ? {
                        value: arg
                    } : arg
                }
            },
            "binary===": function(left, right, context) {
                return function(scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) === right(scope, locals, assign, inputs);
                    return context ? {
                        value: arg
                    } : arg
                }
            },
            "binary!==": function(left, right, context) {
                return function(scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) !== right(scope, locals, assign, inputs);
                    return context ? {
                        value: arg
                    } : arg
                }
            },
            "binary==": function(left, right, context) {
                return function(scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) == right(scope, locals, assign, inputs);
                    return context ? {
                        value: arg
                    } : arg
                }
            },
            "binary!=": function(left, right, context) {
                return function(scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) != right(scope, locals, assign, inputs);
                    return context ? {
                        value: arg
                    } : arg
                }
            },
            "binary<": function(left, right, context) {
                return function(scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) < right(scope, locals, assign, inputs);
                    return context ? {
                        value: arg
                    } : arg
                }
            },
            "binary>": function(left, right, context) {
                return function(scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) > right(scope, locals, assign, inputs);
                    return context ? {
                        value: arg
                    } : arg
                }
            },
            "binary<=": function(left, right, context) {
                return function(scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) <= right(scope, locals, assign, inputs);
                    return context ? {
                        value: arg
                    } : arg
                }
            },
            "binary>=": function(left, right, context) {
                return function(scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) >= right(scope, locals, assign, inputs);
                    return context ? {
                        value: arg
                    } : arg
                }
            },
            "binary&&": function(left, right, context) {
                return function(scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) && right(scope, locals, assign, inputs);
                    return context ? {
                        value: arg
                    } : arg
                }
            },
            "binary||": function(left, right, context) {
                return function(scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) || right(scope, locals, assign, inputs);
                    return context ? {
                        value: arg
                    } : arg
                }
            },
            "ternary?:": function(test, alternate, consequent, context) {
                return function(scope, locals, assign, inputs) {
                    var arg = test(scope, locals, assign, inputs) ? alternate(scope, locals, assign, inputs) : consequent(scope, locals, assign, inputs);
                    return context ? {
                        value: arg
                    } : arg
                }
            },
            value: function(value, context) {
                return function() {
                    return context ? {
                        context: void 0,
                        name: void 0,
                        value: value
                    } : value
                }
            },
            identifier: function(name, context, create) {
                return function(scope, locals, assign, inputs) {
                    var base = locals && name in locals ? locals : scope;
                    create && 1 !== create && base && null == base[name] && (base[name] = {});
                    var value = base ? base[name] : void 0;
                    return context ? {
                        context: base,
                        name: name,
                        value: value
                    } : value
                }
            },
            computedMember: function(left, right, context, create) {
                return function(scope, locals, assign, inputs) {
                    var rhs, value, lhs = left(scope, locals, assign, inputs);
                    return null != lhs && (rhs = getStringValue(rhs = right(scope, locals, assign, inputs)), create && 1 !== create && lhs && !lhs[rhs] && (lhs[rhs] = {}), value = lhs[rhs]), context ? {
                        context: lhs,
                        name: rhs,
                        value: value
                    } : value
                }
            },
            nonComputedMember: function(left, right, context, create) {
                return function(scope, locals, assign, inputs) {
                    var lhs = left(scope, locals, assign, inputs);
                    create && 1 !== create && lhs && null == lhs[right] && (lhs[right] = {});
                    var value = null != lhs ? lhs[right] : void 0;
                    return context ? {
                        context: lhs,
                        name: right,
                        value: value
                    } : value
                }
            },
            inputs: function(input, watchId) {
                return function(scope, value, locals, inputs) {
                    return inputs ? inputs[watchId] : input(scope, value, locals)
                }
            }
        }, Parser.prototype = {
            constructor: Parser,
            parse: function(text) {
                var ast = this.getAst(text),
                    fn = this.astCompiler.compile(ast.ast);
                return fn.literal = function(ast) {
                    return 0 === ast.body.length || 1 === ast.body.length && (ast.body[0].expression.type === AST.Literal || ast.body[0].expression.type === AST.ArrayExpression || ast.body[0].expression.type === AST.ObjectExpression)
                }(ast.ast), fn.constant = function(ast) {
                    return ast.constant
                }(ast.ast), fn.oneTime = ast.oneTime, fn
            },
            getAst: function(exp) {
                var oneTime = !1;
                return ":" === (exp = exp.trim()).charAt(0) && ":" === exp.charAt(1) && (oneTime = !0, exp = exp.substring(2)), {
                    ast: this.ast.ast(exp),
                    oneTime: oneTime
                }
            }
        };
        var $sceMinErr = minErr("$sce"),
            SCE_CONTEXTS = {
                HTML: "html",
                CSS: "css",
                MEDIA_URL: "mediaUrl",
                URL: "url",
                RESOURCE_URL: "resourceUrl",
                JS: "js"
            },
            UNDERSCORE_LOWERCASE_REGEXP = /_([a-z])/g;

        function snakeToCamel(name) {
            return name.replace(UNDERSCORE_LOWERCASE_REGEXP, fnCamelCaseReplace)
        }

        function adjustMatchers(matchers) {
            var adjustedMatchers = [];
            return isDefined(matchers) && forEach(matchers, (function(matcher) {
                adjustedMatchers.push(function(matcher) {
                    if ("self" === matcher) return matcher;
                    if (isString(matcher)) {
                        if (matcher.indexOf("***") > -1) throw $sceMinErr("iwcard", "Illegal sequence *** in string matcher.  String: {0}", matcher);
                        return matcher = escapeForRegexp(matcher).replace(/\\\*\\\*/g, ".*").replace(/\\\*/g, "[^:/.?&;]*"), new RegExp("^" + matcher + "$")
                    }
                    if (isRegExp(matcher)) return new RegExp("^" + matcher.source + "$");
                    throw $sceMinErr("imatcher", 'Matchers may only be "self", string patterns or RegExp objects')
                }(matcher))
            })), adjustedMatchers
        }

        function $SceDelegateProvider() {
            this.SCE_CONTEXTS = SCE_CONTEXTS;
            var trustedResourceUrlList = ["self"],
                bannedResourceUrlList = [];
            this.trustedResourceUrlList = function(value) {
                return arguments.length && (trustedResourceUrlList = adjustMatchers(value)), trustedResourceUrlList
            }, Object.defineProperty(this, "resourceUrlWhitelist", {
                get: function() {
                    return this.trustedResourceUrlList
                },
                set: function(value) {
                    this.trustedResourceUrlList = value
                }
            }), this.bannedResourceUrlList = function(value) {
                return arguments.length && (bannedResourceUrlList = adjustMatchers(value)), bannedResourceUrlList
            }, Object.defineProperty(this, "resourceUrlBlacklist", {
                get: function() {
                    return this.bannedResourceUrlList
                },
                set: function(value) {
                    this.bannedResourceUrlList = value
                }
            }), this.$get = ["$injector", "$$sanitizeUri", function($injector, $$sanitizeUri) {
                var htmlSanitizer = function(html) {
                    throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.")
                };

                function matchUrl(matcher, parsedUrl) {
                    return "self" === matcher ? urlsAreSameOrigin(parsedUrl, originUrl) || function(requestUrl) {
                        return urlsAreSameOrigin(requestUrl, function() {
                            if (window.document.baseURI) return window.document.baseURI;
                            baseUrlParsingNode || ((baseUrlParsingNode = window.document.createElement("a")).href = ".", baseUrlParsingNode = baseUrlParsingNode.cloneNode(!1));
                            return baseUrlParsingNode.href
                        }())
                    }(parsedUrl) : !!matcher.exec(parsedUrl.href)
                }

                function generateHolderType(Base) {
                    var holderType = function(trustedValue) {
                        this.$$unwrapTrustedValue = function() {
                            return trustedValue
                        }
                    };
                    return Base && (holderType.prototype = new Base), holderType.prototype.valueOf = function() {
                        return this.$$unwrapTrustedValue()
                    }, holderType.prototype.toString = function() {
                        return this.$$unwrapTrustedValue().toString()
                    }, holderType
                }
                $injector.has("$sanitize") && (htmlSanitizer = $injector.get("$sanitize"));
                var trustedValueHolderBase = generateHolderType(),
                    byType = {};
                return byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase), byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase), byType[SCE_CONTEXTS.MEDIA_URL] = generateHolderType(trustedValueHolderBase), byType[SCE_CONTEXTS.URL] = generateHolderType(byType[SCE_CONTEXTS.MEDIA_URL]), byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase), byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]), {
                    trustAs: function(type, trustedValue) {
                        var Constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                        if (!Constructor) throw $sceMinErr("icontext", "Attempted to trust a value in invalid context. Context: {0}; Value: {1}", type, trustedValue);
                        if (null === trustedValue || isUndefined(trustedValue) || "" === trustedValue) return trustedValue;
                        if ("string" != typeof trustedValue) throw $sceMinErr("itype", "Attempted to trust a non-string value in a content requiring a string: Context: {0}", type);
                        return new Constructor(trustedValue)
                    },
                    getTrusted: function(type, maybeTrusted) {
                        if (null === maybeTrusted || isUndefined(maybeTrusted) || "" === maybeTrusted) return maybeTrusted;
                        var constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                        if (constructor && maybeTrusted instanceof constructor) return maybeTrusted.$$unwrapTrustedValue();
                        if (isFunction(maybeTrusted.$$unwrapTrustedValue) && (maybeTrusted = maybeTrusted.$$unwrapTrustedValue()), type === SCE_CONTEXTS.MEDIA_URL || type === SCE_CONTEXTS.URL) return $$sanitizeUri(maybeTrusted.toString(), type === SCE_CONTEXTS.MEDIA_URL);
                        if (type === SCE_CONTEXTS.RESOURCE_URL) {
                            if (function(url) {
                                    var i, n, parsedUrl = urlResolve(url.toString()),
                                        allowed = !1;
                                    for (i = 0, n = trustedResourceUrlList.length; i < n; i++)
                                        if (matchUrl(trustedResourceUrlList[i], parsedUrl)) {
                                            allowed = !0;
                                            break
                                        }
                                    if (allowed)
                                        for (i = 0, n = bannedResourceUrlList.length; i < n; i++)
                                            if (matchUrl(bannedResourceUrlList[i], parsedUrl)) {
                                                allowed = !1;
                                                break
                                            }
                                    return allowed
                                }(maybeTrusted)) return maybeTrusted;
                            throw $sceMinErr("insecurl", "Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}", maybeTrusted.toString())
                        }
                        if (type === SCE_CONTEXTS.HTML) return htmlSanitizer(maybeTrusted);
                        throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.")
                    },
                    valueOf: function(maybeTrusted) {
                        return maybeTrusted instanceof trustedValueHolderBase ? maybeTrusted.$$unwrapTrustedValue() : maybeTrusted
                    }
                }
            }]
        }

        function $SceProvider() {
            var enabled = !0;
            this.enabled = function(value) {
                return arguments.length && (enabled = !!value), enabled
            }, this.$get = ["$parse", "$sceDelegate", function($parse, $sceDelegate) {
                if (enabled && msie < 8) throw $sceMinErr("iequirks", "Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks mode.  You can fix this by adding the text <!doctype html> to the top of your HTML document.  See http://docs.angularjs.org/api/ng.$sce for more information.");
                var sce = shallowCopy(SCE_CONTEXTS);
                sce.isEnabled = function() {
                    return enabled
                }, sce.trustAs = $sceDelegate.trustAs, sce.getTrusted = $sceDelegate.getTrusted, sce.valueOf = $sceDelegate.valueOf, enabled || (sce.trustAs = sce.getTrusted = function(type, value) {
                    return value
                }, sce.valueOf = identity), sce.parseAs = function(type, expr) {
                    var parsed = $parse(expr);
                    return parsed.literal && parsed.constant ? parsed : $parse(expr, (function(value) {
                        return sce.getTrusted(type, value)
                    }))
                };
                var parse = sce.parseAs,
                    getTrusted = sce.getTrusted,
                    trustAs = sce.trustAs;
                return forEach(SCE_CONTEXTS, (function(enumValue, name) {
                    var lName = lowercase(name);
                    sce[snakeToCamel("parse_as_" + lName)] = function(expr) {
                        return parse(enumValue, expr)
                    }, sce[snakeToCamel("get_trusted_" + lName)] = function(value) {
                        return getTrusted(enumValue, value)
                    }, sce[snakeToCamel("trust_as_" + lName)] = function(value) {
                        return trustAs(enumValue, value)
                    }
                })), sce
            }]
        }

        function $SnifferProvider() {
            this.$get = ["$window", "$document", function($window, $document) {
                var eventSupport = {},
                    hasHistoryPushState = !(!($window.nw && $window.nw.process) && $window.chrome && ($window.chrome.app && $window.chrome.app.runtime || !$window.chrome.app && $window.chrome.runtime && $window.chrome.runtime.id)) && $window.history && $window.history.pushState,
                    android = toInt((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]),
                    boxee = /Boxee/i.test(($window.navigator || {}).userAgent),
                    document = $document[0] || {},
                    bodyStyle = document.body && document.body.style,
                    transitions = !1,
                    animations = !1;
                return bodyStyle && (transitions = !(!("transition" in bodyStyle) && !("webkitTransition" in bodyStyle)), animations = !(!("animation" in bodyStyle) && !("webkitAnimation" in bodyStyle))), {
                    history: !(!hasHistoryPushState || android < 4 || boxee),
                    hasEvent: function(event) {
                        if ("input" === event && msie) return !1;
                        if (isUndefined(eventSupport[event])) {
                            var divElm = document.createElement("div");
                            eventSupport[event] = "on" + event in divElm
                        }
                        return eventSupport[event]
                    },
                    csp: csp(),
                    transitions: transitions,
                    animations: animations,
                    android: android
                }
            }]
        }

        function $$TaskTrackerFactoryProvider() {
            this.$get = valueFn((function(log) {
                return new TaskTracker(log)
            }))
        }

        function TaskTracker(log) {
            var taskCounts = {},
                taskCallbacks = [],
                ALL_TASKS_TYPE = this.ALL_TASKS_TYPE = "$$all$$",
                DEFAULT_TASK_TYPE = this.DEFAULT_TASK_TYPE = "$$default$$";

            function getLastCallback() {
                var cbInfo = taskCallbacks.pop();
                return cbInfo && cbInfo.cb
            }

            function getLastCallbackForType(taskType) {
                for (var i = taskCallbacks.length - 1; i >= 0; --i) {
                    var cbInfo = taskCallbacks[i];
                    if (cbInfo.type === taskType) return taskCallbacks.splice(i, 1), cbInfo.cb
                }
            }
            this.completeTask = function(fn, taskType) {
                taskType = taskType || DEFAULT_TASK_TYPE;
                try {
                    fn()
                } finally {
                    ! function(taskType) {
                        taskCounts[taskType = taskType || DEFAULT_TASK_TYPE] && (taskCounts[taskType]--, taskCounts[ALL_TASKS_TYPE]--)
                    }(taskType);
                    var countForType = taskCounts[taskType],
                        countForAll = taskCounts[ALL_TASKS_TYPE];
                    if (!countForAll || !countForType)
                        for (var nextCb, getNextCallback = countForAll ? getLastCallbackForType : getLastCallback; nextCb = getNextCallback(taskType);) try {
                            nextCb()
                        } catch (e) {
                            log.error(e)
                        }
                }
            }, this.incTaskCount = function(taskType) {
                taskCounts[taskType = taskType || DEFAULT_TASK_TYPE] = (taskCounts[taskType] || 0) + 1, taskCounts[ALL_TASKS_TYPE] = (taskCounts[ALL_TASKS_TYPE] || 0) + 1
            }, this.notifyWhenNoPendingTasks = function(callback, taskType) {
                taskCounts[taskType = taskType || ALL_TASKS_TYPE] ? taskCallbacks.push({
                    type: taskType,
                    cb: callback
                }) : callback()
            }
        }
        var $templateRequestMinErr = minErr("$templateRequest");

        function $TemplateRequestProvider() {
            var httpOptions;
            this.httpOptions = function(val) {
                return val ? (httpOptions = val, this) : httpOptions
            }, this.$get = ["$exceptionHandler", "$templateCache", "$http", "$q", "$sce", function($exceptionHandler, $templateCache, $http, $q, $sce) {
                function handleRequestFn(tpl, ignoreRequestError) {
                    handleRequestFn.totalPendingRequests++, isString(tpl) && !isUndefined($templateCache.get(tpl)) || (tpl = $sce.getTrustedResourceUrl(tpl));
                    var transformResponse = $http.defaults && $http.defaults.transformResponse;
                    return isArray(transformResponse) ? transformResponse = transformResponse.filter((function(transformer) {
                        return transformer !== defaultHttpResponseTransform
                    })) : transformResponse === defaultHttpResponseTransform && (transformResponse = null), $http.get(tpl, extend({
                        cache: $templateCache,
                        transformResponse: transformResponse
                    }, httpOptions)).finally((function() {
                        handleRequestFn.totalPendingRequests--
                    })).then((function(response) {
                        return $templateCache.put(tpl, response.data)
                    }), (function(resp) {
                        ignoreRequestError || (resp = $templateRequestMinErr("tpload", "Failed to load template: {0} (HTTP status: {1} {2})", tpl, resp.status, resp.statusText), $exceptionHandler(resp));
                        return $q.reject(resp)
                    }))
                }
                return handleRequestFn.totalPendingRequests = 0, handleRequestFn
            }]
        }

        function $$TestabilityProvider() {
            this.$get = ["$rootScope", "$browser", "$location", function($rootScope, $browser, $location) {
                var testability = {
                    findBindings: function(element, expression, opt_exactMatch) {
                        var bindings = element.getElementsByClassName("ng-binding"),
                            matches = [];
                        return forEach(bindings, (function(binding) {
                            var dataBinding = angular.element(binding).data("$binding");
                            dataBinding && forEach(dataBinding, (function(bindingName) {
                                opt_exactMatch ? new RegExp("(^|\\s)" + escapeForRegexp(expression) + "(\\s|\\||$)").test(bindingName) && matches.push(binding) : -1 !== bindingName.indexOf(expression) && matches.push(binding)
                            }))
                        })), matches
                    },
                    findModels: function(element, expression, opt_exactMatch) {
                        for (var prefixes = ["ng-", "data-ng-", "ng\\:"], p = 0; p < prefixes.length; ++p) {
                            var selector = "[" + prefixes[p] + "model" + (opt_exactMatch ? "=" : "*=") + '"' + expression + '"]',
                                elements = element.querySelectorAll(selector);
                            if (elements.length) return elements
                        }
                    },
                    getLocation: function() {
                        return $location.url()
                    },
                    setLocation: function(url) {
                        url !== $location.url() && ($location.url(url), $rootScope.$digest())
                    },
                    whenStable: function(callback) {
                        $browser.notifyWhenNoOutstandingRequests(callback)
                    }
                };
                return testability
            }]
        }
        var $timeoutMinErr = minErr("$timeout");

        function $TimeoutProvider() {
            this.$get = ["$rootScope", "$browser", "$q", "$$q", "$exceptionHandler", function($rootScope, $browser, $q, $$q, $exceptionHandler) {
                var deferreds = {};

                function timeout(fn, delay, invokeApply) {
                    isFunction(fn) || (invokeApply = delay, delay = fn, fn = noop);
                    var timeoutId, args = sliceArgs(arguments, 3),
                        skipApply = isDefined(invokeApply) && !invokeApply,
                        deferred = (skipApply ? $$q : $q).defer(),
                        promise = deferred.promise;
                    return timeoutId = $browser.defer((function() {
                        try {
                            deferred.resolve(fn.apply(null, args))
                        } catch (e) {
                            deferred.reject(e), $exceptionHandler(e)
                        } finally {
                            delete deferreds[promise.$$timeoutId]
                        }
                        skipApply || $rootScope.$apply()
                    }), delay, "$timeout"), promise.$$timeoutId = timeoutId, deferreds[timeoutId] = deferred, promise
                }
                return timeout.cancel = function(promise) {
                    if (!promise) return !1;
                    if (!promise.hasOwnProperty("$$timeoutId")) throw $timeoutMinErr("badprom", "`$timeout.cancel()` called with a promise that was not generated by `$timeout()`.");
                    if (!deferreds.hasOwnProperty(promise.$$timeoutId)) return !1;
                    var id = promise.$$timeoutId,
                        deferred = deferreds[id];
                    return markQExceptionHandled(deferred.promise), deferred.reject("canceled"), delete deferreds[id], $browser.defer.cancel(id)
                }, timeout
            }]
        }
        var baseUrlParsingNode, urlParsingNode = window.document.createElement("a"),
            originUrl = urlResolve(window.location.href);
        urlParsingNode.href = "http://[::1]";
        var ipv6InBrackets = "[::1]" === urlParsingNode.hostname;

        function urlResolve(url) {
            if (!isString(url)) return url;
            var href = url;
            msie && (urlParsingNode.setAttribute("href", href), href = urlParsingNode.href), urlParsingNode.setAttribute("href", href);
            var hostname = urlParsingNode.hostname;
            return !ipv6InBrackets && hostname.indexOf(":") > -1 && (hostname = "[" + hostname + "]"), {
                href: urlParsingNode.href,
                protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
                host: urlParsingNode.host,
                search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
                hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
                hostname: hostname,
                port: urlParsingNode.port,
                pathname: "/" === urlParsingNode.pathname.charAt(0) ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
            }
        }

        function urlsAreSameOrigin(url1, url2) {
            return url1 = urlResolve(url1), url2 = urlResolve(url2), url1.protocol === url2.protocol && url1.host === url2.host
        }

        function $WindowProvider() {
            this.$get = valueFn(window)
        }

        function $$CookieReader($document) {
            var rawDocument = $document[0] || {},
                lastCookies = {},
                lastCookieString = "";

            function safeDecodeURIComponent(str) {
                try {
                    return decodeURIComponent(str)
                } catch (e) {
                    return str
                }
            }
            return function() {
                var cookieArray, cookie, i, index, name, currentCookieString = function(rawDocument) {
                    try {
                        return rawDocument.cookie || ""
                    } catch (e) {
                        return ""
                    }
                }(rawDocument);
                if (currentCookieString !== lastCookieString)
                    for (cookieArray = (lastCookieString = currentCookieString).split("; "), lastCookies = {}, i = 0; i < cookieArray.length; i++)(index = (cookie = cookieArray[i]).indexOf("=")) > 0 && (name = safeDecodeURIComponent(cookie.substring(0, index)), isUndefined(lastCookies[name]) && (lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1))));
                return lastCookies
            }
        }

        function $$CookieReaderProvider() {
            this.$get = $$CookieReader
        }

        function $FilterProvider($provide) {
            function register(name, factory) {
                if (isObject(name)) {
                    var filters = {};
                    return forEach(name, (function(filter, key) {
                        filters[key] = register(key, filter)
                    })), filters
                }
                return $provide.factory(name + "Filter", factory)
            }
            this.register = register, this.$get = ["$injector", function($injector) {
                return function(name) {
                    return $injector.get(name + "Filter")
                }
            }], register("currency", currencyFilter), register("date", dateFilter), register("filter", filterFilter), register("json", jsonFilter), register("limitTo", limitToFilter), register("lowercase", lowercaseFilter), register("number", numberFilter), register("orderBy", orderByFilter), register("uppercase", uppercaseFilter)
        }

        function filterFilter() {
            return function(array, expression, comparator, anyPropertyKey) {
                if (!isArrayLike(array)) {
                    if (null == array) return array;
                    throw minErr("filter")("notarray", "Expected array but received: {0}", array)
                }
                var predicateFn, matchAgainstAnyProp;
                switch (anyPropertyKey = anyPropertyKey || "$", getTypeForFilter(expression)) {
                    case "function":
                        predicateFn = expression;
                        break;
                    case "boolean":
                    case "null":
                    case "number":
                    case "string":
                        matchAgainstAnyProp = !0;
                    case "object":
                        predicateFn = function(expression, comparator, anyPropertyKey, matchAgainstAnyProp) {
                            var shouldMatchPrimitives = isObject(expression) && anyPropertyKey in expression;
                            !0 === comparator ? comparator = equals : isFunction(comparator) || (comparator = function(actual, expected) {
                                return !isUndefined(actual) && (null === actual || null === expected ? actual === expected : !(isObject(expected) || isObject(actual) && !hasCustomToString(actual)) && (actual = lowercase("" + actual), expected = lowercase("" + expected), -1 !== actual.indexOf(expected)))
                            });
                            return function(item) {
                                return shouldMatchPrimitives && !isObject(item) ? deepCompare(item, expression[anyPropertyKey], comparator, anyPropertyKey, !1) : deepCompare(item, expression, comparator, anyPropertyKey, matchAgainstAnyProp)
                            }
                        }(expression, comparator, anyPropertyKey, matchAgainstAnyProp);
                        break;
                    default:
                        return array
                }
                return Array.prototype.filter.call(array, predicateFn)
            }
        }

        function deepCompare(actual, expected, comparator, anyPropertyKey, matchAgainstAnyProp, dontMatchWholeObject) {
            var actualType = getTypeForFilter(actual),
                expectedType = getTypeForFilter(expected);
            if ("string" === expectedType && "!" === expected.charAt(0)) return !deepCompare(actual, expected.substring(1), comparator, anyPropertyKey, matchAgainstAnyProp);
            if (isArray(actual)) return actual.some((function(item) {
                return deepCompare(item, expected, comparator, anyPropertyKey, matchAgainstAnyProp)
            }));
            switch (actualType) {
                case "object":
                    var key;
                    if (matchAgainstAnyProp) {
                        for (key in actual)
                            if (key.charAt && "$" !== key.charAt(0) && deepCompare(actual[key], expected, comparator, anyPropertyKey, !0)) return !0;
                        return !dontMatchWholeObject && deepCompare(actual, expected, comparator, anyPropertyKey, !1)
                    }
                    if ("object" === expectedType) {
                        for (key in expected) {
                            var expectedVal = expected[key];
                            if (!isFunction(expectedVal) && !isUndefined(expectedVal)) {
                                var matchAnyProperty = key === anyPropertyKey;
                                if (!deepCompare(matchAnyProperty ? actual : actual[key], expectedVal, comparator, anyPropertyKey, matchAnyProperty, matchAnyProperty)) return !1
                            }
                        }
                        return !0
                    }
                    return comparator(actual, expected);
                case "function":
                    return !1;
                default:
                    return comparator(actual, expected)
            }
        }

        function getTypeForFilter(val) {
            return null === val ? "null" : typeof val
        }
        $$CookieReader.$inject = ["$document"], $FilterProvider.$inject = ["$provide"];

        function currencyFilter($locale) {
            var formats = $locale.NUMBER_FORMATS;
            return function(amount, currencySymbol, fractionSize) {
                isUndefined(currencySymbol) && (currencySymbol = formats.CURRENCY_SYM), isUndefined(fractionSize) && (fractionSize = formats.PATTERNS[1].maxFrac);
                var currencySymbolRe = currencySymbol ? /\u00A4/g : /\s*\u00A4\s*/g;
                return null == amount ? amount : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).replace(currencySymbolRe, currencySymbol)
            }
        }

        function numberFilter($locale) {
            var formats = $locale.NUMBER_FORMATS;
            return function(number, fractionSize) {
                return null == number ? number : formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize)
            }
        }

        function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
            if (!isString(number) && !isNumber(number) || isNaN(number)) return "";
            var parsedNumber, isInfinity = !isFinite(number),
                isZero = !1,
                numStr = Math.abs(number) + "",
                formattedText = "";
            if (isInfinity) formattedText = "∞";
            else {
                (function(parsedNumber, fractionSize, minFrac, maxFrac) {
                    var digits = parsedNumber.d,
                        fractionLen = digits.length - parsedNumber.i,
                        roundAt = (fractionSize = isUndefined(fractionSize) ? Math.min(Math.max(minFrac, fractionLen), maxFrac) : +fractionSize) + parsedNumber.i,
                        digit = digits[roundAt];
                    if (roundAt > 0) {
                        digits.splice(Math.max(parsedNumber.i, roundAt));
                        for (var j = roundAt; j < digits.length; j++) digits[j] = 0
                    } else {
                        fractionLen = Math.max(0, fractionLen), parsedNumber.i = 1, digits.length = Math.max(1, roundAt = fractionSize + 1), digits[0] = 0;
                        for (var i = 1; i < roundAt; i++) digits[i] = 0
                    }
                    if (digit >= 5)
                        if (roundAt - 1 < 0) {
                            for (var k = 0; k > roundAt; k--) digits.unshift(0), parsedNumber.i++;
                            digits.unshift(1), parsedNumber.i++
                        } else digits[roundAt - 1]++;
                    for (; fractionLen < Math.max(0, fractionSize); fractionLen++) digits.push(0);
                    var carry = digits.reduceRight((function(carry, d, i, digits) {
                        return d += carry, digits[i] = d % 10, Math.floor(d / 10)
                    }), 0);
                    carry && (digits.unshift(carry), parsedNumber.i++)
                })(parsedNumber = function(numStr) {
                    var digits, numberOfIntegerDigits, i, j, zeros, exponent = 0;
                    for ((numberOfIntegerDigits = numStr.indexOf(".")) > -1 && (numStr = numStr.replace(".", "")), (i = numStr.search(/e/i)) > 0 ? (numberOfIntegerDigits < 0 && (numberOfIntegerDigits = i), numberOfIntegerDigits += +numStr.slice(i + 1), numStr = numStr.substring(0, i)) : numberOfIntegerDigits < 0 && (numberOfIntegerDigits = numStr.length), i = 0;
                        "0" === numStr.charAt(i); i++);
                    if (i === (zeros = numStr.length)) digits = [0], numberOfIntegerDigits = 1;
                    else {
                        for (zeros--;
                            "0" === numStr.charAt(zeros);) zeros--;
                        for (numberOfIntegerDigits -= i, digits = [], j = 0; i <= zeros; i++, j++) digits[j] = +numStr.charAt(i)
                    }
                    return numberOfIntegerDigits > 22 && (digits = digits.splice(0, 21), exponent = numberOfIntegerDigits - 1, numberOfIntegerDigits = 1), {
                        d: digits,
                        e: exponent,
                        i: numberOfIntegerDigits
                    }
                }(numStr), fractionSize, pattern.minFrac, pattern.maxFrac);
                var digits = parsedNumber.d,
                    integerLen = parsedNumber.i,
                    exponent = parsedNumber.e,
                    decimals = [];
                for (isZero = digits.reduce((function(isZero, d) {
                        return isZero && !d
                    }), !0); integerLen < 0;) digits.unshift(0), integerLen++;
                integerLen > 0 ? decimals = digits.splice(integerLen, digits.length) : (decimals = digits, digits = [0]);
                var groups = [];
                for (digits.length >= pattern.lgSize && groups.unshift(digits.splice(-pattern.lgSize, digits.length).join("")); digits.length > pattern.gSize;) groups.unshift(digits.splice(-pattern.gSize, digits.length).join(""));
                digits.length && groups.unshift(digits.join("")), formattedText = groups.join(groupSep), decimals.length && (formattedText += decimalSep + decimals.join("")), exponent && (formattedText += "e+" + exponent)
            }
            return number < 0 && !isZero ? pattern.negPre + formattedText + pattern.negSuf : pattern.posPre + formattedText + pattern.posSuf
        }

        function padNumber(num, digits, trim, negWrap) {
            var neg = "";
            for ((num < 0 || negWrap && num <= 0) && (negWrap ? num = 1 - num : (num = -num, neg = "-")), num = "" + num; num.length < digits;) num = "0" + num;
            return trim && (num = num.substr(num.length - digits)), neg + num
        }

        function dateGetter(name, size, offset, trim, negWrap) {
            return offset = offset || 0,
                function(date) {
                    var value = date["get" + name]();
                    return (offset > 0 || value > -offset) && (value += offset), 0 === value && -12 === offset && (value = 12), padNumber(value, size, trim, negWrap)
                }
        }

        function dateStrGetter(name, shortForm, standAlone) {
            return function(date, formats) {
                var value = date["get" + name]();
                return formats[uppercase((standAlone ? "STANDALONE" : "") + (shortForm ? "SHORT" : "") + name)][value]
            }
        }

        function getFirstThursdayOfYear(year) {
            var dayOfWeekOnFirst = new Date(year, 0, 1).getDay();
            return new Date(year, 0, (dayOfWeekOnFirst <= 4 ? 5 : 12) - dayOfWeekOnFirst)
        }

        function weekGetter(size) {
            return function(date) {
                var datetime, firstThurs = getFirstThursdayOfYear(date.getFullYear()),
                    diff = +(datetime = date, new Date(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + (4 - datetime.getDay()))) - +firstThurs;
                return padNumber(1 + Math.round(diff / 6048e5), size)
            }
        }

        function eraGetter(date, formats) {
            return date.getFullYear() <= 0 ? formats.ERAS[0] : formats.ERAS[1]
        }
        currencyFilter.$inject = ["$locale"], numberFilter.$inject = ["$locale"];
        var DATE_FORMATS = {
                yyyy: dateGetter("FullYear", 4, 0, !1, !0),
                yy: dateGetter("FullYear", 2, 0, !0, !0),
                y: dateGetter("FullYear", 1, 0, !1, !0),
                MMMM: dateStrGetter("Month"),
                MMM: dateStrGetter("Month", !0),
                MM: dateGetter("Month", 2, 1),
                M: dateGetter("Month", 1, 1),
                LLLL: dateStrGetter("Month", !1, !0),
                dd: dateGetter("Date", 2),
                d: dateGetter("Date", 1),
                HH: dateGetter("Hours", 2),
                H: dateGetter("Hours", 1),
                hh: dateGetter("Hours", 2, -12),
                h: dateGetter("Hours", 1, -12),
                mm: dateGetter("Minutes", 2),
                m: dateGetter("Minutes", 1),
                ss: dateGetter("Seconds", 2),
                s: dateGetter("Seconds", 1),
                sss: dateGetter("Milliseconds", 3),
                EEEE: dateStrGetter("Day"),
                EEE: dateStrGetter("Day", !0),
                a: function(date, formats) {
                    return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1]
                },
                Z: function(date, formats, offset) {
                    var zone = -1 * offset,
                        paddedZone = zone >= 0 ? "+" : "";
                    return paddedZone += padNumber(Math[zone > 0 ? "floor" : "ceil"](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2)
                },
                ww: weekGetter(2),
                w: weekGetter(1),
                G: eraGetter,
                GG: eraGetter,
                GGG: eraGetter,
                GGGG: function(date, formats) {
                    return date.getFullYear() <= 0 ? formats.ERANAMES[0] : formats.ERANAMES[1]
                }
            },
            DATE_FORMATS_SPLIT = /((?:[^yMLdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|m+|s+|a|Z|G+|w+))([\s\S]*)/,
            NUMBER_STRING = /^-?\d+$/;

        function dateFilter($locale) {
            var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
            return function(date, format, timezone) {
                var fn, match, text = "",
                    parts = [];
                if (format = format || "mediumDate", format = $locale.DATETIME_FORMATS[format] || format, isString(date) && (date = NUMBER_STRING.test(date) ? toInt(date) : function(string) {
                        var match;
                        if (match = string.match(R_ISO8601_STR)) {
                            var date = new Date(0),
                                tzHour = 0,
                                tzMin = 0,
                                dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear,
                                timeSetter = match[8] ? date.setUTCHours : date.setHours;
                            match[9] && (tzHour = toInt(match[9] + match[10]), tzMin = toInt(match[9] + match[11])), dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
                            var h = toInt(match[4] || 0) - tzHour,
                                m = toInt(match[5] || 0) - tzMin,
                                s = toInt(match[6] || 0),
                                ms = Math.round(1e3 * parseFloat("0." + (match[7] || 0)));
                            return timeSetter.call(date, h, m, s, ms), date
                        }
                        return string
                    }(date)), isNumber(date) && (date = new Date(date)), !isDate(date) || !isFinite(date.getTime())) return date;
                for (; format;)(match = DATE_FORMATS_SPLIT.exec(format)) ? format = (parts = concat(parts, match, 1)).pop() : (parts.push(format), format = null);
                var dateTimezoneOffset = date.getTimezoneOffset();
                return timezone && (dateTimezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset), date = convertTimezoneToLocal(date, timezone, !0)), forEach(parts, (function(value) {
                    text += (fn = DATE_FORMATS[value]) ? fn(date, $locale.DATETIME_FORMATS, dateTimezoneOffset) : "''" === value ? "'" : value.replace(/(^'|'$)/g, "").replace(/''/g, "'")
                })), text
            }
        }

        function jsonFilter() {
            return function(object, spacing) {
                return isUndefined(spacing) && (spacing = 2), toJson(object, spacing)
            }
        }
        dateFilter.$inject = ["$locale"];
        var lowercaseFilter = valueFn(lowercase),
            uppercaseFilter = valueFn(uppercase);

        function limitToFilter() {
            return function(input, limit, begin) {
                return limit = Math.abs(Number(limit)) === 1 / 0 ? Number(limit) : toInt(limit), isNumberNaN(limit) ? input : (isNumber(input) && (input = input.toString()), isArrayLike(input) ? (begin = (begin = !begin || isNaN(begin) ? 0 : toInt(begin)) < 0 ? Math.max(0, input.length + begin) : begin, limit >= 0 ? sliceFn(input, begin, begin + limit) : 0 === begin ? sliceFn(input, limit, input.length) : sliceFn(input, Math.max(0, begin + limit), begin)) : input)
            }
        }

        function sliceFn(input, begin, end) {
            return isString(input) ? input.slice(begin, end) : slice.call(input, begin, end)
        }

        function orderByFilter($parse) {
            return function(array, sortPredicate, reverseOrder, compareFn) {
                if (null == array) return array;
                if (!isArrayLike(array)) throw minErr("orderBy")("notarray", "Expected array but received: {0}", array);
                isArray(sortPredicate) || (sortPredicate = [sortPredicate]), 0 === sortPredicate.length && (sortPredicate = ["+"]);
                var predicates = sortPredicate.map((function(predicate) {
                        var descending = 1,
                            get = identity;
                        if (isFunction(predicate)) get = predicate;
                        else if (isString(predicate) && ("+" !== predicate.charAt(0) && "-" !== predicate.charAt(0) || (descending = "-" === predicate.charAt(0) ? -1 : 1, predicate = predicate.substring(1)), "" !== predicate && (get = $parse(predicate)).constant)) {
                            var key = get();
                            get = function(value) {
                                return value[key]
                            }
                        }
                        return {
                            get: get,
                            descending: descending
                        }
                    })),
                    descending = reverseOrder ? -1 : 1,
                    compare = isFunction(compareFn) ? compareFn : defaultCompare,
                    compareValues = Array.prototype.map.call(array, (function(value, index) {
                        return {
                            value: value,
                            tieBreaker: {
                                value: index,
                                type: "number",
                                index: index
                            },
                            predicateValues: predicates.map((function(predicate) {
                                return function(value, index) {
                                    var type = typeof value;
                                    null === value ? type = "null" : "object" === type && (value = function(value) {
                                        if (isFunction(value.valueOf) && isPrimitive(value = value.valueOf())) return value;
                                        if (hasCustomToString(value) && isPrimitive(value = value.toString())) return value;
                                        return value
                                    }(value));
                                    return {
                                        value: value,
                                        type: type,
                                        index: index
                                    }
                                }(predicate.get(value), index)
                            }))
                        }
                    }));
                return compareValues.sort((function(v1, v2) {
                    for (var i = 0, ii = predicates.length; i < ii; i++) {
                        var result = compare(v1.predicateValues[i], v2.predicateValues[i]);
                        if (result) return result * predicates[i].descending * descending
                    }
                    return (compare(v1.tieBreaker, v2.tieBreaker) || defaultCompare(v1.tieBreaker, v2.tieBreaker)) * descending
                })), array = compareValues.map((function(item) {
                    return item.value
                }))
            };

            function isPrimitive(value) {
                switch (typeof value) {
                    case "number":
                    case "boolean":
                    case "string":
                        return !0;
                    default:
                        return !1
                }
            }

            function defaultCompare(v1, v2) {
                var result = 0,
                    type1 = v1.type,
                    type2 = v2.type;
                if (type1 === type2) {
                    var value1 = v1.value,
                        value2 = v2.value;
                    "string" === type1 ? (value1 = value1.toLowerCase(), value2 = value2.toLowerCase()) : "object" === type1 && (isObject(value1) && (value1 = v1.index), isObject(value2) && (value2 = v2.index)), value1 !== value2 && (result = value1 < value2 ? -1 : 1)
                } else result = "undefined" === type1 ? 1 : "undefined" === type2 ? -1 : "null" === type1 ? 1 : "null" === type2 || type1 < type2 ? -1 : 1;
                return result
            }
        }

        function ngDirective(directive) {
            return isFunction(directive) && (directive = {
                link: directive
            }), directive.restrict = directive.restrict || "AC", valueFn(directive)
        }
        orderByFilter.$inject = ["$parse"];
        var htmlAnchorDirective = valueFn({
                restrict: "E",
                compile: function(element, attr) {
                    if (!attr.href && !attr.xlinkHref) return function(scope, element) {
                        if ("a" === element[0].nodeName.toLowerCase()) {
                            var href = "[object SVGAnimatedString]" === toString.call(element.prop("href")) ? "xlink:href" : "href";
                            element.on("click", (function(event) {
                                element.attr(href) || event.preventDefault()
                            }))
                        }
                    }
                }
            }),
            ngAttributeAliasDirectives = {};
        forEach(BOOLEAN_ATTR, (function(propName, attrName) {
            if ("multiple" !== propName) {
                var normalized = directiveNormalize("ng-" + attrName),
                    linkFn = defaultLinkFn;
                "checked" === propName && (linkFn = function(scope, element, attr) {
                    attr.ngModel !== attr[normalized] && defaultLinkFn(scope, 0, attr)
                }), ngAttributeAliasDirectives[normalized] = function() {
                    return {
                        restrict: "A",
                        priority: 100,
                        link: linkFn
                    }
                }
            }

            function defaultLinkFn(scope, element, attr) {
                scope.$watch(attr[normalized], (function(value) {
                    attr.$set(attrName, !!value)
                }))
            }
        })), forEach(ALIASED_ATTR, (function(htmlAttr, ngAttr) {
            ngAttributeAliasDirectives[ngAttr] = function() {
                return {
                    priority: 100,
                    link: function(scope, element, attr) {
                        if ("ngPattern" === ngAttr && "/" === attr.ngPattern.charAt(0)) {
                            var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
                            if (match) return void attr.$set("ngPattern", new RegExp(match[1], match[2]))
                        }
                        scope.$watch(attr[ngAttr], (function(value) {
                            attr.$set(ngAttr, value)
                        }))
                    }
                }
            }
        })), forEach(["src", "srcset", "href"], (function(attrName) {
            var normalized = directiveNormalize("ng-" + attrName);
            ngAttributeAliasDirectives[normalized] = ["$sce", function($sce) {
                return {
                    priority: 99,
                    link: function(scope, element, attr) {
                        var propName = attrName,
                            name = attrName;
                        "href" === attrName && "[object SVGAnimatedString]" === toString.call(element.prop("href")) && (name = "xlinkHref", attr.$attr[name] = "xlink:href", propName = null), attr.$set(normalized, $sce.getTrustedMediaUrl(attr[normalized])), attr.$observe(normalized, (function(value) {
                            value ? (attr.$set(name, value), msie && propName && element.prop(propName, attr[name])) : "href" === attrName && attr.$set(name, null)
                        }))
                    }
                }
            }]
        }));
        var nullFormCtrl = {
            $addControl: noop,
            $getControls: valueFn([]),
            $$renameControl: function(control, name) {
                control.$name = name
            },
            $removeControl: noop,
            $setValidity: noop,
            $setDirty: noop,
            $setPristine: noop,
            $setSubmitted: noop,
            $$setSubmitted: noop
        };

        function FormController($element, $attrs, $scope, $animate, $interpolate) {
            this.$$controls = [], this.$error = {}, this.$$success = {}, this.$pending = void 0, this.$name = $interpolate($attrs.name || $attrs.ngForm || "")($scope), this.$dirty = !1, this.$pristine = !0, this.$valid = !0, this.$invalid = !1, this.$submitted = !1, this.$$parentForm = nullFormCtrl, this.$$element = $element, this.$$animate = $animate, setupValidity(this)
        }
        FormController.$inject = ["$element", "$attrs", "$scope", "$animate", "$interpolate"], FormController.prototype = {
            $rollbackViewValue: function() {
                forEach(this.$$controls, (function(control) {
                    control.$rollbackViewValue()
                }))
            },
            $commitViewValue: function() {
                forEach(this.$$controls, (function(control) {
                    control.$commitViewValue()
                }))
            },
            $addControl: function(control) {
                assertNotHasOwnProperty(control.$name, "input"), this.$$controls.push(control), control.$name && (this[control.$name] = control), control.$$parentForm = this
            },
            $getControls: function() {
                return shallowCopy(this.$$controls)
            },
            $$renameControl: function(control, newName) {
                var oldName = control.$name;
                this[oldName] === control && delete this[oldName], this[newName] = control, control.$name = newName
            },
            $removeControl: function(control) {
                control.$name && this[control.$name] === control && delete this[control.$name], forEach(this.$pending, (function(value, name) {
                    this.$setValidity(name, null, control)
                }), this), forEach(this.$error, (function(value, name) {
                    this.$setValidity(name, null, control)
                }), this), forEach(this.$$success, (function(value, name) {
                    this.$setValidity(name, null, control)
                }), this), arrayRemove(this.$$controls, control), control.$$parentForm = nullFormCtrl
            },
            $setDirty: function() {
                this.$$animate.removeClass(this.$$element, PRISTINE_CLASS), this.$$animate.addClass(this.$$element, DIRTY_CLASS), this.$dirty = !0, this.$pristine = !1, this.$$parentForm.$setDirty()
            },
            $setPristine: function() {
                this.$$animate.setClass(this.$$element, PRISTINE_CLASS, DIRTY_CLASS + " ng-submitted"), this.$dirty = !1, this.$pristine = !0, this.$submitted = !1, forEach(this.$$controls, (function(control) {
                    control.$setPristine()
                }))
            },
            $setUntouched: function() {
                forEach(this.$$controls, (function(control) {
                    control.$setUntouched()
                }))
            },
            $setSubmitted: function() {
                for (var rootForm = this; rootForm.$$parentForm && rootForm.$$parentForm !== nullFormCtrl;) rootForm = rootForm.$$parentForm;
                rootForm.$$setSubmitted()
            },
            $$setSubmitted: function() {
                this.$$animate.addClass(this.$$element, "ng-submitted"), this.$submitted = !0, forEach(this.$$controls, (function(control) {
                    control.$$setSubmitted && control.$$setSubmitted()
                }))
            }
        }, addSetValidityMethod({
            clazz: FormController,
            set: function(object, property, controller) {
                var list = object[property];
                list ? -1 === list.indexOf(controller) && list.push(controller) : object[property] = [controller]
            },
            unset: function(object, property, controller) {
                var list = object[property];
                list && (arrayRemove(list, controller), 0 === list.length && delete object[property])
            }
        });
        var formDirectiveFactory = function(isNgForm) {
                return ["$timeout", "$parse", function($timeout, $parse) {
                    return {
                        name: "form",
                        restrict: isNgForm ? "EAC" : "E",
                        require: ["form", "^^?form"],
                        controller: FormController,
                        compile: function(formElement, attr) {
                            formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
                            var nameAttr = attr.name ? "name" : !(!isNgForm || !attr.ngForm) && "ngForm";
                            return {
                                pre: function(scope, formElement, attr, ctrls) {
                                    var controller = ctrls[0];
                                    if (!("action" in attr)) {
                                        var handleFormSubmission = function(event) {
                                            scope.$apply((function() {
                                                controller.$commitViewValue(), controller.$setSubmitted()
                                            })), event.preventDefault()
                                        };
                                        formElement[0].addEventListener("submit", handleFormSubmission), formElement.on("$destroy", (function() {
                                            $timeout((function() {
                                                formElement[0].removeEventListener("submit", handleFormSubmission)
                                            }), 0, !1)
                                        }))
                                    }(ctrls[1] || controller.$$parentForm).$addControl(controller);
                                    var setter = nameAttr ? getSetter(controller.$name) : noop;
                                    nameAttr && (setter(scope, controller), attr.$observe(nameAttr, (function(newValue) {
                                        controller.$name !== newValue && (setter(scope, void 0), controller.$$parentForm.$$renameControl(controller, newValue), (setter = getSetter(controller.$name))(scope, controller))
                                    }))), formElement.on("$destroy", (function() {
                                        controller.$$parentForm.$removeControl(controller), setter(scope, void 0), extend(controller, nullFormCtrl)
                                    }))
                                }
                            }
                        }
                    };

                    function getSetter(expression) {
                        return "" === expression ? $parse('this[""]').assign : $parse(expression).assign || noop
                    }
                }]
            },
            formDirective = formDirectiveFactory(),
            ngFormDirective = formDirectiveFactory(!0);

        function setupValidity(instance) {
            instance.$$classCache = {}, instance.$$classCache[INVALID_CLASS] = !(instance.$$classCache[VALID_CLASS] = instance.$$element.hasClass(VALID_CLASS))
        }

        function addSetValidityMethod(context) {
            var clazz = context.clazz,
                set = context.set,
                unset = context.unset;

            function cachedToggleClass(ctrl, className, switchValue) {
                switchValue && !ctrl.$$classCache[className] ? (ctrl.$$animate.addClass(ctrl.$$element, className), ctrl.$$classCache[className] = !0) : !switchValue && ctrl.$$classCache[className] && (ctrl.$$animate.removeClass(ctrl.$$element, className), ctrl.$$classCache[className] = !1)
            }

            function toggleValidationCss(ctrl, validationErrorKey, isValid) {
                validationErrorKey = validationErrorKey ? "-" + snake_case(validationErrorKey, "-") : "", cachedToggleClass(ctrl, VALID_CLASS + validationErrorKey, !0 === isValid), cachedToggleClass(ctrl, INVALID_CLASS + validationErrorKey, !1 === isValid)
            }
            clazz.prototype.$setValidity = function(validationErrorKey, state, controller) {
                var combinedState;
                isUndefined(state) ? function(ctrl, name, value, controller) {
                    ctrl[name] || (ctrl[name] = {});
                    set(ctrl[name], value, controller)
                }(this, "$pending", validationErrorKey, controller) : function(ctrl, name, value, controller) {
                    ctrl[name] && unset(ctrl[name], value, controller);
                    isObjectEmpty(ctrl[name]) && (ctrl[name] = void 0)
                }(this, "$pending", validationErrorKey, controller), isBoolean(state) ? state ? (unset(this.$error, validationErrorKey, controller), set(this.$$success, validationErrorKey, controller)) : (set(this.$error, validationErrorKey, controller), unset(this.$$success, validationErrorKey, controller)) : (unset(this.$error, validationErrorKey, controller), unset(this.$$success, validationErrorKey, controller)), this.$pending ? (cachedToggleClass(this, "ng-pending", !0), this.$valid = this.$invalid = void 0, toggleValidationCss(this, "", null)) : (cachedToggleClass(this, "ng-pending", !1), this.$valid = isObjectEmpty(this.$error), this.$invalid = !this.$valid, toggleValidationCss(this, "", this.$valid)), toggleValidationCss(this, validationErrorKey, combinedState = this.$pending && this.$pending[validationErrorKey] ? void 0 : !this.$error[validationErrorKey] && (!!this.$$success[validationErrorKey] || null)), this.$$parentForm.$setValidity(validationErrorKey, combinedState, this)
            }
        }

        function isObjectEmpty(obj) {
            if (obj)
                for (var prop in obj)
                    if (obj.hasOwnProperty(prop)) return !1;
            return !0
        }
        var ISO_DATE_REGEXP = /^\d{4,}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+(?:[+-][0-2]\d:[0-5]\d|Z)$/,
            URL_REGEXP = /^[a-z][a-z\d.+-]*:\/*(?:[^:@]+(?::[^@]+)?@)?(?:[^\s:/?#]+|\[[a-f\d:]+])(?::\d+)?(?:\/[^?#]*)?(?:\?[^#]*)?(?:#.*)?$/i,
            EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+(\.[-!#$%&'*+/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/,
            NUMBER_REGEXP = /^\s*(-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/,
            DATE_REGEXP = /^(\d{4,})-(\d{2})-(\d{2})$/,
            DATETIMELOCAL_REGEXP = /^(\d{4,})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/,
            WEEK_REGEXP = /^(\d{4,})-W(\d\d)$/,
            MONTH_REGEXP = /^(\d{4,})-(\d\d)$/,
            TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/,
            PARTIAL_VALIDATION_TYPES = createMap();
        forEach("date,datetime-local,month,time,week".split(","), (function(type) {
            PARTIAL_VALIDATION_TYPES[type] = !0
        }));
        var inputType = {
            text: function(scope, element, attr, ctrl, $sniffer, $browser) {
                baseInputType(scope, element, attr, ctrl, $sniffer, $browser), stringBasedInputType(ctrl)
            },
            date: createDateInputType("date", DATE_REGEXP, createDateParser(DATE_REGEXP, ["yyyy", "MM", "dd"]), "yyyy-MM-dd"),
            "datetime-local": createDateInputType("datetimelocal", DATETIMELOCAL_REGEXP, createDateParser(DATETIMELOCAL_REGEXP, ["yyyy", "MM", "dd", "HH", "mm", "ss", "sss"]), "yyyy-MM-ddTHH:mm:ss.sss"),
            time: createDateInputType("time", TIME_REGEXP, createDateParser(TIME_REGEXP, ["HH", "mm", "ss", "sss"]), "HH:mm:ss.sss"),
            week: createDateInputType("week", WEEK_REGEXP, (function(isoWeek, existingDate) {
                if (isDate(isoWeek)) return isoWeek;
                if (isString(isoWeek)) {
                    WEEK_REGEXP.lastIndex = 0;
                    var parts = WEEK_REGEXP.exec(isoWeek);
                    if (parts) {
                        var year = +parts[1],
                            week = +parts[2],
                            hours = 0,
                            minutes = 0,
                            seconds = 0,
                            milliseconds = 0,
                            firstThurs = getFirstThursdayOfYear(year),
                            addDays = 7 * (week - 1);
                        return existingDate && (hours = existingDate.getHours(), minutes = existingDate.getMinutes(), seconds = existingDate.getSeconds(), milliseconds = existingDate.getMilliseconds()), new Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds)
                    }
                }
                return NaN
            }), "yyyy-Www"),
            month: createDateInputType("month", MONTH_REGEXP, createDateParser(MONTH_REGEXP, ["yyyy", "MM"]), "yyyy-MM"),
            number: function(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
                var parsedMinVal;
                if (badInputChecker(scope, element, attr, ctrl, "number"), numberFormatterParser(ctrl), baseInputType(scope, element, attr, ctrl, $sniffer, $browser), isDefined(attr.min) || attr.ngMin) {
                    var minVal = attr.min || $parse(attr.ngMin)(scope);
                    parsedMinVal = parseNumberAttrVal(minVal), ctrl.$validators.min = function(modelValue, viewValue) {
                        return ctrl.$isEmpty(viewValue) || isUndefined(parsedMinVal) || viewValue >= parsedMinVal
                    }, attr.$observe("min", (function(val) {
                        val !== minVal && (parsedMinVal = parseNumberAttrVal(val), minVal = val, ctrl.$validate())
                    }))
                }
                if (isDefined(attr.max) || attr.ngMax) {
                    var maxVal = attr.max || $parse(attr.ngMax)(scope),
                        parsedMaxVal = parseNumberAttrVal(maxVal);
                    ctrl.$validators.max = function(modelValue, viewValue) {
                        return ctrl.$isEmpty(viewValue) || isUndefined(parsedMaxVal) || viewValue <= parsedMaxVal
                    }, attr.$observe("max", (function(val) {
                        val !== maxVal && (parsedMaxVal = parseNumberAttrVal(val), maxVal = val, ctrl.$validate())
                    }))
                }
                if (isDefined(attr.step) || attr.ngStep) {
                    var stepVal = attr.step || $parse(attr.ngStep)(scope),
                        parsedStepVal = parseNumberAttrVal(stepVal);
                    ctrl.$validators.step = function(modelValue, viewValue) {
                        return ctrl.$isEmpty(viewValue) || isUndefined(parsedStepVal) || isValidForStep(viewValue, parsedMinVal || 0, parsedStepVal)
                    }, attr.$observe("step", (function(val) {
                        val !== stepVal && (parsedStepVal = parseNumberAttrVal(val), stepVal = val, ctrl.$validate())
                    }))
                }
            },
            url: function(scope, element, attr, ctrl, $sniffer, $browser) {
                baseInputType(scope, element, attr, ctrl, $sniffer, $browser), stringBasedInputType(ctrl), ctrl.$validators.url = function(modelValue, viewValue) {
                    var value = modelValue || viewValue;
                    return ctrl.$isEmpty(value) || URL_REGEXP.test(value)
                }
            },
            email: function(scope, element, attr, ctrl, $sniffer, $browser) {
                baseInputType(scope, element, attr, ctrl, $sniffer, $browser), stringBasedInputType(ctrl), ctrl.$validators.email = function(modelValue, viewValue) {
                    var value = modelValue || viewValue;
                    return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value)
                }
            },
            radio: function(scope, element, attr, ctrl) {
                var doTrim = !attr.ngTrim || "false" !== trim(attr.ngTrim);
                isUndefined(attr.name) && element.attr("name", nextUid());
                element.on("change", (function(ev) {
                    var value;
                    element[0].checked && (value = attr.value, doTrim && (value = trim(value)), ctrl.$setViewValue(value, ev && ev.type))
                })), ctrl.$render = function() {
                    var value = attr.value;
                    doTrim && (value = trim(value)), element[0].checked = value === ctrl.$viewValue
                }, attr.$observe("value", ctrl.$render)
            },
            range: function(scope, element, attr, ctrl, $sniffer, $browser) {
                badInputChecker(scope, element, attr, ctrl, "range"), numberFormatterParser(ctrl), baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
                var supportsRange = ctrl.$$hasNativeValidators && "range" === element[0].type,
                    minVal = supportsRange ? 0 : void 0,
                    maxVal = supportsRange ? 100 : void 0,
                    stepVal = supportsRange ? 1 : void 0,
                    validity = element[0].validity,
                    hasMinAttr = isDefined(attr.min),
                    hasMaxAttr = isDefined(attr.max),
                    hasStepAttr = isDefined(attr.step),
                    originalRender = ctrl.$render;
                ctrl.$render = supportsRange && isDefined(validity.rangeUnderflow) && isDefined(validity.rangeOverflow) ? function() {
                    originalRender(), ctrl.$setViewValue(element.val())
                } : originalRender, hasMinAttr && (minVal = parseNumberAttrVal(attr.min), ctrl.$validators.min = supportsRange ? function() {
                    return !0
                } : function(modelValue, viewValue) {
                    return ctrl.$isEmpty(viewValue) || isUndefined(minVal) || viewValue >= minVal
                }, setInitialValueAndObserver("min", (function(val) {
                    if (minVal = parseNumberAttrVal(val), isNumberNaN(ctrl.$modelValue)) return;
                    if (supportsRange) {
                        var elVal = element.val();
                        minVal > elVal && (elVal = minVal, element.val(elVal)), ctrl.$setViewValue(elVal)
                    } else ctrl.$validate()
                })));
                hasMaxAttr && (maxVal = parseNumberAttrVal(attr.max), ctrl.$validators.max = supportsRange ? function() {
                    return !0
                } : function(modelValue, viewValue) {
                    return ctrl.$isEmpty(viewValue) || isUndefined(maxVal) || viewValue <= maxVal
                }, setInitialValueAndObserver("max", (function(val) {
                    if (maxVal = parseNumberAttrVal(val), isNumberNaN(ctrl.$modelValue)) return;
                    if (supportsRange) {
                        var elVal = element.val();
                        maxVal < elVal && (element.val(maxVal), elVal = maxVal < minVal ? minVal : maxVal), ctrl.$setViewValue(elVal)
                    } else ctrl.$validate()
                })));
                hasStepAttr && (stepVal = parseNumberAttrVal(attr.step), ctrl.$validators.step = supportsRange ? function() {
                    return !validity.stepMismatch
                } : function(modelValue, viewValue) {
                    return ctrl.$isEmpty(viewValue) || isUndefined(stepVal) || isValidForStep(viewValue, minVal || 0, stepVal)
                }, setInitialValueAndObserver("step", (function(val) {
                    if (stepVal = parseNumberAttrVal(val), isNumberNaN(ctrl.$modelValue)) return;
                    supportsRange ? ctrl.$viewValue !== element.val() && ctrl.$setViewValue(element.val()) : ctrl.$validate()
                })));

                function setInitialValueAndObserver(htmlAttrName, changeFn) {
                    element.attr(htmlAttrName, attr[htmlAttrName]);
                    var oldVal = attr[htmlAttrName];
                    attr.$observe(htmlAttrName, (function(val) {
                        val !== oldVal && (oldVal = val, changeFn(val))
                    }))
                }
            },
            checkbox: function(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
                var trueValue = parseConstantExpr($parse, scope, "ngTrueValue", attr.ngTrueValue, !0),
                    falseValue = parseConstantExpr($parse, scope, "ngFalseValue", attr.ngFalseValue, !1);
                element.on("change", (function(ev) {
                    ctrl.$setViewValue(element[0].checked, ev && ev.type)
                })), ctrl.$render = function() {
                    element[0].checked = ctrl.$viewValue
                }, ctrl.$isEmpty = function(value) {
                    return !1 === value
                }, ctrl.$formatters.push((function(value) {
                    return equals(value, trueValue)
                })), ctrl.$parsers.push((function(value) {
                    return value ? trueValue : falseValue
                }))
            },
            hidden: noop,
            button: noop,
            submit: noop,
            reset: noop,
            file: noop
        };

        function stringBasedInputType(ctrl) {
            ctrl.$formatters.push((function(value) {
                return ctrl.$isEmpty(value) ? value : value.toString()
            }))
        }

        function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {
            var timeout, type = lowercase(element[0].type);
            if (!$sniffer.android) {
                var composing = !1;
                element.on("compositionstart", (function() {
                    composing = !0
                })), element.on("compositionupdate", (function(ev) {
                    (isUndefined(ev.data) || "" === ev.data) && (composing = !1)
                })), element.on("compositionend", (function() {
                    composing = !1, listener()
                }))
            }
            var listener = function(ev) {
                if (timeout && ($browser.defer.cancel(timeout), timeout = null), !composing) {
                    var value = element.val(),
                        event = ev && ev.type;
                    "password" === type || attr.ngTrim && "false" === attr.ngTrim || (value = trim(value)), (ctrl.$viewValue !== value || "" === value && ctrl.$$hasNativeValidators) && ctrl.$setViewValue(value, event)
                }
            };
            if ($sniffer.hasEvent("input")) element.on("input", listener);
            else {
                var deferListener = function(ev, input, origValue) {
                    timeout || (timeout = $browser.defer((function() {
                        timeout = null, input && input.value === origValue || listener(ev)
                    })))
                };
                element.on("keydown", (function(event) {
                    var key = event.keyCode;
                    91 === key || 15 < key && key < 19 || 37 <= key && key <= 40 || deferListener(event, this, this.value)
                })), $sniffer.hasEvent("paste") && element.on("paste cut drop", deferListener)
            }
            element.on("change", listener), PARTIAL_VALIDATION_TYPES[type] && ctrl.$$hasNativeValidators && type === attr.type && element.on("keydown wheel mousedown", (function(ev) {
                if (!timeout) {
                    var validity = this.validity,
                        origBadInput = validity.badInput,
                        origTypeMismatch = validity.typeMismatch;
                    timeout = $browser.defer((function() {
                        timeout = null, validity.badInput === origBadInput && validity.typeMismatch === origTypeMismatch || listener(ev)
                    }))
                }
            })), ctrl.$render = function() {
                var value = ctrl.$isEmpty(ctrl.$viewValue) ? "" : ctrl.$viewValue;
                element.val() !== value && element.val(value)
            }
        }

        function createDateParser(regexp, mapping) {
            return function(iso, previousDate) {
                var parts, map;
                if (isDate(iso)) return iso;
                if (isString(iso)) {
                    if ('"' === iso.charAt(0) && '"' === iso.charAt(iso.length - 1) && (iso = iso.substring(1, iso.length - 1)), ISO_DATE_REGEXP.test(iso)) return new Date(iso);
                    if (regexp.lastIndex = 0, parts = regexp.exec(iso)) {
                        parts.shift(), map = previousDate ? {
                            yyyy: previousDate.getFullYear(),
                            MM: previousDate.getMonth() + 1,
                            dd: previousDate.getDate(),
                            HH: previousDate.getHours(),
                            mm: previousDate.getMinutes(),
                            ss: previousDate.getSeconds(),
                            sss: previousDate.getMilliseconds() / 1e3
                        } : {
                            yyyy: 1970,
                            MM: 1,
                            dd: 1,
                            HH: 0,
                            mm: 0,
                            ss: 0,
                            sss: 0
                        }, forEach(parts, (function(part, index) {
                            index < mapping.length && (map[mapping[index]] = +part)
                        }));
                        var date = new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, 1e3 * map.sss || 0);
                        return map.yyyy < 100 && date.setFullYear(map.yyyy), date
                    }
                }
                return NaN
            }
        }

        function createDateInputType(type, regexp, parseDate, format) {
            return function(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
                badInputChecker(scope, element, attr, ctrl, type), baseInputType(0, element, attr, ctrl, $sniffer, $browser);
                var previousDate, previousTimezone, isTimeType = "time" === type || "datetimelocal" === type;
                if (ctrl.$parsers.push((function(value) {
                        return ctrl.$isEmpty(value) ? null : regexp.test(value) ? parseDateAndConvertTimeZoneToLocal(value, previousDate) : void(ctrl.$$parserName = type)
                    })), ctrl.$formatters.push((function(value) {
                        if (value && !isDate(value)) throw ngModelMinErr("datefmt", "Expected `{0}` to be a date", value);
                        if (isValidDate(value)) {
                            previousDate = value;
                            var timezone = ctrl.$options.getOption("timezone");
                            return timezone && (previousTimezone = timezone, previousDate = convertTimezoneToLocal(previousDate, timezone, !0)),
                                function(value, timezone) {
                                    var targetFormat = format;
                                    isTimeType && isString(ctrl.$options.getOption("timeSecondsFormat")) && (targetFormat = format.replace("ss.sss", ctrl.$options.getOption("timeSecondsFormat")).replace(/:$/, ""));
                                    var formatted = $filter("date")(value, targetFormat, timezone);
                                    isTimeType && ctrl.$options.getOption("timeStripZeroSeconds") && (formatted = formatted.replace(/(?::00)?(?:\.000)?$/, ""));
                                    return formatted
                                }(value, timezone)
                        }
                        return previousDate = null, previousTimezone = null, ""
                    })), isDefined(attr.min) || attr.ngMin) {
                    var minVal = attr.min || $parse(attr.ngMin)(scope),
                        parsedMinVal = parseObservedDateValue(minVal);
                    ctrl.$validators.min = function(value) {
                        return !isValidDate(value) || isUndefined(parsedMinVal) || parseDate(value) >= parsedMinVal
                    }, attr.$observe("min", (function(val) {
                        val !== minVal && (parsedMinVal = parseObservedDateValue(val), minVal = val, ctrl.$validate())
                    }))
                }
                if (isDefined(attr.max) || attr.ngMax) {
                    var maxVal = attr.max || $parse(attr.ngMax)(scope),
                        parsedMaxVal = parseObservedDateValue(maxVal);
                    ctrl.$validators.max = function(value) {
                        return !isValidDate(value) || isUndefined(parsedMaxVal) || parseDate(value) <= parsedMaxVal
                    }, attr.$observe("max", (function(val) {
                        val !== maxVal && (parsedMaxVal = parseObservedDateValue(val), maxVal = val, ctrl.$validate())
                    }))
                }

                function isValidDate(value) {
                    return value && !(value.getTime && value.getTime() != value.getTime())
                }

                function parseObservedDateValue(val) {
                    return isDefined(val) && !isDate(val) ? parseDateAndConvertTimeZoneToLocal(val) || void 0 : val
                }

                function parseDateAndConvertTimeZoneToLocal(value, previousDate) {
                    var timezone = ctrl.$options.getOption("timezone");
                    previousTimezone && previousTimezone !== timezone && (previousDate = addDateMinutes(previousDate, timezoneToOffset(previousTimezone)));
                    var parsedDate = parseDate(value, previousDate);
                    return !isNaN(parsedDate) && timezone && (parsedDate = convertTimezoneToLocal(parsedDate, timezone)), parsedDate
                }
            }
        }

        function badInputChecker(scope, element, attr, ctrl, parserName) {
            var node = element[0];
            (ctrl.$$hasNativeValidators = isObject(node.validity)) && ctrl.$parsers.push((function(value) {
                var validity = element.prop("validity") || {};
                if (!validity.badInput && !validity.typeMismatch) return value;
                ctrl.$$parserName = parserName
            }))
        }

        function numberFormatterParser(ctrl) {
            ctrl.$parsers.push((function(value) {
                return ctrl.$isEmpty(value) ? null : NUMBER_REGEXP.test(value) ? parseFloat(value) : void(ctrl.$$parserName = "number")
            })), ctrl.$formatters.push((function(value) {
                if (!ctrl.$isEmpty(value)) {
                    if (!isNumber(value)) throw ngModelMinErr("numfmt", "Expected `{0}` to be a number", value);
                    value = value.toString()
                }
                return value
            }))
        }

        function parseNumberAttrVal(val) {
            return isDefined(val) && !isNumber(val) && (val = parseFloat(val)), isNumberNaN(val) ? void 0 : val
        }

        function isNumberInteger(num) {
            return (0 | num) === num
        }

        function countDecimals(num) {
            var numString = num.toString(),
                decimalSymbolIndex = numString.indexOf(".");
            if (-1 === decimalSymbolIndex) {
                if (-1 < num && num < 1) {
                    var match = /e-(\d+)$/.exec(numString);
                    if (match) return Number(match[1])
                }
                return 0
            }
            return numString.length - decimalSymbolIndex - 1
        }

        function isValidForStep(viewValue, stepBase, step) {
            var value = Number(viewValue),
                isNonIntegerValue = !isNumberInteger(value),
                isNonIntegerStepBase = !isNumberInteger(stepBase),
                isNonIntegerStep = !isNumberInteger(step);
            if (isNonIntegerValue || isNonIntegerStepBase || isNonIntegerStep) {
                var valueDecimals = isNonIntegerValue ? countDecimals(value) : 0,
                    stepBaseDecimals = isNonIntegerStepBase ? countDecimals(stepBase) : 0,
                    stepDecimals = isNonIntegerStep ? countDecimals(step) : 0,
                    decimalCount = Math.max(valueDecimals, stepBaseDecimals, stepDecimals),
                    multiplier = Math.pow(10, decimalCount);
                value *= multiplier, stepBase *= multiplier, step *= multiplier, isNonIntegerValue && (value = Math.round(value)), isNonIntegerStepBase && (stepBase = Math.round(stepBase)), isNonIntegerStep && (step = Math.round(step))
            }
            return (value - stepBase) % step == 0
        }

        function parseConstantExpr($parse, context, name, expression, fallback) {
            var parseFn;
            if (isDefined(expression)) {
                if (!(parseFn = $parse(expression)).constant) throw ngModelMinErr("constexpr", "Expected constant expression for `{0}`, but saw `{1}`.", name, expression);
                return parseFn(context)
            }
            return fallback
        }
        var inputDirective = ["$browser", "$sniffer", "$filter", "$parse", function($browser, $sniffer, $filter, $parse) {
                return {
                    restrict: "E",
                    require: ["?ngModel"],
                    link: {
                        pre: function(scope, element, attr, ctrls) {
                            ctrls[0] && (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer, $browser, $filter, $parse)
                        }
                    }
                }
            }],
            hiddenInputBrowserCacheDirective = function() {
                var valueProperty = {
                    configurable: !0,
                    enumerable: !1,
                    get: function() {
                        return this.getAttribute("value") || ""
                    },
                    set: function(val) {
                        this.setAttribute("value", val)
                    }
                };
                return {
                    restrict: "E",
                    priority: 200,
                    compile: function(_, attr) {
                        if ("hidden" === lowercase(attr.type)) return {
                            pre: function(scope, element, attr, ctrls) {
                                var node = element[0];
                                node.parentNode && node.parentNode.insertBefore(node, node.nextSibling), Object.defineProperty && Object.defineProperty(node, "value", valueProperty)
                            }
                        }
                    }
                }
            },
            CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/,
            ngValueDirective = function() {
                function updateElementValue(element, attr, value) {
                    var propValue = isDefined(value) ? value : 9 === msie ? "" : null;
                    element.prop("value", propValue), attr.$set("value", value)
                }
                return {
                    restrict: "A",
                    priority: 100,
                    compile: function(tpl, tplAttr) {
                        return CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue) ? function(scope, elm, attr) {
                            updateElementValue(elm, attr, scope.$eval(attr.ngValue))
                        } : function(scope, elm, attr) {
                            scope.$watch(attr.ngValue, (function(value) {
                                updateElementValue(elm, attr, value)
                            }))
                        }
                    }
                }
            },
            ngBindDirective = ["$compile", function($compile) {
                return {
                    restrict: "AC",
                    compile: function(templateElement) {
                        return $compile.$$addBindingClass(templateElement),
                            function(scope, element, attr) {
                                $compile.$$addBindingInfo(element, attr.ngBind), element = element[0], scope.$watch(attr.ngBind, (function(value) {
                                    element.textContent = stringify(value)
                                }))
                            }
                    }
                }
            }],
            ngBindTemplateDirective = ["$interpolate", "$compile", function($interpolate, $compile) {
                return {
                    compile: function(templateElement) {
                        return $compile.$$addBindingClass(templateElement),
                            function(scope, element, attr) {
                                var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
                                $compile.$$addBindingInfo(element, interpolateFn.expressions), element = element[0], attr.$observe("ngBindTemplate", (function(value) {
                                    element.textContent = isUndefined(value) ? "" : value
                                }))
                            }
                    }
                }
            }],
            ngBindHtmlDirective = ["$sce", "$parse", "$compile", function($sce, $parse, $compile) {
                return {
                    restrict: "A",
                    compile: function(tElement, tAttrs) {
                        var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml),
                            ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, (function(val) {
                                return $sce.valueOf(val)
                            }));
                        return $compile.$$addBindingClass(tElement),
                            function(scope, element, attr) {
                                $compile.$$addBindingInfo(element, attr.ngBindHtml), scope.$watch(ngBindHtmlWatch, (function() {
                                    var value = ngBindHtmlGetter(scope);
                                    element.html($sce.getTrustedHtml(value) || "")
                                }))
                            }
                    }
                }
            }],
            ngChangeDirective = valueFn({
                restrict: "A",
                require: "ngModel",
                link: function(scope, element, attr, ctrl) {
                    ctrl.$viewChangeListeners.push((function() {
                        scope.$eval(attr.ngChange)
                    }))
                }
            });

        function classDirective(name, selector) {
            var indexWatchExpression;
            return name = "ngClass" + name, ["$parse", function($parse) {
                return {
                    restrict: "AC",
                    link: function(scope, element, attr) {
                        var oldClassString, classCounts = element.data("$classCounts"),
                            oldModulo = !0;

                        function digestClassCounts(classArray, count) {
                            var classesToUpdate = [];
                            return forEach(classArray, (function(className) {
                                (count > 0 || classCounts[className]) && (classCounts[className] = (classCounts[className] || 0) + count, classCounts[className] === +(count > 0) && classesToUpdate.push(className))
                            })), classesToUpdate.join(" ")
                        }
                        classCounts || (classCounts = createMap(), element.data("$classCounts", classCounts)), "ngClass" !== name && (indexWatchExpression || (indexWatchExpression = $parse("$index", (function($index) {
                            return 1 & $index
                        }))), scope.$watch(indexWatchExpression, (function(newModulo) {
                            newModulo === selector ? (classString = digestClassCounts(split(classString = oldClassString), 1), attr.$addClass(classString)) : function(classString) {
                                classString = digestClassCounts(split(classString), -1), attr.$removeClass(classString)
                            }(oldClassString);
                            var classString;
                            oldModulo = newModulo
                        }))), scope.$watch($parse(attr[name], toClassString), (function(newClassString) {
                            oldModulo === selector && function(oldClassString, newClassString) {
                                var oldClassArray = split(oldClassString),
                                    newClassArray = split(newClassString),
                                    toRemoveArray = arrayDifference(oldClassArray, newClassArray),
                                    toAddArray = arrayDifference(newClassArray, oldClassArray),
                                    toRemoveString = digestClassCounts(toRemoveArray, -1),
                                    toAddString = digestClassCounts(toAddArray, 1);
                                attr.$addClass(toAddString), attr.$removeClass(toRemoveString)
                            }(oldClassString, newClassString);
                            oldClassString = newClassString
                        }))
                    }
                }
            }];

            function arrayDifference(tokens1, tokens2) {
                if (!tokens1 || !tokens1.length) return [];
                if (!tokens2 || !tokens2.length) return tokens1;
                var values = [];
                outer: for (var i = 0; i < tokens1.length; i++) {
                    for (var token = tokens1[i], j = 0; j < tokens2.length; j++)
                        if (token === tokens2[j]) continue outer;
                    values.push(token)
                }
                return values
            }

            function split(classString) {
                return classString && classString.split(" ")
            }

            function toClassString(classValue) {
                if (!classValue) return classValue;
                var classString = classValue;
                return isArray(classValue) ? classString = classValue.map(toClassString).join(" ") : isObject(classValue) ? classString = Object.keys(classValue).filter((function(key) {
                    return classValue[key]
                })).join(" ") : isString(classValue) || (classString = classValue + ""), classString
            }
        }
        var ngClassDirective = classDirective("", !0),
            ngClassOddDirective = classDirective("Odd", 0),
            ngClassEvenDirective = classDirective("Even", 1),
            ngCloakDirective = ngDirective({
                compile: function(element, attr) {
                    attr.$set("ngCloak", void 0), element.removeClass("ng-cloak")
                }
            }),
            ngControllerDirective = [function() {
                return {
                    restrict: "A",
                    scope: !0,
                    controller: "@",
                    priority: 500
                }
            }],
            ngEventDirectives = {},
            forceAsyncEvents = {
                blur: !0,
                focus: !0
            };

        function createEventDirective($parse, $rootScope, $exceptionHandler, directiveName, eventName, forceAsync) {
            return {
                restrict: "A",
                compile: function($element, attr) {
                    var fn = $parse(attr[directiveName]);
                    return function(scope, element) {
                        element.on(eventName, (function(event) {
                            var callback = function() {
                                fn(scope, {
                                    $event: event
                                })
                            };
                            if ($rootScope.$$phase)
                                if (forceAsync) scope.$evalAsync(callback);
                                else try {
                                    callback()
                                } catch (error) {
                                    $exceptionHandler(error)
                                } else scope.$apply(callback)
                        }))
                    }
                }
            }
        }
        forEach("click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste".split(" "), (function(eventName) {
            var directiveName = directiveNormalize("ng-" + eventName);
            ngEventDirectives[directiveName] = ["$parse", "$rootScope", "$exceptionHandler", function($parse, $rootScope, $exceptionHandler) {
                return createEventDirective($parse, $rootScope, $exceptionHandler, directiveName, eventName, forceAsyncEvents[eventName])
            }]
        }));
        var ngIfDirective = ["$animate", "$compile", function($animate, $compile) {
                return {
                    multiElement: !0,
                    transclude: "element",
                    priority: 600,
                    terminal: !0,
                    restrict: "A",
                    $$tlb: !0,
                    link: function($scope, $element, $attr, ctrl, $transclude) {
                        var block, childScope, previousElements;
                        $scope.$watch($attr.ngIf, (function(value) {
                            value ? childScope || $transclude((function(clone, newScope) {
                                childScope = newScope, clone[clone.length++] = $compile.$$createComment("end ngIf", $attr.ngIf), block = {
                                    clone: clone
                                }, $animate.enter(clone, $element.parent(), $element)
                            })) : (previousElements && (previousElements.remove(), previousElements = null), childScope && (childScope.$destroy(), childScope = null), block && (previousElements = getBlockNodes(block.clone), $animate.leave(previousElements).done((function(response) {
                                !1 !== response && (previousElements = null)
                            })), block = null))
                        }))
                    }
                }
            }],
            ngIncludeDirective = ["$templateRequest", "$anchorScroll", "$animate", function($templateRequest, $anchorScroll, $animate) {
                return {
                    restrict: "ECA",
                    priority: 400,
                    terminal: !0,
                    transclude: "element",
                    controller: angular.noop,
                    compile: function(element, attr) {
                        var srcExp = attr.ngInclude || attr.src,
                            onloadExp = attr.onload || "",
                            autoScrollExp = attr.autoscroll;
                        return function(scope, $element, $attr, ctrl, $transclude) {
                            var currentScope, previousElement, currentElement, changeCounter = 0,
                                cleanupLastIncludeContent = function() {
                                    previousElement && (previousElement.remove(), previousElement = null), currentScope && (currentScope.$destroy(), currentScope = null), currentElement && ($animate.leave(currentElement).done((function(response) {
                                        !1 !== response && (previousElement = null)
                                    })), previousElement = currentElement, currentElement = null)
                                };
                            scope.$watch(srcExp, (function(src) {
                                var afterAnimation = function(response) {
                                        !1 === response || !isDefined(autoScrollExp) || autoScrollExp && !scope.$eval(autoScrollExp) || $anchorScroll()
                                    },
                                    thisChangeId = ++changeCounter;
                                src ? ($templateRequest(src, !0).then((function(response) {
                                    if (!scope.$$destroyed && thisChangeId === changeCounter) {
                                        var newScope = scope.$new();
                                        ctrl.template = response;
                                        var clone = $transclude(newScope, (function(clone) {
                                            cleanupLastIncludeContent(), $animate.enter(clone, null, $element).done(afterAnimation)
                                        }));
                                        currentElement = clone, (currentScope = newScope).$emit("$includeContentLoaded", src), scope.$eval(onloadExp)
                                    }
                                }), (function() {
                                    scope.$$destroyed || thisChangeId === changeCounter && (cleanupLastIncludeContent(), scope.$emit("$includeContentError", src))
                                })), scope.$emit("$includeContentRequested", src)) : (cleanupLastIncludeContent(), ctrl.template = null)
                            }))
                        }
                    }
                }
            }],
            ngIncludeFillContentDirective = ["$compile", function($compile) {
                return {
                    restrict: "ECA",
                    priority: -400,
                    require: "ngInclude",
                    link: function(scope, $element, $attr, ctrl) {
                        if (toString.call($element[0]).match(/SVG/)) return $element.empty(), void $compile(jqLiteBuildFragment(ctrl.template, window.document).childNodes)(scope, (function(clone) {
                            $element.append(clone)
                        }), {
                            futureParentElement: $element
                        });
                        $element.html(ctrl.template), $compile($element.contents())(scope)
                    }
                }
            }],
            ngInitDirective = ngDirective({
                priority: 450,
                compile: function() {
                    return {
                        pre: function(scope, element, attrs) {
                            scope.$eval(attrs.ngInit)
                        }
                    }
                }
            }),
            ngListDirective = function() {
                return {
                    restrict: "A",
                    priority: 100,
                    require: "ngModel",
                    link: function(scope, element, attr, ctrl) {
                        var ngList = attr.ngList || ", ",
                            trimValues = "false" !== attr.ngTrim,
                            separator = trimValues ? trim(ngList) : ngList;
                        ctrl.$parsers.push((function(viewValue) {
                            if (!isUndefined(viewValue)) {
                                var list = [];
                                return viewValue && forEach(viewValue.split(separator), (function(value) {
                                    value && list.push(trimValues ? trim(value) : value)
                                })), list
                            }
                        })), ctrl.$formatters.push((function(value) {
                            if (isArray(value)) return value.join(ngList)
                        })), ctrl.$isEmpty = function(value) {
                            return !value || !value.length
                        }
                    }
                }
            },
            VALID_CLASS = "ng-valid",
            INVALID_CLASS = "ng-invalid",
            PRISTINE_CLASS = "ng-pristine",
            DIRTY_CLASS = "ng-dirty",
            ngModelMinErr = minErr("ngModel");

        function NgModelController($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $q, $interpolate) {
            var ctrl;
            this.$viewValue = Number.NaN, this.$modelValue = Number.NaN, this.$$rawModelValue = void 0, this.$validators = {}, this.$asyncValidators = {}, this.$parsers = [], this.$formatters = [], this.$viewChangeListeners = [], this.$untouched = !0, this.$touched = !1, this.$pristine = !0, this.$dirty = !1, this.$valid = !0, this.$invalid = !1, this.$error = {}, this.$$success = {}, this.$pending = void 0, this.$name = $interpolate($attr.name || "", !1)($scope), this.$$parentForm = nullFormCtrl, this.$options = defaultModelOptions, this.$$updateEvents = "", this.$$updateEventHandler = this.$$updateEventHandler.bind(this), this.$$parsedNgModel = $parse($attr.ngModel), this.$$parsedNgModelAssign = this.$$parsedNgModel.assign, this.$$ngModelGet = this.$$parsedNgModel, this.$$ngModelSet = this.$$parsedNgModelAssign, this.$$pendingDebounce = null, this.$$parserValid = void 0, this.$$parserName = "parse", this.$$currentValidationRunId = 0, this.$$scope = $scope, this.$$rootScope = $scope.$root, this.$$attr = $attr, this.$$element = $element, this.$$animate = $animate, this.$$timeout = $timeout, this.$$parse = $parse, this.$$q = $q, this.$$exceptionHandler = $exceptionHandler, setupValidity(this), (ctrl = this).$$scope.$watch((function(scope) {
                var modelValue = ctrl.$$ngModelGet(scope);
                return modelValue === ctrl.$modelValue || ctrl.$modelValue != ctrl.$modelValue && modelValue != modelValue || ctrl.$$setModelValue(modelValue), modelValue
            }))
        }
        NgModelController.$inject = ["$scope", "$exceptionHandler", "$attrs", "$element", "$parse", "$animate", "$timeout", "$q", "$interpolate"], NgModelController.prototype = {
            $$initGetterSetters: function() {
                if (this.$options.getOption("getterSetter")) {
                    var invokeModelGetter = this.$$parse(this.$$attr.ngModel + "()"),
                        invokeModelSetter = this.$$parse(this.$$attr.ngModel + "($$$p)");
                    this.$$ngModelGet = function($scope) {
                        var modelValue = this.$$parsedNgModel($scope);
                        return isFunction(modelValue) && (modelValue = invokeModelGetter($scope)), modelValue
                    }, this.$$ngModelSet = function($scope, newValue) {
                        isFunction(this.$$parsedNgModel($scope)) ? invokeModelSetter($scope, {
                            $$$p: newValue
                        }) : this.$$parsedNgModelAssign($scope, newValue)
                    }
                } else if (!this.$$parsedNgModel.assign) throw ngModelMinErr("nonassign", "Expression '{0}' is non-assignable. Element: {1}", this.$$attr.ngModel, startingTag(this.$$element))
            },
            $render: noop,
            $isEmpty: function(value) {
                return isUndefined(value) || "" === value || null === value || value != value
            },
            $$updateEmptyClasses: function(value) {
                this.$isEmpty(value) ? (this.$$animate.removeClass(this.$$element, "ng-not-empty"), this.$$animate.addClass(this.$$element, "ng-empty")) : (this.$$animate.removeClass(this.$$element, "ng-empty"), this.$$animate.addClass(this.$$element, "ng-not-empty"))
            },
            $setPristine: function() {
                this.$dirty = !1, this.$pristine = !0, this.$$animate.removeClass(this.$$element, DIRTY_CLASS), this.$$animate.addClass(this.$$element, PRISTINE_CLASS)
            },
            $setDirty: function() {
                this.$dirty = !0, this.$pristine = !1, this.$$animate.removeClass(this.$$element, PRISTINE_CLASS), this.$$animate.addClass(this.$$element, DIRTY_CLASS), this.$$parentForm.$setDirty()
            },
            $setUntouched: function() {
                this.$touched = !1, this.$untouched = !0, this.$$animate.setClass(this.$$element, "ng-untouched", "ng-touched")
            },
            $setTouched: function() {
                this.$touched = !0, this.$untouched = !1, this.$$animate.setClass(this.$$element, "ng-touched", "ng-untouched")
            },
            $rollbackViewValue: function() {
                this.$$timeout.cancel(this.$$pendingDebounce), this.$viewValue = this.$$lastCommittedViewValue, this.$render()
            },
            $validate: function() {
                if (!isNumberNaN(this.$modelValue)) {
                    var viewValue = this.$$lastCommittedViewValue,
                        modelValue = this.$$rawModelValue,
                        prevValid = this.$valid,
                        prevModelValue = this.$modelValue,
                        allowInvalid = this.$options.getOption("allowInvalid"),
                        that = this;
                    this.$$runValidators(modelValue, viewValue, (function(allValid) {
                        allowInvalid || prevValid === allValid || (that.$modelValue = allValid ? modelValue : void 0, that.$modelValue !== prevModelValue && that.$$writeModelToScope())
                    }))
                }
            },
            $$runValidators: function(modelValue, viewValue, doneCallback) {
                this.$$currentValidationRunId++;
                var validatorPromises, allValid, localValidationRunId = this.$$currentValidationRunId,
                    that = this;
                (function() {
                    var errorKey = that.$$parserName;
                    if (!isUndefined(that.$$parserValid)) return that.$$parserValid || (forEach(that.$validators, (function(v, name) {
                        setValidity(name, null)
                    })), forEach(that.$asyncValidators, (function(v, name) {
                        setValidity(name, null)
                    }))), setValidity(errorKey, that.$$parserValid), that.$$parserValid;
                    setValidity(errorKey, null);
                    return !0
                })() ? ! function() {
                    var syncValidatorsValid = !0;
                    if (forEach(that.$validators, (function(validator, name) {
                            var result = Boolean(validator(modelValue, viewValue));
                            syncValidatorsValid = syncValidatorsValid && result, setValidity(name, result)
                        })), !syncValidatorsValid) return forEach(that.$asyncValidators, (function(v, name) {
                        setValidity(name, null)
                    })), !1;
                    return !0
                }() ? validationDone(!1): (validatorPromises = [], allValid = !0, forEach(that.$asyncValidators, (function(validator, name) {
                    var promise = validator(modelValue, viewValue);
                    if (!isPromiseLike(promise)) throw ngModelMinErr("nopromise", "Expected asynchronous validator to return a promise but got '{0}' instead.", promise);
                    setValidity(name, void 0), validatorPromises.push(promise.then((function() {
                        setValidity(name, !0)
                    }), (function() {
                        allValid = !1, setValidity(name, !1)
                    })))
                })), validatorPromises.length ? that.$$q.all(validatorPromises).then((function() {
                    validationDone(allValid)
                }), noop) : validationDone(!0)): validationDone(!1);

                function setValidity(name, isValid) {
                    localValidationRunId === that.$$currentValidationRunId && that.$setValidity(name, isValid)
                }

                function validationDone(allValid) {
                    localValidationRunId === that.$$currentValidationRunId && doneCallback(allValid)
                }
            },
            $commitViewValue: function() {
                var viewValue = this.$viewValue;
                this.$$timeout.cancel(this.$$pendingDebounce), (this.$$lastCommittedViewValue !== viewValue || "" === viewValue && this.$$hasNativeValidators) && (this.$$updateEmptyClasses(viewValue), this.$$lastCommittedViewValue = viewValue, this.$pristine && this.$setDirty(), this.$$parseAndValidate())
            },
            $$parseAndValidate: function() {
                var modelValue = this.$$lastCommittedViewValue,
                    that = this;
                if (this.$$parserValid = !isUndefined(modelValue) || void 0, this.$setValidity(this.$$parserName, null), this.$$parserName = "parse", this.$$parserValid)
                    for (var i = 0; i < this.$parsers.length; i++)
                        if (isUndefined(modelValue = this.$parsers[i](modelValue))) {
                            this.$$parserValid = !1;
                            break
                        }
                isNumberNaN(this.$modelValue) && (this.$modelValue = this.$$ngModelGet(this.$$scope));
                var prevModelValue = this.$modelValue,
                    allowInvalid = this.$options.getOption("allowInvalid");

                function writeToModelIfNeeded() {
                    that.$modelValue !== prevModelValue && that.$$writeModelToScope()
                }
                this.$$rawModelValue = modelValue, allowInvalid && (this.$modelValue = modelValue, writeToModelIfNeeded()), this.$$runValidators(modelValue, this.$$lastCommittedViewValue, (function(allValid) {
                    allowInvalid || (that.$modelValue = allValid ? modelValue : void 0, writeToModelIfNeeded())
                }))
            },
            $$writeModelToScope: function() {
                this.$$ngModelSet(this.$$scope, this.$modelValue), forEach(this.$viewChangeListeners, (function(listener) {
                    try {
                        listener()
                    } catch (e) {
                        this.$$exceptionHandler(e)
                    }
                }), this)
            },
            $setViewValue: function(value, trigger) {
                this.$viewValue = value, this.$options.getOption("updateOnDefault") && this.$$debounceViewValueCommit(trigger)
            },
            $$debounceViewValueCommit: function(trigger) {
                var debounceDelay = this.$options.getOption("debounce");
                isNumber(debounceDelay[trigger]) ? debounceDelay = debounceDelay[trigger] : isNumber(debounceDelay.default) && -1 === this.$options.getOption("updateOn").indexOf(trigger) ? debounceDelay = debounceDelay.default : isNumber(debounceDelay["*"]) && (debounceDelay = debounceDelay["*"]), this.$$timeout.cancel(this.$$pendingDebounce);
                var that = this;
                debounceDelay > 0 ? this.$$pendingDebounce = this.$$timeout((function() {
                    that.$commitViewValue()
                }), debounceDelay) : this.$$rootScope.$$phase ? this.$commitViewValue() : this.$$scope.$apply((function() {
                    that.$commitViewValue()
                }))
            },
            $overrideModelOptions: function(options) {
                this.$options = this.$options.createChild(options), this.$$setUpdateOnEvents()
            },
            $processModelValue: function() {
                var viewValue = this.$$format();
                this.$viewValue !== viewValue && (this.$$updateEmptyClasses(viewValue), this.$viewValue = this.$$lastCommittedViewValue = viewValue, this.$render(), this.$$runValidators(this.$modelValue, this.$viewValue, noop))
            },
            $$format: function() {
                for (var formatters = this.$formatters, idx = formatters.length, viewValue = this.$modelValue; idx--;) viewValue = formatters[idx](viewValue);
                return viewValue
            },
            $$setModelValue: function(modelValue) {
                this.$modelValue = this.$$rawModelValue = modelValue, this.$$parserValid = void 0, this.$processModelValue()
            },
            $$setUpdateOnEvents: function() {
                this.$$updateEvents && this.$$element.off(this.$$updateEvents, this.$$updateEventHandler), this.$$updateEvents = this.$options.getOption("updateOn"), this.$$updateEvents && this.$$element.on(this.$$updateEvents, this.$$updateEventHandler)
            },
            $$updateEventHandler: function(ev) {
                this.$$debounceViewValueCommit(ev && ev.type)
            }
        }, addSetValidityMethod({
            clazz: NgModelController,
            set: function(object, property) {
                object[property] = !0
            },
            unset: function(object, property) {
                delete object[property]
            }
        });
        var defaultModelOptions, ngModelDirective = ["$rootScope", function($rootScope) {
                return {
                    restrict: "A",
                    require: ["ngModel", "^?form", "^?ngModelOptions"],
                    controller: NgModelController,
                    priority: 1,
                    compile: function(element) {
                        return element.addClass(PRISTINE_CLASS).addClass("ng-untouched").addClass(VALID_CLASS), {
                            pre: function(scope, element, attr, ctrls) {
                                var modelCtrl = ctrls[0],
                                    formCtrl = ctrls[1] || modelCtrl.$$parentForm,
                                    optionsCtrl = ctrls[2];
                                optionsCtrl && (modelCtrl.$options = optionsCtrl.$options), modelCtrl.$$initGetterSetters(), formCtrl.$addControl(modelCtrl), attr.$observe("name", (function(newValue) {
                                    modelCtrl.$name !== newValue && modelCtrl.$$parentForm.$$renameControl(modelCtrl, newValue)
                                })), scope.$on("$destroy", (function() {
                                    modelCtrl.$$parentForm.$removeControl(modelCtrl)
                                }))
                            },
                            post: function(scope, element, attr, ctrls) {
                                var modelCtrl = ctrls[0];

                                function setTouched() {
                                    modelCtrl.$setTouched()
                                }
                                modelCtrl.$$setUpdateOnEvents(), element.on("blur", (function() {
                                    modelCtrl.$touched || ($rootScope.$$phase ? scope.$evalAsync(setTouched) : scope.$apply(setTouched))
                                }))
                            }
                        }
                    }
                }
            }],
            DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/;

        function ModelOptions(options) {
            this.$$options = options
        }
        ModelOptions.prototype = {
            getOption: function(name) {
                return this.$$options[name]
            },
            createChild: function(options) {
                var inheritAll = !1;
                return forEach(options = extend({}, options), (function(option, key) {
                    "$inherit" === option ? "*" === key ? inheritAll = !0 : (options[key] = this.$$options[key], "updateOn" === key && (options.updateOnDefault = this.$$options.updateOnDefault)) : "updateOn" === key && (options.updateOnDefault = !1, options[key] = trim(option.replace(DEFAULT_REGEXP, (function() {
                        return options.updateOnDefault = !0, " "
                    }))))
                }), this), inheritAll && (delete options["*"], defaults(options, this.$$options)), defaults(options, defaultModelOptions.$$options), new ModelOptions(options)
            }
        }, defaultModelOptions = new ModelOptions({
            updateOn: "",
            updateOnDefault: !0,
            debounce: 0,
            getterSetter: !1,
            allowInvalid: !1,
            timezone: null
        });
        var ngModelOptionsDirective = function() {
            function NgModelOptionsController($attrs, $scope) {
                this.$$attrs = $attrs, this.$$scope = $scope
            }
            return NgModelOptionsController.$inject = ["$attrs", "$scope"], NgModelOptionsController.prototype = {
                $onInit: function() {
                    var parentOptions = this.parentCtrl ? this.parentCtrl.$options : defaultModelOptions,
                        modelOptionsDefinition = this.$$scope.$eval(this.$$attrs.ngModelOptions);
                    this.$options = parentOptions.createChild(modelOptionsDefinition)
                }
            }, {
                restrict: "A",
                priority: 10,
                require: {
                    parentCtrl: "?^^ngModelOptions"
                },
                bindToController: !0,
                controller: NgModelOptionsController
            }
        };

        function defaults(dst, src) {
            forEach(src, (function(value, key) {
                isDefined(dst[key]) || (dst[key] = value)
            }))
        }
        var ngNonBindableDirective = ngDirective({
                terminal: !0,
                priority: 1e3
            }),
            ngOptionsMinErr = minErr("ngOptions"),
            NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([$\w][$\w]*)|(?:\(\s*([$\w][$\w]*)\s*,\s*([$\w][$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/,
            ngOptionsDirective = ["$compile", "$document", "$parse", function($compile, $document, $parse) {
                var optionTemplate = window.document.createElement("option"),
                    optGroupTemplate = window.document.createElement("optgroup");
                return {
                    restrict: "A",
                    terminal: !0,
                    require: ["select", "ngModel"],
                    link: {
                        pre: function(scope, selectElement, attr, ctrls) {
                            ctrls[0].registerOption = noop
                        },
                        post: function(scope, selectElement, attr, ctrls) {
                            for (var selectCtrl = ctrls[0], ngModelCtrl = ctrls[1], multiple = attr.multiple, i = 0, children = selectElement.children(), ii = children.length; i < ii; i++)
                                if ("" === children[i].value) {
                                    selectCtrl.hasEmptyOption = !0, selectCtrl.emptyOption = children.eq(i);
                                    break
                                }
                            selectElement.empty();
                            var options, providedEmptyOption = !!selectCtrl.emptyOption;
                            jqLite(optionTemplate.cloneNode(!1)).val("?");
                            var ngOptions = function(optionsExp, selectElement, scope) {
                                    var match = optionsExp.match(NG_OPTIONS_REGEXP);
                                    if (!match) throw ngOptionsMinErr("iexp", "Expected expression in form of '_select_ (as _label_)? for (_key_,)?_value_ in _collection_' but got '{0}'. Element: {1}", optionsExp, startingTag(selectElement));
                                    var valueName = match[5] || match[7],
                                        keyName = match[6],
                                        selectAs = / as /.test(match[0]) && match[1],
                                        trackBy = match[9],
                                        valueFn = $parse(match[2] ? match[1] : valueName),
                                        viewValueFn = selectAs && $parse(selectAs) || valueFn,
                                        trackByFn = trackBy && $parse(trackBy),
                                        getTrackByValueFn = trackBy ? function(value, locals) {
                                            return trackByFn(scope, locals)
                                        } : function(value) {
                                            return hashKey(value)
                                        },
                                        getTrackByValue = function(value, key) {
                                            return getTrackByValueFn(value, getLocals(value, key))
                                        },
                                        displayFn = $parse(match[2] || match[1]),
                                        groupByFn = $parse(match[3] || ""),
                                        disableWhenFn = $parse(match[4] || ""),
                                        valuesFn = $parse(match[8]),
                                        locals = {},
                                        getLocals = keyName ? function(value, key) {
                                            return locals[keyName] = key, locals[valueName] = value, locals
                                        } : function(value) {
                                            return locals[valueName] = value, locals
                                        };

                                    function Option(selectValue, viewValue, label, group, disabled) {
                                        this.selectValue = selectValue, this.viewValue = viewValue, this.label = label, this.group = group, this.disabled = disabled
                                    }

                                    function getOptionValuesKeys(optionValues) {
                                        var optionValuesKeys;
                                        if (!keyName && isArrayLike(optionValues)) optionValuesKeys = optionValues;
                                        else
                                            for (var itemKey in optionValuesKeys = [], optionValues) optionValues.hasOwnProperty(itemKey) && "$" !== itemKey.charAt(0) && optionValuesKeys.push(itemKey);
                                        return optionValuesKeys
                                    }
                                    return {
                                        trackBy: trackBy,
                                        getTrackByValue: getTrackByValue,
                                        getWatchables: $parse(valuesFn, (function(optionValues) {
                                            for (var watchedArray = [], optionValuesKeys = getOptionValuesKeys(optionValues = optionValues || []), optionValuesLength = optionValuesKeys.length, index = 0; index < optionValuesLength; index++) {
                                                var key = optionValues === optionValuesKeys ? index : optionValuesKeys[index],
                                                    value = optionValues[key],
                                                    locals = getLocals(value, key),
                                                    selectValue = getTrackByValueFn(value, locals);
                                                if (watchedArray.push(selectValue), match[2] || match[1]) {
                                                    var label = displayFn(scope, locals);
                                                    watchedArray.push(label)
                                                }
                                                if (match[4]) {
                                                    var disableWhen = disableWhenFn(scope, locals);
                                                    watchedArray.push(disableWhen)
                                                }
                                            }
                                            return watchedArray
                                        })),
                                        getOptions: function() {
                                            for (var optionItems = [], selectValueMap = {}, optionValues = valuesFn(scope) || [], optionValuesKeys = getOptionValuesKeys(optionValues), optionValuesLength = optionValuesKeys.length, index = 0; index < optionValuesLength; index++) {
                                                var key = optionValues === optionValuesKeys ? index : optionValuesKeys[index],
                                                    value = optionValues[key],
                                                    locals = getLocals(value, key),
                                                    viewValue = viewValueFn(scope, locals),
                                                    selectValue = getTrackByValueFn(viewValue, locals),
                                                    optionItem = new Option(selectValue, viewValue, displayFn(scope, locals), groupByFn(scope, locals), disableWhenFn(scope, locals));
                                                optionItems.push(optionItem), selectValueMap[selectValue] = optionItem
                                            }
                                            return {
                                                items: optionItems,
                                                selectValueMap: selectValueMap,
                                                getOptionFromViewValue: function(value) {
                                                    return selectValueMap[getTrackByValue(value)]
                                                },
                                                getViewValueFromOption: function(option) {
                                                    return trackBy ? copy(option.viewValue) : option.viewValue
                                                }
                                            }
                                        }
                                    }
                                }(attr.ngOptions, selectElement, scope),
                                listFragment = $document[0].createDocumentFragment();

                            function addOptionElement(option, parent) {
                                var optionElement = optionTemplate.cloneNode(!1);
                                parent.appendChild(optionElement),
                                    function(option, element) {
                                        option.element = element, element.disabled = option.disabled, option.label !== element.label && (element.label = option.label, element.textContent = option.label);
                                        element.value = option.selectValue
                                    }(option, optionElement)
                            }

                            function getAndUpdateSelectedOption(viewValue) {
                                var option = options.getOptionFromViewValue(viewValue),
                                    element = option && option.element;
                                return element && !element.selected && (element.selected = !0), option
                            }
                            selectCtrl.generateUnknownOptionValue = function(val) {
                                return "?"
                            }, multiple ? (selectCtrl.writeValue = function(values) {
                                if (options) {
                                    var selectedOptions = values && values.map(getAndUpdateSelectedOption) || [];
                                    options.items.forEach((function(option) {
                                        option.element.selected && !includes(selectedOptions, option) && (option.element.selected = !1)
                                    }))
                                }
                            }, selectCtrl.readValue = function() {
                                var selectedValues = selectElement.val() || [],
                                    selections = [];
                                return forEach(selectedValues, (function(value) {
                                    var option = options.selectValueMap[value];
                                    option && !option.disabled && selections.push(options.getViewValueFromOption(option))
                                })), selections
                            }, ngOptions.trackBy && scope.$watchCollection((function() {
                                if (isArray(ngModelCtrl.$viewValue)) return ngModelCtrl.$viewValue.map((function(value) {
                                    return ngOptions.getTrackByValue(value)
                                }))
                            }), (function() {
                                ngModelCtrl.$render()
                            }))) : (selectCtrl.writeValue = function(value) {
                                if (options) {
                                    var selectedOption = selectElement[0].options[selectElement[0].selectedIndex],
                                        option = options.getOptionFromViewValue(value);
                                    selectedOption && selectedOption.removeAttribute("selected"), option ? (selectElement[0].value !== option.selectValue && (selectCtrl.removeUnknownOption(), selectElement[0].value = option.selectValue, option.element.selected = !0), option.element.setAttribute("selected", "selected")) : selectCtrl.selectUnknownOrEmptyOption(value)
                                }
                            }, selectCtrl.readValue = function() {
                                var selectedOption = options.selectValueMap[selectElement.val()];
                                return selectedOption && !selectedOption.disabled ? (selectCtrl.unselectEmptyOption(), selectCtrl.removeUnknownOption(), options.getViewValueFromOption(selectedOption)) : null
                            }, ngOptions.trackBy && scope.$watch((function() {
                                return ngOptions.getTrackByValue(ngModelCtrl.$viewValue)
                            }), (function() {
                                ngModelCtrl.$render()
                            }))), providedEmptyOption && ($compile(selectCtrl.emptyOption)(scope), selectElement.prepend(selectCtrl.emptyOption), 8 === selectCtrl.emptyOption[0].nodeType ? (selectCtrl.hasEmptyOption = !1, selectCtrl.registerOption = function(optionScope, optionEl) {
                                "" === optionEl.val() && (selectCtrl.hasEmptyOption = !0, selectCtrl.emptyOption = optionEl, selectCtrl.emptyOption.removeClass("ng-scope"), ngModelCtrl.$render(), optionEl.on("$destroy", (function() {
                                    var needsRerender = selectCtrl.$isEmptyOptionSelected();
                                    selectCtrl.hasEmptyOption = !1, selectCtrl.emptyOption = void 0, needsRerender && ngModelCtrl.$render()
                                })))
                            }) : selectCtrl.emptyOption.removeClass("ng-scope")), scope.$watchCollection(ngOptions.getWatchables, (function() {
                                var previousValue = options && selectCtrl.readValue();
                                if (options)
                                    for (var i = options.items.length - 1; i >= 0; i--) {
                                        var option = options.items[i];
                                        isDefined(option.group) ? jqLiteRemove(option.element.parentNode) : jqLiteRemove(option.element)
                                    }
                                options = ngOptions.getOptions();
                                var groupElementMap = {};
                                if (options.items.forEach((function(option) {
                                        var groupElement;
                                        isDefined(option.group) ? ((groupElement = groupElementMap[option.group]) || (groupElement = optGroupTemplate.cloneNode(!1), listFragment.appendChild(groupElement), groupElement.label = null === option.group ? "null" : option.group, groupElementMap[option.group] = groupElement), addOptionElement(option, groupElement)) : addOptionElement(option, listFragment)
                                    })), selectElement[0].appendChild(listFragment), ngModelCtrl.$render(), !ngModelCtrl.$isEmpty(previousValue)) {
                                    var nextValue = selectCtrl.readValue();
                                    (ngOptions.trackBy || multiple ? equals(previousValue, nextValue) : previousValue === nextValue) || (ngModelCtrl.$setViewValue(nextValue), ngModelCtrl.$render())
                                }
                            }))
                        }
                    }
                }
            }],
            ngPluralizeDirective = ["$locale", "$interpolate", "$log", function($locale, $interpolate, $log) {
                var BRACE = /{}/g,
                    IS_WHEN = /^when(Minus)?(.+)$/;
                return {
                    link: function(scope, element, attr) {
                        var lastCount, numberExp = attr.count,
                            whenExp = attr.$attr.when && element.attr(attr.$attr.when),
                            offset = attr.offset || 0,
                            whens = scope.$eval(whenExp) || {},
                            whensExpFns = {},
                            startSymbol = $interpolate.startSymbol(),
                            endSymbol = $interpolate.endSymbol(),
                            braceReplacement = startSymbol + numberExp + "-" + offset + endSymbol,
                            watchRemover = angular.noop;

                        function updateElementText(newText) {
                            element.text(newText || "")
                        }
                        forEach(attr, (function(expression, attributeName) {
                            var tmpMatch = IS_WHEN.exec(attributeName);
                            if (tmpMatch) {
                                var whenKey = (tmpMatch[1] ? "-" : "") + lowercase(tmpMatch[2]);
                                whens[whenKey] = element.attr(attr.$attr[attributeName])
                            }
                        })), forEach(whens, (function(expression, key) {
                            whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement))
                        })), scope.$watch(numberExp, (function(newVal) {
                            var count = parseFloat(newVal),
                                countIsNaN = isNumberNaN(count);
                            if (countIsNaN || count in whens || (count = $locale.pluralCat(count - offset)), !(count === lastCount || countIsNaN && isNumberNaN(lastCount))) {
                                watchRemover();
                                var whenExpFn = whensExpFns[count];
                                isUndefined(whenExpFn) ? (null != newVal && $log.debug("ngPluralize: no rule defined for '" + count + "' in " + whenExp), watchRemover = noop, updateElementText()) : watchRemover = scope.$watch(whenExpFn, updateElementText), lastCount = count
                            }
                        }))
                    }
                }
            }],
            ngRefMinErr = minErr("ngRef"),
            ngRefDirective = ["$parse", function($parse) {
                return {
                    priority: -1,
                    restrict: "A",
                    compile: function(tElement, tAttrs) {
                        var controllerName = directiveNormalize(nodeName_(tElement)),
                            getter = $parse(tAttrs.ngRef),
                            setter = getter.assign || function() {
                                throw ngRefMinErr("nonassign", 'Expression in ngRef="{0}" is non-assignable!', tAttrs.ngRef)
                            };
                        return function(scope, element, attrs) {
                            var refValue;
                            if (attrs.hasOwnProperty("ngRefRead")) {
                                if ("$element" === attrs.ngRefRead) refValue = element;
                                else if (!(refValue = element.data("$" + attrs.ngRefRead + "Controller"))) throw ngRefMinErr("noctrl", 'The controller for ngRefRead="{0}" could not be found on ngRef="{1}"', attrs.ngRefRead, tAttrs.ngRef)
                            } else refValue = element.data("$" + controllerName + "Controller");
                            setter(scope, refValue = refValue || element), element.on("$destroy", (function() {
                                getter(scope) === refValue && setter(scope, null)
                            }))
                        }
                    }
                }
            }],
            ngRepeatDirective = ["$parse", "$animate", "$compile", function($parse, $animate, $compile) {
                var ngRepeatMinErr = minErr("ngRepeat"),
                    updateScope = function(scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {
                        scope[valueIdentifier] = value, keyIdentifier && (scope[keyIdentifier] = key), scope.$index = index, scope.$first = 0 === index, scope.$last = index === arrayLength - 1, scope.$middle = !(scope.$first || scope.$last), scope.$odd = !(scope.$even = 0 == (1 & index))
                    },
                    getBlockStart = function(block) {
                        return block.clone[0]
                    },
                    getBlockEnd = function(block) {
                        return block.clone[block.clone.length - 1]
                    },
                    trackByIdArrayFn = function($scope, key, value) {
                        return hashKey(value)
                    },
                    trackByIdObjFn = function($scope, key) {
                        return key
                    };
                return {
                    restrict: "A",
                    multiElement: !0,
                    transclude: "element",
                    priority: 1e3,
                    terminal: !0,
                    $$tlb: !0,
                    compile: function($element, $attr) {
                        var expression = $attr.ngRepeat,
                            ngRepeatEndComment = $compile.$$createComment("end ngRepeat", expression),
                            match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
                        if (!match) throw ngRepeatMinErr("iexp", "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
                        var lhs = match[1],
                            rhs = match[2],
                            aliasAs = match[3],
                            trackByExp = match[4];
                        if (!(match = lhs.match(/^(?:(\s*[$\w]+)|\(\s*([$\w]+)\s*,\s*([$\w]+)\s*\))$/))) throw ngRepeatMinErr("iidexp", "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.", lhs);
                        var trackByIdExpFn, valueIdentifier = match[3] || match[1],
                            keyIdentifier = match[2];
                        if (aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(aliasAs))) throw ngRepeatMinErr("badident", "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.", aliasAs);
                        if (trackByExp) {
                            var hashFnLocals = {
                                    $id: hashKey
                                },
                                trackByExpGetter = $parse(trackByExp);
                            trackByIdExpFn = function($scope, key, value, index) {
                                return keyIdentifier && (hashFnLocals[keyIdentifier] = key), hashFnLocals[valueIdentifier] = value, hashFnLocals.$index = index, trackByExpGetter($scope, hashFnLocals)
                            }
                        }
                        return function($scope, $element, $attr, ctrl, $transclude) {
                            var lastBlockMap = createMap();
                            $scope.$watchCollection(rhs, (function(collection) {
                                var index, length, nextNode, collectionLength, key, value, trackById, trackByIdFn, collectionKeys, block, nextBlockOrder, elementsToRemove, previousNode = $element[0],
                                    nextBlockMap = createMap();
                                if (aliasAs && ($scope[aliasAs] = collection), isArrayLike(collection)) collectionKeys = collection, trackByIdFn = trackByIdExpFn || trackByIdArrayFn;
                                else
                                    for (var itemKey in trackByIdFn = trackByIdExpFn || trackByIdObjFn, collectionKeys = [], collection) hasOwnProperty.call(collection, itemKey) && "$" !== itemKey.charAt(0) && collectionKeys.push(itemKey);
                                for (collectionLength = collectionKeys.length, nextBlockOrder = new Array(collectionLength), index = 0; index < collectionLength; index++)
                                    if (key = collection === collectionKeys ? index : collectionKeys[index], value = collection[key], trackById = trackByIdFn($scope, key, value, index), lastBlockMap[trackById]) block = lastBlockMap[trackById], delete lastBlockMap[trackById], nextBlockMap[trackById] = block, nextBlockOrder[index] = block;
                                    else {
                                        if (nextBlockMap[trackById]) throw forEach(nextBlockOrder, (function(block) {
                                            block && block.scope && (lastBlockMap[block.id] = block)
                                        })), ngRepeatMinErr("dupes", "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}", expression, trackById, value);
                                        nextBlockOrder[index] = {
                                            id: trackById,
                                            scope: void 0,
                                            clone: void 0
                                        }, nextBlockMap[trackById] = !0
                                    }
                                for (var blockKey in hashFnLocals && (hashFnLocals[valueIdentifier] = void 0), lastBlockMap) {
                                    if (elementsToRemove = getBlockNodes((block = lastBlockMap[blockKey]).clone), $animate.leave(elementsToRemove), elementsToRemove[0].parentNode)
                                        for (index = 0, length = elementsToRemove.length; index < length; index++) elementsToRemove[index].$$NG_REMOVED = !0;
                                    block.scope.$destroy()
                                }
                                for (index = 0; index < collectionLength; index++)
                                    if (key = collection === collectionKeys ? index : collectionKeys[index], value = collection[key], (block = nextBlockOrder[index]).scope) {
                                        nextNode = previousNode;
                                        do {
                                            nextNode = nextNode.nextSibling
                                        } while (nextNode && nextNode.$$NG_REMOVED);
                                        getBlockStart(block) !== nextNode && $animate.move(getBlockNodes(block.clone), null, previousNode), previousNode = getBlockEnd(block), updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength)
                                    } else $transclude((function(clone, scope) {
                                        block.scope = scope;
                                        var endNode = ngRepeatEndComment.cloneNode(!1);
                                        clone[clone.length++] = endNode, $animate.enter(clone, null, previousNode), previousNode = endNode, block.clone = clone, nextBlockMap[block.id] = block, updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength)
                                    }));
                                lastBlockMap = nextBlockMap
                            }))
                        }
                    }
                }
            }],
            ngShowDirective = ["$animate", function($animate) {
                return {
                    restrict: "A",
                    multiElement: !0,
                    link: function(scope, element, attr) {
                        scope.$watch(attr.ngShow, (function(value) {
                            $animate[value ? "removeClass" : "addClass"](element, "ng-hide", {
                                tempClasses: "ng-hide-animate"
                            })
                        }))
                    }
                }
            }],
            ngHideDirective = ["$animate", function($animate) {
                return {
                    restrict: "A",
                    multiElement: !0,
                    link: function(scope, element, attr) {
                        scope.$watch(attr.ngHide, (function(value) {
                            $animate[value ? "addClass" : "removeClass"](element, "ng-hide", {
                                tempClasses: "ng-hide-animate"
                            })
                        }))
                    }
                }
            }],
            ngStyleDirective = ngDirective((function(scope, element, attr) {
                scope.$watchCollection(attr.ngStyle, (function(newStyles, oldStyles) {
                    oldStyles && newStyles !== oldStyles && forEach(oldStyles, (function(val, style) {
                        element.css(style, "")
                    })), newStyles && element.css(newStyles)
                }))
            })),
            ngSwitchDirective = ["$animate", "$compile", function($animate, $compile) {
                return {
                    require: "ngSwitch",
                    controller: ["$scope", function() {
                        this.cases = {}
                    }],
                    link: function(scope, element, attr, ngSwitchController) {
                        var watchExpr = attr.ngSwitch || attr.on,
                            selectedTranscludes = [],
                            selectedElements = [],
                            previousLeaveAnimations = [],
                            selectedScopes = [],
                            spliceFactory = function(array, index) {
                                return function(response) {
                                    !1 !== response && array.splice(index, 1)
                                }
                            };
                        scope.$watch(watchExpr, (function(value) {
                            for (var i, ii; previousLeaveAnimations.length;) $animate.cancel(previousLeaveAnimations.pop());
                            for (i = 0, ii = selectedScopes.length; i < ii; ++i) {
                                var selected = getBlockNodes(selectedElements[i].clone);
                                selectedScopes[i].$destroy(), (previousLeaveAnimations[i] = $animate.leave(selected)).done(spliceFactory(previousLeaveAnimations, i))
                            }
                            selectedElements.length = 0, selectedScopes.length = 0, (selectedTranscludes = ngSwitchController.cases["!" + value] || ngSwitchController.cases["?"]) && forEach(selectedTranscludes, (function(selectedTransclude) {
                                selectedTransclude.transclude((function(caseElement, selectedScope) {
                                    selectedScopes.push(selectedScope);
                                    var anchor = selectedTransclude.element;
                                    caseElement[caseElement.length++] = $compile.$$createComment("end ngSwitchWhen");
                                    var block = {
                                        clone: caseElement
                                    };
                                    selectedElements.push(block), $animate.enter(caseElement, anchor.parent(), anchor)
                                }))
                            }))
                        }))
                    }
                }
            }],
            ngSwitchWhenDirective = ngDirective({
                transclude: "element",
                priority: 1200,
                require: "^ngSwitch",
                multiElement: !0,
                link: function(scope, element, attrs, ctrl, $transclude) {
                    forEach(attrs.ngSwitchWhen.split(attrs.ngSwitchWhenSeparator).sort().filter((function(element, index, array) {
                        return array[index - 1] !== element
                    })), (function(whenCase) {
                        ctrl.cases["!" + whenCase] = ctrl.cases["!" + whenCase] || [], ctrl.cases["!" + whenCase].push({
                            transclude: $transclude,
                            element: element
                        })
                    }))
                }
            }),
            ngSwitchDefaultDirective = ngDirective({
                transclude: "element",
                priority: 1200,
                require: "^ngSwitch",
                multiElement: !0,
                link: function(scope, element, attr, ctrl, $transclude) {
                    ctrl.cases["?"] = ctrl.cases["?"] || [], ctrl.cases["?"].push({
                        transclude: $transclude,
                        element: element
                    })
                }
            }),
            ngTranscludeMinErr = minErr("ngTransclude"),
            ngTranscludeDirective = ["$compile", function($compile) {
                return {
                    restrict: "EAC",
                    compile: function(tElement) {
                        var fallbackLinkFn = $compile(tElement.contents());
                        return tElement.empty(),
                            function($scope, $element, $attrs, controller, $transclude) {
                                if (!$transclude) throw ngTranscludeMinErr("orphan", "Illegal use of ngTransclude directive in the template! No parent directive that requires a transclusion found. Element: {0}", startingTag($element));
                                $attrs.ngTransclude === $attrs.$attr.ngTransclude && ($attrs.ngTransclude = "");
                                var slotName = $attrs.ngTransclude || $attrs.ngTranscludeSlot;

                                function useFallbackContent() {
                                    fallbackLinkFn($scope, (function(clone) {
                                        $element.append(clone)
                                    }))
                                }
                                $transclude((function(clone, transcludedScope) {
                                    clone.length && function(nodes) {
                                        for (var i = 0, ii = nodes.length; i < ii; i++) {
                                            var node = nodes[i];
                                            if (node.nodeType !== NODE_TYPE_TEXT || node.nodeValue.trim()) return !0
                                        }
                                    }(clone) ? $element.append(clone) : (useFallbackContent(), transcludedScope.$destroy())
                                }), null, slotName), slotName && !$transclude.isSlotFilled(slotName) && useFallbackContent()
                            }
                    }
                }
            }],
            scriptDirective = ["$templateCache", function($templateCache) {
                return {
                    restrict: "E",
                    terminal: !0,
                    compile: function(element, attr) {
                        if ("text/ng-template" === attr.type) {
                            var templateUrl = attr.id,
                                text = element[0].text;
                            $templateCache.put(templateUrl, text)
                        }
                    }
                }
            }],
            noopNgModelController = {
                $setViewValue: noop,
                $render: noop
            };

        function setOptionSelectedStatus(optionEl, value) {
            optionEl.prop("selected", value), optionEl.attr("selected", value)
        }
        var SelectController = ["$element", "$scope", function($element, $scope) {
                var self = this,
                    optionsMap = new NgMap;
                self.selectValueMap = {}, self.ngModelCtrl = noopNgModelController, self.multiple = !1, self.unknownOption = jqLite(window.document.createElement("option")), self.hasEmptyOption = !1, self.emptyOption = void 0, self.renderUnknownOption = function(val) {
                    var unknownVal = self.generateUnknownOptionValue(val);
                    self.unknownOption.val(unknownVal), $element.prepend(self.unknownOption), setOptionSelectedStatus(self.unknownOption, !0), $element.val(unknownVal)
                }, self.updateUnknownOption = function(val) {
                    var unknownVal = self.generateUnknownOptionValue(val);
                    self.unknownOption.val(unknownVal), setOptionSelectedStatus(self.unknownOption, !0), $element.val(unknownVal)
                }, self.generateUnknownOptionValue = function(val) {
                    return "? " + hashKey(val) + " ?"
                }, self.removeUnknownOption = function() {
                    self.unknownOption.parent() && self.unknownOption.remove()
                }, self.selectEmptyOption = function() {
                    self.emptyOption && ($element.val(""), setOptionSelectedStatus(self.emptyOption, !0))
                }, self.unselectEmptyOption = function() {
                    self.hasEmptyOption && setOptionSelectedStatus(self.emptyOption, !1)
                }, $scope.$on("$destroy", (function() {
                    self.renderUnknownOption = noop
                })), self.readValue = function() {
                    var val = $element.val(),
                        realVal = val in self.selectValueMap ? self.selectValueMap[val] : val;
                    return self.hasOption(realVal) ? realVal : null
                }, self.writeValue = function(value) {
                    var currentlySelectedOption = $element[0].options[$element[0].selectedIndex];
                    if (currentlySelectedOption && setOptionSelectedStatus(jqLite(currentlySelectedOption), !1), self.hasOption(value)) {
                        self.removeUnknownOption();
                        var hashedVal = hashKey(value);
                        $element.val(hashedVal in self.selectValueMap ? hashedVal : value);
                        var selectedOption = $element[0].options[$element[0].selectedIndex];
                        setOptionSelectedStatus(jqLite(selectedOption), !0)
                    } else self.selectUnknownOrEmptyOption(value)
                }, self.addOption = function(value, element) {
                    if (8 !== element[0].nodeType) {
                        assertNotHasOwnProperty(value, '"option value"'), "" === value && (self.hasEmptyOption = !0, self.emptyOption = element);
                        var count = optionsMap.get(value) || 0;
                        optionsMap.set(value, count + 1), scheduleRender()
                    }
                }, self.removeOption = function(value) {
                    var count = optionsMap.get(value);
                    count && (1 === count ? (optionsMap.delete(value), "" === value && (self.hasEmptyOption = !1, self.emptyOption = void 0)) : optionsMap.set(value, count - 1))
                }, self.hasOption = function(value) {
                    return !!optionsMap.get(value)
                }, self.$hasEmptyOption = function() {
                    return self.hasEmptyOption
                }, self.$isUnknownOptionSelected = function() {
                    return $element[0].options[0] === self.unknownOption[0]
                }, self.$isEmptyOptionSelected = function() {
                    return self.hasEmptyOption && $element[0].options[$element[0].selectedIndex] === self.emptyOption[0]
                }, self.selectUnknownOrEmptyOption = function(value) {
                    null == value && self.emptyOption ? (self.removeUnknownOption(), self.selectEmptyOption()) : self.unknownOption.parent().length ? self.updateUnknownOption(value) : self.renderUnknownOption(value)
                };
                var renderScheduled = !1;

                function scheduleRender() {
                    renderScheduled || (renderScheduled = !0, $scope.$$postDigest((function() {
                        renderScheduled = !1, self.ngModelCtrl.$render()
                    })))
                }
                var updateScheduled = !1;

                function scheduleViewValueUpdate(renderAfter) {
                    updateScheduled || (updateScheduled = !0, $scope.$$postDigest((function() {
                        $scope.$$destroyed || (updateScheduled = !1, self.ngModelCtrl.$setViewValue(self.readValue()), renderAfter && self.ngModelCtrl.$render())
                    })))
                }
                self.registerOption = function(optionScope, optionElement, optionAttrs, interpolateValueFn, interpolateTextFn) {
                    var oldVal, hashedVal;
                    optionAttrs.$attr.ngValue ? optionAttrs.$observe("value", (function(newVal) {
                        var removal, previouslySelected = optionElement.prop("selected");
                        isDefined(hashedVal) && (self.removeOption(oldVal), delete self.selectValueMap[hashedVal], removal = !0), hashedVal = hashKey(newVal), oldVal = newVal, self.selectValueMap[hashedVal] = newVal, self.addOption(newVal, optionElement), optionElement.attr("value", hashedVal), removal && previouslySelected && scheduleViewValueUpdate()
                    })) : interpolateValueFn ? optionAttrs.$observe("value", (function(newVal) {
                        var removal;
                        self.readValue();
                        var previouslySelected = optionElement.prop("selected");
                        isDefined(oldVal) && (self.removeOption(oldVal), removal = !0), oldVal = newVal, self.addOption(newVal, optionElement), removal && previouslySelected && scheduleViewValueUpdate()
                    })) : interpolateTextFn ? optionScope.$watch(interpolateTextFn, (function(newVal, oldVal) {
                        optionAttrs.$set("value", newVal);
                        var previouslySelected = optionElement.prop("selected");
                        oldVal !== newVal && self.removeOption(oldVal), self.addOption(newVal, optionElement), oldVal && previouslySelected && scheduleViewValueUpdate()
                    })) : self.addOption(optionAttrs.value, optionElement);
                    optionAttrs.$observe("disabled", (function(newVal) {
                        ("true" === newVal || newVal && optionElement.prop("selected")) && (self.multiple ? scheduleViewValueUpdate(!0) : (self.ngModelCtrl.$setViewValue(null), self.ngModelCtrl.$render()))
                    })), optionElement.on("$destroy", (function() {
                        var currentValue = self.readValue(),
                            removeValue = optionAttrs.value;
                        self.removeOption(removeValue), scheduleRender(), (self.multiple && currentValue && -1 !== currentValue.indexOf(removeValue) || currentValue === removeValue) && scheduleViewValueUpdate(!0)
                    }))
                }
            }],
            selectDirective = function() {
                return {
                    restrict: "E",
                    require: ["select", "?ngModel"],
                    controller: SelectController,
                    priority: 1,
                    link: {
                        pre: function(scope, element, attr, ctrls) {
                            var selectCtrl = ctrls[0],
                                ngModelCtrl = ctrls[1];
                            if (!ngModelCtrl) return void(selectCtrl.registerOption = noop);
                            if (selectCtrl.ngModelCtrl = ngModelCtrl, element.on("change", (function() {
                                    selectCtrl.removeUnknownOption(), scope.$apply((function() {
                                        ngModelCtrl.$setViewValue(selectCtrl.readValue())
                                    }))
                                })), attr.multiple) {
                                selectCtrl.multiple = !0, selectCtrl.readValue = function() {
                                    var array = [];
                                    return forEach(element.find("option"), (function(option) {
                                        if (option.selected && !option.disabled) {
                                            var val = option.value;
                                            array.push(val in selectCtrl.selectValueMap ? selectCtrl.selectValueMap[val] : val)
                                        }
                                    })), array
                                }, selectCtrl.writeValue = function(value) {
                                    forEach(element.find("option"), (function(option) {
                                        var shouldBeSelected = !!value && (includes(value, option.value) || includes(value, selectCtrl.selectValueMap[option.value]));
                                        shouldBeSelected !== option.selected && setOptionSelectedStatus(jqLite(option), shouldBeSelected)
                                    }))
                                };
                                var lastView, lastViewRef = NaN;
                                scope.$watch((function() {
                                    lastViewRef !== ngModelCtrl.$viewValue || equals(lastView, ngModelCtrl.$viewValue) || (lastView = shallowCopy(ngModelCtrl.$viewValue), ngModelCtrl.$render()), lastViewRef = ngModelCtrl.$viewValue
                                })), ngModelCtrl.$isEmpty = function(value) {
                                    return !value || 0 === value.length
                                }
                            }
                        },
                        post: function(scope, element, attrs, ctrls) {
                            var ngModelCtrl = ctrls[1];
                            if (!ngModelCtrl) return;
                            var selectCtrl = ctrls[0];
                            ngModelCtrl.$render = function() {
                                selectCtrl.writeValue(ngModelCtrl.$viewValue)
                            }
                        }
                    }
                }
            },
            optionDirective = ["$interpolate", function($interpolate) {
                return {
                    restrict: "E",
                    priority: 100,
                    compile: function(element, attr) {
                        var interpolateValueFn, interpolateTextFn;
                        return isDefined(attr.ngValue) || (isDefined(attr.value) ? interpolateValueFn = $interpolate(attr.value, !0) : (interpolateTextFn = $interpolate(element.text(), !0)) || attr.$set("value", element.text())),
                            function(scope, element, attr) {
                                var parent = element.parent(),
                                    selectCtrl = parent.data("$selectController") || parent.parent().data("$selectController");
                                selectCtrl && selectCtrl.registerOption(scope, element, attr, interpolateValueFn, interpolateTextFn)
                            }
                    }
                }
            }],
            requiredDirective = ["$parse", function($parse) {
                return {
                    restrict: "A",
                    require: "?ngModel",
                    link: function(scope, elm, attr, ctrl) {
                        if (ctrl) {
                            var value = attr.hasOwnProperty("required") || $parse(attr.ngRequired)(scope);
                            attr.ngRequired || (attr.required = !0), ctrl.$validators.required = function(modelValue, viewValue) {
                                return !value || !ctrl.$isEmpty(viewValue)
                            }, attr.$observe("required", (function(newVal) {
                                value !== newVal && (value = newVal, ctrl.$validate())
                            }))
                        }
                    }
                }
            }],
            patternDirective = ["$parse", function($parse) {
                return {
                    restrict: "A",
                    require: "?ngModel",
                    compile: function(tElm, tAttr) {
                        var patternExp, parseFn;
                        return tAttr.ngPattern && (patternExp = tAttr.ngPattern, parseFn = "/" === tAttr.ngPattern.charAt(0) && REGEX_STRING_REGEXP.test(tAttr.ngPattern) ? function() {
                                return tAttr.ngPattern
                            } : $parse(tAttr.ngPattern)),
                            function(scope, elm, attr, ctrl) {
                                if (ctrl) {
                                    var attrVal = attr.pattern;
                                    attr.ngPattern ? attrVal = parseFn(scope) : patternExp = attr.pattern;
                                    var regexp = parsePatternAttr(attrVal, patternExp, elm);
                                    attr.$observe("pattern", (function(newVal) {
                                        var oldRegexp = regexp;
                                        regexp = parsePatternAttr(newVal, patternExp, elm), (oldRegexp && oldRegexp.toString()) !== (regexp && regexp.toString()) && ctrl.$validate()
                                    })), ctrl.$validators.pattern = function(modelValue, viewValue) {
                                        return ctrl.$isEmpty(viewValue) || isUndefined(regexp) || regexp.test(viewValue)
                                    }
                                }
                            }
                    }
                }
            }],
            maxlengthDirective = ["$parse", function($parse) {
                return {
                    restrict: "A",
                    require: "?ngModel",
                    link: function(scope, elm, attr, ctrl) {
                        if (ctrl) {
                            var maxlength = attr.maxlength || $parse(attr.ngMaxlength)(scope),
                                maxlengthParsed = parseLength(maxlength);
                            attr.$observe("maxlength", (function(value) {
                                maxlength !== value && (maxlengthParsed = parseLength(value), maxlength = value, ctrl.$validate())
                            })), ctrl.$validators.maxlength = function(modelValue, viewValue) {
                                return maxlengthParsed < 0 || ctrl.$isEmpty(viewValue) || viewValue.length <= maxlengthParsed
                            }
                        }
                    }
                }
            }],
            minlengthDirective = ["$parse", function($parse) {
                return {
                    restrict: "A",
                    require: "?ngModel",
                    link: function(scope, elm, attr, ctrl) {
                        if (ctrl) {
                            var minlength = attr.minlength || $parse(attr.ngMinlength)(scope),
                                minlengthParsed = parseLength(minlength) || -1;
                            attr.$observe("minlength", (function(value) {
                                minlength !== value && (minlengthParsed = parseLength(value) || -1, minlength = value, ctrl.$validate())
                            })), ctrl.$validators.minlength = function(modelValue, viewValue) {
                                return ctrl.$isEmpty(viewValue) || viewValue.length >= minlengthParsed
                            }
                        }
                    }
                }
            }];

        function parsePatternAttr(regex, patternExp, elm) {
            if (regex) {
                if (isString(regex) && (regex = new RegExp("^" + regex + "$")), !regex.test) throw minErr("ngPattern")("noregexp", "Expected {0} to be a RegExp but was {1}. Element: {2}", patternExp, regex, startingTag(elm));
                return regex
            }
        }

        function parseLength(val) {
            var intVal = toInt(val);
            return isNumberNaN(intVal) ? -1 : intVal
        }
        window.angular.bootstrap ? window.console && console.log("WARNING: Tried to load AngularJS more than once.") : (! function() {
            var originalCleanData;
            if (!bindJQueryFired) {
                var jqName = jq();
                (jQuery = isUndefined(jqName) ? window.jQuery : jqName ? window[jqName] : void 0) && jQuery.fn.on ? (jqLite = jQuery, extend(jQuery.fn, {
                    scope: JQLitePrototype.scope,
                    isolateScope: JQLitePrototype.isolateScope,
                    controller: JQLitePrototype.controller,
                    injector: JQLitePrototype.injector,
                    inheritedData: JQLitePrototype.inheritedData
                })) : jqLite = JQLite, originalCleanData = jqLite.cleanData, jqLite.cleanData = function(elems) {
                    for (var events, elem, i = 0; null != (elem = elems[i]); i++)(events = (jqLite._data(elem) || {}).events) && events.$destroy && jqLite(elem).triggerHandler("$destroy");
                    originalCleanData(elems)
                }, angular.element = jqLite, bindJQueryFired = !0
            }
        }(), function(angular) {
            extend(angular, {
                errorHandlingConfig: errorHandlingConfig,
                bootstrap: bootstrap,
                copy: copy,
                extend: extend,
                merge: merge,
                equals: equals,
                element: jqLite,
                forEach: forEach,
                injector: createInjector,
                noop: noop,
                bind: bind,
                toJson: toJson,
                fromJson: fromJson,
                identity: identity,
                isUndefined: isUndefined,
                isDefined: isDefined,
                isString: isString,
                isFunction: isFunction,
                isObject: isObject,
                isNumber: isNumber,
                isElement: isElement,
                isArray: isArray,
                version: version,
                isDate: isDate,
                callbacks: {
                    $$counter: 0
                },
                getTestability: getTestability,
                reloadWithDebugInfo: reloadWithDebugInfo,
                UNSAFE_restoreLegacyJqLiteXHTMLReplacement: UNSAFE_restoreLegacyJqLiteXHTMLReplacement,
                $$minErr: minErr,
                $$csp: csp,
                $$encodeUriSegment: encodeUriSegment,
                $$encodeUriQuery: encodeUriQuery,
                $$lowercase: lowercase,
                $$stringify: stringify,
                $$uppercase: uppercase
            }), (angularModule = function(window) {
                var $injectorMinErr = minErr("$injector"),
                    ngMinErr = minErr("ng");

                function ensure(obj, name, factory) {
                    return obj[name] || (obj[name] = factory())
                }
                var angular = ensure(window, "angular", Object);
                return angular.$$minErr = angular.$$minErr || minErr, ensure(angular, "module", (function() {
                    var modules = {};
                    return function(name, requires, configFn) {
                        var info = {};
                        return function(name, context) {
                            if ("hasOwnProperty" === name) throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", "module")
                        }(name), requires && modules.hasOwnProperty(name) && (modules[name] = null), ensure(modules, name, (function() {
                            if (!requires) throw $injectorMinErr("nomod", "Module '{0}' is not available! You either misspelled the module name or forgot to load it. If registering a module ensure that you specify the dependencies as the second argument.", name);
                            var invokeQueue = [],
                                configBlocks = [],
                                runBlocks = [],
                                config = invokeLater("$injector", "invoke", "push", configBlocks),
                                moduleInstance = {
                                    _invokeQueue: invokeQueue,
                                    _configBlocks: configBlocks,
                                    _runBlocks: runBlocks,
                                    info: function(value) {
                                        if (isDefined(value)) {
                                            if (!isObject(value)) throw ngMinErr("aobj", "Argument '{0}' must be an object", "value");
                                            return info = value, this
                                        }
                                        return info
                                    },
                                    requires: requires,
                                    name: name,
                                    provider: invokeLaterAndSetModuleName("$provide", "provider"),
                                    factory: invokeLaterAndSetModuleName("$provide", "factory"),
                                    service: invokeLaterAndSetModuleName("$provide", "service"),
                                    value: invokeLater("$provide", "value"),
                                    constant: invokeLater("$provide", "constant", "unshift"),
                                    decorator: invokeLaterAndSetModuleName("$provide", "decorator", configBlocks),
                                    animation: invokeLaterAndSetModuleName("$animateProvider", "register"),
                                    filter: invokeLaterAndSetModuleName("$filterProvider", "register"),
                                    controller: invokeLaterAndSetModuleName("$controllerProvider", "register"),
                                    directive: invokeLaterAndSetModuleName("$compileProvider", "directive"),
                                    component: invokeLaterAndSetModuleName("$compileProvider", "component"),
                                    config: config,
                                    run: function(block) {
                                        return runBlocks.push(block), this
                                    }
                                };
                            return configFn && config(configFn), moduleInstance;

                            function invokeLater(provider, method, insertMethod, queue) {
                                return queue || (queue = invokeQueue),
                                    function() {
                                        return queue[insertMethod || "push"]([provider, method, arguments]), moduleInstance
                                    }
                            }

                            function invokeLaterAndSetModuleName(provider, method, queue) {
                                return queue || (queue = invokeQueue),
                                    function(recipeName, factoryFunction) {
                                        return factoryFunction && isFunction(factoryFunction) && (factoryFunction.$$moduleName = name), queue.push([provider, method, arguments]), moduleInstance
                                    }
                            }
                        }))
                    }
                }))
            }(window))("ng", ["ngLocale"], ["$provide", function($provide) {
                $provide.provider({
                    $$sanitizeUri: $$SanitizeUriProvider
                }), $provide.provider("$compile", $CompileProvider).directive({
                    a: htmlAnchorDirective,
                    input: inputDirective,
                    textarea: inputDirective,
                    form: formDirective,
                    script: scriptDirective,
                    select: selectDirective,
                    option: optionDirective,
                    ngBind: ngBindDirective,
                    ngBindHtml: ngBindHtmlDirective,
                    ngBindTemplate: ngBindTemplateDirective,
                    ngClass: ngClassDirective,
                    ngClassEven: ngClassEvenDirective,
                    ngClassOdd: ngClassOddDirective,
                    ngCloak: ngCloakDirective,
                    ngController: ngControllerDirective,
                    ngForm: ngFormDirective,
                    ngHide: ngHideDirective,
                    ngIf: ngIfDirective,
                    ngInclude: ngIncludeDirective,
                    ngInit: ngInitDirective,
                    ngNonBindable: ngNonBindableDirective,
                    ngPluralize: ngPluralizeDirective,
                    ngRef: ngRefDirective,
                    ngRepeat: ngRepeatDirective,
                    ngShow: ngShowDirective,
                    ngStyle: ngStyleDirective,
                    ngSwitch: ngSwitchDirective,
                    ngSwitchWhen: ngSwitchWhenDirective,
                    ngSwitchDefault: ngSwitchDefaultDirective,
                    ngOptions: ngOptionsDirective,
                    ngTransclude: ngTranscludeDirective,
                    ngModel: ngModelDirective,
                    ngList: ngListDirective,
                    ngChange: ngChangeDirective,
                    pattern: patternDirective,
                    ngPattern: patternDirective,
                    required: requiredDirective,
                    ngRequired: requiredDirective,
                    minlength: minlengthDirective,
                    ngMinlength: minlengthDirective,
                    maxlength: maxlengthDirective,
                    ngMaxlength: maxlengthDirective,
                    ngValue: ngValueDirective,
                    ngModelOptions: ngModelOptionsDirective
                }).directive({
                    ngInclude: ngIncludeFillContentDirective,
                    input: hiddenInputBrowserCacheDirective
                }).directive(ngAttributeAliasDirectives).directive(ngEventDirectives), $provide.provider({
                    $anchorScroll: $AnchorScrollProvider,
                    $animate: $AnimateProvider,
                    $animateCss: $CoreAnimateCssProvider,
                    $$animateJs: $$CoreAnimateJsProvider,
                    $$animateQueue: $$CoreAnimateQueueProvider,
                    $$AnimateRunner: $$AnimateRunnerFactoryProvider,
                    $$animateAsyncRun: $$AnimateAsyncRunFactoryProvider,
                    $browser: $BrowserProvider,
                    $cacheFactory: $CacheFactoryProvider,
                    $controller: $ControllerProvider,
                    $document: $DocumentProvider,
                    $$isDocumentHidden: $$IsDocumentHiddenProvider,
                    $exceptionHandler: $ExceptionHandlerProvider,
                    $filter: $FilterProvider,
                    $$forceReflow: $$ForceReflowProvider,
                    $interpolate: $InterpolateProvider,
                    $interval: $IntervalProvider,
                    $$intervalFactory: $$IntervalFactoryProvider,
                    $http: $HttpProvider,
                    $httpParamSerializer: $HttpParamSerializerProvider,
                    $httpParamSerializerJQLike: $HttpParamSerializerJQLikeProvider,
                    $httpBackend: $HttpBackendProvider,
                    $xhrFactory: $xhrFactoryProvider,
                    $jsonpCallbacks: $jsonpCallbacksProvider,
                    $location: $LocationProvider,
                    $log: $LogProvider,
                    $parse: $ParseProvider,
                    $rootScope: $RootScopeProvider,
                    $q: $QProvider,
                    $$q: $$QProvider,
                    $sce: $SceProvider,
                    $sceDelegate: $SceDelegateProvider,
                    $sniffer: $SnifferProvider,
                    $$taskTrackerFactory: $$TaskTrackerFactoryProvider,
                    $templateCache: $TemplateCacheProvider,
                    $templateRequest: $TemplateRequestProvider,
                    $$testability: $$TestabilityProvider,
                    $timeout: $TimeoutProvider,
                    $window: $WindowProvider,
                    $$rAF: $$RAFProvider,
                    $$jqLite: $$jqLiteProvider,
                    $$Map: $$MapProvider,
                    $$cookieReader: $$CookieReaderProvider
                })
            }]).info({
                angularVersion: "1.8.2"
            })
        }(angular), angular.module("ngLocale", [], ["$provide", function($provide) {
            var PLURAL_CATEGORY_ONE = "one",
                PLURAL_CATEGORY_OTHER = "other";
            $provide.value("$locale", {
                DATETIME_FORMATS: {
                    AMPMS: ["AM", "PM"],
                    DAY: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
                    ERANAMES: ["Before Christ", "Anno Domini"],
                    ERAS: ["BC", "AD"],
                    FIRSTDAYOFWEEK: 6,
                    MONTH: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
                    SHORTDAY: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
                    SHORTMONTH: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
                    STANDALONEMONTH: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
                    WEEKENDRANGE: [5, 6],
                    fullDate: "EEEE, MMMM d, y",
                    longDate: "MMMM d, y",
                    medium: "MMM d, y h:mm:ss a",
                    mediumDate: "MMM d, y",
                    mediumTime: "h:mm:ss a",
                    short: "M/d/yy h:mm a",
                    shortDate: "M/d/yy",
                    shortTime: "h:mm a"
                },
                NUMBER_FORMATS: {
                    CURRENCY_SYM: "$",
                    DECIMAL_SEP: ".",
                    GROUP_SEP: ",",
                    PATTERNS: [{
                        gSize: 3,
                        lgSize: 3,
                        maxFrac: 3,
                        minFrac: 0,
                        minInt: 1,
                        negPre: "-",
                        negSuf: "",
                        posPre: "",
                        posSuf: ""
                    }, {
                        gSize: 3,
                        lgSize: 3,
                        maxFrac: 2,
                        minFrac: 2,
                        minInt: 1,
                        negPre: "-¤",
                        negSuf: "",
                        posPre: "¤",
                        posSuf: ""
                    }]
                },
                id: "en-us",
                localeID: "en_US",
                pluralCat: function(n, opt_precision) {
                    var i = 0 | n,
                        vf = function(n, opt_precision) {
                            var v = opt_precision;
                            void 0 === v && (v = Math.min(function(n) {
                                var i = (n += "").indexOf(".");
                                return -1 == i ? 0 : n.length - i - 1
                            }(n), 3));
                            var base = Math.pow(10, v);
                            return {
                                v: v,
                                f: (n * base | 0) % base
                            }
                        }(n, opt_precision);
                    return 1 == i && 0 == vf.v ? PLURAL_CATEGORY_ONE : PLURAL_CATEGORY_OTHER
                }
            })
        }]), jqLite((function() {
            angularInit(window.document, bootstrap)
        })))
    }(window), !window.angular.$$csp().noInlineStyle && window.angular.element(document.head).prepend(window.angular.element("<style>").text('@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}'))
}, function(module, exports) {}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var uiSrefDirective, uiStateDirective, uiSrefActiveDirective, _angular__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(16),
        _uirouter_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(1);

    function parseStateRef(ref) {
        var paramsOnly = ref.match(/^\s*({[^}]*})\s*$/);
        paramsOnly && (ref = "(" + paramsOnly[1] + ")");
        var parsed = ref.replace(/\n/g, " ").match(/^\s*([^(]*?)\s*(\((.*)\))?\s*$/);
        if (!parsed || 4 !== parsed.length) throw new Error("Invalid state ref '" + ref + "'");
        return {
            state: parsed[1] || null,
            paramExpr: parsed[3] || null
        }
    }

    function stateContext(el) {
        var $uiView = el.parent().inheritedData("$uiView"),
            path = Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_1__.parse)("$cfg.path")($uiView);
        return path ? Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_1__.tail)(path).state.name : void 0
    }

    function processedDef($state, $element, def) {
        var uiState = def.uiState || $state.current.name,
            uiStateOpts = Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_1__.extend)(function(el, $state) {
                return {
                    relative: stateContext(el) || $state.$current,
                    inherit: !0,
                    source: "sref"
                }
            }($element, $state), def.uiStateOpts || {}),
            href = $state.href(uiState, def.uiStateParams, uiStateOpts);
        return {
            uiState: uiState,
            uiStateParams: def.uiStateParams,
            uiStateOpts: uiStateOpts,
            href: href
        }
    }

    function getTypeInfo(el) {
        var isSvg = "[object SVGAnimatedString]" === Object.prototype.toString.call(el.prop("href")),
            isForm = "FORM" === el[0].nodeName;
        return {
            attr: isForm ? "action" : isSvg ? "xlink:href" : "href",
            isAnchor: "A" === el.prop("tagName").toUpperCase(),
            clickable: !isForm
        }
    }

    function clickHook(el, $state, $timeout, type, getDef) {
        return function(e) {
            var button = e.which || e.button,
                target = getDef();
            if (!(button > 1 || e.ctrlKey || e.metaKey || e.shiftKey || e.altKey || el.attr("target"))) {
                var transition_1 = $timeout((function() {
                    el.attr("disabled") || $state.go(target.uiState, target.uiStateParams, target.uiStateOpts)
                }));
                e.preventDefault();
                var ignorePreventDefaultCount_1 = type.isAnchor && !target.href ? 1 : 0;
                e.preventDefault = function() {
                    ignorePreventDefaultCount_1-- <= 0 && $timeout.cancel(transition_1)
                }
            }
        }
    }

    function bindEvents(element, scope, hookFn, uiStateOpts) {
        var events;
        uiStateOpts && (events = uiStateOpts.events), Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_1__.isArray)(events) || (events = ["click"]);
        for (var on = element.on ? "on" : "bind", _i = 0, events_1 = events; _i < events_1.length; _i++) {
            var event_1 = events_1[_i];
            element[on](event_1, hookFn)
        }
        scope.$on("$destroy", (function() {
            for (var off = element.off ? "off" : "unbind", _i = 0, events_2 = events; _i < events_2.length; _i++) {
                var event_2 = events_2[_i];
                element[off](event_2, hookFn)
            }
        }))
    }
    uiSrefDirective = ["$uiRouter", "$timeout", function($uiRouter, $timeout) {
        var $state = $uiRouter.stateService;
        return {
            restrict: "A",
            require: ["?^uiSrefActive", "?^uiSrefActiveEq"],
            link: function(scope, element, attrs, uiSrefActive) {
                var type = getTypeInfo(element),
                    active = uiSrefActive[1] || uiSrefActive[0],
                    unlinkInfoFn = null,
                    rawDef = {},
                    getDef = function() {
                        return processedDef($state, element, rawDef)
                    },
                    ref = parseStateRef(attrs.uiSref);

                function update() {
                    var def = getDef();
                    unlinkInfoFn && unlinkInfoFn(), active && (unlinkInfoFn = active.$$addStateInfo(def.uiState, def.uiStateParams)), null != def.href && attrs.$set(type.attr, def.href)
                }
                if (rawDef.uiState = ref.state, rawDef.uiStateOpts = attrs.uiSrefOpts ? scope.$eval(attrs.uiSrefOpts) : {}, ref.paramExpr && (scope.$watch(ref.paramExpr, (function(val) {
                        rawDef.uiStateParams = Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_1__.extend)({}, val), update()
                    }), !0), rawDef.uiStateParams = Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_1__.extend)({}, scope.$eval(ref.paramExpr))), update(), scope.$on("$destroy", $uiRouter.stateRegistry.onStatesChanged(update)), scope.$on("$destroy", $uiRouter.transitionService.onSuccess({}, update)), type.clickable) {
                    var hookFn = clickHook(element, $state, $timeout, type, getDef);
                    bindEvents(element, scope, hookFn, rawDef.uiStateOpts)
                }
            }
        }
    }], uiStateDirective = ["$uiRouter", "$timeout", function($uiRouter, $timeout) {
        var $state = $uiRouter.stateService;
        return {
            restrict: "A",
            require: ["?^uiSrefActive", "?^uiSrefActiveEq"],
            link: function(scope, element, attrs, uiSrefActive) {
                var hookFn, type = getTypeInfo(element),
                    active = uiSrefActive[1] || uiSrefActive[0],
                    unlinkInfoFn = null,
                    rawDef = {},
                    getDef = function() {
                        return processedDef($state, element, rawDef)
                    },
                    inputAttrs = ["uiState", "uiStateParams", "uiStateOpts"],
                    watchDeregFns = inputAttrs.reduce((function(acc, attr) {
                        return acc[attr] = _uirouter_core__WEBPACK_IMPORTED_MODULE_1__.noop, acc
                    }), {});

                function update() {
                    var def = getDef();
                    unlinkInfoFn && unlinkInfoFn(), active && (unlinkInfoFn = active.$$addStateInfo(def.uiState, def.uiStateParams)), null != def.href && attrs.$set(type.attr, def.href)
                }
                inputAttrs.forEach((function(field) {
                    rawDef[field] = attrs[field] ? scope.$eval(attrs[field]) : null, attrs.$observe(field, (function(expr) {
                        watchDeregFns[field](), watchDeregFns[field] = scope.$watch(expr, (function(newval) {
                            rawDef[field] = newval, update()
                        }), !0)
                    }))
                })), update(), scope.$on("$destroy", $uiRouter.stateRegistry.onStatesChanged(update)), scope.$on("$destroy", $uiRouter.transitionService.onSuccess({}, update)), type.clickable && (hookFn = clickHook(element, $state, $timeout, type, getDef), bindEvents(element, scope, hookFn, rawDef.uiStateOpts))
            }
        }
    }], uiSrefActiveDirective = ["$state", "$stateParams", "$interpolate", "$uiRouter", function($state, $stateParams, $interpolate, $uiRouter) {
        return {
            restrict: "A",
            controller: ["$scope", "$element", "$attrs", function($scope, $element, $attrs) {
                var activeEqClass, uiSrefActive, deregisterStatesChangedListener, deregisterOnStartListener, deregisterStateChangeSuccessListener, states = [];
                activeEqClass = $interpolate($attrs.uiSrefActiveEq || "", !1)($scope);
                try {
                    uiSrefActive = $scope.$eval($attrs.uiSrefActive)
                } catch (e) {}

                function updateAfterTransition(trans) {
                    trans.promise.then(update, _uirouter_core__WEBPACK_IMPORTED_MODULE_1__.noop)
                }

                function handleStatesChanged() {
                    setStatesFromDefinitionObject(uiSrefActive)
                }

                function setStatesFromDefinitionObject(statesDefinition) {
                    Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_1__.isObject)(statesDefinition) && (states = [], Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_1__.forEach)(statesDefinition, (function(stateOrName, activeClass) {
                        var addStateForClass = function(stateOrName, activeClass) {
                            var ref = parseStateRef(stateOrName);
                            addState(ref.state, $scope.$eval(ref.paramExpr), activeClass)
                        };
                        Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_1__.isString)(stateOrName) ? addStateForClass(stateOrName, activeClass) : Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_1__.isArray)(stateOrName) && Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_1__.forEach)(stateOrName, (function(stateOrName) {
                            addStateForClass(stateOrName, activeClass)
                        }))
                    })))
                }

                function addState(stateName, stateParams, activeClass) {
                    var stateInfo = {
                        state: $state.get(stateName, stateContext($element)) || {
                            name: stateName
                        },
                        params: stateParams,
                        activeClass: activeClass
                    };
                    return states.push(stateInfo),
                        function() {
                            Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_1__.removeFrom)(states)(stateInfo)
                        }
                }

                function update() {
                    var splitClasses = function(str) {
                            return str.split(/\s/).filter(_uirouter_core__WEBPACK_IMPORTED_MODULE_1__.identity)
                        },
                        getClasses = function(stateList) {
                            return stateList.map((function(x) {
                                return x.activeClass
                            })).map(splitClasses).reduce(_uirouter_core__WEBPACK_IMPORTED_MODULE_1__.unnestR, [])
                        },
                        allClasses = getClasses(states).concat(splitClasses(activeEqClass)).reduce(_uirouter_core__WEBPACK_IMPORTED_MODULE_1__.uniqR, []),
                        fuzzyClasses = getClasses(states.filter((function(x) {
                            return $state.includes(x.state.name, x.params)
                        }))),
                        exactClasses = !!states.filter((function(x) {
                            return $state.is(x.state.name, x.params)
                        })).length ? splitClasses(activeEqClass) : [],
                        addClasses = fuzzyClasses.concat(exactClasses).reduce(_uirouter_core__WEBPACK_IMPORTED_MODULE_1__.uniqR, []),
                        removeClasses = allClasses.filter((function(cls) {
                            return !Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_1__.inArray)(addClasses, cls)
                        }));
                    $scope.$evalAsync((function() {
                        addClasses.forEach((function(className) {
                            return $element.addClass(className)
                        })), removeClasses.forEach((function(className) {
                            return $element.removeClass(className)
                        }))
                    }))
                }
                setStatesFromDefinitionObject(uiSrefActive = uiSrefActive || $interpolate($attrs.uiSrefActive || "", !1)($scope)), this.$$addStateInfo = function(newState, newParams) {
                    if (!(Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_1__.isObject)(uiSrefActive) && states.length > 0)) {
                        var deregister = addState(newState, newParams, uiSrefActive);
                        return update(), deregister
                    }
                }, $scope.$on("$destroy", (deregisterStatesChangedListener = $uiRouter.stateRegistry.onStatesChanged(handleStatesChanged), deregisterOnStartListener = $uiRouter.transitionService.onStart({}, updateAfterTransition), deregisterStateChangeSuccessListener = $scope.$on("$stateChangeSuccess", update), function() {
                    deregisterStatesChangedListener(), deregisterOnStartListener(), deregisterStateChangeSuccessListener()
                })), $uiRouter.globals.transition && updateAfterTransition($uiRouter.globals.transition), update()
            }]
        }
    }], _angular__WEBPACK_IMPORTED_MODULE_0__.a.module("ui.router.state").directive("uiSref", uiSrefDirective).directive("uiSrefActive", uiSrefActiveDirective).directive("uiSrefActiveEq", uiSrefActiveDirective).directive("uiState", uiStateDirective)
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var _angular__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(16);

    function $IsStateFilter($state) {
        var isFilter = function(state, params, options) {
            return $state.is(state, params, options)
        };
        return isFilter.$stateful = !0, isFilter
    }

    function $IncludedByStateFilter($state) {
        var includesFilter = function(state, params, options) {
            return $state.includes(state, params, options)
        };
        return includesFilter.$stateful = !0, includesFilter
    }
    $IsStateFilter.$inject = ["$state"], $IncludedByStateFilter.$inject = ["$state"], _angular__WEBPACK_IMPORTED_MODULE_0__.a.module("ui.router.state").filter("isState", $IsStateFilter).filter("includedByState", $IncludedByStateFilter)
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    var uiView, _uirouter_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1),
        _angular__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(16),
        _services__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(88),
        _statebuilders_views__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(46);

    function $ViewDirectiveFill($compile, $controller, $transitions, $view, $q) {
        var getControllerAs = Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.parse)("viewDecl.controllerAs"),
            getResolveAs = Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.parse)("viewDecl.resolveAs");
        return {
            restrict: "ECA",
            priority: -400,
            compile: function(tElement) {
                var initial = tElement.html();
                return tElement.empty(),
                    function(scope, $element) {
                        var data = $element.data("$uiView");
                        if (!data) return $element.html(initial), void $compile($element.contents())(scope);
                        var cfg = data.$cfg || {
                                viewDecl: {},
                                getTemplate: _uirouter_core__WEBPACK_IMPORTED_MODULE_0__.noop
                            },
                            resolveCtx = cfg.path && new _uirouter_core__WEBPACK_IMPORTED_MODULE_0__.ResolveContext(cfg.path);
                        $element.html(cfg.getTemplate($element, resolveCtx) || initial), _uirouter_core__WEBPACK_IMPORTED_MODULE_0__.trace.traceUIViewFill(data.$uiView, $element.html());
                        var link = $compile($element.contents()),
                            controller = cfg.controller,
                            controllerAs = getControllerAs(cfg),
                            resolveAs = getResolveAs(cfg),
                            locals = resolveCtx && Object(_services__WEBPACK_IMPORTED_MODULE_2__.a)(resolveCtx);
                        if (scope[resolveAs] = locals, controller) {
                            var controllerInstance = $controller(controller, Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.extend)({}, locals, {
                                $scope: scope,
                                $element: $element
                            }));
                            controllerAs && (scope[controllerAs] = controllerInstance, scope[controllerAs][resolveAs] = locals), $element.data("$ngControllerController", controllerInstance), $element.children().data("$ngControllerController", controllerInstance), registerControllerCallbacks($q, $transitions, controllerInstance, scope, cfg)
                        }
                        if (Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.isString)(cfg.component)) var kebobName = Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.kebobString)(cfg.component),
                            tagRegexp_1 = new RegExp("^(x-|data-)?" + kebobName + "$", "i"),
                            deregisterWatch_1 = scope.$watch((function() {
                                var directiveEl = [].slice.call($element[0].children).filter((function(el) {
                                    return el && el.tagName && tagRegexp_1.exec(el.tagName)
                                }));
                                return directiveEl && _angular__WEBPACK_IMPORTED_MODULE_1__.a.element(directiveEl).data("$" + cfg.component + "Controller")
                            }), (function(ctrlInstance) {
                                ctrlInstance && (registerControllerCallbacks($q, $transitions, ctrlInstance, scope, cfg), deregisterWatch_1())
                            }));
                        link(scope)
                    }
            }
        }
    }
    uiView = ["$view", "$animate", "$uiViewScroll", "$interpolate", "$q", function($view, $animate, $uiViewScroll, $interpolate, $q) {
        var rootData = {
                $cfg: {
                    viewDecl: {
                        $context: $view._pluginapi._rootViewContext()
                    }
                },
                $uiView: {}
            },
            directive = {
                count: 0,
                restrict: "ECA",
                terminal: !0,
                priority: 400,
                transclude: "element",
                compile: function(tElement, tAttrs, $transclude) {
                    return function(scope, $element, attrs) {
                        var previousEl, currentEl, currentScope, viewConfig, onloadExp = attrs.onload || "",
                            autoScrollExp = attrs.autoscroll,
                            renderer = {
                                enter: function(element, target, cb) {
                                    _angular__WEBPACK_IMPORTED_MODULE_1__.a.version.minor > 2 ? $animate.enter(element, null, target).then(cb) : $animate.enter(element, null, target, cb)
                                },
                                leave: function(element, cb) {
                                    _angular__WEBPACK_IMPORTED_MODULE_1__.a.version.minor > 2 ? $animate.leave(element).then(cb) : $animate.leave(element, cb)
                                }
                            },
                            inherited = $element.inheritedData("$uiView") || rootData,
                            name = $interpolate(attrs.uiView || attrs.name || "")(scope) || "$default",
                            activeUIView = {
                                $type: "ng1",
                                id: directive.count++,
                                name: name,
                                fqn: inherited.$uiView.fqn ? inherited.$uiView.fqn + "." + name : name,
                                config: null,
                                configUpdated: function(config) {
                                    if (config && !(config instanceof _statebuilders_views__WEBPACK_IMPORTED_MODULE_3__.a)) return;
                                    if (config1 = viewConfig, config2 = config, config1 === config2) return;
                                    var config1, config2;
                                    _uirouter_core__WEBPACK_IMPORTED_MODULE_0__.trace.traceUIViewConfigUpdated(activeUIView, config && config.viewDecl && config.viewDecl.$context), viewConfig = config, updateView(config)
                                },
                                get creationContext() {
                                    var fromParentTagConfig = Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.parse)("$cfg.viewDecl.$context")(inherited),
                                        fromParentTag = Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.parse)("$uiView.creationContext")(inherited);
                                    return fromParentTagConfig || fromParentTag
                                }
                            };
                        _uirouter_core__WEBPACK_IMPORTED_MODULE_0__.trace.traceUIViewEvent("Linking", activeUIView), $element.data("$uiView", {
                            $uiView: activeUIView
                        }), updateView();
                        var unregister = $view.registerUIView(activeUIView);

                        function updateView(config) {
                            var newScope = scope.$new(),
                                animEnter = $q.defer(),
                                animLeave = $q.defer(),
                                $uiViewData = {
                                    $cfg: config,
                                    $uiView: activeUIView
                                },
                                $uiViewAnim = {
                                    $animEnter: animEnter.promise,
                                    $animLeave: animLeave.promise,
                                    $$animLeave: animLeave
                                };
                            newScope.$emit("$viewContentLoading", name);
                            var cloned = $transclude(newScope, (function(clone) {
                                clone.data("$uiViewAnim", $uiViewAnim), clone.data("$uiView", $uiViewData), renderer.enter(clone, $element, (function() {
                                        animEnter.resolve(), currentScope && currentScope.$emit("$viewContentAnimationEnded"), (Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.isDefined)(autoScrollExp) && !autoScrollExp || scope.$eval(autoScrollExp)) && $uiViewScroll(clone)
                                    })),
                                    function() {
                                        if (previousEl && (_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.trace.traceUIViewEvent("Removing (previous) el", previousEl.data("$uiView")), previousEl.remove(), previousEl = null), currentScope && (_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.trace.traceUIViewEvent("Destroying scope", activeUIView), currentScope.$destroy(), currentScope = null), currentEl) {
                                            var _viewData_1 = currentEl.data("$uiViewAnim");
                                            _uirouter_core__WEBPACK_IMPORTED_MODULE_0__.trace.traceUIViewEvent("Animate out", _viewData_1), renderer.leave(currentEl, (function() {
                                                _viewData_1.$$animLeave.resolve(), previousEl = null
                                            })), previousEl = currentEl, currentEl = null
                                        }
                                    }()
                            }));
                            currentEl = cloned, (currentScope = newScope).$emit("$viewContentLoaded", config || viewConfig), currentScope.$eval(onloadExp)
                        }
                        scope.$on("$destroy", (function() {
                            _uirouter_core__WEBPACK_IMPORTED_MODULE_0__.trace.traceUIViewEvent("Destroying/Unregistering", activeUIView), unregister()
                        }))
                    }
                }
            };
        return directive
    }], $ViewDirectiveFill.$inject = ["$compile", "$controller", "$transitions", "$view", "$q"];
    var hasComponentImpl = "function" == typeof _angular__WEBPACK_IMPORTED_MODULE_1__.a.module("ui.router").component,
        _uiCanExitId = 0;

    function registerControllerCallbacks($q, $transitions, controllerInstance, $scope, cfg) {
        !Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.isFunction)(controllerInstance.$onInit) || (cfg.viewDecl.component || cfg.viewDecl.componentProvider) && hasComponentImpl || controllerInstance.$onInit();
        var viewState = Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.tail)(cfg.path).state.self,
            hookOptions = {
                bind: controllerInstance
            };
        if (Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.isFunction)(controllerInstance.uiOnParamsChanged)) {
            var viewCreationTrans_1 = new _uirouter_core__WEBPACK_IMPORTED_MODULE_0__.ResolveContext(cfg.path).getResolvable("$transition$").data;
            $scope.$on("$destroy", $transitions.onSuccess({}, (function($transition$) {
                if ($transition$ !== viewCreationTrans_1 && -1 === $transition$.exiting().indexOf(viewState)) {
                    var toParams = $transition$.params("to"),
                        fromParams = $transition$.params("from"),
                        getNodeSchema = function(node) {
                            return node.paramSchema
                        },
                        toSchema = $transition$.treeChanges("to").map(getNodeSchema).reduce(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.unnestR, []),
                        fromSchema = $transition$.treeChanges("from").map(getNodeSchema).reduce(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.unnestR, []),
                        changedToParams = toSchema.filter((function(param) {
                            var idx = fromSchema.indexOf(param);
                            return -1 === idx || !fromSchema[idx].type.equals(toParams[param.id], fromParams[param.id])
                        }));
                    if (changedToParams.length) {
                        var changedKeys_1 = changedToParams.map((function(x) {
                                return x.id
                            })),
                            newValues = Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.filter)(toParams, (function(val, key) {
                                return -1 !== changedKeys_1.indexOf(key)
                            }));
                        controllerInstance.uiOnParamsChanged(newValues, $transition$)
                    }
                }
            }), hookOptions))
        }
        if (Object(_uirouter_core__WEBPACK_IMPORTED_MODULE_0__.isFunction)(controllerInstance.uiCanExit)) {
            var id_1 = _uiCanExitId++,
                prevTruthyAnswer_1 = function(trans) {
                    return !!trans && (trans._uiCanExitIds && !0 === trans._uiCanExitIds[id_1] || prevTruthyAnswer_1(trans.redirectedFrom()))
                },
                criteria = {
                    exiting: viewState.name
                };
            $scope.$on("$destroy", $transitions.onBefore(criteria, (function(trans) {
                var promise, ids = trans._uiCanExitIds = trans._uiCanExitIds || {};
                return prevTruthyAnswer_1(trans) || (promise = $q.when(controllerInstance.uiCanExit(trans))).then((function(val) {
                    return ids[id_1] = !1 !== val
                })), promise
            }), hookOptions))
        }
    }
    _angular__WEBPACK_IMPORTED_MODULE_1__.a.module("ui.router.state").directive("uiView", uiView), _angular__WEBPACK_IMPORTED_MODULE_1__.a.module("ui.router.state").directive("uiView", $ViewDirectiveFill)
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__(16).a.module("ui.router.state").provider("$uiViewScroll", (function() {
        var useAnchorScroll = !1;
        this.useAnchorScroll = function() {
            useAnchorScroll = !0
        }, this.$get = ["$anchorScroll", "$timeout", function($anchorScroll, $timeout) {
            return useAnchorScroll ? $anchorScroll : function($element) {
                return $timeout((function() {
                    $element[0].scrollIntoView()
                }), 0, !1)
            }
        }]
    }))
}, function(module, exports) {}, function(module, exports, __webpack_require__) {
    var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;
    ! function() {
        "use strict";

        function isUndefinedOrNull(val) {
            return angular.isUndefined(val) || null === val
        }
        window && window.process && window.process.type;
        __WEBPACK_AMD_DEFINE_ARRAY__ = [__webpack_require__(50), __webpack_require__(3)], void 0 === (__WEBPACK_AMD_DEFINE_RESULT__ = "function" == typeof(__WEBPACK_AMD_DEFINE_FACTORY__ = function(angular, moment) {
            return void 0 === moment && (moment = function() {
                try {
                    return __webpack_require__(3)
                } catch (e) {
                    throw new Error("Please install moment via npm. Please reference to: https://github.com/urish/angular-moment")
                }
            }()), angular.module("angularMoment", []).constant("angularMomentConfig", {
                preprocess: null,
                timezone: null,
                format: null,
                statefulFilters: !0
            }).constant("moment", moment).constant("amTimeAgoConfig", {
                withoutSuffix: !1,
                serverTime: null,
                titleFormat: null,
                fullDateThreshold: null,
                fullDateFormat: null,
                fullDateThresholdUnit: "day"
            }).directive("amTimeAgo", ["$window", "moment", "amMoment", "amTimeAgoConfig", function($window, moment, amMoment, amTimeAgoConfig) {
                return function(scope, element, attr) {
                    var currentValue, currentFrom, activeTimeout = null,
                        withoutSuffix = amTimeAgoConfig.withoutSuffix,
                        titleFormat = amTimeAgoConfig.titleFormat,
                        fullDateThreshold = amTimeAgoConfig.fullDateThreshold,
                        fullDateFormat = amTimeAgoConfig.fullDateFormat,
                        fullDateThresholdUnit = amTimeAgoConfig.fullDateThresholdUnit,
                        localDate = (new Date).getTime(),
                        modelName = attr.amTimeAgo,
                        isTimeElement = "TIME" === element[0].nodeName.toUpperCase(),
                        setTitleTime = !element.attr("title");

                    function getNow() {
                        var now;
                        if (currentFrom) now = currentFrom;
                        else if (amTimeAgoConfig.serverTime) {
                            var nowMillis = (new Date).getTime() - localDate + amTimeAgoConfig.serverTime;
                            now = moment(nowMillis)
                        } else now = moment();
                        return now
                    }

                    function cancelTimer() {
                        activeTimeout && ($window.clearTimeout(activeTimeout), activeTimeout = null)
                    }

                    function updateTime(momentInstance) {
                        var timeAgo = getNow().diff(momentInstance, fullDateThresholdUnit),
                            showFullDate = fullDateThreshold && timeAgo >= fullDateThreshold;
                        if (showFullDate ? element.text(momentInstance.format(fullDateFormat)) : element.text(momentInstance.from(getNow(), withoutSuffix)), titleFormat && setTitleTime && element.attr("title", momentInstance.format(titleFormat)), !showFullDate) {
                            var howOld = Math.abs(getNow().diff(momentInstance, "minute")),
                                secondsUntilUpdate = 3600;
                            howOld < 1 ? secondsUntilUpdate = 1 : howOld < 60 ? secondsUntilUpdate = 30 : howOld < 180 && (secondsUntilUpdate = 300), activeTimeout = $window.setTimeout((function() {
                                updateTime(momentInstance)
                            }), 1e3 * secondsUntilUpdate)
                        }
                    }

                    function updateDateTimeAttr(value) {
                        isTimeElement && element.attr("datetime", value)
                    }

                    function updateMoment() {
                        if (cancelTimer(), currentValue) {
                            var momentValue = amMoment.preprocessDate(currentValue);
                            updateTime(momentValue), updateDateTimeAttr(momentValue.toISOString())
                        }
                    }
                    scope.$watch(modelName, (function(value) {
                        if (isUndefinedOrNull(value) || "" === value) return cancelTimer(), void(currentValue && (element.text(""), updateDateTimeAttr(""), currentValue = null));
                        currentValue = value, updateMoment()
                    })), angular.isDefined(attr.amFrom) && scope.$watch(attr.amFrom, (function(value) {
                        currentFrom = isUndefinedOrNull(value) || "" === value ? null : moment(value), updateMoment()
                    })), angular.isDefined(attr.amWithoutSuffix) && scope.$watch(attr.amWithoutSuffix, (function(value) {
                        "boolean" == typeof value ? (withoutSuffix = value, updateMoment()) : withoutSuffix = amTimeAgoConfig.withoutSuffix
                    })), attr.$observe("amFullDateThreshold", (function(newValue) {
                        fullDateThreshold = newValue, updateMoment()
                    })), attr.$observe("amFullDateFormat", (function(newValue) {
                        fullDateFormat = newValue, updateMoment()
                    })), attr.$observe("amFullDateThresholdUnit", (function(newValue) {
                        fullDateThresholdUnit = newValue, updateMoment()
                    })), scope.$on("$destroy", (function() {
                        cancelTimer()
                    })), scope.$on("amMoment:localeChanged", (function() {
                        updateMoment()
                    }))
                }
            }]).service("amMoment", ["moment", "$rootScope", "$log", "angularMomentConfig", function(moment, $rootScope, $log, angularMomentConfig) {
                var defaultTimezone = null;
                this.changeLocale = function(locale, customization) {
                    var result = moment.locale(locale, customization);
                    return angular.isDefined(locale) && $rootScope.$broadcast("amMoment:localeChanged"), result
                }, this.changeTimezone = function(timezone) {
                    moment.tz && moment.tz.setDefault ? (moment.tz.setDefault(timezone), $rootScope.$broadcast("amMoment:timezoneChanged")) : $log.warn("angular-moment: changeTimezone() works only with moment-timezone.js v0.3.0 or greater."), angularMomentConfig.timezone = timezone, defaultTimezone = timezone
                }, this.preprocessDate = function(value) {
                    return defaultTimezone !== angularMomentConfig.timezone && this.changeTimezone(angularMomentConfig.timezone), angularMomentConfig.preprocess ? angularMomentConfig.preprocess(value) : !isNaN(parseFloat(value)) && isFinite(value) ? moment(parseInt(value, 10)) : moment(value)
                }
            }]).filter("amParse", ["moment", function(moment) {
                return function(value, format) {
                    return moment(value, format)
                }
            }]).filter("amFromUnix", ["moment", function(moment) {
                return function(value) {
                    return moment.unix(value)
                }
            }]).filter("amUtc", ["moment", function(moment) {
                return function(value) {
                    return moment.utc(value)
                }
            }]).filter("amUtcOffset", ["amMoment", function(amMoment) {
                return function(value, offset) {
                    return amMoment.preprocessDate(value).utcOffset(offset)
                }
            }]).filter("amLocal", ["moment", function(moment) {
                return function(value) {
                    return moment.isMoment(value) ? value.local() : null
                }
            }]).filter("amTimezone", ["amMoment", "angularMomentConfig", "$log", function(amMoment, angularMomentConfig, $log) {
                return function(value, timezone) {
                    var aMoment = amMoment.preprocessDate(value);
                    return timezone ? aMoment.tz ? aMoment.tz(timezone) : ($log.warn("angular-moment: named timezone specified but moment.tz() is undefined. Did you forget to include moment-timezone.js ?"), aMoment) : aMoment
                }
            }]).filter("amCalendar", ["moment", "amMoment", "angularMomentConfig", function(moment, amMoment, angularMomentConfig) {
                function amCalendarFilter(value, referenceTime, formats) {
                    if (isUndefinedOrNull(value)) return "";
                    var date = amMoment.preprocessDate(value);
                    return date.isValid() ? date.calendar(referenceTime, formats) : ""
                }
                return amCalendarFilter.$stateful = angularMomentConfig.statefulFilters, amCalendarFilter
            }]).filter("amDifference", ["moment", "amMoment", "angularMomentConfig", function(moment, amMoment, angularMomentConfig) {
                function amDifferenceFilter(value, otherValue, unit, usePrecision) {
                    if (isUndefinedOrNull(value)) return "";
                    var date = amMoment.preprocessDate(value),
                        date2 = isUndefinedOrNull(otherValue) ? moment() : amMoment.preprocessDate(otherValue);
                    return date.isValid() && date2.isValid() ? date.diff(date2, unit, usePrecision) : ""
                }
                return amDifferenceFilter.$stateful = angularMomentConfig.statefulFilters, amDifferenceFilter
            }]).filter("amDateFormat", ["moment", "amMoment", "angularMomentConfig", function(moment, amMoment, angularMomentConfig) {
                function amDateFormatFilter(value, format) {
                    if (isUndefinedOrNull(value)) return "";
                    var date = amMoment.preprocessDate(value);
                    return date.isValid() ? date.format(format) : ""
                }
                return amDateFormatFilter.$stateful = angularMomentConfig.statefulFilters, amDateFormatFilter
            }]).filter("amDurationFormat", ["moment", "angularMomentConfig", function(moment, angularMomentConfig) {
                function amDurationFormatFilter(value, format, suffix) {
                    return isUndefinedOrNull(value) ? "" : moment.duration(value, format).humanize(suffix)
                }
                return amDurationFormatFilter.$stateful = angularMomentConfig.statefulFilters, amDurationFormatFilter
            }]).filter("amTimeAgo", ["moment", "amMoment", "angularMomentConfig", function(moment, amMoment, angularMomentConfig) {
                function amTimeAgoFilter(value, suffix, from) {
                    var date, dateFrom;
                    return isUndefinedOrNull(value) ? "" : (value = amMoment.preprocessDate(value), (date = moment(value)).isValid() ? (dateFrom = moment(from), !isUndefinedOrNull(from) && dateFrom.isValid() ? date.from(dateFrom, suffix) : date.fromNow(suffix)) : "")
                }
                return amTimeAgoFilter.$stateful = angularMomentConfig.statefulFilters, amTimeAgoFilter
            }]).filter("amSubtract", ["moment", "angularMomentConfig", function(moment, angularMomentConfig) {
                function amSubtractFilter(value, amount, type) {
                    return isUndefinedOrNull(value) ? "" : moment(value).subtract(parseInt(amount, 10), type)
                }
                return amSubtractFilter.$stateful = angularMomentConfig.statefulFilters, amSubtractFilter
            }]).filter("amAdd", ["moment", "angularMomentConfig", function(moment, angularMomentConfig) {
                function amAddFilter(value, amount, type) {
                    return isUndefinedOrNull(value) ? "" : moment(value).add(parseInt(amount, 10), type)
                }
                return amAddFilter.$stateful = angularMomentConfig.statefulFilters, amAddFilter
            }]).filter("amStartOf", ["moment", "angularMomentConfig", function(moment, angularMomentConfig) {
                function amStartOfFilter(value, type) {
                    return isUndefinedOrNull(value) ? "" : moment(value).startOf(type)
                }
                return amStartOfFilter.$stateful = angularMomentConfig.statefulFilters, amStartOfFilter
            }]).filter("amEndOf", ["moment", "angularMomentConfig", function(moment, angularMomentConfig) {
                function amEndOfFilter(value, type) {
                    return isUndefinedOrNull(value) ? "" : moment(value).endOf(type)
                }
                return amEndOfFilter.$stateful = angularMomentConfig.statefulFilters, amEndOfFilter
            }]), "angularMoment"
        }) ? __WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__) : __WEBPACK_AMD_DEFINE_FACTORY__) || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)
    }()
}, function(module, exports, __webpack_require__) {
    __webpack_require__(274), module.exports = "ngSanitize"
}, function(module, exports) {
    ! function(window, angular) {
        "use strict";
        var bind, extend, forEach, isArray, isDefined, lowercase, noop, nodeContains, htmlParser, htmlSanitizeWriter, $sanitizeMinErr = angular.$$minErr("$sanitize");
        angular.module("ngSanitize", []).provider("$sanitize", (function() {
            var hasBeenInstantiated = !1,
                svgEnabled = !1;
            this.$get = ["$$sanitizeUri", function($$sanitizeUri) {
                return hasBeenInstantiated = !0, svgEnabled && extend(validElements, svgElements),
                    function(html) {
                        var buf = [];
                        return htmlParser(html, htmlSanitizeWriter(buf, (function(uri, isImage) {
                            return !/^unsafe:/.test($$sanitizeUri(uri, isImage))
                        }))), buf.join("")
                    }
            }], this.enableSvg = function(enableSvg) {
                return isDefined(enableSvg) ? (svgEnabled = enableSvg, this) : svgEnabled
            }, this.addValidElements = function(elements) {
                return hasBeenInstantiated || (isArray(elements) && (elements = {
                    htmlElements: elements
                }), addElementsTo(svgElements, elements.svgElements), addElementsTo(voidElements, elements.htmlVoidElements), addElementsTo(validElements, elements.htmlVoidElements), addElementsTo(validElements, elements.htmlElements)), this
            }, this.addValidAttrs = function(attrs) {
                return hasBeenInstantiated || extend(validAttrs, arrayToMap(attrs, !0)), this
            }, bind = angular.bind, extend = angular.extend, forEach = angular.forEach, isArray = angular.isArray, isDefined = angular.isDefined, lowercase = angular.$$lowercase, noop = angular.noop, htmlParser = function(html, handler) {
                null == html ? html = "" : "string" != typeof html && (html = "" + html);
                var inertBodyElement = getInertBodyElement(html);
                if (!inertBodyElement) return "";
                var mXSSAttempts = 5;
                do {
                    if (0 === mXSSAttempts) throw $sanitizeMinErr("uinput", "Failed to sanitize html because the input is unstable");
                    mXSSAttempts--, html = inertBodyElement.innerHTML, inertBodyElement = getInertBodyElement(html)
                } while (html !== inertBodyElement.innerHTML);
                var node = inertBodyElement.firstChild;
                for (; node;) {
                    switch (node.nodeType) {
                        case 1:
                            handler.start(node.nodeName.toLowerCase(), attrToMap(node.attributes));
                            break;
                        case 3:
                            handler.chars(node.textContent)
                    }
                    var nextNode;
                    if (!((nextNode = node.firstChild) || (1 === node.nodeType && handler.end(node.nodeName.toLowerCase()), nextNode = getNonDescendant("nextSibling", node))))
                        for (; null == nextNode && (node = getNonDescendant("parentNode", node)) !== inertBodyElement;) nextNode = getNonDescendant("nextSibling", node), 1 === node.nodeType && handler.end(node.nodeName.toLowerCase());
                    node = nextNode
                }
                for (; node = inertBodyElement.firstChild;) inertBodyElement.removeChild(node)
            }, htmlSanitizeWriter = function(buf, uriValidator) {
                var ignoreCurrentElement = !1,
                    out = bind(buf, buf.push);
                return {
                    start: function(tag, attrs) {
                        tag = lowercase(tag), !ignoreCurrentElement && blockedElements[tag] && (ignoreCurrentElement = tag), ignoreCurrentElement || !0 !== validElements[tag] || (out("<"), out(tag), forEach(attrs, (function(value, key) {
                            var lkey = lowercase(key),
                                isImage = "img" === tag && "src" === lkey || "background" === lkey;
                            !0 !== validAttrs[lkey] || !0 === uriAttrs[lkey] && !uriValidator(value, isImage) || (out(" "), out(key), out('="'), out(encodeEntities(value)), out('"'))
                        })), out(">"))
                    },
                    end: function(tag) {
                        tag = lowercase(tag), ignoreCurrentElement || !0 !== validElements[tag] || !0 === voidElements[tag] || (out("</"), out(tag), out(">")), tag == ignoreCurrentElement && (ignoreCurrentElement = !1)
                    },
                    chars: function(chars) {
                        ignoreCurrentElement || out(encodeEntities(chars))
                    }
                }
            }, nodeContains = window.Node.prototype.contains || function(arg) {
                return !!(16 & this.compareDocumentPosition(arg))
            };
            var SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
                NON_ALPHANUMERIC_REGEXP = /([^#-~ |!])/g,
                voidElements = stringToMap("area,br,col,hr,img,wbr"),
                optionalEndTagBlockElements = stringToMap("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"),
                optionalEndTagInlineElements = stringToMap("rp,rt"),
                optionalEndTagElements = extend({}, optionalEndTagInlineElements, optionalEndTagBlockElements),
                blockElements = extend({}, optionalEndTagBlockElements, stringToMap("address,article,aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,section,table,ul")),
                inlineElements = extend({}, optionalEndTagInlineElements, stringToMap("a,abbr,acronym,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s,samp,small,span,strike,strong,sub,sup,time,tt,u,var")),
                svgElements = stringToMap("circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph,hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline,radialGradient,rect,stop,svg,switch,text,title,tspan"),
                blockedElements = stringToMap("script,style"),
                validElements = extend({}, voidElements, blockElements, inlineElements, optionalEndTagElements),
                uriAttrs = stringToMap("background,cite,href,longdesc,src,xlink:href,xml:base"),
                htmlAttrs = stringToMap("abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type,valign,value,vspace,width"),
                svgAttrs = stringToMap("accent-height,accumulate,additive,alphabetic,arabic-form,ascent,baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan", !0),
                validAttrs = extend({}, uriAttrs, svgAttrs, htmlAttrs);

            function stringToMap(str, lowercaseKeys) {
                return arrayToMap(str.split(","), lowercaseKeys)
            }

            function arrayToMap(items, lowercaseKeys) {
                var i, obj = {};
                for (i = 0; i < items.length; i++) obj[lowercaseKeys ? lowercase(items[i]) : items[i]] = !0;
                return obj
            }

            function addElementsTo(elementsMap, newElements) {
                newElements && newElements.length && extend(elementsMap, arrayToMap(newElements))
            }
            var getInertBodyElement = function(window, document) {
                if (function() {
                        try {
                            return !!getInertBodyElement_DOMParser("")
                        } catch (e) {
                            return !1
                        }
                    }()) return getInertBodyElement_DOMParser;
                if (!document || !document.implementation) throw $sanitizeMinErr("noinert", "Can't create an inert html document");
                var inertDocument = document.implementation.createHTMLDocument("inert"),
                    inertBodyElement = (inertDocument.documentElement || inertDocument.getDocumentElement()).querySelector("body");
                return function(html) {
                    inertBodyElement.innerHTML = html, document.documentMode && stripCustomNsAttrs(inertBodyElement);
                    return inertBodyElement
                };

                function getInertBodyElement_DOMParser(html) {
                    html = "<remove></remove>" + html;
                    try {
                        var body = (new window.DOMParser).parseFromString(html, "text/html").body;
                        return body.firstChild.remove(), body
                    } catch (e) {
                        return
                    }
                }
            }(window, window.document);

            function attrToMap(attrs) {
                for (var map = {}, i = 0, ii = attrs.length; i < ii; i++) {
                    var attr = attrs[i];
                    map[attr.name] = attr.value
                }
                return map
            }

            function encodeEntities(value) {
                return value.replace(/&/g, "&amp;").replace(SURROGATE_PAIR_REGEXP, (function(value) {
                    return "&#" + (1024 * (value.charCodeAt(0) - 55296) + (value.charCodeAt(1) - 56320) + 65536) + ";"
                })).replace(NON_ALPHANUMERIC_REGEXP, (function(value) {
                    return "&#" + value.charCodeAt(0) + ";"
                })).replace(/</g, "&lt;").replace(/>/g, "&gt;")
            }

            function stripCustomNsAttrs(node) {
                for (; node;) {
                    if (node.nodeType === window.Node.ELEMENT_NODE)
                        for (var attrs = node.attributes, i = 0, l = attrs.length; i < l; i++) {
                            var attrNode = attrs[i],
                                attrName = attrNode.name.toLowerCase();
                            "xmlns:ns1" !== attrName && 0 !== attrName.lastIndexOf("ns1:", 0) || (node.removeAttributeNode(attrNode), i--, l--)
                        }
                    var nextNode = node.firstChild;
                    nextNode && stripCustomNsAttrs(nextNode), node = getNonDescendant("nextSibling", node)
                }
            }

            function getNonDescendant(propName, node) {
                var nextNode = node[propName];
                if (nextNode && nodeContains.call(node, nextNode)) throw $sanitizeMinErr("elclob", "Failed to sanitize html because the element is clobbered: {0}", node.outerHTML || node.outerText);
                return nextNode
            }
        })).info({
            angularVersion: "1.8.2"
        }), angular.module("ngSanitize").filter("linky", ["$sanitize", function($sanitize) {
            var LINKY_URL_REGEXP = /((s?ftp|https?):\/\/|(www\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>"\u201d\u2019]/i,
                MAILTO_REGEXP = /^mailto:/i,
                linkyMinErr = angular.$$minErr("linky"),
                isDefined = angular.isDefined,
                isFunction = angular.isFunction,
                isObject = angular.isObject,
                isString = angular.isString;
            return function(text, target, attributes) {
                if (null == text || "" === text) return text;
                if (!isString(text)) throw linkyMinErr("notstring", "Expected string but received: {0}", text);
                for (var match, url, i, attributesFn = isFunction(attributes) ? attributes : isObject(attributes) ? function() {
                        return attributes
                    } : function() {
                        return {}
                    }, raw = text, html = []; match = raw.match(LINKY_URL_REGEXP);) url = match[0], match[2] || match[4] || (url = (match[3] ? "http://" : "mailto:") + url), i = match.index, addText(raw.substr(0, i)), addLink(url, match[0].replace(MAILTO_REGEXP, "")), raw = raw.substring(i + match[0].length);
                return addText(raw), $sanitize(html.join(""));

                function addText(text) {
                    var chars, buf;
                    text && html.push((chars = text, htmlSanitizeWriter(buf = [], noop).chars(chars), buf.join("")))
                }

                function addLink(url, text) {
                    var key, linkAttributes = attributesFn(url);
                    for (key in html.push("<a "), linkAttributes) html.push(key + '="' + linkAttributes[key] + '" ');
                    isDefined(target) && !("target" in linkAttributes) && html.push('target="', target, '" '), html.push('href="', url.replace(/"/g, "&quot;"), '">'), addText(text), html.push("</a>")
                }
            }
        }])
    }(window, window.angular)
}, function(module, exports, __webpack_require__) {
    var ___EXPOSE_LOADER_IMPORT___ = __webpack_require__(276),
        ___EXPOSE_LOADER_GLOBAL_THIS___ = __webpack_require__(101);
    void 0 === ___EXPOSE_LOADER_GLOBAL_THIS___.he && (___EXPOSE_LOADER_GLOBAL_THIS___.he = ___EXPOSE_LOADER_IMPORT___), module.exports = ___EXPOSE_LOADER_IMPORT___
}, function(module, exports, __webpack_require__) {
    (function(module, global) {
        var __WEBPACK_AMD_DEFINE_RESULT__;
        ! function(root) {
            var freeExports = exports,
                freeGlobal = (module && module.exports, "object" == typeof global && global);
            freeGlobal.global !== freeGlobal && freeGlobal.window;
            var regexAstralSymbols = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
                regexAsciiWhitelist = /[\x01-\x7F]/g,
                regexBmpWhitelist = /[\x01-\t\x0B\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g,
                regexEncodeNonAscii = /<\u20D2|=\u20E5|>\u20D2|\u205F\u200A|\u219D\u0338|\u2202\u0338|\u2220\u20D2|\u2229\uFE00|\u222A\uFE00|\u223C\u20D2|\u223D\u0331|\u223E\u0333|\u2242\u0338|\u224B\u0338|\u224D\u20D2|\u224E\u0338|\u224F\u0338|\u2250\u0338|\u2261\u20E5|\u2264\u20D2|\u2265\u20D2|\u2266\u0338|\u2267\u0338|\u2268\uFE00|\u2269\uFE00|\u226A\u0338|\u226A\u20D2|\u226B\u0338|\u226B\u20D2|\u227F\u0338|\u2282\u20D2|\u2283\u20D2|\u228A\uFE00|\u228B\uFE00|\u228F\u0338|\u2290\u0338|\u2293\uFE00|\u2294\uFE00|\u22B4\u20D2|\u22B5\u20D2|\u22D8\u0338|\u22D9\u0338|\u22DA\uFE00|\u22DB\uFE00|\u22F5\u0338|\u22F9\u0338|\u2933\u0338|\u29CF\u0338|\u29D0\u0338|\u2A6D\u0338|\u2A70\u0338|\u2A7D\u0338|\u2A7E\u0338|\u2AA1\u0338|\u2AA2\u0338|\u2AAC\uFE00|\u2AAD\uFE00|\u2AAF\u0338|\u2AB0\u0338|\u2AC5\u0338|\u2AC6\u0338|\u2ACB\uFE00|\u2ACC\uFE00|\u2AFD\u20E5|[\xA0-\u0113\u0116-\u0122\u0124-\u012B\u012E-\u014D\u0150-\u017E\u0192\u01B5\u01F5\u0237\u02C6\u02C7\u02D8-\u02DD\u0311\u0391-\u03A1\u03A3-\u03A9\u03B1-\u03C9\u03D1\u03D2\u03D5\u03D6\u03DC\u03DD\u03F0\u03F1\u03F5\u03F6\u0401-\u040C\u040E-\u044F\u0451-\u045C\u045E\u045F\u2002-\u2005\u2007-\u2010\u2013-\u2016\u2018-\u201A\u201C-\u201E\u2020-\u2022\u2025\u2026\u2030-\u2035\u2039\u203A\u203E\u2041\u2043\u2044\u204F\u2057\u205F-\u2063\u20AC\u20DB\u20DC\u2102\u2105\u210A-\u2113\u2115-\u211E\u2122\u2124\u2127-\u2129\u212C\u212D\u212F-\u2131\u2133-\u2138\u2145-\u2148\u2153-\u215E\u2190-\u219B\u219D-\u21A7\u21A9-\u21AE\u21B0-\u21B3\u21B5-\u21B7\u21BA-\u21DB\u21DD\u21E4\u21E5\u21F5\u21FD-\u2205\u2207-\u2209\u220B\u220C\u220F-\u2214\u2216-\u2218\u221A\u221D-\u2238\u223A-\u2257\u2259\u225A\u225C\u225F-\u2262\u2264-\u228B\u228D-\u229B\u229D-\u22A5\u22A7-\u22B0\u22B2-\u22BB\u22BD-\u22DB\u22DE-\u22E3\u22E6-\u22F7\u22F9-\u22FE\u2305\u2306\u2308-\u2310\u2312\u2313\u2315\u2316\u231C-\u231F\u2322\u2323\u232D\u232E\u2336\u233D\u233F\u237C\u23B0\u23B1\u23B4-\u23B6\u23DC-\u23DF\u23E2\u23E7\u2423\u24C8\u2500\u2502\u250C\u2510\u2514\u2518\u251C\u2524\u252C\u2534\u253C\u2550-\u256C\u2580\u2584\u2588\u2591-\u2593\u25A1\u25AA\u25AB\u25AD\u25AE\u25B1\u25B3-\u25B5\u25B8\u25B9\u25BD-\u25BF\u25C2\u25C3\u25CA\u25CB\u25EC\u25EF\u25F8-\u25FC\u2605\u2606\u260E\u2640\u2642\u2660\u2663\u2665\u2666\u266A\u266D-\u266F\u2713\u2717\u2720\u2736\u2758\u2772\u2773\u27C8\u27C9\u27E6-\u27ED\u27F5-\u27FA\u27FC\u27FF\u2902-\u2905\u290C-\u2913\u2916\u2919-\u2920\u2923-\u292A\u2933\u2935-\u2939\u293C\u293D\u2945\u2948-\u294B\u294E-\u2976\u2978\u2979\u297B-\u297F\u2985\u2986\u298B-\u2996\u299A\u299C\u299D\u29A4-\u29B7\u29B9\u29BB\u29BC\u29BE-\u29C5\u29C9\u29CD-\u29D0\u29DC-\u29DE\u29E3-\u29E5\u29EB\u29F4\u29F6\u2A00-\u2A02\u2A04\u2A06\u2A0C\u2A0D\u2A10-\u2A17\u2A22-\u2A27\u2A29\u2A2A\u2A2D-\u2A31\u2A33-\u2A3C\u2A3F\u2A40\u2A42-\u2A4D\u2A50\u2A53-\u2A58\u2A5A-\u2A5D\u2A5F\u2A66\u2A6A\u2A6D-\u2A75\u2A77-\u2A9A\u2A9D-\u2AA2\u2AA4-\u2AB0\u2AB3-\u2AC8\u2ACB\u2ACC\u2ACF-\u2ADB\u2AE4\u2AE6-\u2AE9\u2AEB-\u2AF3\u2AFD\uFB00-\uFB04]|\uD835[\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDCCF\uDD04\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDD6B]/g,
                encodeMap = {
                    "­": "shy",
                    "‌": "zwnj",
                    "‍": "zwj",
                    "‎": "lrm",
                    "⁣": "ic",
                    "⁢": "it",
                    "⁡": "af",
                    "‏": "rlm",
                    "​": "ZeroWidthSpace",
                    "⁠": "NoBreak",
                    "̑": "DownBreve",
                    "⃛": "tdot",
                    "⃜": "DotDot",
                    "\t": "Tab",
                    "\n": "NewLine",
                    " ": "puncsp",
                    " ": "MediumSpace",
                    " ": "thinsp",
                    " ": "hairsp",
                    " ": "emsp13",
                    " ": "ensp",
                    " ": "emsp14",
                    " ": "emsp",
                    " ": "numsp",
                    " ": "nbsp",
                    "  ": "ThickSpace",
                    "‾": "oline",
                    _: "lowbar",
                    "‐": "dash",
                    "–": "ndash",
                    "—": "mdash",
                    "―": "horbar",
                    ",": "comma",
                    ";": "semi",
                    "⁏": "bsemi",
                    ":": "colon",
                    "⩴": "Colone",
                    "!": "excl",
                    "¡": "iexcl",
                    "?": "quest",
                    "¿": "iquest",
                    ".": "period",
                    "‥": "nldr",
                    "…": "mldr",
                    "·": "middot",
                    "'": "apos",
                    "‘": "lsquo",
                    "’": "rsquo",
                    "‚": "sbquo",
                    "‹": "lsaquo",
                    "›": "rsaquo",
                    '"': "quot",
                    "“": "ldquo",
                    "”": "rdquo",
                    "„": "bdquo",
                    "«": "laquo",
                    "»": "raquo",
                    "(": "lpar",
                    ")": "rpar",
                    "[": "lsqb",
                    "]": "rsqb",
                    "{": "lcub",
                    "}": "rcub",
                    "⌈": "lceil",
                    "⌉": "rceil",
                    "⌊": "lfloor",
                    "⌋": "rfloor",
                    "⦅": "lopar",
                    "⦆": "ropar",
                    "⦋": "lbrke",
                    "⦌": "rbrke",
                    "⦍": "lbrkslu",
                    "⦎": "rbrksld",
                    "⦏": "lbrksld",
                    "⦐": "rbrkslu",
                    "⦑": "langd",
                    "⦒": "rangd",
                    "⦓": "lparlt",
                    "⦔": "rpargt",
                    "⦕": "gtlPar",
                    "⦖": "ltrPar",
                    "⟦": "lobrk",
                    "⟧": "robrk",
                    "⟨": "lang",
                    "⟩": "rang",
                    "⟪": "Lang",
                    "⟫": "Rang",
                    "⟬": "loang",
                    "⟭": "roang",
                    "❲": "lbbrk",
                    "❳": "rbbrk",
                    "‖": "Vert",
                    "§": "sect",
                    "¶": "para",
                    "@": "commat",
                    "*": "ast",
                    "/": "sol",
                    undefined: null,
                    "&": "amp",
                    "#": "num",
                    "%": "percnt",
                    "‰": "permil",
                    "‱": "pertenk",
                    "†": "dagger",
                    "‡": "Dagger",
                    "•": "bull",
                    "⁃": "hybull",
                    "′": "prime",
                    "″": "Prime",
                    "‴": "tprime",
                    "⁗": "qprime",
                    "‵": "bprime",
                    "⁁": "caret",
                    "`": "grave",
                    "´": "acute",
                    "˜": "tilde",
                    "^": "Hat",
                    "¯": "macr",
                    "˘": "breve",
                    "˙": "dot",
                    "¨": "die",
                    "˚": "ring",
                    "˝": "dblac",
                    "¸": "cedil",
                    "˛": "ogon",
                    "ˆ": "circ",
                    "ˇ": "caron",
                    "°": "deg",
                    "©": "copy",
                    "®": "reg",
                    "℗": "copysr",
                    "℘": "wp",
                    "℞": "rx",
                    "℧": "mho",
                    "℩": "iiota",
                    "←": "larr",
                    "↚": "nlarr",
                    "→": "rarr",
                    "↛": "nrarr",
                    "↑": "uarr",
                    "↓": "darr",
                    "↔": "harr",
                    "↮": "nharr",
                    "↕": "varr",
                    "↖": "nwarr",
                    "↗": "nearr",
                    "↘": "searr",
                    "↙": "swarr",
                    "↝": "rarrw",
                    "↝̸": "nrarrw",
                    "↞": "Larr",
                    "↟": "Uarr",
                    "↠": "Rarr",
                    "↡": "Darr",
                    "↢": "larrtl",
                    "↣": "rarrtl",
                    "↤": "mapstoleft",
                    "↥": "mapstoup",
                    "↦": "map",
                    "↧": "mapstodown",
                    "↩": "larrhk",
                    "↪": "rarrhk",
                    "↫": "larrlp",
                    "↬": "rarrlp",
                    "↭": "harrw",
                    "↰": "lsh",
                    "↱": "rsh",
                    "↲": "ldsh",
                    "↳": "rdsh",
                    "↵": "crarr",
                    "↶": "cularr",
                    "↷": "curarr",
                    "↺": "olarr",
                    "↻": "orarr",
                    "↼": "lharu",
                    "↽": "lhard",
                    "↾": "uharr",
                    "↿": "uharl",
                    "⇀": "rharu",
                    "⇁": "rhard",
                    "⇂": "dharr",
                    "⇃": "dharl",
                    "⇄": "rlarr",
                    "⇅": "udarr",
                    "⇆": "lrarr",
                    "⇇": "llarr",
                    "⇈": "uuarr",
                    "⇉": "rrarr",
                    "⇊": "ddarr",
                    "⇋": "lrhar",
                    "⇌": "rlhar",
                    "⇐": "lArr",
                    "⇍": "nlArr",
                    "⇑": "uArr",
                    "⇒": "rArr",
                    "⇏": "nrArr",
                    "⇓": "dArr",
                    "⇔": "iff",
                    "⇎": "nhArr",
                    "⇕": "vArr",
                    "⇖": "nwArr",
                    "⇗": "neArr",
                    "⇘": "seArr",
                    "⇙": "swArr",
                    "⇚": "lAarr",
                    "⇛": "rAarr",
                    "⇝": "zigrarr",
                    "⇤": "larrb",
                    "⇥": "rarrb",
                    "⇵": "duarr",
                    "⇽": "loarr",
                    "⇾": "roarr",
                    "⇿": "hoarr",
                    "∀": "forall",
                    "∁": "comp",
                    "∂": "part",
                    "∂̸": "npart",
                    "∃": "exist",
                    "∄": "nexist",
                    "∅": "empty",
                    "∇": "Del",
                    "∈": "in",
                    "∉": "notin",
                    "∋": "ni",
                    "∌": "notni",
                    "϶": "bepsi",
                    "∏": "prod",
                    "∐": "coprod",
                    "∑": "sum",
                    "+": "plus",
                    "±": "pm",
                    "÷": "div",
                    "×": "times",
                    "<": "lt",
                    "≮": "nlt",
                    "<⃒": "nvlt",
                    "=": "equals",
                    "≠": "ne",
                    "=⃥": "bne",
                    "⩵": "Equal",
                    ">": "gt",
                    "≯": "ngt",
                    ">⃒": "nvgt",
                    "¬": "not",
                    "|": "vert",
                    "¦": "brvbar",
                    "−": "minus",
                    "∓": "mp",
                    "∔": "plusdo",
                    "⁄": "frasl",
                    "∖": "setmn",
                    "∗": "lowast",
                    "∘": "compfn",
                    "√": "Sqrt",
                    "∝": "prop",
                    "∞": "infin",
                    "∟": "angrt",
                    "∠": "ang",
                    "∠⃒": "nang",
                    "∡": "angmsd",
                    "∢": "angsph",
                    "∣": "mid",
                    "∤": "nmid",
                    "∥": "par",
                    "∦": "npar",
                    "∧": "and",
                    "∨": "or",
                    "∩": "cap",
                    "∩︀": "caps",
                    "∪": "cup",
                    "∪︀": "cups",
                    "∫": "int",
                    "∬": "Int",
                    "∭": "tint",
                    "⨌": "qint",
                    "∮": "oint",
                    "∯": "Conint",
                    "∰": "Cconint",
                    "∱": "cwint",
                    "∲": "cwconint",
                    "∳": "awconint",
                    "∴": "there4",
                    "∵": "becaus",
                    "∶": "ratio",
                    "∷": "Colon",
                    "∸": "minusd",
                    "∺": "mDDot",
                    "∻": "homtht",
                    "∼": "sim",
                    "≁": "nsim",
                    "∼⃒": "nvsim",
                    "∽": "bsim",
                    "∽̱": "race",
                    "∾": "ac",
                    "∾̳": "acE",
                    "∿": "acd",
                    "≀": "wr",
                    "≂": "esim",
                    "≂̸": "nesim",
                    "≃": "sime",
                    "≄": "nsime",
                    "≅": "cong",
                    "≇": "ncong",
                    "≆": "simne",
                    "≈": "ap",
                    "≉": "nap",
                    "≊": "ape",
                    "≋": "apid",
                    "≋̸": "napid",
                    "≌": "bcong",
                    "≍": "CupCap",
                    "≭": "NotCupCap",
                    "≍⃒": "nvap",
                    "≎": "bump",
                    "≎̸": "nbump",
                    "≏": "bumpe",
                    "≏̸": "nbumpe",
                    "≐": "doteq",
                    "≐̸": "nedot",
                    "≑": "eDot",
                    "≒": "efDot",
                    "≓": "erDot",
                    "≔": "colone",
                    "≕": "ecolon",
                    "≖": "ecir",
                    "≗": "cire",
                    "≙": "wedgeq",
                    "≚": "veeeq",
                    "≜": "trie",
                    "≟": "equest",
                    "≡": "equiv",
                    "≢": "nequiv",
                    "≡⃥": "bnequiv",
                    "≤": "le",
                    "≰": "nle",
                    "≤⃒": "nvle",
                    "≥": "ge",
                    "≱": "nge",
                    "≥⃒": "nvge",
                    "≦": "lE",
                    "≦̸": "nlE",
                    "≧": "gE",
                    "≧̸": "ngE",
                    "≨︀": "lvnE",
                    "≨": "lnE",
                    "≩": "gnE",
                    "≩︀": "gvnE",
                    "≪": "ll",
                    "≪̸": "nLtv",
                    "≪⃒": "nLt",
                    "≫": "gg",
                    "≫̸": "nGtv",
                    "≫⃒": "nGt",
                    "≬": "twixt",
                    "≲": "lsim",
                    "≴": "nlsim",
                    "≳": "gsim",
                    "≵": "ngsim",
                    "≶": "lg",
                    "≸": "ntlg",
                    "≷": "gl",
                    "≹": "ntgl",
                    "≺": "pr",
                    "⊀": "npr",
                    "≻": "sc",
                    "⊁": "nsc",
                    "≼": "prcue",
                    "⋠": "nprcue",
                    "≽": "sccue",
                    "⋡": "nsccue",
                    "≾": "prsim",
                    "≿": "scsim",
                    "≿̸": "NotSucceedsTilde",
                    "⊂": "sub",
                    "⊄": "nsub",
                    "⊂⃒": "vnsub",
                    "⊃": "sup",
                    "⊅": "nsup",
                    "⊃⃒": "vnsup",
                    "⊆": "sube",
                    "⊈": "nsube",
                    "⊇": "supe",
                    "⊉": "nsupe",
                    "⊊︀": "vsubne",
                    "⊊": "subne",
                    "⊋︀": "vsupne",
                    "⊋": "supne",
                    "⊍": "cupdot",
                    "⊎": "uplus",
                    "⊏": "sqsub",
                    "⊏̸": "NotSquareSubset",
                    "⊐": "sqsup",
                    "⊐̸": "NotSquareSuperset",
                    "⊑": "sqsube",
                    "⋢": "nsqsube",
                    "⊒": "sqsupe",
                    "⋣": "nsqsupe",
                    "⊓": "sqcap",
                    "⊓︀": "sqcaps",
                    "⊔": "sqcup",
                    "⊔︀": "sqcups",
                    "⊕": "oplus",
                    "⊖": "ominus",
                    "⊗": "otimes",
                    "⊘": "osol",
                    "⊙": "odot",
                    "⊚": "ocir",
                    "⊛": "oast",
                    "⊝": "odash",
                    "⊞": "plusb",
                    "⊟": "minusb",
                    "⊠": "timesb",
                    "⊡": "sdotb",
                    "⊢": "vdash",
                    "⊬": "nvdash",
                    "⊣": "dashv",
                    "⊤": "top",
                    "⊥": "bot",
                    "⊧": "models",
                    "⊨": "vDash",
                    "⊭": "nvDash",
                    "⊩": "Vdash",
                    "⊮": "nVdash",
                    "⊪": "Vvdash",
                    "⊫": "VDash",
                    "⊯": "nVDash",
                    "⊰": "prurel",
                    "⊲": "vltri",
                    "⋪": "nltri",
                    "⊳": "vrtri",
                    "⋫": "nrtri",
                    "⊴": "ltrie",
                    "⋬": "nltrie",
                    "⊴⃒": "nvltrie",
                    "⊵": "rtrie",
                    "⋭": "nrtrie",
                    "⊵⃒": "nvrtrie",
                    "⊶": "origof",
                    "⊷": "imof",
                    "⊸": "mumap",
                    "⊹": "hercon",
                    "⊺": "intcal",
                    "⊻": "veebar",
                    "⊽": "barvee",
                    "⊾": "angrtvb",
                    "⊿": "lrtri",
                    "⋀": "Wedge",
                    "⋁": "Vee",
                    "⋂": "xcap",
                    "⋃": "xcup",
                    "⋄": "diam",
                    "⋅": "sdot",
                    "⋆": "Star",
                    "⋇": "divonx",
                    "⋈": "bowtie",
                    "⋉": "ltimes",
                    "⋊": "rtimes",
                    "⋋": "lthree",
                    "⋌": "rthree",
                    "⋍": "bsime",
                    "⋎": "cuvee",
                    "⋏": "cuwed",
                    "⋐": "Sub",
                    "⋑": "Sup",
                    "⋒": "Cap",
                    "⋓": "Cup",
                    "⋔": "fork",
                    "⋕": "epar",
                    "⋖": "ltdot",
                    "⋗": "gtdot",
                    "⋘": "Ll",
                    "⋘̸": "nLl",
                    "⋙": "Gg",
                    "⋙̸": "nGg",
                    "⋚︀": "lesg",
                    "⋚": "leg",
                    "⋛": "gel",
                    "⋛︀": "gesl",
                    "⋞": "cuepr",
                    "⋟": "cuesc",
                    "⋦": "lnsim",
                    "⋧": "gnsim",
                    "⋨": "prnsim",
                    "⋩": "scnsim",
                    "⋮": "vellip",
                    "⋯": "ctdot",
                    "⋰": "utdot",
                    "⋱": "dtdot",
                    "⋲": "disin",
                    "⋳": "isinsv",
                    "⋴": "isins",
                    "⋵": "isindot",
                    "⋵̸": "notindot",
                    "⋶": "notinvc",
                    "⋷": "notinvb",
                    "⋹": "isinE",
                    "⋹̸": "notinE",
                    "⋺": "nisd",
                    "⋻": "xnis",
                    "⋼": "nis",
                    "⋽": "notnivc",
                    "⋾": "notnivb",
                    "⌅": "barwed",
                    "⌆": "Barwed",
                    "⌌": "drcrop",
                    "⌍": "dlcrop",
                    "⌎": "urcrop",
                    "⌏": "ulcrop",
                    "⌐": "bnot",
                    "⌒": "profline",
                    "⌓": "profsurf",
                    "⌕": "telrec",
                    "⌖": "target",
                    "⌜": "ulcorn",
                    "⌝": "urcorn",
                    "⌞": "dlcorn",
                    "⌟": "drcorn",
                    "⌢": "frown",
                    "⌣": "smile",
                    "⌭": "cylcty",
                    "⌮": "profalar",
                    "⌶": "topbot",
                    "⌽": "ovbar",
                    "⌿": "solbar",
                    "⍼": "angzarr",
                    "⎰": "lmoust",
                    "⎱": "rmoust",
                    "⎴": "tbrk",
                    "⎵": "bbrk",
                    "⎶": "bbrktbrk",
                    "⏜": "OverParenthesis",
                    "⏝": "UnderParenthesis",
                    "⏞": "OverBrace",
                    "⏟": "UnderBrace",
                    "⏢": "trpezium",
                    "⏧": "elinters",
                    "␣": "blank",
                    "─": "boxh",
                    "│": "boxv",
                    "┌": "boxdr",
                    "┐": "boxdl",
                    "└": "boxur",
                    "┘": "boxul",
                    "├": "boxvr",
                    "┤": "boxvl",
                    "┬": "boxhd",
                    "┴": "boxhu",
                    "┼": "boxvh",
                    "═": "boxH",
                    "║": "boxV",
                    "╒": "boxdR",
                    "╓": "boxDr",
                    "╔": "boxDR",
                    "╕": "boxdL",
                    "╖": "boxDl",
                    "╗": "boxDL",
                    "╘": "boxuR",
                    "╙": "boxUr",
                    "╚": "boxUR",
                    "╛": "boxuL",
                    "╜": "boxUl",
                    "╝": "boxUL",
                    "╞": "boxvR",
                    "╟": "boxVr",
                    "╠": "boxVR",
                    "╡": "boxvL",
                    "╢": "boxVl",
                    "╣": "boxVL",
                    "╤": "boxHd",
                    "╥": "boxhD",
                    "╦": "boxHD",
                    "╧": "boxHu",
                    "╨": "boxhU",
                    "╩": "boxHU",
                    "╪": "boxvH",
                    "╫": "boxVh",
                    "╬": "boxVH",
                    "▀": "uhblk",
                    "▄": "lhblk",
                    "█": "block",
                    "░": "blk14",
                    "▒": "blk12",
                    "▓": "blk34",
                    "□": "squ",
                    "▪": "squf",
                    "▫": "EmptyVerySmallSquare",
                    "▭": "rect",
                    "▮": "marker",
                    "▱": "fltns",
                    "△": "xutri",
                    "▴": "utrif",
                    "▵": "utri",
                    "▸": "rtrif",
                    "▹": "rtri",
                    "▽": "xdtri",
                    "▾": "dtrif",
                    "▿": "dtri",
                    "◂": "ltrif",
                    "◃": "ltri",
                    "◊": "loz",
                    "○": "cir",
                    "◬": "tridot",
                    "◯": "xcirc",
                    "◸": "ultri",
                    "◹": "urtri",
                    "◺": "lltri",
                    "◻": "EmptySmallSquare",
                    "◼": "FilledSmallSquare",
                    "★": "starf",
                    "☆": "star",
                    "☎": "phone",
                    "♀": "female",
                    "♂": "male",
                    "♠": "spades",
                    "♣": "clubs",
                    "♥": "hearts",
                    "♦": "diams",
                    "♪": "sung",
                    "✓": "check",
                    "✗": "cross",
                    "✠": "malt",
                    "✶": "sext",
                    "❘": "VerticalSeparator",
                    "⟈": "bsolhsub",
                    "⟉": "suphsol",
                    "⟵": "xlarr",
                    "⟶": "xrarr",
                    "⟷": "xharr",
                    "⟸": "xlArr",
                    "⟹": "xrArr",
                    "⟺": "xhArr",
                    "⟼": "xmap",
                    "⟿": "dzigrarr",
                    "⤂": "nvlArr",
                    "⤃": "nvrArr",
                    "⤄": "nvHarr",
                    "⤅": "Map",
                    "⤌": "lbarr",
                    "⤍": "rbarr",
                    "⤎": "lBarr",
                    "⤏": "rBarr",
                    "⤐": "RBarr",
                    "⤑": "DDotrahd",
                    "⤒": "UpArrowBar",
                    "⤓": "DownArrowBar",
                    "⤖": "Rarrtl",
                    "⤙": "latail",
                    "⤚": "ratail",
                    "⤛": "lAtail",
                    "⤜": "rAtail",
                    "⤝": "larrfs",
                    "⤞": "rarrfs",
                    "⤟": "larrbfs",
                    "⤠": "rarrbfs",
                    "⤣": "nwarhk",
                    "⤤": "nearhk",
                    "⤥": "searhk",
                    "⤦": "swarhk",
                    "⤧": "nwnear",
                    "⤨": "toea",
                    "⤩": "tosa",
                    "⤪": "swnwar",
                    "⤳": "rarrc",
                    "⤳̸": "nrarrc",
                    "⤵": "cudarrr",
                    "⤶": "ldca",
                    "⤷": "rdca",
                    "⤸": "cudarrl",
                    "⤹": "larrpl",
                    "⤼": "curarrm",
                    "⤽": "cularrp",
                    "⥅": "rarrpl",
                    "⥈": "harrcir",
                    "⥉": "Uarrocir",
                    "⥊": "lurdshar",
                    "⥋": "ldrushar",
                    "⥎": "LeftRightVector",
                    "⥏": "RightUpDownVector",
                    "⥐": "DownLeftRightVector",
                    "⥑": "LeftUpDownVector",
                    "⥒": "LeftVectorBar",
                    "⥓": "RightVectorBar",
                    "⥔": "RightUpVectorBar",
                    "⥕": "RightDownVectorBar",
                    "⥖": "DownLeftVectorBar",
                    "⥗": "DownRightVectorBar",
                    "⥘": "LeftUpVectorBar",
                    "⥙": "LeftDownVectorBar",
                    "⥚": "LeftTeeVector",
                    "⥛": "RightTeeVector",
                    "⥜": "RightUpTeeVector",
                    "⥝": "RightDownTeeVector",
                    "⥞": "DownLeftTeeVector",
                    "⥟": "DownRightTeeVector",
                    "⥠": "LeftUpTeeVector",
                    "⥡": "LeftDownTeeVector",
                    "⥢": "lHar",
                    "⥣": "uHar",
                    "⥤": "rHar",
                    "⥥": "dHar",
                    "⥦": "luruhar",
                    "⥧": "ldrdhar",
                    "⥨": "ruluhar",
                    "⥩": "rdldhar",
                    "⥪": "lharul",
                    "⥫": "llhard",
                    "⥬": "rharul",
                    "⥭": "lrhard",
                    "⥮": "udhar",
                    "⥯": "duhar",
                    "⥰": "RoundImplies",
                    "⥱": "erarr",
                    "⥲": "simrarr",
                    "⥳": "larrsim",
                    "⥴": "rarrsim",
                    "⥵": "rarrap",
                    "⥶": "ltlarr",
                    "⥸": "gtrarr",
                    "⥹": "subrarr",
                    "⥻": "suplarr",
                    "⥼": "lfisht",
                    "⥽": "rfisht",
                    "⥾": "ufisht",
                    "⥿": "dfisht",
                    "⦚": "vzigzag",
                    "⦜": "vangrt",
                    "⦝": "angrtvbd",
                    "⦤": "ange",
                    "⦥": "range",
                    "⦦": "dwangle",
                    "⦧": "uwangle",
                    "⦨": "angmsdaa",
                    "⦩": "angmsdab",
                    "⦪": "angmsdac",
                    "⦫": "angmsdad",
                    "⦬": "angmsdae",
                    "⦭": "angmsdaf",
                    "⦮": "angmsdag",
                    "⦯": "angmsdah",
                    "⦰": "bemptyv",
                    "⦱": "demptyv",
                    "⦲": "cemptyv",
                    "⦳": "raemptyv",
                    "⦴": "laemptyv",
                    "⦵": "ohbar",
                    "⦶": "omid",
                    "⦷": "opar",
                    "⦹": "operp",
                    "⦻": "olcross",
                    "⦼": "odsold",
                    "⦾": "olcir",
                    "⦿": "ofcir",
                    "⧀": "olt",
                    "⧁": "ogt",
                    "⧂": "cirscir",
                    "⧃": "cirE",
                    "⧄": "solb",
                    "⧅": "bsolb",
                    "⧉": "boxbox",
                    "⧍": "trisb",
                    "⧎": "rtriltri",
                    "⧏": "LeftTriangleBar",
                    "⧏̸": "NotLeftTriangleBar",
                    "⧐": "RightTriangleBar",
                    "⧐̸": "NotRightTriangleBar",
                    "⧜": "iinfin",
                    "⧝": "infintie",
                    "⧞": "nvinfin",
                    "⧣": "eparsl",
                    "⧤": "smeparsl",
                    "⧥": "eqvparsl",
                    "⧫": "lozf",
                    "⧴": "RuleDelayed",
                    "⧶": "dsol",
                    "⨀": "xodot",
                    "⨁": "xoplus",
                    "⨂": "xotime",
                    "⨄": "xuplus",
                    "⨆": "xsqcup",
                    "⨍": "fpartint",
                    "⨐": "cirfnint",
                    "⨑": "awint",
                    "⨒": "rppolint",
                    "⨓": "scpolint",
                    "⨔": "npolint",
                    "⨕": "pointint",
                    "⨖": "quatint",
                    "⨗": "intlarhk",
                    "⨢": "pluscir",
                    "⨣": "plusacir",
                    "⨤": "simplus",
                    "⨥": "plusdu",
                    "⨦": "plussim",
                    "⨧": "plustwo",
                    "⨩": "mcomma",
                    "⨪": "minusdu",
                    "⨭": "loplus",
                    "⨮": "roplus",
                    "⨯": "Cross",
                    "⨰": "timesd",
                    "⨱": "timesbar",
                    "⨳": "smashp",
                    "⨴": "lotimes",
                    "⨵": "rotimes",
                    "⨶": "otimesas",
                    "⨷": "Otimes",
                    "⨸": "odiv",
                    "⨹": "triplus",
                    "⨺": "triminus",
                    "⨻": "tritime",
                    "⨼": "iprod",
                    "⨿": "amalg",
                    "⩀": "capdot",
                    "⩂": "ncup",
                    "⩃": "ncap",
                    "⩄": "capand",
                    "⩅": "cupor",
                    "⩆": "cupcap",
                    "⩇": "capcup",
                    "⩈": "cupbrcap",
                    "⩉": "capbrcup",
                    "⩊": "cupcup",
                    "⩋": "capcap",
                    "⩌": "ccups",
                    "⩍": "ccaps",
                    "⩐": "ccupssm",
                    "⩓": "And",
                    "⩔": "Or",
                    "⩕": "andand",
                    "⩖": "oror",
                    "⩗": "orslope",
                    "⩘": "andslope",
                    "⩚": "andv",
                    "⩛": "orv",
                    "⩜": "andd",
                    "⩝": "ord",
                    "⩟": "wedbar",
                    "⩦": "sdote",
                    "⩪": "simdot",
                    "⩭": "congdot",
                    "⩭̸": "ncongdot",
                    "⩮": "easter",
                    "⩯": "apacir",
                    "⩰": "apE",
                    "⩰̸": "napE",
                    "⩱": "eplus",
                    "⩲": "pluse",
                    "⩳": "Esim",
                    "⩷": "eDDot",
                    "⩸": "equivDD",
                    "⩹": "ltcir",
                    "⩺": "gtcir",
                    "⩻": "ltquest",
                    "⩼": "gtquest",
                    "⩽": "les",
                    "⩽̸": "nles",
                    "⩾": "ges",
                    "⩾̸": "nges",
                    "⩿": "lesdot",
                    "⪀": "gesdot",
                    "⪁": "lesdoto",
                    "⪂": "gesdoto",
                    "⪃": "lesdotor",
                    "⪄": "gesdotol",
                    "⪅": "lap",
                    "⪆": "gap",
                    "⪇": "lne",
                    "⪈": "gne",
                    "⪉": "lnap",
                    "⪊": "gnap",
                    "⪋": "lEg",
                    "⪌": "gEl",
                    "⪍": "lsime",
                    "⪎": "gsime",
                    "⪏": "lsimg",
                    "⪐": "gsiml",
                    "⪑": "lgE",
                    "⪒": "glE",
                    "⪓": "lesges",
                    "⪔": "gesles",
                    "⪕": "els",
                    "⪖": "egs",
                    "⪗": "elsdot",
                    "⪘": "egsdot",
                    "⪙": "el",
                    "⪚": "eg",
                    "⪝": "siml",
                    "⪞": "simg",
                    "⪟": "simlE",
                    "⪠": "simgE",
                    "⪡": "LessLess",
                    "⪡̸": "NotNestedLessLess",
                    "⪢": "GreaterGreater",
                    "⪢̸": "NotNestedGreaterGreater",
                    "⪤": "glj",
                    "⪥": "gla",
                    "⪦": "ltcc",
                    "⪧": "gtcc",
                    "⪨": "lescc",
                    "⪩": "gescc",
                    "⪪": "smt",
                    "⪫": "lat",
                    "⪬": "smte",
                    "⪬︀": "smtes",
                    "⪭": "late",
                    "⪭︀": "lates",
                    "⪮": "bumpE",
                    "⪯": "pre",
                    "⪯̸": "npre",
                    "⪰": "sce",
                    "⪰̸": "nsce",
                    "⪳": "prE",
                    "⪴": "scE",
                    "⪵": "prnE",
                    "⪶": "scnE",
                    "⪷": "prap",
                    "⪸": "scap",
                    "⪹": "prnap",
                    "⪺": "scnap",
                    "⪻": "Pr",
                    "⪼": "Sc",
                    "⪽": "subdot",
                    "⪾": "supdot",
                    "⪿": "subplus",
                    "⫀": "supplus",
                    "⫁": "submult",
                    "⫂": "supmult",
                    "⫃": "subedot",
                    "⫄": "supedot",
                    "⫅": "subE",
                    "⫅̸": "nsubE",
                    "⫆": "supE",
                    "⫆̸": "nsupE",
                    "⫇": "subsim",
                    "⫈": "supsim",
                    "⫋︀": "vsubnE",
                    "⫋": "subnE",
                    "⫌︀": "vsupnE",
                    "⫌": "supnE",
                    "⫏": "csub",
                    "⫐": "csup",
                    "⫑": "csube",
                    "⫒": "csupe",
                    "⫓": "subsup",
                    "⫔": "supsub",
                    "⫕": "subsub",
                    "⫖": "supsup",
                    "⫗": "suphsub",
                    "⫘": "supdsub",
                    "⫙": "forkv",
                    "⫚": "topfork",
                    "⫛": "mlcp",
                    "⫤": "Dashv",
                    "⫦": "Vdashl",
                    "⫧": "Barv",
                    "⫨": "vBar",
                    "⫩": "vBarv",
                    "⫫": "Vbar",
                    "⫬": "Not",
                    "⫭": "bNot",
                    "⫮": "rnmid",
                    "⫯": "cirmid",
                    "⫰": "midcir",
                    "⫱": "topcir",
                    "⫲": "nhpar",
                    "⫳": "parsim",
                    "⫽": "parsl",
                    "⫽⃥": "nparsl",
                    "♭": "flat",
                    "♮": "natur",
                    "♯": "sharp",
                    "¤": "curren",
                    "¢": "cent",
                    $: "dollar",
                    "£": "pound",
                    "¥": "yen",
                    "€": "euro",
                    "¹": "sup1",
                    "½": "half",
                    "⅓": "frac13",
                    "¼": "frac14",
                    "⅕": "frac15",
                    "⅙": "frac16",
                    "⅛": "frac18",
                    "²": "sup2",
                    "⅔": "frac23",
                    "⅖": "frac25",
                    "³": "sup3",
                    "¾": "frac34",
                    "⅗": "frac35",
                    "⅜": "frac38",
                    "⅘": "frac45",
                    "⅚": "frac56",
                    "⅝": "frac58",
                    "⅞": "frac78",
                    "𝒶": "ascr",
                    "𝕒": "aopf",
                    "𝔞": "afr",
                    "𝔸": "Aopf",
                    "𝔄": "Afr",
                    "𝒜": "Ascr",
                    "ª": "ordf",
                    "á": "aacute",
                    "Á": "Aacute",
                    "à": "agrave",
                    "À": "Agrave",
                    "ă": "abreve",
                    "Ă": "Abreve",
                    "â": "acirc",
                    "Â": "Acirc",
                    "å": "aring",
                    "Å": "angst",
                    "ä": "auml",
                    "Ä": "Auml",
                    "ã": "atilde",
                    "Ã": "Atilde",
                    "ą": "aogon",
                    "Ą": "Aogon",
                    "ā": "amacr",
                    "Ā": "Amacr",
                    "æ": "aelig",
                    "Æ": "AElig",
                    "𝒷": "bscr",
                    "𝕓": "bopf",
                    "𝔟": "bfr",
                    "𝔹": "Bopf",
                    "ℬ": "Bscr",
                    "𝔅": "Bfr",
                    "𝔠": "cfr",
                    "𝒸": "cscr",
                    "𝕔": "copf",
                    "ℭ": "Cfr",
                    "𝒞": "Cscr",
                    "ℂ": "Copf",
                    "ć": "cacute",
                    "Ć": "Cacute",
                    "ĉ": "ccirc",
                    "Ĉ": "Ccirc",
                    "č": "ccaron",
                    "Č": "Ccaron",
                    "ċ": "cdot",
                    "Ċ": "Cdot",
                    "ç": "ccedil",
                    "Ç": "Ccedil",
                    "℅": "incare",
                    "𝔡": "dfr",
                    "ⅆ": "dd",
                    "𝕕": "dopf",
                    "𝒹": "dscr",
                    "𝒟": "Dscr",
                    "𝔇": "Dfr",
                    "ⅅ": "DD",
                    "𝔻": "Dopf",
                    "ď": "dcaron",
                    "Ď": "Dcaron",
                    "đ": "dstrok",
                    "Đ": "Dstrok",
                    "ð": "eth",
                    "Ð": "ETH",
                    "ⅇ": "ee",
                    "ℯ": "escr",
                    "𝔢": "efr",
                    "𝕖": "eopf",
                    "ℰ": "Escr",
                    "𝔈": "Efr",
                    "𝔼": "Eopf",
                    "é": "eacute",
                    "É": "Eacute",
                    "è": "egrave",
                    "È": "Egrave",
                    "ê": "ecirc",
                    "Ê": "Ecirc",
                    "ě": "ecaron",
                    "Ě": "Ecaron",
                    "ë": "euml",
                    "Ë": "Euml",
                    "ė": "edot",
                    "Ė": "Edot",
                    "ę": "eogon",
                    "Ę": "Eogon",
                    "ē": "emacr",
                    "Ē": "Emacr",
                    "𝔣": "ffr",
                    "𝕗": "fopf",
                    "𝒻": "fscr",
                    "𝔉": "Ffr",
                    "𝔽": "Fopf",
                    "ℱ": "Fscr",
                    "ﬀ": "fflig",
                    "ﬃ": "ffilig",
                    "ﬄ": "ffllig",
                    "ﬁ": "filig",
                    fj: "fjlig",
                    "ﬂ": "fllig",
                    "ƒ": "fnof",
                    "ℊ": "gscr",
                    "𝕘": "gopf",
                    "𝔤": "gfr",
                    "𝒢": "Gscr",
                    "𝔾": "Gopf",
                    "𝔊": "Gfr",
                    "ǵ": "gacute",
                    "ğ": "gbreve",
                    "Ğ": "Gbreve",
                    "ĝ": "gcirc",
                    "Ĝ": "Gcirc",
                    "ġ": "gdot",
                    "Ġ": "Gdot",
                    "Ģ": "Gcedil",
                    "𝔥": "hfr",
                    "ℎ": "planckh",
                    "𝒽": "hscr",
                    "𝕙": "hopf",
                    "ℋ": "Hscr",
                    "ℌ": "Hfr",
                    "ℍ": "Hopf",
                    "ĥ": "hcirc",
                    "Ĥ": "Hcirc",
                    "ℏ": "hbar",
                    "ħ": "hstrok",
                    "Ħ": "Hstrok",
                    "𝕚": "iopf",
                    "𝔦": "ifr",
                    "𝒾": "iscr",
                    "ⅈ": "ii",
                    "𝕀": "Iopf",
                    "ℐ": "Iscr",
                    "ℑ": "Im",
                    "í": "iacute",
                    "Í": "Iacute",
                    "ì": "igrave",
                    "Ì": "Igrave",
                    "î": "icirc",
                    "Î": "Icirc",
                    "ï": "iuml",
                    "Ï": "Iuml",
                    "ĩ": "itilde",
                    "Ĩ": "Itilde",
                    "İ": "Idot",
                    "į": "iogon",
                    "Į": "Iogon",
                    "ī": "imacr",
                    "Ī": "Imacr",
                    "ĳ": "ijlig",
                    "Ĳ": "IJlig",
                    "ı": "imath",
                    "𝒿": "jscr",
                    "𝕛": "jopf",
                    "𝔧": "jfr",
                    "𝒥": "Jscr",
                    "𝔍": "Jfr",
                    "𝕁": "Jopf",
                    "ĵ": "jcirc",
                    "Ĵ": "Jcirc",
                    "ȷ": "jmath",
                    "𝕜": "kopf",
                    "𝓀": "kscr",
                    "𝔨": "kfr",
                    "𝒦": "Kscr",
                    "𝕂": "Kopf",
                    "𝔎": "Kfr",
                    "ķ": "kcedil",
                    "Ķ": "Kcedil",
                    "𝔩": "lfr",
                    "𝓁": "lscr",
                    "ℓ": "ell",
                    "𝕝": "lopf",
                    "ℒ": "Lscr",
                    "𝔏": "Lfr",
                    "𝕃": "Lopf",
                    "ĺ": "lacute",
                    "Ĺ": "Lacute",
                    "ľ": "lcaron",
                    "Ľ": "Lcaron",
                    "ļ": "lcedil",
                    "Ļ": "Lcedil",
                    "ł": "lstrok",
                    "Ł": "Lstrok",
                    "ŀ": "lmidot",
                    "Ŀ": "Lmidot",
                    "𝔪": "mfr",
                    "𝕞": "mopf",
                    "𝓂": "mscr",
                    "𝔐": "Mfr",
                    "𝕄": "Mopf",
                    "ℳ": "Mscr",
                    "𝔫": "nfr",
                    "𝕟": "nopf",
                    "𝓃": "nscr",
                    "ℕ": "Nopf",
                    "𝒩": "Nscr",
                    "𝔑": "Nfr",
                    "ń": "nacute",
                    "Ń": "Nacute",
                    "ň": "ncaron",
                    "Ň": "Ncaron",
                    "ñ": "ntilde",
                    "Ñ": "Ntilde",
                    "ņ": "ncedil",
                    "Ņ": "Ncedil",
                    "№": "numero",
                    "ŋ": "eng",
                    "Ŋ": "ENG",
                    "𝕠": "oopf",
                    "𝔬": "ofr",
                    "ℴ": "oscr",
                    "𝒪": "Oscr",
                    "𝔒": "Ofr",
                    "𝕆": "Oopf",
                    "º": "ordm",
                    "ó": "oacute",
                    "Ó": "Oacute",
                    "ò": "ograve",
                    "Ò": "Ograve",
                    "ô": "ocirc",
                    "Ô": "Ocirc",
                    "ö": "ouml",
                    "Ö": "Ouml",
                    "ő": "odblac",
                    "Ő": "Odblac",
                    "õ": "otilde",
                    "Õ": "Otilde",
                    "ø": "oslash",
                    "Ø": "Oslash",
                    "ō": "omacr",
                    "Ō": "Omacr",
                    "œ": "oelig",
                    "Œ": "OElig",
                    "𝔭": "pfr",
                    "𝓅": "pscr",
                    "𝕡": "popf",
                    "ℙ": "Popf",
                    "𝔓": "Pfr",
                    "𝒫": "Pscr",
                    "𝕢": "qopf",
                    "𝔮": "qfr",
                    "𝓆": "qscr",
                    "𝒬": "Qscr",
                    "𝔔": "Qfr",
                    "ℚ": "Qopf",
                    "ĸ": "kgreen",
                    "𝔯": "rfr",
                    "𝕣": "ropf",
                    "𝓇": "rscr",
                    "ℛ": "Rscr",
                    "ℜ": "Re",
                    "ℝ": "Ropf",
                    "ŕ": "racute",
                    "Ŕ": "Racute",
                    "ř": "rcaron",
                    "Ř": "Rcaron",
                    "ŗ": "rcedil",
                    "Ŗ": "Rcedil",
                    "𝕤": "sopf",
                    "𝓈": "sscr",
                    "𝔰": "sfr",
                    "𝕊": "Sopf",
                    "𝔖": "Sfr",
                    "𝒮": "Sscr",
                    "Ⓢ": "oS",
                    "ś": "sacute",
                    "Ś": "Sacute",
                    "ŝ": "scirc",
                    "Ŝ": "Scirc",
                    "š": "scaron",
                    "Š": "Scaron",
                    "ş": "scedil",
                    "Ş": "Scedil",
                    "ß": "szlig",
                    "𝔱": "tfr",
                    "𝓉": "tscr",
                    "𝕥": "topf",
                    "𝒯": "Tscr",
                    "𝔗": "Tfr",
                    "𝕋": "Topf",
                    "ť": "tcaron",
                    "Ť": "Tcaron",
                    "ţ": "tcedil",
                    "Ţ": "Tcedil",
                    "™": "trade",
                    "ŧ": "tstrok",
                    "Ŧ": "Tstrok",
                    "𝓊": "uscr",
                    "𝕦": "uopf",
                    "𝔲": "ufr",
                    "𝕌": "Uopf",
                    "𝔘": "Ufr",
                    "𝒰": "Uscr",
                    "ú": "uacute",
                    "Ú": "Uacute",
                    "ù": "ugrave",
                    "Ù": "Ugrave",
                    "ŭ": "ubreve",
                    "Ŭ": "Ubreve",
                    "û": "ucirc",
                    "Û": "Ucirc",
                    "ů": "uring",
                    "Ů": "Uring",
                    "ü": "uuml",
                    "Ü": "Uuml",
                    "ű": "udblac",
                    "Ű": "Udblac",
                    "ũ": "utilde",
                    "Ũ": "Utilde",
                    "ų": "uogon",
                    "Ų": "Uogon",
                    "ū": "umacr",
                    "Ū": "Umacr",
                    "𝔳": "vfr",
                    "𝕧": "vopf",
                    "𝓋": "vscr",
                    "𝔙": "Vfr",
                    "𝕍": "Vopf",
                    "𝒱": "Vscr",
                    "𝕨": "wopf",
                    "𝓌": "wscr",
                    "𝔴": "wfr",
                    "𝒲": "Wscr",
                    "𝕎": "Wopf",
                    "𝔚": "Wfr",
                    "ŵ": "wcirc",
                    "Ŵ": "Wcirc",
                    "𝔵": "xfr",
                    "𝓍": "xscr",
                    "𝕩": "xopf",
                    "𝕏": "Xopf",
                    "𝔛": "Xfr",
                    "𝒳": "Xscr",
                    "𝔶": "yfr",
                    "𝓎": "yscr",
                    "𝕪": "yopf",
                    "𝒴": "Yscr",
                    "𝔜": "Yfr",
                    "𝕐": "Yopf",
                    "ý": "yacute",
                    "Ý": "Yacute",
                    "ŷ": "ycirc",
                    "Ŷ": "Ycirc",
                    "ÿ": "yuml",
                    "Ÿ": "Yuml",
                    "𝓏": "zscr",
                    "𝔷": "zfr",
                    "𝕫": "zopf",
                    "ℨ": "Zfr",
                    "ℤ": "Zopf",
                    "𝒵": "Zscr",
                    "ź": "zacute",
                    "Ź": "Zacute",
                    "ž": "zcaron",
                    "Ž": "Zcaron",
                    "ż": "zdot",
                    "Ż": "Zdot",
                    "Ƶ": "imped",
                    "þ": "thorn",
                    "Þ": "THORN",
                    "ŉ": "napos",
                    "α": "alpha",
                    "Α": "Alpha",
                    "β": "beta",
                    "Β": "Beta",
                    "γ": "gamma",
                    "Γ": "Gamma",
                    "δ": "delta",
                    "Δ": "Delta",
                    "ε": "epsi",
                    "ϵ": "epsiv",
                    "Ε": "Epsilon",
                    "ϝ": "gammad",
                    "Ϝ": "Gammad",
                    "ζ": "zeta",
                    "Ζ": "Zeta",
                    "η": "eta",
                    "Η": "Eta",
                    "θ": "theta",
                    "ϑ": "thetav",
                    "Θ": "Theta",
                    "ι": "iota",
                    "Ι": "Iota",
                    "κ": "kappa",
                    "ϰ": "kappav",
                    "Κ": "Kappa",
                    "λ": "lambda",
                    "Λ": "Lambda",
                    "μ": "mu",
                    "µ": "micro",
                    "Μ": "Mu",
                    "ν": "nu",
                    "Ν": "Nu",
                    "ξ": "xi",
                    "Ξ": "Xi",
                    "ο": "omicron",
                    "Ο": "Omicron",
                    "π": "pi",
                    "ϖ": "piv",
                    "Π": "Pi",
                    "ρ": "rho",
                    "ϱ": "rhov",
                    "Ρ": "Rho",
                    "σ": "sigma",
                    "Σ": "Sigma",
                    "ς": "sigmaf",
                    "τ": "tau",
                    "Τ": "Tau",
                    "υ": "upsi",
                    "Υ": "Upsilon",
                    "ϒ": "Upsi",
                    "φ": "phi",
                    "ϕ": "phiv",
                    "Φ": "Phi",
                    "χ": "chi",
                    "Χ": "Chi",
                    "ψ": "psi",
                    "Ψ": "Psi",
                    "ω": "omega",
                    "Ω": "ohm",
                    "а": "acy",
                    "А": "Acy",
                    "б": "bcy",
                    "Б": "Bcy",
                    "в": "vcy",
                    "В": "Vcy",
                    "г": "gcy",
                    "Г": "Gcy",
                    "ѓ": "gjcy",
                    "Ѓ": "GJcy",
                    "д": "dcy",
                    "Д": "Dcy",
                    "ђ": "djcy",
                    "Ђ": "DJcy",
                    "е": "iecy",
                    "Е": "IEcy",
                    "ё": "iocy",
                    "Ё": "IOcy",
                    "є": "jukcy",
                    "Є": "Jukcy",
                    "ж": "zhcy",
                    "Ж": "ZHcy",
                    "з": "zcy",
                    "З": "Zcy",
                    "ѕ": "dscy",
                    "Ѕ": "DScy",
                    "и": "icy",
                    "И": "Icy",
                    "і": "iukcy",
                    "І": "Iukcy",
                    "ї": "yicy",
                    "Ї": "YIcy",
                    "й": "jcy",
                    "Й": "Jcy",
                    "ј": "jsercy",
                    "Ј": "Jsercy",
                    "к": "kcy",
                    "К": "Kcy",
                    "ќ": "kjcy",
                    "Ќ": "KJcy",
                    "л": "lcy",
                    "Л": "Lcy",
                    "љ": "ljcy",
                    "Љ": "LJcy",
                    "м": "mcy",
                    "М": "Mcy",
                    "н": "ncy",
                    "Н": "Ncy",
                    "њ": "njcy",
                    "Њ": "NJcy",
                    "о": "ocy",
                    "О": "Ocy",
                    "п": "pcy",
                    "П": "Pcy",
                    "р": "rcy",
                    "Р": "Rcy",
                    "с": "scy",
                    "С": "Scy",
                    "т": "tcy",
                    "Т": "Tcy",
                    "ћ": "tshcy",
                    "Ћ": "TSHcy",
                    "у": "ucy",
                    "У": "Ucy",
                    "ў": "ubrcy",
                    "Ў": "Ubrcy",
                    "ф": "fcy",
                    "Ф": "Fcy",
                    "х": "khcy",
                    "Х": "KHcy",
                    "ц": "tscy",
                    "Ц": "TScy",
                    "ч": "chcy",
                    "Ч": "CHcy",
                    "џ": "dzcy",
                    "Џ": "DZcy",
                    "ш": "shcy",
                    "Ш": "SHcy",
                    "щ": "shchcy",
                    "Щ": "SHCHcy",
                    "ъ": "hardcy",
                    "Ъ": "HARDcy",
                    "ы": "ycy",
                    "Ы": "Ycy",
                    "ь": "softcy",
                    "Ь": "SOFTcy",
                    "э": "ecy",
                    "Э": "Ecy",
                    "ю": "yucy",
                    "Ю": "YUcy",
                    "я": "yacy",
                    "Я": "YAcy",
                    "ℵ": "aleph",
                    "ℶ": "beth",
                    "ℷ": "gimel",
                    "ℸ": "daleth"
                },
                regexEscape = /["&'<>`]/g,
                escapeMap = {
                    '"': "&quot;",
                    "&": "&amp;",
                    "'": "&#x27;",
                    "<": "&lt;",
                    ">": "&gt;",
                    "`": "&#x60;"
                },
                regexInvalidEntity = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/,
                regexInvalidRawCodePoint = /[\0-\x08\x0B\x0E-\x1F\x7F-\x9F\uFDD0-\uFDEF\uFFFE\uFFFF]|[\uD83F\uD87F\uD8BF\uD8FF\uD93F\uD97F\uD9BF\uD9FF\uDA3F\uDA7F\uDABF\uDAFF\uDB3F\uDB7F\uDBBF\uDBFF][\uDFFE\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/,
                regexDecode = /&(CounterClockwiseContourIntegral|DoubleLongLeftRightArrow|ClockwiseContourIntegral|NotNestedGreaterGreater|NotSquareSupersetEqual|DiacriticalDoubleAcute|NotRightTriangleEqual|NotSucceedsSlantEqual|NotPrecedesSlantEqual|CloseCurlyDoubleQuote|NegativeVeryThinSpace|DoubleContourIntegral|FilledVerySmallSquare|CapitalDifferentialD|OpenCurlyDoubleQuote|EmptyVerySmallSquare|NestedGreaterGreater|DoubleLongRightArrow|NotLeftTriangleEqual|NotGreaterSlantEqual|ReverseUpEquilibrium|DoubleLeftRightArrow|NotSquareSubsetEqual|NotDoubleVerticalBar|RightArrowLeftArrow|NotGreaterFullEqual|NotRightTriangleBar|SquareSupersetEqual|DownLeftRightVector|DoubleLongLeftArrow|leftrightsquigarrow|LeftArrowRightArrow|NegativeMediumSpace|blacktriangleright|RightDownVectorBar|PrecedesSlantEqual|RightDoubleBracket|SucceedsSlantEqual|NotLeftTriangleBar|RightTriangleEqual|SquareIntersection|RightDownTeeVector|ReverseEquilibrium|NegativeThickSpace|longleftrightarrow|Longleftrightarrow|LongLeftRightArrow|DownRightTeeVector|DownRightVectorBar|GreaterSlantEqual|SquareSubsetEqual|LeftDownVectorBar|LeftDoubleBracket|VerticalSeparator|rightleftharpoons|NotGreaterGreater|NotSquareSuperset|blacktriangleleft|blacktriangledown|NegativeThinSpace|LeftDownTeeVector|NotLessSlantEqual|leftrightharpoons|DoubleUpDownArrow|DoubleVerticalBar|LeftTriangleEqual|FilledSmallSquare|twoheadrightarrow|NotNestedLessLess|DownLeftTeeVector|DownLeftVectorBar|RightAngleBracket|NotTildeFullEqual|NotReverseElement|RightUpDownVector|DiacriticalTilde|NotSucceedsTilde|circlearrowright|NotPrecedesEqual|rightharpoondown|DoubleRightArrow|NotSucceedsEqual|NonBreakingSpace|NotRightTriangle|LessEqualGreater|RightUpTeeVector|LeftAngleBracket|GreaterFullEqual|DownArrowUpArrow|RightUpVectorBar|twoheadleftarrow|GreaterEqualLess|downharpoonright|RightTriangleBar|ntrianglerighteq|NotSupersetEqual|LeftUpDownVector|DiacriticalAcute|rightrightarrows|vartriangleright|UpArrowDownArrow|DiacriticalGrave|UnderParenthesis|EmptySmallSquare|LeftUpVectorBar|leftrightarrows|DownRightVector|downharpoonleft|trianglerighteq|ShortRightArrow|OverParenthesis|DoubleLeftArrow|DoubleDownArrow|NotSquareSubset|bigtriangledown|ntrianglelefteq|UpperRightArrow|curvearrowright|vartriangleleft|NotLeftTriangle|nleftrightarrow|LowerRightArrow|NotHumpDownHump|NotGreaterTilde|rightthreetimes|LeftUpTeeVector|NotGreaterEqual|straightepsilon|LeftTriangleBar|rightsquigarrow|ContourIntegral|rightleftarrows|CloseCurlyQuote|RightDownVector|LeftRightVector|nLeftrightarrow|leftharpoondown|circlearrowleft|SquareSuperset|OpenCurlyQuote|hookrightarrow|HorizontalLine|DiacriticalDot|NotLessGreater|ntriangleright|DoubleRightTee|InvisibleComma|InvisibleTimes|LowerLeftArrow|DownLeftVector|NotSubsetEqual|curvearrowleft|trianglelefteq|NotVerticalBar|TildeFullEqual|downdownarrows|NotGreaterLess|RightTeeVector|ZeroWidthSpace|looparrowright|LongRightArrow|doublebarwedge|ShortLeftArrow|ShortDownArrow|RightVectorBar|GreaterGreater|ReverseElement|rightharpoonup|LessSlantEqual|leftthreetimes|upharpoonright|rightarrowtail|LeftDownVector|Longrightarrow|NestedLessLess|UpperLeftArrow|nshortparallel|leftleftarrows|leftrightarrow|Leftrightarrow|LeftRightArrow|longrightarrow|upharpoonleft|RightArrowBar|ApplyFunction|LeftTeeVector|leftarrowtail|NotEqualTilde|varsubsetneqq|varsupsetneqq|RightTeeArrow|SucceedsEqual|SucceedsTilde|LeftVectorBar|SupersetEqual|hookleftarrow|DifferentialD|VerticalTilde|VeryThinSpace|blacktriangle|bigtriangleup|LessFullEqual|divideontimes|leftharpoonup|UpEquilibrium|ntriangleleft|RightTriangle|measuredangle|shortparallel|longleftarrow|Longleftarrow|LongLeftArrow|DoubleLeftTee|Poincareplane|PrecedesEqual|triangleright|DoubleUpArrow|RightUpVector|fallingdotseq|looparrowleft|PrecedesTilde|NotTildeEqual|NotTildeTilde|smallsetminus|Proportional|triangleleft|triangledown|UnderBracket|NotHumpEqual|exponentiale|ExponentialE|NotLessTilde|HilbertSpace|RightCeiling|blacklozenge|varsupsetneq|HumpDownHump|GreaterEqual|VerticalLine|LeftTeeArrow|NotLessEqual|DownTeeArrow|LeftTriangle|varsubsetneq|Intersection|NotCongruent|DownArrowBar|LeftUpVector|LeftArrowBar|risingdotseq|GreaterTilde|RoundImplies|SquareSubset|ShortUpArrow|NotSuperset|quaternions|precnapprox|backepsilon|preccurlyeq|OverBracket|blacksquare|MediumSpace|VerticalBar|circledcirc|circleddash|CircleMinus|CircleTimes|LessGreater|curlyeqprec|curlyeqsucc|diamondsuit|UpDownArrow|Updownarrow|RuleDelayed|Rrightarrow|updownarrow|RightVector|nRightarrow|nrightarrow|eqslantless|LeftCeiling|Equilibrium|SmallCircle|expectation|NotSucceeds|thickapprox|GreaterLess|SquareUnion|NotPrecedes|NotLessLess|straightphi|succnapprox|succcurlyeq|SubsetEqual|sqsupseteq|Proportion|Laplacetrf|ImaginaryI|supsetneqq|NotGreater|gtreqqless|NotElement|ThickSpace|TildeEqual|TildeTilde|Fouriertrf|rmoustache|EqualTilde|eqslantgtr|UnderBrace|LeftVector|UpArrowBar|nLeftarrow|nsubseteqq|subsetneqq|nsupseteqq|nleftarrow|succapprox|lessapprox|UpTeeArrow|upuparrows|curlywedge|lesseqqgtr|varepsilon|varnothing|RightFloor|complement|CirclePlus|sqsubseteq|Lleftarrow|circledast|RightArrow|Rightarrow|rightarrow|lmoustache|Bernoullis|precapprox|mapstoleft|mapstodown|longmapsto|dotsquare|downarrow|DoubleDot|nsubseteq|supsetneq|leftarrow|nsupseteq|subsetneq|ThinSpace|ngeqslant|subseteqq|HumpEqual|NotSubset|triangleq|NotCupCap|lesseqgtr|heartsuit|TripleDot|Leftarrow|Coproduct|Congruent|varpropto|complexes|gvertneqq|LeftArrow|LessTilde|supseteqq|MinusPlus|CircleDot|nleqslant|NotExists|gtreqless|nparallel|UnionPlus|LeftFloor|checkmark|CenterDot|centerdot|Mellintrf|gtrapprox|bigotimes|OverBrace|spadesuit|therefore|pitchfork|rationals|PlusMinus|Backslash|Therefore|DownBreve|backsimeq|backprime|DownArrow|nshortmid|Downarrow|lvertneqq|eqvparsl|imagline|imagpart|infintie|integers|Integral|intercal|LessLess|Uarrocir|intlarhk|sqsupset|angmsdaf|sqsubset|llcorner|vartheta|cupbrcap|lnapprox|Superset|SuchThat|succnsim|succneqq|angmsdag|biguplus|curlyvee|trpezium|Succeeds|NotTilde|bigwedge|angmsdah|angrtvbd|triminus|cwconint|fpartint|lrcorner|smeparsl|subseteq|urcorner|lurdshar|laemptyv|DDotrahd|approxeq|ldrushar|awconint|mapstoup|backcong|shortmid|triangle|geqslant|gesdotol|timesbar|circledR|circledS|setminus|multimap|naturals|scpolint|ncongdot|RightTee|boxminus|gnapprox|boxtimes|andslope|thicksim|angmsdaa|varsigma|cirfnint|rtriltri|angmsdab|rppolint|angmsdac|barwedge|drbkarow|clubsuit|thetasym|bsolhsub|capbrcup|dzigrarr|doteqdot|DotEqual|dotminus|UnderBar|NotEqual|realpart|otimesas|ulcorner|hksearow|hkswarow|parallel|PartialD|elinters|emptyset|plusacir|bbrktbrk|angmsdad|pointint|bigoplus|angmsdae|Precedes|bigsqcup|varkappa|notindot|supseteq|precneqq|precnsim|profalar|profline|profsurf|leqslant|lesdotor|raemptyv|subplus|notnivb|notnivc|subrarr|zigrarr|vzigzag|submult|subedot|Element|between|cirscir|larrbfs|larrsim|lotimes|lbrksld|lbrkslu|lozenge|ldrdhar|dbkarow|bigcirc|epsilon|simrarr|simplus|ltquest|Epsilon|luruhar|gtquest|maltese|npolint|eqcolon|npreceq|bigodot|ddagger|gtrless|bnequiv|harrcir|ddotseq|equivDD|backsim|demptyv|nsqsube|nsqsupe|Upsilon|nsubset|upsilon|minusdu|nsucceq|swarrow|nsupset|coloneq|searrow|boxplus|napprox|natural|asympeq|alefsym|congdot|nearrow|bigstar|diamond|supplus|tritime|LeftTee|nvinfin|triplus|NewLine|nvltrie|nvrtrie|nwarrow|nexists|Diamond|ruluhar|Implies|supmult|angzarr|suplarr|suphsub|questeq|because|digamma|Because|olcross|bemptyv|omicron|Omicron|rotimes|NoBreak|intprod|angrtvb|orderof|uwangle|suphsol|lesdoto|orslope|DownTee|realine|cudarrl|rdldhar|OverBar|supedot|lessdot|supdsub|topfork|succsim|rbrkslu|rbrksld|pertenk|cudarrr|isindot|planckh|lessgtr|pluscir|gesdoto|plussim|plustwo|lesssim|cularrp|rarrsim|Cayleys|notinva|notinvb|notinvc|UpArrow|Uparrow|uparrow|NotLess|dwangle|precsim|Product|curarrm|Cconint|dotplus|rarrbfs|ccupssm|Cedilla|cemptyv|notniva|quatint|frac35|frac38|frac45|frac56|frac58|frac78|tridot|xoplus|gacute|gammad|Gammad|lfisht|lfloor|bigcup|sqsupe|gbreve|Gbreve|lharul|sqsube|sqcups|Gcedil|apacir|llhard|lmidot|Lmidot|lmoust|andand|sqcaps|approx|Abreve|spades|circeq|tprime|divide|topcir|Assign|topbot|gesdot|divonx|xuplus|timesd|gesles|atilde|solbar|SOFTcy|loplus|timesb|lowast|lowbar|dlcorn|dlcrop|softcy|dollar|lparlt|thksim|lrhard|Atilde|lsaquo|smashp|bigvee|thinsp|wreath|bkarow|lsquor|lstrok|Lstrok|lthree|ltimes|ltlarr|DotDot|simdot|ltrPar|weierp|xsqcup|angmsd|sigmav|sigmaf|zeetrf|Zcaron|zcaron|mapsto|vsupne|thetav|cirmid|marker|mcomma|Zacute|vsubnE|there4|gtlPar|vsubne|bottom|gtrarr|SHCHcy|shchcy|midast|midcir|middot|minusb|minusd|gtrdot|bowtie|sfrown|mnplus|models|colone|seswar|Colone|mstpos|searhk|gtrsim|nacute|Nacute|boxbox|telrec|hairsp|Tcedil|nbumpe|scnsim|ncaron|Ncaron|ncedil|Ncedil|hamilt|Scedil|nearhk|hardcy|HARDcy|tcedil|Tcaron|commat|nequiv|nesear|tcaron|target|hearts|nexist|varrho|scedil|Scaron|scaron|hellip|Sacute|sacute|hercon|swnwar|compfn|rtimes|rthree|rsquor|rsaquo|zacute|wedgeq|homtht|barvee|barwed|Barwed|rpargt|horbar|conint|swarhk|roplus|nltrie|hslash|hstrok|Hstrok|rmoust|Conint|bprime|hybull|hyphen|iacute|Iacute|supsup|supsub|supsim|varphi|coprod|brvbar|agrave|Supset|supset|igrave|Igrave|notinE|Agrave|iiiint|iinfin|copysr|wedbar|Verbar|vangrt|becaus|incare|verbar|inodot|bullet|drcorn|intcal|drcrop|cularr|vellip|Utilde|bumpeq|cupcap|dstrok|Dstrok|CupCap|cupcup|cupdot|eacute|Eacute|supdot|iquest|easter|ecaron|Ecaron|ecolon|isinsv|utilde|itilde|Itilde|curarr|succeq|Bumpeq|cacute|ulcrop|nparsl|Cacute|nprcue|egrave|Egrave|nrarrc|nrarrw|subsup|subsub|nrtrie|jsercy|nsccue|Jsercy|kappav|kcedil|Kcedil|subsim|ulcorn|nsimeq|egsdot|veebar|kgreen|capand|elsdot|Subset|subset|curren|aacute|lacute|Lacute|emptyv|ntilde|Ntilde|lagran|lambda|Lambda|capcap|Ugrave|langle|subdot|emsp13|numero|emsp14|nvdash|nvDash|nVdash|nVDash|ugrave|ufisht|nvHarr|larrfs|nvlArr|larrhk|larrlp|larrpl|nvrArr|Udblac|nwarhk|larrtl|nwnear|oacute|Oacute|latail|lAtail|sstarf|lbrace|odblac|Odblac|lbrack|udblac|odsold|eparsl|lcaron|Lcaron|ograve|Ograve|lcedil|Lcedil|Aacute|ssmile|ssetmn|squarf|ldquor|capcup|ominus|cylcty|rharul|eqcirc|dagger|rfloor|rfisht|Dagger|daleth|equals|origof|capdot|equest|dcaron|Dcaron|rdquor|oslash|Oslash|otilde|Otilde|otimes|Otimes|urcrop|Ubreve|ubreve|Yacute|Uacute|uacute|Rcedil|rcedil|urcorn|parsim|Rcaron|Vdashl|rcaron|Tstrok|percnt|period|permil|Exists|yacute|rbrack|rbrace|phmmat|ccaron|Ccaron|planck|ccedil|plankv|tstrok|female|plusdo|plusdu|ffilig|plusmn|ffllig|Ccedil|rAtail|dfisht|bernou|ratail|Rarrtl|rarrtl|angsph|rarrpl|rarrlp|rarrhk|xwedge|xotime|forall|ForAll|Vvdash|vsupnE|preceq|bigcap|frac12|frac13|frac14|primes|rarrfs|prnsim|frac15|Square|frac16|square|lesdot|frac18|frac23|propto|prurel|rarrap|rangle|puncsp|frac25|Racute|qprime|racute|lesges|frac34|abreve|AElig|eqsim|utdot|setmn|urtri|Equal|Uring|seArr|uring|searr|dashv|Dashv|mumap|nabla|iogon|Iogon|sdote|sdotb|scsim|napid|napos|equiv|natur|Acirc|dblac|erarr|nbump|iprod|erDot|ucirc|awint|esdot|angrt|ncong|isinE|scnap|Scirc|scirc|ndash|isins|Ubrcy|nearr|neArr|isinv|nedot|ubrcy|acute|Ycirc|iukcy|Iukcy|xutri|nesim|caret|jcirc|Jcirc|caron|twixt|ddarr|sccue|exist|jmath|sbquo|ngeqq|angst|ccaps|lceil|ngsim|UpTee|delta|Delta|rtrif|nharr|nhArr|nhpar|rtrie|jukcy|Jukcy|kappa|rsquo|Kappa|nlarr|nlArr|TSHcy|rrarr|aogon|Aogon|fflig|xrarr|tshcy|ccirc|nleqq|filig|upsih|nless|dharl|nlsim|fjlig|ropar|nltri|dharr|robrk|roarr|fllig|fltns|roang|rnmid|subnE|subne|lAarr|trisb|Ccirc|acirc|ccups|blank|VDash|forkv|Vdash|langd|cedil|blk12|blk14|laquo|strns|diams|notin|vDash|larrb|blk34|block|disin|uplus|vdash|vBarv|aelig|starf|Wedge|check|xrArr|lates|lbarr|lBarr|notni|lbbrk|bcong|frasl|lbrke|frown|vrtri|vprop|vnsup|gamma|Gamma|wedge|xodot|bdquo|srarr|doteq|ldquo|boxdl|boxdL|gcirc|Gcirc|boxDl|boxDL|boxdr|boxdR|boxDr|TRADE|trade|rlhar|boxDR|vnsub|npart|vltri|rlarr|boxhd|boxhD|nprec|gescc|nrarr|nrArr|boxHd|boxHD|boxhu|boxhU|nrtri|boxHu|clubs|boxHU|times|colon|Colon|gimel|xlArr|Tilde|nsime|tilde|nsmid|nspar|THORN|thorn|xlarr|nsube|nsubE|thkap|xhArr|comma|nsucc|boxul|boxuL|nsupe|nsupE|gneqq|gnsim|boxUl|boxUL|grave|boxur|boxuR|boxUr|boxUR|lescc|angle|bepsi|boxvh|varpi|boxvH|numsp|Theta|gsime|gsiml|theta|boxVh|boxVH|boxvl|gtcir|gtdot|boxvL|boxVl|boxVL|crarr|cross|Cross|nvsim|boxvr|nwarr|nwArr|sqsup|dtdot|Uogon|lhard|lharu|dtrif|ocirc|Ocirc|lhblk|duarr|odash|sqsub|Hacek|sqcup|llarr|duhar|oelig|OElig|ofcir|boxvR|uogon|lltri|boxVr|csube|uuarr|ohbar|csupe|ctdot|olarr|olcir|harrw|oline|sqcap|omacr|Omacr|omega|Omega|boxVR|aleph|lneqq|lnsim|loang|loarr|rharu|lobrk|hcirc|operp|oplus|rhard|Hcirc|orarr|Union|order|ecirc|Ecirc|cuepr|szlig|cuesc|breve|reals|eDDot|Breve|hoarr|lopar|utrif|rdquo|Umacr|umacr|efDot|swArr|ultri|alpha|rceil|ovbar|swarr|Wcirc|wcirc|smtes|smile|bsemi|lrarr|aring|parsl|lrhar|bsime|uhblk|lrtri|cupor|Aring|uharr|uharl|slarr|rbrke|bsolb|lsime|rbbrk|RBarr|lsimg|phone|rBarr|rbarr|icirc|lsquo|Icirc|emacr|Emacr|ratio|simne|plusb|simlE|simgE|simeq|pluse|ltcir|ltdot|empty|xharr|xdtri|iexcl|Alpha|ltrie|rarrw|pound|ltrif|xcirc|bumpe|prcue|bumpE|asymp|amacr|cuvee|Sigma|sigma|iiint|udhar|iiota|ijlig|IJlig|supnE|imacr|Imacr|prime|Prime|image|prnap|eogon|Eogon|rarrc|mdash|mDDot|cuwed|imath|supne|imped|Amacr|udarr|prsim|micro|rarrb|cwint|raquo|infin|eplus|range|rangd|Ucirc|radic|minus|amalg|veeeq|rAarr|epsiv|ycirc|quest|sharp|quot|zwnj|Qscr|race|qscr|Qopf|qopf|qint|rang|Rang|Zscr|zscr|Zopf|zopf|rarr|rArr|Rarr|Pscr|pscr|prop|prod|prnE|prec|ZHcy|zhcy|prap|Zeta|zeta|Popf|popf|Zdot|plus|zdot|Yuml|yuml|phiv|YUcy|yucy|Yscr|yscr|perp|Yopf|yopf|part|para|YIcy|Ouml|rcub|yicy|YAcy|rdca|ouml|osol|Oscr|rdsh|yacy|real|oscr|xvee|andd|rect|andv|Xscr|oror|ordm|ordf|xscr|ange|aopf|Aopf|rHar|Xopf|opar|Oopf|xopf|xnis|rhov|oopf|omid|xmap|oint|apid|apos|ogon|ascr|Ascr|odot|odiv|xcup|xcap|ocir|oast|nvlt|nvle|nvgt|nvge|nvap|Wscr|wscr|auml|ntlg|ntgl|nsup|nsub|nsim|Nscr|nscr|nsce|Wopf|ring|npre|wopf|npar|Auml|Barv|bbrk|Nopf|nopf|nmid|nLtv|beta|ropf|Ropf|Beta|beth|nles|rpar|nleq|bnot|bNot|nldr|NJcy|rscr|Rscr|Vscr|vscr|rsqb|njcy|bopf|nisd|Bopf|rtri|Vopf|nGtv|ngtr|vopf|boxh|boxH|boxv|nges|ngeq|boxV|bscr|scap|Bscr|bsim|Vert|vert|bsol|bull|bump|caps|cdot|ncup|scnE|ncap|nbsp|napE|Cdot|cent|sdot|Vbar|nang|vBar|chcy|Mscr|mscr|sect|semi|CHcy|Mopf|mopf|sext|circ|cire|mldr|mlcp|cirE|comp|shcy|SHcy|vArr|varr|cong|copf|Copf|copy|COPY|malt|male|macr|lvnE|cscr|ltri|sime|ltcc|simg|Cscr|siml|csub|Uuml|lsqb|lsim|uuml|csup|Lscr|lscr|utri|smid|lpar|cups|smte|lozf|darr|Lopf|Uscr|solb|lopf|sopf|Sopf|lneq|uscr|spar|dArr|lnap|Darr|dash|Sqrt|LJcy|ljcy|lHar|dHar|Upsi|upsi|diam|lesg|djcy|DJcy|leqq|dopf|Dopf|dscr|Dscr|dscy|ldsh|ldca|squf|DScy|sscr|Sscr|dsol|lcub|late|star|Star|Uopf|Larr|lArr|larr|uopf|dtri|dzcy|sube|subE|Lang|lang|Kscr|kscr|Kopf|kopf|KJcy|kjcy|KHcy|khcy|DZcy|ecir|edot|eDot|Jscr|jscr|succ|Jopf|jopf|Edot|uHar|emsp|ensp|Iuml|iuml|eopf|isin|Iscr|iscr|Eopf|epar|sung|epsi|escr|sup1|sup2|sup3|Iota|iota|supe|supE|Iopf|iopf|IOcy|iocy|Escr|esim|Esim|imof|Uarr|QUOT|uArr|uarr|euml|IEcy|iecy|Idot|Euml|euro|excl|Hscr|hscr|Hopf|hopf|TScy|tscy|Tscr|hbar|tscr|flat|tbrk|fnof|hArr|harr|half|fopf|Fopf|tdot|gvnE|fork|trie|gtcc|fscr|Fscr|gdot|gsim|Gscr|gscr|Gopf|gopf|gneq|Gdot|tosa|gnap|Topf|topf|geqq|toea|GJcy|gjcy|tint|gesl|mid|Sfr|ggg|top|ges|gla|glE|glj|geq|gne|gEl|gel|gnE|Gcy|gcy|gap|Tfr|tfr|Tcy|tcy|Hat|Tau|Ffr|tau|Tab|hfr|Hfr|ffr|Fcy|fcy|icy|Icy|iff|ETH|eth|ifr|Ifr|Eta|eta|int|Int|Sup|sup|ucy|Ucy|Sum|sum|jcy|ENG|ufr|Ufr|eng|Jcy|jfr|els|ell|egs|Efr|efr|Jfr|uml|kcy|Kcy|Ecy|ecy|kfr|Kfr|lap|Sub|sub|lat|lcy|Lcy|leg|Dot|dot|lEg|leq|les|squ|div|die|lfr|Lfr|lgE|Dfr|dfr|Del|deg|Dcy|dcy|lne|lnE|sol|loz|smt|Cup|lrm|cup|lsh|Lsh|sim|shy|map|Map|mcy|Mcy|mfr|Mfr|mho|gfr|Gfr|sfr|cir|Chi|chi|nap|Cfr|vcy|Vcy|cfr|Scy|scy|ncy|Ncy|vee|Vee|Cap|cap|nfr|scE|sce|Nfr|nge|ngE|nGg|vfr|Vfr|ngt|bot|nGt|nis|niv|Rsh|rsh|nle|nlE|bne|Bfr|bfr|nLl|nlt|nLt|Bcy|bcy|not|Not|rlm|wfr|Wfr|npr|nsc|num|ocy|ast|Ocy|ofr|xfr|Xfr|Ofr|ogt|ohm|apE|olt|Rho|ape|rho|Rfr|rfr|ord|REG|ang|reg|orv|And|and|AMP|Rcy|amp|Afr|ycy|Ycy|yen|yfr|Yfr|rcy|par|pcy|Pcy|pfr|Pfr|phi|Phi|afr|Acy|acy|zcy|Zcy|piv|acE|acd|zfr|Zfr|pre|prE|psi|Psi|qfr|Qfr|zwj|Or|ge|Gg|gt|gg|el|oS|lt|Lt|LT|Re|lg|gl|eg|ne|Im|it|le|DD|wp|wr|nu|Nu|dd|lE|Sc|sc|pi|Pi|ee|af|ll|Ll|rx|gE|xi|pm|Xi|ic|pr|Pr|in|ni|mp|mu|ac|Mu|or|ap|Gt|GT|ii);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)(?!;)([=a-zA-Z0-9]?)|&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+)/g,
                decodeMap = {
                    aacute: "á",
                    Aacute: "Á",
                    abreve: "ă",
                    Abreve: "Ă",
                    ac: "∾",
                    acd: "∿",
                    acE: "∾̳",
                    acirc: "â",
                    Acirc: "Â",
                    acute: "´",
                    acy: "а",
                    Acy: "А",
                    aelig: "æ",
                    AElig: "Æ",
                    af: "⁡",
                    afr: "𝔞",
                    Afr: "𝔄",
                    agrave: "à",
                    Agrave: "À",
                    alefsym: "ℵ",
                    aleph: "ℵ",
                    alpha: "α",
                    Alpha: "Α",
                    amacr: "ā",
                    Amacr: "Ā",
                    amalg: "⨿",
                    amp: "&",
                    AMP: "&",
                    and: "∧",
                    And: "⩓",
                    andand: "⩕",
                    andd: "⩜",
                    andslope: "⩘",
                    andv: "⩚",
                    ang: "∠",
                    ange: "⦤",
                    angle: "∠",
                    angmsd: "∡",
                    angmsdaa: "⦨",
                    angmsdab: "⦩",
                    angmsdac: "⦪",
                    angmsdad: "⦫",
                    angmsdae: "⦬",
                    angmsdaf: "⦭",
                    angmsdag: "⦮",
                    angmsdah: "⦯",
                    angrt: "∟",
                    angrtvb: "⊾",
                    angrtvbd: "⦝",
                    angsph: "∢",
                    angst: "Å",
                    angzarr: "⍼",
                    aogon: "ą",
                    Aogon: "Ą",
                    aopf: "𝕒",
                    Aopf: "𝔸",
                    ap: "≈",
                    apacir: "⩯",
                    ape: "≊",
                    apE: "⩰",
                    apid: "≋",
                    apos: "'",
                    ApplyFunction: "⁡",
                    approx: "≈",
                    approxeq: "≊",
                    aring: "å",
                    Aring: "Å",
                    ascr: "𝒶",
                    Ascr: "𝒜",
                    Assign: "≔",
                    ast: "*",
                    asymp: "≈",
                    asympeq: "≍",
                    atilde: "ã",
                    Atilde: "Ã",
                    auml: "ä",
                    Auml: "Ä",
                    awconint: "∳",
                    awint: "⨑",
                    backcong: "≌",
                    backepsilon: "϶",
                    backprime: "‵",
                    backsim: "∽",
                    backsimeq: "⋍",
                    Backslash: "∖",
                    Barv: "⫧",
                    barvee: "⊽",
                    barwed: "⌅",
                    Barwed: "⌆",
                    barwedge: "⌅",
                    bbrk: "⎵",
                    bbrktbrk: "⎶",
                    bcong: "≌",
                    bcy: "б",
                    Bcy: "Б",
                    bdquo: "„",
                    becaus: "∵",
                    because: "∵",
                    Because: "∵",
                    bemptyv: "⦰",
                    bepsi: "϶",
                    bernou: "ℬ",
                    Bernoullis: "ℬ",
                    beta: "β",
                    Beta: "Β",
                    beth: "ℶ",
                    between: "≬",
                    bfr: "𝔟",
                    Bfr: "𝔅",
                    bigcap: "⋂",
                    bigcirc: "◯",
                    bigcup: "⋃",
                    bigodot: "⨀",
                    bigoplus: "⨁",
                    bigotimes: "⨂",
                    bigsqcup: "⨆",
                    bigstar: "★",
                    bigtriangledown: "▽",
                    bigtriangleup: "△",
                    biguplus: "⨄",
                    bigvee: "⋁",
                    bigwedge: "⋀",
                    bkarow: "⤍",
                    blacklozenge: "⧫",
                    blacksquare: "▪",
                    blacktriangle: "▴",
                    blacktriangledown: "▾",
                    blacktriangleleft: "◂",
                    blacktriangleright: "▸",
                    blank: "␣",
                    blk12: "▒",
                    blk14: "░",
                    blk34: "▓",
                    block: "█",
                    bne: "=⃥",
                    bnequiv: "≡⃥",
                    bnot: "⌐",
                    bNot: "⫭",
                    bopf: "𝕓",
                    Bopf: "𝔹",
                    bot: "⊥",
                    bottom: "⊥",
                    bowtie: "⋈",
                    boxbox: "⧉",
                    boxdl: "┐",
                    boxdL: "╕",
                    boxDl: "╖",
                    boxDL: "╗",
                    boxdr: "┌",
                    boxdR: "╒",
                    boxDr: "╓",
                    boxDR: "╔",
                    boxh: "─",
                    boxH: "═",
                    boxhd: "┬",
                    boxhD: "╥",
                    boxHd: "╤",
                    boxHD: "╦",
                    boxhu: "┴",
                    boxhU: "╨",
                    boxHu: "╧",
                    boxHU: "╩",
                    boxminus: "⊟",
                    boxplus: "⊞",
                    boxtimes: "⊠",
                    boxul: "┘",
                    boxuL: "╛",
                    boxUl: "╜",
                    boxUL: "╝",
                    boxur: "└",
                    boxuR: "╘",
                    boxUr: "╙",
                    boxUR: "╚",
                    boxv: "│",
                    boxV: "║",
                    boxvh: "┼",
                    boxvH: "╪",
                    boxVh: "╫",
                    boxVH: "╬",
                    boxvl: "┤",
                    boxvL: "╡",
                    boxVl: "╢",
                    boxVL: "╣",
                    boxvr: "├",
                    boxvR: "╞",
                    boxVr: "╟",
                    boxVR: "╠",
                    bprime: "‵",
                    breve: "˘",
                    Breve: "˘",
                    brvbar: "¦",
                    bscr: "𝒷",
                    Bscr: "ℬ",
                    bsemi: "⁏",
                    bsim: "∽",
                    bsime: "⋍",
                    bsol: "\\",
                    bsolb: "⧅",
                    bsolhsub: "⟈",
                    bull: "•",
                    bullet: "•",
                    bump: "≎",
                    bumpe: "≏",
                    bumpE: "⪮",
                    bumpeq: "≏",
                    Bumpeq: "≎",
                    cacute: "ć",
                    Cacute: "Ć",
                    cap: "∩",
                    Cap: "⋒",
                    capand: "⩄",
                    capbrcup: "⩉",
                    capcap: "⩋",
                    capcup: "⩇",
                    capdot: "⩀",
                    CapitalDifferentialD: "ⅅ",
                    caps: "∩︀",
                    caret: "⁁",
                    caron: "ˇ",
                    Cayleys: "ℭ",
                    ccaps: "⩍",
                    ccaron: "č",
                    Ccaron: "Č",
                    ccedil: "ç",
                    Ccedil: "Ç",
                    ccirc: "ĉ",
                    Ccirc: "Ĉ",
                    Cconint: "∰",
                    ccups: "⩌",
                    ccupssm: "⩐",
                    cdot: "ċ",
                    Cdot: "Ċ",
                    cedil: "¸",
                    Cedilla: "¸",
                    cemptyv: "⦲",
                    cent: "¢",
                    centerdot: "·",
                    CenterDot: "·",
                    cfr: "𝔠",
                    Cfr: "ℭ",
                    chcy: "ч",
                    CHcy: "Ч",
                    check: "✓",
                    checkmark: "✓",
                    chi: "χ",
                    Chi: "Χ",
                    cir: "○",
                    circ: "ˆ",
                    circeq: "≗",
                    circlearrowleft: "↺",
                    circlearrowright: "↻",
                    circledast: "⊛",
                    circledcirc: "⊚",
                    circleddash: "⊝",
                    CircleDot: "⊙",
                    circledR: "®",
                    circledS: "Ⓢ",
                    CircleMinus: "⊖",
                    CirclePlus: "⊕",
                    CircleTimes: "⊗",
                    cire: "≗",
                    cirE: "⧃",
                    cirfnint: "⨐",
                    cirmid: "⫯",
                    cirscir: "⧂",
                    ClockwiseContourIntegral: "∲",
                    CloseCurlyDoubleQuote: "”",
                    CloseCurlyQuote: "’",
                    clubs: "♣",
                    clubsuit: "♣",
                    colon: ":",
                    Colon: "∷",
                    colone: "≔",
                    Colone: "⩴",
                    coloneq: "≔",
                    comma: ",",
                    commat: "@",
                    comp: "∁",
                    compfn: "∘",
                    complement: "∁",
                    complexes: "ℂ",
                    cong: "≅",
                    congdot: "⩭",
                    Congruent: "≡",
                    conint: "∮",
                    Conint: "∯",
                    ContourIntegral: "∮",
                    copf: "𝕔",
                    Copf: "ℂ",
                    coprod: "∐",
                    Coproduct: "∐",
                    copy: "©",
                    COPY: "©",
                    copysr: "℗",
                    CounterClockwiseContourIntegral: "∳",
                    crarr: "↵",
                    cross: "✗",
                    Cross: "⨯",
                    cscr: "𝒸",
                    Cscr: "𝒞",
                    csub: "⫏",
                    csube: "⫑",
                    csup: "⫐",
                    csupe: "⫒",
                    ctdot: "⋯",
                    cudarrl: "⤸",
                    cudarrr: "⤵",
                    cuepr: "⋞",
                    cuesc: "⋟",
                    cularr: "↶",
                    cularrp: "⤽",
                    cup: "∪",
                    Cup: "⋓",
                    cupbrcap: "⩈",
                    cupcap: "⩆",
                    CupCap: "≍",
                    cupcup: "⩊",
                    cupdot: "⊍",
                    cupor: "⩅",
                    cups: "∪︀",
                    curarr: "↷",
                    curarrm: "⤼",
                    curlyeqprec: "⋞",
                    curlyeqsucc: "⋟",
                    curlyvee: "⋎",
                    curlywedge: "⋏",
                    curren: "¤",
                    curvearrowleft: "↶",
                    curvearrowright: "↷",
                    cuvee: "⋎",
                    cuwed: "⋏",
                    cwconint: "∲",
                    cwint: "∱",
                    cylcty: "⌭",
                    dagger: "†",
                    Dagger: "‡",
                    daleth: "ℸ",
                    darr: "↓",
                    dArr: "⇓",
                    Darr: "↡",
                    dash: "‐",
                    dashv: "⊣",
                    Dashv: "⫤",
                    dbkarow: "⤏",
                    dblac: "˝",
                    dcaron: "ď",
                    Dcaron: "Ď",
                    dcy: "д",
                    Dcy: "Д",
                    dd: "ⅆ",
                    DD: "ⅅ",
                    ddagger: "‡",
                    ddarr: "⇊",
                    DDotrahd: "⤑",
                    ddotseq: "⩷",
                    deg: "°",
                    Del: "∇",
                    delta: "δ",
                    Delta: "Δ",
                    demptyv: "⦱",
                    dfisht: "⥿",
                    dfr: "𝔡",
                    Dfr: "𝔇",
                    dHar: "⥥",
                    dharl: "⇃",
                    dharr: "⇂",
                    DiacriticalAcute: "´",
                    DiacriticalDot: "˙",
                    DiacriticalDoubleAcute: "˝",
                    DiacriticalGrave: "`",
                    DiacriticalTilde: "˜",
                    diam: "⋄",
                    diamond: "⋄",
                    Diamond: "⋄",
                    diamondsuit: "♦",
                    diams: "♦",
                    die: "¨",
                    DifferentialD: "ⅆ",
                    digamma: "ϝ",
                    disin: "⋲",
                    div: "÷",
                    divide: "÷",
                    divideontimes: "⋇",
                    divonx: "⋇",
                    djcy: "ђ",
                    DJcy: "Ђ",
                    dlcorn: "⌞",
                    dlcrop: "⌍",
                    dollar: "$",
                    dopf: "𝕕",
                    Dopf: "𝔻",
                    dot: "˙",
                    Dot: "¨",
                    DotDot: "⃜",
                    doteq: "≐",
                    doteqdot: "≑",
                    DotEqual: "≐",
                    dotminus: "∸",
                    dotplus: "∔",
                    dotsquare: "⊡",
                    doublebarwedge: "⌆",
                    DoubleContourIntegral: "∯",
                    DoubleDot: "¨",
                    DoubleDownArrow: "⇓",
                    DoubleLeftArrow: "⇐",
                    DoubleLeftRightArrow: "⇔",
                    DoubleLeftTee: "⫤",
                    DoubleLongLeftArrow: "⟸",
                    DoubleLongLeftRightArrow: "⟺",
                    DoubleLongRightArrow: "⟹",
                    DoubleRightArrow: "⇒",
                    DoubleRightTee: "⊨",
                    DoubleUpArrow: "⇑",
                    DoubleUpDownArrow: "⇕",
                    DoubleVerticalBar: "∥",
                    downarrow: "↓",
                    Downarrow: "⇓",
                    DownArrow: "↓",
                    DownArrowBar: "⤓",
                    DownArrowUpArrow: "⇵",
                    DownBreve: "̑",
                    downdownarrows: "⇊",
                    downharpoonleft: "⇃",
                    downharpoonright: "⇂",
                    DownLeftRightVector: "⥐",
                    DownLeftTeeVector: "⥞",
                    DownLeftVector: "↽",
                    DownLeftVectorBar: "⥖",
                    DownRightTeeVector: "⥟",
                    DownRightVector: "⇁",
                    DownRightVectorBar: "⥗",
                    DownTee: "⊤",
                    DownTeeArrow: "↧",
                    drbkarow: "⤐",
                    drcorn: "⌟",
                    drcrop: "⌌",
                    dscr: "𝒹",
                    Dscr: "𝒟",
                    dscy: "ѕ",
                    DScy: "Ѕ",
                    dsol: "⧶",
                    dstrok: "đ",
                    Dstrok: "Đ",
                    dtdot: "⋱",
                    dtri: "▿",
                    dtrif: "▾",
                    duarr: "⇵",
                    duhar: "⥯",
                    dwangle: "⦦",
                    dzcy: "џ",
                    DZcy: "Џ",
                    dzigrarr: "⟿",
                    eacute: "é",
                    Eacute: "É",
                    easter: "⩮",
                    ecaron: "ě",
                    Ecaron: "Ě",
                    ecir: "≖",
                    ecirc: "ê",
                    Ecirc: "Ê",
                    ecolon: "≕",
                    ecy: "э",
                    Ecy: "Э",
                    eDDot: "⩷",
                    edot: "ė",
                    eDot: "≑",
                    Edot: "Ė",
                    ee: "ⅇ",
                    efDot: "≒",
                    efr: "𝔢",
                    Efr: "𝔈",
                    eg: "⪚",
                    egrave: "è",
                    Egrave: "È",
                    egs: "⪖",
                    egsdot: "⪘",
                    el: "⪙",
                    Element: "∈",
                    elinters: "⏧",
                    ell: "ℓ",
                    els: "⪕",
                    elsdot: "⪗",
                    emacr: "ē",
                    Emacr: "Ē",
                    empty: "∅",
                    emptyset: "∅",
                    EmptySmallSquare: "◻",
                    emptyv: "∅",
                    EmptyVerySmallSquare: "▫",
                    emsp: " ",
                    emsp13: " ",
                    emsp14: " ",
                    eng: "ŋ",
                    ENG: "Ŋ",
                    ensp: " ",
                    eogon: "ę",
                    Eogon: "Ę",
                    eopf: "𝕖",
                    Eopf: "𝔼",
                    epar: "⋕",
                    eparsl: "⧣",
                    eplus: "⩱",
                    epsi: "ε",
                    epsilon: "ε",
                    Epsilon: "Ε",
                    epsiv: "ϵ",
                    eqcirc: "≖",
                    eqcolon: "≕",
                    eqsim: "≂",
                    eqslantgtr: "⪖",
                    eqslantless: "⪕",
                    Equal: "⩵",
                    equals: "=",
                    EqualTilde: "≂",
                    equest: "≟",
                    Equilibrium: "⇌",
                    equiv: "≡",
                    equivDD: "⩸",
                    eqvparsl: "⧥",
                    erarr: "⥱",
                    erDot: "≓",
                    escr: "ℯ",
                    Escr: "ℰ",
                    esdot: "≐",
                    esim: "≂",
                    Esim: "⩳",
                    eta: "η",
                    Eta: "Η",
                    eth: "ð",
                    ETH: "Ð",
                    euml: "ë",
                    Euml: "Ë",
                    euro: "€",
                    excl: "!",
                    exist: "∃",
                    Exists: "∃",
                    expectation: "ℰ",
                    exponentiale: "ⅇ",
                    ExponentialE: "ⅇ",
                    fallingdotseq: "≒",
                    fcy: "ф",
                    Fcy: "Ф",
                    female: "♀",
                    ffilig: "ﬃ",
                    fflig: "ﬀ",
                    ffllig: "ﬄ",
                    ffr: "𝔣",
                    Ffr: "𝔉",
                    filig: "ﬁ",
                    FilledSmallSquare: "◼",
                    FilledVerySmallSquare: "▪",
                    fjlig: "fj",
                    flat: "♭",
                    fllig: "ﬂ",
                    fltns: "▱",
                    fnof: "ƒ",
                    fopf: "𝕗",
                    Fopf: "𝔽",
                    forall: "∀",
                    ForAll: "∀",
                    fork: "⋔",
                    forkv: "⫙",
                    Fouriertrf: "ℱ",
                    fpartint: "⨍",
                    frac12: "½",
                    frac13: "⅓",
                    frac14: "¼",
                    frac15: "⅕",
                    frac16: "⅙",
                    frac18: "⅛",
                    frac23: "⅔",
                    frac25: "⅖",
                    frac34: "¾",
                    frac35: "⅗",
                    frac38: "⅜",
                    frac45: "⅘",
                    frac56: "⅚",
                    frac58: "⅝",
                    frac78: "⅞",
                    frasl: "⁄",
                    frown: "⌢",
                    fscr: "𝒻",
                    Fscr: "ℱ",
                    gacute: "ǵ",
                    gamma: "γ",
                    Gamma: "Γ",
                    gammad: "ϝ",
                    Gammad: "Ϝ",
                    gap: "⪆",
                    gbreve: "ğ",
                    Gbreve: "Ğ",
                    Gcedil: "Ģ",
                    gcirc: "ĝ",
                    Gcirc: "Ĝ",
                    gcy: "г",
                    Gcy: "Г",
                    gdot: "ġ",
                    Gdot: "Ġ",
                    ge: "≥",
                    gE: "≧",
                    gel: "⋛",
                    gEl: "⪌",
                    geq: "≥",
                    geqq: "≧",
                    geqslant: "⩾",
                    ges: "⩾",
                    gescc: "⪩",
                    gesdot: "⪀",
                    gesdoto: "⪂",
                    gesdotol: "⪄",
                    gesl: "⋛︀",
                    gesles: "⪔",
                    gfr: "𝔤",
                    Gfr: "𝔊",
                    gg: "≫",
                    Gg: "⋙",
                    ggg: "⋙",
                    gimel: "ℷ",
                    gjcy: "ѓ",
                    GJcy: "Ѓ",
                    gl: "≷",
                    gla: "⪥",
                    glE: "⪒",
                    glj: "⪤",
                    gnap: "⪊",
                    gnapprox: "⪊",
                    gne: "⪈",
                    gnE: "≩",
                    gneq: "⪈",
                    gneqq: "≩",
                    gnsim: "⋧",
                    gopf: "𝕘",
                    Gopf: "𝔾",
                    grave: "`",
                    GreaterEqual: "≥",
                    GreaterEqualLess: "⋛",
                    GreaterFullEqual: "≧",
                    GreaterGreater: "⪢",
                    GreaterLess: "≷",
                    GreaterSlantEqual: "⩾",
                    GreaterTilde: "≳",
                    gscr: "ℊ",
                    Gscr: "𝒢",
                    gsim: "≳",
                    gsime: "⪎",
                    gsiml: "⪐",
                    gt: ">",
                    Gt: "≫",
                    GT: ">",
                    gtcc: "⪧",
                    gtcir: "⩺",
                    gtdot: "⋗",
                    gtlPar: "⦕",
                    gtquest: "⩼",
                    gtrapprox: "⪆",
                    gtrarr: "⥸",
                    gtrdot: "⋗",
                    gtreqless: "⋛",
                    gtreqqless: "⪌",
                    gtrless: "≷",
                    gtrsim: "≳",
                    gvertneqq: "≩︀",
                    gvnE: "≩︀",
                    Hacek: "ˇ",
                    hairsp: " ",
                    half: "½",
                    hamilt: "ℋ",
                    hardcy: "ъ",
                    HARDcy: "Ъ",
                    harr: "↔",
                    hArr: "⇔",
                    harrcir: "⥈",
                    harrw: "↭",
                    Hat: "^",
                    hbar: "ℏ",
                    hcirc: "ĥ",
                    Hcirc: "Ĥ",
                    hearts: "♥",
                    heartsuit: "♥",
                    hellip: "…",
                    hercon: "⊹",
                    hfr: "𝔥",
                    Hfr: "ℌ",
                    HilbertSpace: "ℋ",
                    hksearow: "⤥",
                    hkswarow: "⤦",
                    hoarr: "⇿",
                    homtht: "∻",
                    hookleftarrow: "↩",
                    hookrightarrow: "↪",
                    hopf: "𝕙",
                    Hopf: "ℍ",
                    horbar: "―",
                    HorizontalLine: "─",
                    hscr: "𝒽",
                    Hscr: "ℋ",
                    hslash: "ℏ",
                    hstrok: "ħ",
                    Hstrok: "Ħ",
                    HumpDownHump: "≎",
                    HumpEqual: "≏",
                    hybull: "⁃",
                    hyphen: "‐",
                    iacute: "í",
                    Iacute: "Í",
                    ic: "⁣",
                    icirc: "î",
                    Icirc: "Î",
                    icy: "и",
                    Icy: "И",
                    Idot: "İ",
                    iecy: "е",
                    IEcy: "Е",
                    iexcl: "¡",
                    iff: "⇔",
                    ifr: "𝔦",
                    Ifr: "ℑ",
                    igrave: "ì",
                    Igrave: "Ì",
                    ii: "ⅈ",
                    iiiint: "⨌",
                    iiint: "∭",
                    iinfin: "⧜",
                    iiota: "℩",
                    ijlig: "ĳ",
                    IJlig: "Ĳ",
                    Im: "ℑ",
                    imacr: "ī",
                    Imacr: "Ī",
                    image: "ℑ",
                    ImaginaryI: "ⅈ",
                    imagline: "ℐ",
                    imagpart: "ℑ",
                    imath: "ı",
                    imof: "⊷",
                    imped: "Ƶ",
                    Implies: "⇒",
                    in: "∈",
                    incare: "℅",
                    infin: "∞",
                    infintie: "⧝",
                    inodot: "ı",
                    int: "∫",
                    Int: "∬",
                    intcal: "⊺",
                    integers: "ℤ",
                    Integral: "∫",
                    intercal: "⊺",
                    Intersection: "⋂",
                    intlarhk: "⨗",
                    intprod: "⨼",
                    InvisibleComma: "⁣",
                    InvisibleTimes: "⁢",
                    iocy: "ё",
                    IOcy: "Ё",
                    iogon: "į",
                    Iogon: "Į",
                    iopf: "𝕚",
                    Iopf: "𝕀",
                    iota: "ι",
                    Iota: "Ι",
                    iprod: "⨼",
                    iquest: "¿",
                    iscr: "𝒾",
                    Iscr: "ℐ",
                    isin: "∈",
                    isindot: "⋵",
                    isinE: "⋹",
                    isins: "⋴",
                    isinsv: "⋳",
                    isinv: "∈",
                    it: "⁢",
                    itilde: "ĩ",
                    Itilde: "Ĩ",
                    iukcy: "і",
                    Iukcy: "І",
                    iuml: "ï",
                    Iuml: "Ï",
                    jcirc: "ĵ",
                    Jcirc: "Ĵ",
                    jcy: "й",
                    Jcy: "Й",
                    jfr: "𝔧",
                    Jfr: "𝔍",
                    jmath: "ȷ",
                    jopf: "𝕛",
                    Jopf: "𝕁",
                    jscr: "𝒿",
                    Jscr: "𝒥",
                    jsercy: "ј",
                    Jsercy: "Ј",
                    jukcy: "є",
                    Jukcy: "Є",
                    kappa: "κ",
                    Kappa: "Κ",
                    kappav: "ϰ",
                    kcedil: "ķ",
                    Kcedil: "Ķ",
                    kcy: "к",
                    Kcy: "К",
                    kfr: "𝔨",
                    Kfr: "𝔎",
                    kgreen: "ĸ",
                    khcy: "х",
                    KHcy: "Х",
                    kjcy: "ќ",
                    KJcy: "Ќ",
                    kopf: "𝕜",
                    Kopf: "𝕂",
                    kscr: "𝓀",
                    Kscr: "𝒦",
                    lAarr: "⇚",
                    lacute: "ĺ",
                    Lacute: "Ĺ",
                    laemptyv: "⦴",
                    lagran: "ℒ",
                    lambda: "λ",
                    Lambda: "Λ",
                    lang: "⟨",
                    Lang: "⟪",
                    langd: "⦑",
                    langle: "⟨",
                    lap: "⪅",
                    Laplacetrf: "ℒ",
                    laquo: "«",
                    larr: "←",
                    lArr: "⇐",
                    Larr: "↞",
                    larrb: "⇤",
                    larrbfs: "⤟",
                    larrfs: "⤝",
                    larrhk: "↩",
                    larrlp: "↫",
                    larrpl: "⤹",
                    larrsim: "⥳",
                    larrtl: "↢",
                    lat: "⪫",
                    latail: "⤙",
                    lAtail: "⤛",
                    late: "⪭",
                    lates: "⪭︀",
                    lbarr: "⤌",
                    lBarr: "⤎",
                    lbbrk: "❲",
                    lbrace: "{",
                    lbrack: "[",
                    lbrke: "⦋",
                    lbrksld: "⦏",
                    lbrkslu: "⦍",
                    lcaron: "ľ",
                    Lcaron: "Ľ",
                    lcedil: "ļ",
                    Lcedil: "Ļ",
                    lceil: "⌈",
                    lcub: "{",
                    lcy: "л",
                    Lcy: "Л",
                    ldca: "⤶",
                    ldquo: "“",
                    ldquor: "„",
                    ldrdhar: "⥧",
                    ldrushar: "⥋",
                    ldsh: "↲",
                    le: "≤",
                    lE: "≦",
                    LeftAngleBracket: "⟨",
                    leftarrow: "←",
                    Leftarrow: "⇐",
                    LeftArrow: "←",
                    LeftArrowBar: "⇤",
                    LeftArrowRightArrow: "⇆",
                    leftarrowtail: "↢",
                    LeftCeiling: "⌈",
                    LeftDoubleBracket: "⟦",
                    LeftDownTeeVector: "⥡",
                    LeftDownVector: "⇃",
                    LeftDownVectorBar: "⥙",
                    LeftFloor: "⌊",
                    leftharpoondown: "↽",
                    leftharpoonup: "↼",
                    leftleftarrows: "⇇",
                    leftrightarrow: "↔",
                    Leftrightarrow: "⇔",
                    LeftRightArrow: "↔",
                    leftrightarrows: "⇆",
                    leftrightharpoons: "⇋",
                    leftrightsquigarrow: "↭",
                    LeftRightVector: "⥎",
                    LeftTee: "⊣",
                    LeftTeeArrow: "↤",
                    LeftTeeVector: "⥚",
                    leftthreetimes: "⋋",
                    LeftTriangle: "⊲",
                    LeftTriangleBar: "⧏",
                    LeftTriangleEqual: "⊴",
                    LeftUpDownVector: "⥑",
                    LeftUpTeeVector: "⥠",
                    LeftUpVector: "↿",
                    LeftUpVectorBar: "⥘",
                    LeftVector: "↼",
                    LeftVectorBar: "⥒",
                    leg: "⋚",
                    lEg: "⪋",
                    leq: "≤",
                    leqq: "≦",
                    leqslant: "⩽",
                    les: "⩽",
                    lescc: "⪨",
                    lesdot: "⩿",
                    lesdoto: "⪁",
                    lesdotor: "⪃",
                    lesg: "⋚︀",
                    lesges: "⪓",
                    lessapprox: "⪅",
                    lessdot: "⋖",
                    lesseqgtr: "⋚",
                    lesseqqgtr: "⪋",
                    LessEqualGreater: "⋚",
                    LessFullEqual: "≦",
                    LessGreater: "≶",
                    lessgtr: "≶",
                    LessLess: "⪡",
                    lesssim: "≲",
                    LessSlantEqual: "⩽",
                    LessTilde: "≲",
                    lfisht: "⥼",
                    lfloor: "⌊",
                    lfr: "𝔩",
                    Lfr: "𝔏",
                    lg: "≶",
                    lgE: "⪑",
                    lHar: "⥢",
                    lhard: "↽",
                    lharu: "↼",
                    lharul: "⥪",
                    lhblk: "▄",
                    ljcy: "љ",
                    LJcy: "Љ",
                    ll: "≪",
                    Ll: "⋘",
                    llarr: "⇇",
                    llcorner: "⌞",
                    Lleftarrow: "⇚",
                    llhard: "⥫",
                    lltri: "◺",
                    lmidot: "ŀ",
                    Lmidot: "Ŀ",
                    lmoust: "⎰",
                    lmoustache: "⎰",
                    lnap: "⪉",
                    lnapprox: "⪉",
                    lne: "⪇",
                    lnE: "≨",
                    lneq: "⪇",
                    lneqq: "≨",
                    lnsim: "⋦",
                    loang: "⟬",
                    loarr: "⇽",
                    lobrk: "⟦",
                    longleftarrow: "⟵",
                    Longleftarrow: "⟸",
                    LongLeftArrow: "⟵",
                    longleftrightarrow: "⟷",
                    Longleftrightarrow: "⟺",
                    LongLeftRightArrow: "⟷",
                    longmapsto: "⟼",
                    longrightarrow: "⟶",
                    Longrightarrow: "⟹",
                    LongRightArrow: "⟶",
                    looparrowleft: "↫",
                    looparrowright: "↬",
                    lopar: "⦅",
                    lopf: "𝕝",
                    Lopf: "𝕃",
                    loplus: "⨭",
                    lotimes: "⨴",
                    lowast: "∗",
                    lowbar: "_",
                    LowerLeftArrow: "↙",
                    LowerRightArrow: "↘",
                    loz: "◊",
                    lozenge: "◊",
                    lozf: "⧫",
                    lpar: "(",
                    lparlt: "⦓",
                    lrarr: "⇆",
                    lrcorner: "⌟",
                    lrhar: "⇋",
                    lrhard: "⥭",
                    lrm: "‎",
                    lrtri: "⊿",
                    lsaquo: "‹",
                    lscr: "𝓁",
                    Lscr: "ℒ",
                    lsh: "↰",
                    Lsh: "↰",
                    lsim: "≲",
                    lsime: "⪍",
                    lsimg: "⪏",
                    lsqb: "[",
                    lsquo: "‘",
                    lsquor: "‚",
                    lstrok: "ł",
                    Lstrok: "Ł",
                    lt: "<",
                    Lt: "≪",
                    LT: "<",
                    ltcc: "⪦",
                    ltcir: "⩹",
                    ltdot: "⋖",
                    lthree: "⋋",
                    ltimes: "⋉",
                    ltlarr: "⥶",
                    ltquest: "⩻",
                    ltri: "◃",
                    ltrie: "⊴",
                    ltrif: "◂",
                    ltrPar: "⦖",
                    lurdshar: "⥊",
                    luruhar: "⥦",
                    lvertneqq: "≨︀",
                    lvnE: "≨︀",
                    macr: "¯",
                    male: "♂",
                    malt: "✠",
                    maltese: "✠",
                    map: "↦",
                    Map: "⤅",
                    mapsto: "↦",
                    mapstodown: "↧",
                    mapstoleft: "↤",
                    mapstoup: "↥",
                    marker: "▮",
                    mcomma: "⨩",
                    mcy: "м",
                    Mcy: "М",
                    mdash: "—",
                    mDDot: "∺",
                    measuredangle: "∡",
                    MediumSpace: " ",
                    Mellintrf: "ℳ",
                    mfr: "𝔪",
                    Mfr: "𝔐",
                    mho: "℧",
                    micro: "µ",
                    mid: "∣",
                    midast: "*",
                    midcir: "⫰",
                    middot: "·",
                    minus: "−",
                    minusb: "⊟",
                    minusd: "∸",
                    minusdu: "⨪",
                    MinusPlus: "∓",
                    mlcp: "⫛",
                    mldr: "…",
                    mnplus: "∓",
                    models: "⊧",
                    mopf: "𝕞",
                    Mopf: "𝕄",
                    mp: "∓",
                    mscr: "𝓂",
                    Mscr: "ℳ",
                    mstpos: "∾",
                    mu: "μ",
                    Mu: "Μ",
                    multimap: "⊸",
                    mumap: "⊸",
                    nabla: "∇",
                    nacute: "ń",
                    Nacute: "Ń",
                    nang: "∠⃒",
                    nap: "≉",
                    napE: "⩰̸",
                    napid: "≋̸",
                    napos: "ŉ",
                    napprox: "≉",
                    natur: "♮",
                    natural: "♮",
                    naturals: "ℕ",
                    nbsp: " ",
                    nbump: "≎̸",
                    nbumpe: "≏̸",
                    ncap: "⩃",
                    ncaron: "ň",
                    Ncaron: "Ň",
                    ncedil: "ņ",
                    Ncedil: "Ņ",
                    ncong: "≇",
                    ncongdot: "⩭̸",
                    ncup: "⩂",
                    ncy: "н",
                    Ncy: "Н",
                    ndash: "–",
                    ne: "≠",
                    nearhk: "⤤",
                    nearr: "↗",
                    neArr: "⇗",
                    nearrow: "↗",
                    nedot: "≐̸",
                    NegativeMediumSpace: "​",
                    NegativeThickSpace: "​",
                    NegativeThinSpace: "​",
                    NegativeVeryThinSpace: "​",
                    nequiv: "≢",
                    nesear: "⤨",
                    nesim: "≂̸",
                    NestedGreaterGreater: "≫",
                    NestedLessLess: "≪",
                    NewLine: "\n",
                    nexist: "∄",
                    nexists: "∄",
                    nfr: "𝔫",
                    Nfr: "𝔑",
                    nge: "≱",
                    ngE: "≧̸",
                    ngeq: "≱",
                    ngeqq: "≧̸",
                    ngeqslant: "⩾̸",
                    nges: "⩾̸",
                    nGg: "⋙̸",
                    ngsim: "≵",
                    ngt: "≯",
                    nGt: "≫⃒",
                    ngtr: "≯",
                    nGtv: "≫̸",
                    nharr: "↮",
                    nhArr: "⇎",
                    nhpar: "⫲",
                    ni: "∋",
                    nis: "⋼",
                    nisd: "⋺",
                    niv: "∋",
                    njcy: "њ",
                    NJcy: "Њ",
                    nlarr: "↚",
                    nlArr: "⇍",
                    nldr: "‥",
                    nle: "≰",
                    nlE: "≦̸",
                    nleftarrow: "↚",
                    nLeftarrow: "⇍",
                    nleftrightarrow: "↮",
                    nLeftrightarrow: "⇎",
                    nleq: "≰",
                    nleqq: "≦̸",
                    nleqslant: "⩽̸",
                    nles: "⩽̸",
                    nless: "≮",
                    nLl: "⋘̸",
                    nlsim: "≴",
                    nlt: "≮",
                    nLt: "≪⃒",
                    nltri: "⋪",
                    nltrie: "⋬",
                    nLtv: "≪̸",
                    nmid: "∤",
                    NoBreak: "⁠",
                    NonBreakingSpace: " ",
                    nopf: "𝕟",
                    Nopf: "ℕ",
                    not: "¬",
                    Not: "⫬",
                    NotCongruent: "≢",
                    NotCupCap: "≭",
                    NotDoubleVerticalBar: "∦",
                    NotElement: "∉",
                    NotEqual: "≠",
                    NotEqualTilde: "≂̸",
                    NotExists: "∄",
                    NotGreater: "≯",
                    NotGreaterEqual: "≱",
                    NotGreaterFullEqual: "≧̸",
                    NotGreaterGreater: "≫̸",
                    NotGreaterLess: "≹",
                    NotGreaterSlantEqual: "⩾̸",
                    NotGreaterTilde: "≵",
                    NotHumpDownHump: "≎̸",
                    NotHumpEqual: "≏̸",
                    notin: "∉",
                    notindot: "⋵̸",
                    notinE: "⋹̸",
                    notinva: "∉",
                    notinvb: "⋷",
                    notinvc: "⋶",
                    NotLeftTriangle: "⋪",
                    NotLeftTriangleBar: "⧏̸",
                    NotLeftTriangleEqual: "⋬",
                    NotLess: "≮",
                    NotLessEqual: "≰",
                    NotLessGreater: "≸",
                    NotLessLess: "≪̸",
                    NotLessSlantEqual: "⩽̸",
                    NotLessTilde: "≴",
                    NotNestedGreaterGreater: "⪢̸",
                    NotNestedLessLess: "⪡̸",
                    notni: "∌",
                    notniva: "∌",
                    notnivb: "⋾",
                    notnivc: "⋽",
                    NotPrecedes: "⊀",
                    NotPrecedesEqual: "⪯̸",
                    NotPrecedesSlantEqual: "⋠",
                    NotReverseElement: "∌",
                    NotRightTriangle: "⋫",
                    NotRightTriangleBar: "⧐̸",
                    NotRightTriangleEqual: "⋭",
                    NotSquareSubset: "⊏̸",
                    NotSquareSubsetEqual: "⋢",
                    NotSquareSuperset: "⊐̸",
                    NotSquareSupersetEqual: "⋣",
                    NotSubset: "⊂⃒",
                    NotSubsetEqual: "⊈",
                    NotSucceeds: "⊁",
                    NotSucceedsEqual: "⪰̸",
                    NotSucceedsSlantEqual: "⋡",
                    NotSucceedsTilde: "≿̸",
                    NotSuperset: "⊃⃒",
                    NotSupersetEqual: "⊉",
                    NotTilde: "≁",
                    NotTildeEqual: "≄",
                    NotTildeFullEqual: "≇",
                    NotTildeTilde: "≉",
                    NotVerticalBar: "∤",
                    npar: "∦",
                    nparallel: "∦",
                    nparsl: "⫽⃥",
                    npart: "∂̸",
                    npolint: "⨔",
                    npr: "⊀",
                    nprcue: "⋠",
                    npre: "⪯̸",
                    nprec: "⊀",
                    npreceq: "⪯̸",
                    nrarr: "↛",
                    nrArr: "⇏",
                    nrarrc: "⤳̸",
                    nrarrw: "↝̸",
                    nrightarrow: "↛",
                    nRightarrow: "⇏",
                    nrtri: "⋫",
                    nrtrie: "⋭",
                    nsc: "⊁",
                    nsccue: "⋡",
                    nsce: "⪰̸",
                    nscr: "𝓃",
                    Nscr: "𝒩",
                    nshortmid: "∤",
                    nshortparallel: "∦",
                    nsim: "≁",
                    nsime: "≄",
                    nsimeq: "≄",
                    nsmid: "∤",
                    nspar: "∦",
                    nsqsube: "⋢",
                    nsqsupe: "⋣",
                    nsub: "⊄",
                    nsube: "⊈",
                    nsubE: "⫅̸",
                    nsubset: "⊂⃒",
                    nsubseteq: "⊈",
                    nsubseteqq: "⫅̸",
                    nsucc: "⊁",
                    nsucceq: "⪰̸",
                    nsup: "⊅",
                    nsupe: "⊉",
                    nsupE: "⫆̸",
                    nsupset: "⊃⃒",
                    nsupseteq: "⊉",
                    nsupseteqq: "⫆̸",
                    ntgl: "≹",
                    ntilde: "ñ",
                    Ntilde: "Ñ",
                    ntlg: "≸",
                    ntriangleleft: "⋪",
                    ntrianglelefteq: "⋬",
                    ntriangleright: "⋫",
                    ntrianglerighteq: "⋭",
                    nu: "ν",
                    Nu: "Ν",
                    num: "#",
                    numero: "№",
                    numsp: " ",
                    nvap: "≍⃒",
                    nvdash: "⊬",
                    nvDash: "⊭",
                    nVdash: "⊮",
                    nVDash: "⊯",
                    nvge: "≥⃒",
                    nvgt: ">⃒",
                    nvHarr: "⤄",
                    nvinfin: "⧞",
                    nvlArr: "⤂",
                    nvle: "≤⃒",
                    nvlt: "<⃒",
                    nvltrie: "⊴⃒",
                    nvrArr: "⤃",
                    nvrtrie: "⊵⃒",
                    nvsim: "∼⃒",
                    nwarhk: "⤣",
                    nwarr: "↖",
                    nwArr: "⇖",
                    nwarrow: "↖",
                    nwnear: "⤧",
                    oacute: "ó",
                    Oacute: "Ó",
                    oast: "⊛",
                    ocir: "⊚",
                    ocirc: "ô",
                    Ocirc: "Ô",
                    ocy: "о",
                    Ocy: "О",
                    odash: "⊝",
                    odblac: "ő",
                    Odblac: "Ő",
                    odiv: "⨸",
                    odot: "⊙",
                    odsold: "⦼",
                    oelig: "œ",
                    OElig: "Œ",
                    ofcir: "⦿",
                    ofr: "𝔬",
                    Ofr: "𝔒",
                    ogon: "˛",
                    ograve: "ò",
                    Ograve: "Ò",
                    ogt: "⧁",
                    ohbar: "⦵",
                    ohm: "Ω",
                    oint: "∮",
                    olarr: "↺",
                    olcir: "⦾",
                    olcross: "⦻",
                    oline: "‾",
                    olt: "⧀",
                    omacr: "ō",
                    Omacr: "Ō",
                    omega: "ω",
                    Omega: "Ω",
                    omicron: "ο",
                    Omicron: "Ο",
                    omid: "⦶",
                    ominus: "⊖",
                    oopf: "𝕠",
                    Oopf: "𝕆",
                    opar: "⦷",
                    OpenCurlyDoubleQuote: "“",
                    OpenCurlyQuote: "‘",
                    operp: "⦹",
                    oplus: "⊕",
                    or: "∨",
                    Or: "⩔",
                    orarr: "↻",
                    ord: "⩝",
                    order: "ℴ",
                    orderof: "ℴ",
                    ordf: "ª",
                    ordm: "º",
                    origof: "⊶",
                    oror: "⩖",
                    orslope: "⩗",
                    orv: "⩛",
                    oS: "Ⓢ",
                    oscr: "ℴ",
                    Oscr: "𝒪",
                    oslash: "ø",
                    Oslash: "Ø",
                    osol: "⊘",
                    otilde: "õ",
                    Otilde: "Õ",
                    otimes: "⊗",
                    Otimes: "⨷",
                    otimesas: "⨶",
                    ouml: "ö",
                    Ouml: "Ö",
                    ovbar: "⌽",
                    OverBar: "‾",
                    OverBrace: "⏞",
                    OverBracket: "⎴",
                    OverParenthesis: "⏜",
                    par: "∥",
                    para: "¶",
                    parallel: "∥",
                    parsim: "⫳",
                    parsl: "⫽",
                    part: "∂",
                    PartialD: "∂",
                    pcy: "п",
                    Pcy: "П",
                    percnt: "%",
                    period: ".",
                    permil: "‰",
                    perp: "⊥",
                    pertenk: "‱",
                    pfr: "𝔭",
                    Pfr: "𝔓",
                    phi: "φ",
                    Phi: "Φ",
                    phiv: "ϕ",
                    phmmat: "ℳ",
                    phone: "☎",
                    pi: "π",
                    Pi: "Π",
                    pitchfork: "⋔",
                    piv: "ϖ",
                    planck: "ℏ",
                    planckh: "ℎ",
                    plankv: "ℏ",
                    plus: "+",
                    plusacir: "⨣",
                    plusb: "⊞",
                    pluscir: "⨢",
                    plusdo: "∔",
                    plusdu: "⨥",
                    pluse: "⩲",
                    PlusMinus: "±",
                    plusmn: "±",
                    plussim: "⨦",
                    plustwo: "⨧",
                    pm: "±",
                    Poincareplane: "ℌ",
                    pointint: "⨕",
                    popf: "𝕡",
                    Popf: "ℙ",
                    pound: "£",
                    pr: "≺",
                    Pr: "⪻",
                    prap: "⪷",
                    prcue: "≼",
                    pre: "⪯",
                    prE: "⪳",
                    prec: "≺",
                    precapprox: "⪷",
                    preccurlyeq: "≼",
                    Precedes: "≺",
                    PrecedesEqual: "⪯",
                    PrecedesSlantEqual: "≼",
                    PrecedesTilde: "≾",
                    preceq: "⪯",
                    precnapprox: "⪹",
                    precneqq: "⪵",
                    precnsim: "⋨",
                    precsim: "≾",
                    prime: "′",
                    Prime: "″",
                    primes: "ℙ",
                    prnap: "⪹",
                    prnE: "⪵",
                    prnsim: "⋨",
                    prod: "∏",
                    Product: "∏",
                    profalar: "⌮",
                    profline: "⌒",
                    profsurf: "⌓",
                    prop: "∝",
                    Proportion: "∷",
                    Proportional: "∝",
                    propto: "∝",
                    prsim: "≾",
                    prurel: "⊰",
                    pscr: "𝓅",
                    Pscr: "𝒫",
                    psi: "ψ",
                    Psi: "Ψ",
                    puncsp: " ",
                    qfr: "𝔮",
                    Qfr: "𝔔",
                    qint: "⨌",
                    qopf: "𝕢",
                    Qopf: "ℚ",
                    qprime: "⁗",
                    qscr: "𝓆",
                    Qscr: "𝒬",
                    quaternions: "ℍ",
                    quatint: "⨖",
                    quest: "?",
                    questeq: "≟",
                    quot: '"',
                    QUOT: '"',
                    rAarr: "⇛",
                    race: "∽̱",
                    racute: "ŕ",
                    Racute: "Ŕ",
                    radic: "√",
                    raemptyv: "⦳",
                    rang: "⟩",
                    Rang: "⟫",
                    rangd: "⦒",
                    range: "⦥",
                    rangle: "⟩",
                    raquo: "»",
                    rarr: "→",
                    rArr: "⇒",
                    Rarr: "↠",
                    rarrap: "⥵",
                    rarrb: "⇥",
                    rarrbfs: "⤠",
                    rarrc: "⤳",
                    rarrfs: "⤞",
                    rarrhk: "↪",
                    rarrlp: "↬",
                    rarrpl: "⥅",
                    rarrsim: "⥴",
                    rarrtl: "↣",
                    Rarrtl: "⤖",
                    rarrw: "↝",
                    ratail: "⤚",
                    rAtail: "⤜",
                    ratio: "∶",
                    rationals: "ℚ",
                    rbarr: "⤍",
                    rBarr: "⤏",
                    RBarr: "⤐",
                    rbbrk: "❳",
                    rbrace: "}",
                    rbrack: "]",
                    rbrke: "⦌",
                    rbrksld: "⦎",
                    rbrkslu: "⦐",
                    rcaron: "ř",
                    Rcaron: "Ř",
                    rcedil: "ŗ",
                    Rcedil: "Ŗ",
                    rceil: "⌉",
                    rcub: "}",
                    rcy: "р",
                    Rcy: "Р",
                    rdca: "⤷",
                    rdldhar: "⥩",
                    rdquo: "”",
                    rdquor: "”",
                    rdsh: "↳",
                    Re: "ℜ",
                    real: "ℜ",
                    realine: "ℛ",
                    realpart: "ℜ",
                    reals: "ℝ",
                    rect: "▭",
                    reg: "®",
                    REG: "®",
                    ReverseElement: "∋",
                    ReverseEquilibrium: "⇋",
                    ReverseUpEquilibrium: "⥯",
                    rfisht: "⥽",
                    rfloor: "⌋",
                    rfr: "𝔯",
                    Rfr: "ℜ",
                    rHar: "⥤",
                    rhard: "⇁",
                    rharu: "⇀",
                    rharul: "⥬",
                    rho: "ρ",
                    Rho: "Ρ",
                    rhov: "ϱ",
                    RightAngleBracket: "⟩",
                    rightarrow: "→",
                    Rightarrow: "⇒",
                    RightArrow: "→",
                    RightArrowBar: "⇥",
                    RightArrowLeftArrow: "⇄",
                    rightarrowtail: "↣",
                    RightCeiling: "⌉",
                    RightDoubleBracket: "⟧",
                    RightDownTeeVector: "⥝",
                    RightDownVector: "⇂",
                    RightDownVectorBar: "⥕",
                    RightFloor: "⌋",
                    rightharpoondown: "⇁",
                    rightharpoonup: "⇀",
                    rightleftarrows: "⇄",
                    rightleftharpoons: "⇌",
                    rightrightarrows: "⇉",
                    rightsquigarrow: "↝",
                    RightTee: "⊢",
                    RightTeeArrow: "↦",
                    RightTeeVector: "⥛",
                    rightthreetimes: "⋌",
                    RightTriangle: "⊳",
                    RightTriangleBar: "⧐",
                    RightTriangleEqual: "⊵",
                    RightUpDownVector: "⥏",
                    RightUpTeeVector: "⥜",
                    RightUpVector: "↾",
                    RightUpVectorBar: "⥔",
                    RightVector: "⇀",
                    RightVectorBar: "⥓",
                    ring: "˚",
                    risingdotseq: "≓",
                    rlarr: "⇄",
                    rlhar: "⇌",
                    rlm: "‏",
                    rmoust: "⎱",
                    rmoustache: "⎱",
                    rnmid: "⫮",
                    roang: "⟭",
                    roarr: "⇾",
                    robrk: "⟧",
                    ropar: "⦆",
                    ropf: "𝕣",
                    Ropf: "ℝ",
                    roplus: "⨮",
                    rotimes: "⨵",
                    RoundImplies: "⥰",
                    rpar: ")",
                    rpargt: "⦔",
                    rppolint: "⨒",
                    rrarr: "⇉",
                    Rrightarrow: "⇛",
                    rsaquo: "›",
                    rscr: "𝓇",
                    Rscr: "ℛ",
                    rsh: "↱",
                    Rsh: "↱",
                    rsqb: "]",
                    rsquo: "’",
                    rsquor: "’",
                    rthree: "⋌",
                    rtimes: "⋊",
                    rtri: "▹",
                    rtrie: "⊵",
                    rtrif: "▸",
                    rtriltri: "⧎",
                    RuleDelayed: "⧴",
                    ruluhar: "⥨",
                    rx: "℞",
                    sacute: "ś",
                    Sacute: "Ś",
                    sbquo: "‚",
                    sc: "≻",
                    Sc: "⪼",
                    scap: "⪸",
                    scaron: "š",
                    Scaron: "Š",
                    sccue: "≽",
                    sce: "⪰",
                    scE: "⪴",
                    scedil: "ş",
                    Scedil: "Ş",
                    scirc: "ŝ",
                    Scirc: "Ŝ",
                    scnap: "⪺",
                    scnE: "⪶",
                    scnsim: "⋩",
                    scpolint: "⨓",
                    scsim: "≿",
                    scy: "с",
                    Scy: "С",
                    sdot: "⋅",
                    sdotb: "⊡",
                    sdote: "⩦",
                    searhk: "⤥",
                    searr: "↘",
                    seArr: "⇘",
                    searrow: "↘",
                    sect: "§",
                    semi: ";",
                    seswar: "⤩",
                    setminus: "∖",
                    setmn: "∖",
                    sext: "✶",
                    sfr: "𝔰",
                    Sfr: "𝔖",
                    sfrown: "⌢",
                    sharp: "♯",
                    shchcy: "щ",
                    SHCHcy: "Щ",
                    shcy: "ш",
                    SHcy: "Ш",
                    ShortDownArrow: "↓",
                    ShortLeftArrow: "←",
                    shortmid: "∣",
                    shortparallel: "∥",
                    ShortRightArrow: "→",
                    ShortUpArrow: "↑",
                    shy: "­",
                    sigma: "σ",
                    Sigma: "Σ",
                    sigmaf: "ς",
                    sigmav: "ς",
                    sim: "∼",
                    simdot: "⩪",
                    sime: "≃",
                    simeq: "≃",
                    simg: "⪞",
                    simgE: "⪠",
                    siml: "⪝",
                    simlE: "⪟",
                    simne: "≆",
                    simplus: "⨤",
                    simrarr: "⥲",
                    slarr: "←",
                    SmallCircle: "∘",
                    smallsetminus: "∖",
                    smashp: "⨳",
                    smeparsl: "⧤",
                    smid: "∣",
                    smile: "⌣",
                    smt: "⪪",
                    smte: "⪬",
                    smtes: "⪬︀",
                    softcy: "ь",
                    SOFTcy: "Ь",
                    sol: "/",
                    solb: "⧄",
                    solbar: "⌿",
                    sopf: "𝕤",
                    Sopf: "𝕊",
                    spades: "♠",
                    spadesuit: "♠",
                    spar: "∥",
                    sqcap: "⊓",
                    sqcaps: "⊓︀",
                    sqcup: "⊔",
                    sqcups: "⊔︀",
                    Sqrt: "√",
                    sqsub: "⊏",
                    sqsube: "⊑",
                    sqsubset: "⊏",
                    sqsubseteq: "⊑",
                    sqsup: "⊐",
                    sqsupe: "⊒",
                    sqsupset: "⊐",
                    sqsupseteq: "⊒",
                    squ: "□",
                    square: "□",
                    Square: "□",
                    SquareIntersection: "⊓",
                    SquareSubset: "⊏",
                    SquareSubsetEqual: "⊑",
                    SquareSuperset: "⊐",
                    SquareSupersetEqual: "⊒",
                    SquareUnion: "⊔",
                    squarf: "▪",
                    squf: "▪",
                    srarr: "→",
                    sscr: "𝓈",
                    Sscr: "𝒮",
                    ssetmn: "∖",
                    ssmile: "⌣",
                    sstarf: "⋆",
                    star: "☆",
                    Star: "⋆",
                    starf: "★",
                    straightepsilon: "ϵ",
                    straightphi: "ϕ",
                    strns: "¯",
                    sub: "⊂",
                    Sub: "⋐",
                    subdot: "⪽",
                    sube: "⊆",
                    subE: "⫅",
                    subedot: "⫃",
                    submult: "⫁",
                    subne: "⊊",
                    subnE: "⫋",
                    subplus: "⪿",
                    subrarr: "⥹",
                    subset: "⊂",
                    Subset: "⋐",
                    subseteq: "⊆",
                    subseteqq: "⫅",
                    SubsetEqual: "⊆",
                    subsetneq: "⊊",
                    subsetneqq: "⫋",
                    subsim: "⫇",
                    subsub: "⫕",
                    subsup: "⫓",
                    succ: "≻",
                    succapprox: "⪸",
                    succcurlyeq: "≽",
                    Succeeds: "≻",
                    SucceedsEqual: "⪰",
                    SucceedsSlantEqual: "≽",
                    SucceedsTilde: "≿",
                    succeq: "⪰",
                    succnapprox: "⪺",
                    succneqq: "⪶",
                    succnsim: "⋩",
                    succsim: "≿",
                    SuchThat: "∋",
                    sum: "∑",
                    Sum: "∑",
                    sung: "♪",
                    sup: "⊃",
                    Sup: "⋑",
                    sup1: "¹",
                    sup2: "²",
                    sup3: "³",
                    supdot: "⪾",
                    supdsub: "⫘",
                    supe: "⊇",
                    supE: "⫆",
                    supedot: "⫄",
                    Superset: "⊃",
                    SupersetEqual: "⊇",
                    suphsol: "⟉",
                    suphsub: "⫗",
                    suplarr: "⥻",
                    supmult: "⫂",
                    supne: "⊋",
                    supnE: "⫌",
                    supplus: "⫀",
                    supset: "⊃",
                    Supset: "⋑",
                    supseteq: "⊇",
                    supseteqq: "⫆",
                    supsetneq: "⊋",
                    supsetneqq: "⫌",
                    supsim: "⫈",
                    supsub: "⫔",
                    supsup: "⫖",
                    swarhk: "⤦",
                    swarr: "↙",
                    swArr: "⇙",
                    swarrow: "↙",
                    swnwar: "⤪",
                    szlig: "ß",
                    Tab: "\t",
                    target: "⌖",
                    tau: "τ",
                    Tau: "Τ",
                    tbrk: "⎴",
                    tcaron: "ť",
                    Tcaron: "Ť",
                    tcedil: "ţ",
                    Tcedil: "Ţ",
                    tcy: "т",
                    Tcy: "Т",
                    tdot: "⃛",
                    telrec: "⌕",
                    tfr: "𝔱",
                    Tfr: "𝔗",
                    there4: "∴",
                    therefore: "∴",
                    Therefore: "∴",
                    theta: "θ",
                    Theta: "Θ",
                    thetasym: "ϑ",
                    thetav: "ϑ",
                    thickapprox: "≈",
                    thicksim: "∼",
                    ThickSpace: "  ",
                    thinsp: " ",
                    ThinSpace: " ",
                    thkap: "≈",
                    thksim: "∼",
                    thorn: "þ",
                    THORN: "Þ",
                    tilde: "˜",
                    Tilde: "∼",
                    TildeEqual: "≃",
                    TildeFullEqual: "≅",
                    TildeTilde: "≈",
                    times: "×",
                    timesb: "⊠",
                    timesbar: "⨱",
                    timesd: "⨰",
                    tint: "∭",
                    toea: "⤨",
                    top: "⊤",
                    topbot: "⌶",
                    topcir: "⫱",
                    topf: "𝕥",
                    Topf: "𝕋",
                    topfork: "⫚",
                    tosa: "⤩",
                    tprime: "‴",
                    trade: "™",
                    TRADE: "™",
                    triangle: "▵",
                    triangledown: "▿",
                    triangleleft: "◃",
                    trianglelefteq: "⊴",
                    triangleq: "≜",
                    triangleright: "▹",
                    trianglerighteq: "⊵",
                    tridot: "◬",
                    trie: "≜",
                    triminus: "⨺",
                    TripleDot: "⃛",
                    triplus: "⨹",
                    trisb: "⧍",
                    tritime: "⨻",
                    trpezium: "⏢",
                    tscr: "𝓉",
                    Tscr: "𝒯",
                    tscy: "ц",
                    TScy: "Ц",
                    tshcy: "ћ",
                    TSHcy: "Ћ",
                    tstrok: "ŧ",
                    Tstrok: "Ŧ",
                    twixt: "≬",
                    twoheadleftarrow: "↞",
                    twoheadrightarrow: "↠",
                    uacute: "ú",
                    Uacute: "Ú",
                    uarr: "↑",
                    uArr: "⇑",
                    Uarr: "↟",
                    Uarrocir: "⥉",
                    ubrcy: "ў",
                    Ubrcy: "Ў",
                    ubreve: "ŭ",
                    Ubreve: "Ŭ",
                    ucirc: "û",
                    Ucirc: "Û",
                    ucy: "у",
                    Ucy: "У",
                    udarr: "⇅",
                    udblac: "ű",
                    Udblac: "Ű",
                    udhar: "⥮",
                    ufisht: "⥾",
                    ufr: "𝔲",
                    Ufr: "𝔘",
                    ugrave: "ù",
                    Ugrave: "Ù",
                    uHar: "⥣",
                    uharl: "↿",
                    uharr: "↾",
                    uhblk: "▀",
                    ulcorn: "⌜",
                    ulcorner: "⌜",
                    ulcrop: "⌏",
                    ultri: "◸",
                    umacr: "ū",
                    Umacr: "Ū",
                    uml: "¨",
                    UnderBar: "_",
                    UnderBrace: "⏟",
                    UnderBracket: "⎵",
                    UnderParenthesis: "⏝",
                    Union: "⋃",
                    UnionPlus: "⊎",
                    uogon: "ų",
                    Uogon: "Ų",
                    uopf: "𝕦",
                    Uopf: "𝕌",
                    uparrow: "↑",
                    Uparrow: "⇑",
                    UpArrow: "↑",
                    UpArrowBar: "⤒",
                    UpArrowDownArrow: "⇅",
                    updownarrow: "↕",
                    Updownarrow: "⇕",
                    UpDownArrow: "↕",
                    UpEquilibrium: "⥮",
                    upharpoonleft: "↿",
                    upharpoonright: "↾",
                    uplus: "⊎",
                    UpperLeftArrow: "↖",
                    UpperRightArrow: "↗",
                    upsi: "υ",
                    Upsi: "ϒ",
                    upsih: "ϒ",
                    upsilon: "υ",
                    Upsilon: "Υ",
                    UpTee: "⊥",
                    UpTeeArrow: "↥",
                    upuparrows: "⇈",
                    urcorn: "⌝",
                    urcorner: "⌝",
                    urcrop: "⌎",
                    uring: "ů",
                    Uring: "Ů",
                    urtri: "◹",
                    uscr: "𝓊",
                    Uscr: "𝒰",
                    utdot: "⋰",
                    utilde: "ũ",
                    Utilde: "Ũ",
                    utri: "▵",
                    utrif: "▴",
                    uuarr: "⇈",
                    uuml: "ü",
                    Uuml: "Ü",
                    uwangle: "⦧",
                    vangrt: "⦜",
                    varepsilon: "ϵ",
                    varkappa: "ϰ",
                    varnothing: "∅",
                    varphi: "ϕ",
                    varpi: "ϖ",
                    varpropto: "∝",
                    varr: "↕",
                    vArr: "⇕",
                    varrho: "ϱ",
                    varsigma: "ς",
                    varsubsetneq: "⊊︀",
                    varsubsetneqq: "⫋︀",
                    varsupsetneq: "⊋︀",
                    varsupsetneqq: "⫌︀",
                    vartheta: "ϑ",
                    vartriangleleft: "⊲",
                    vartriangleright: "⊳",
                    vBar: "⫨",
                    Vbar: "⫫",
                    vBarv: "⫩",
                    vcy: "в",
                    Vcy: "В",
                    vdash: "⊢",
                    vDash: "⊨",
                    Vdash: "⊩",
                    VDash: "⊫",
                    Vdashl: "⫦",
                    vee: "∨",
                    Vee: "⋁",
                    veebar: "⊻",
                    veeeq: "≚",
                    vellip: "⋮",
                    verbar: "|",
                    Verbar: "‖",
                    vert: "|",
                    Vert: "‖",
                    VerticalBar: "∣",
                    VerticalLine: "|",
                    VerticalSeparator: "❘",
                    VerticalTilde: "≀",
                    VeryThinSpace: " ",
                    vfr: "𝔳",
                    Vfr: "𝔙",
                    vltri: "⊲",
                    vnsub: "⊂⃒",
                    vnsup: "⊃⃒",
                    vopf: "𝕧",
                    Vopf: "𝕍",
                    vprop: "∝",
                    vrtri: "⊳",
                    vscr: "𝓋",
                    Vscr: "𝒱",
                    vsubne: "⊊︀",
                    vsubnE: "⫋︀",
                    vsupne: "⊋︀",
                    vsupnE: "⫌︀",
                    Vvdash: "⊪",
                    vzigzag: "⦚",
                    wcirc: "ŵ",
                    Wcirc: "Ŵ",
                    wedbar: "⩟",
                    wedge: "∧",
                    Wedge: "⋀",
                    wedgeq: "≙",
                    weierp: "℘",
                    wfr: "𝔴",
                    Wfr: "𝔚",
                    wopf: "𝕨",
                    Wopf: "𝕎",
                    wp: "℘",
                    wr: "≀",
                    wreath: "≀",
                    wscr: "𝓌",
                    Wscr: "𝒲",
                    xcap: "⋂",
                    xcirc: "◯",
                    xcup: "⋃",
                    xdtri: "▽",
                    xfr: "𝔵",
                    Xfr: "𝔛",
                    xharr: "⟷",
                    xhArr: "⟺",
                    xi: "ξ",
                    Xi: "Ξ",
                    xlarr: "⟵",
                    xlArr: "⟸",
                    xmap: "⟼",
                    xnis: "⋻",
                    xodot: "⨀",
                    xopf: "𝕩",
                    Xopf: "𝕏",
                    xoplus: "⨁",
                    xotime: "⨂",
                    xrarr: "⟶",
                    xrArr: "⟹",
                    xscr: "𝓍",
                    Xscr: "𝒳",
                    xsqcup: "⨆",
                    xuplus: "⨄",
                    xutri: "△",
                    xvee: "⋁",
                    xwedge: "⋀",
                    yacute: "ý",
                    Yacute: "Ý",
                    yacy: "я",
                    YAcy: "Я",
                    ycirc: "ŷ",
                    Ycirc: "Ŷ",
                    ycy: "ы",
                    Ycy: "Ы",
                    yen: "¥",
                    yfr: "𝔶",
                    Yfr: "𝔜",
                    yicy: "ї",
                    YIcy: "Ї",
                    yopf: "𝕪",
                    Yopf: "𝕐",
                    yscr: "𝓎",
                    Yscr: "𝒴",
                    yucy: "ю",
                    YUcy: "Ю",
                    yuml: "ÿ",
                    Yuml: "Ÿ",
                    zacute: "ź",
                    Zacute: "Ź",
                    zcaron: "ž",
                    Zcaron: "Ž",
                    zcy: "з",
                    Zcy: "З",
                    zdot: "ż",
                    Zdot: "Ż",
                    zeetrf: "ℨ",
                    ZeroWidthSpace: "​",
                    zeta: "ζ",
                    Zeta: "Ζ",
                    zfr: "𝔷",
                    Zfr: "ℨ",
                    zhcy: "ж",
                    ZHcy: "Ж",
                    zigrarr: "⇝",
                    zopf: "𝕫",
                    Zopf: "ℤ",
                    zscr: "𝓏",
                    Zscr: "𝒵",
                    zwj: "‍",
                    zwnj: "‌"
                },
                decodeMapLegacy = {
                    aacute: "á",
                    Aacute: "Á",
                    acirc: "â",
                    Acirc: "Â",
                    acute: "´",
                    aelig: "æ",
                    AElig: "Æ",
                    agrave: "à",
                    Agrave: "À",
                    amp: "&",
                    AMP: "&",
                    aring: "å",
                    Aring: "Å",
                    atilde: "ã",
                    Atilde: "Ã",
                    auml: "ä",
                    Auml: "Ä",
                    brvbar: "¦",
                    ccedil: "ç",
                    Ccedil: "Ç",
                    cedil: "¸",
                    cent: "¢",
                    copy: "©",
                    COPY: "©",
                    curren: "¤",
                    deg: "°",
                    divide: "÷",
                    eacute: "é",
                    Eacute: "É",
                    ecirc: "ê",
                    Ecirc: "Ê",
                    egrave: "è",
                    Egrave: "È",
                    eth: "ð",
                    ETH: "Ð",
                    euml: "ë",
                    Euml: "Ë",
                    frac12: "½",
                    frac14: "¼",
                    frac34: "¾",
                    gt: ">",
                    GT: ">",
                    iacute: "í",
                    Iacute: "Í",
                    icirc: "î",
                    Icirc: "Î",
                    iexcl: "¡",
                    igrave: "ì",
                    Igrave: "Ì",
                    iquest: "¿",
                    iuml: "ï",
                    Iuml: "Ï",
                    laquo: "«",
                    lt: "<",
                    LT: "<",
                    macr: "¯",
                    micro: "µ",
                    middot: "·",
                    nbsp: " ",
                    not: "¬",
                    ntilde: "ñ",
                    Ntilde: "Ñ",
                    oacute: "ó",
                    Oacute: "Ó",
                    ocirc: "ô",
                    Ocirc: "Ô",
                    ograve: "ò",
                    Ograve: "Ò",
                    ordf: "ª",
                    ordm: "º",
                    oslash: "ø",
                    Oslash: "Ø",
                    otilde: "õ",
                    Otilde: "Õ",
                    ouml: "ö",
                    Ouml: "Ö",
                    para: "¶",
                    plusmn: "±",
                    pound: "£",
                    quot: '"',
                    QUOT: '"',
                    raquo: "»",
                    reg: "®",
                    REG: "®",
                    sect: "§",
                    shy: "­",
                    sup1: "¹",
                    sup2: "²",
                    sup3: "³",
                    szlig: "ß",
                    thorn: "þ",
                    THORN: "Þ",
                    times: "×",
                    uacute: "ú",
                    Uacute: "Ú",
                    ucirc: "û",
                    Ucirc: "Û",
                    ugrave: "ù",
                    Ugrave: "Ù",
                    uml: "¨",
                    uuml: "ü",
                    Uuml: "Ü",
                    yacute: "ý",
                    Yacute: "Ý",
                    yen: "¥",
                    yuml: "ÿ"
                },
                decodeMapNumeric = {
                    0: "�",
                    128: "€",
                    130: "‚",
                    131: "ƒ",
                    132: "„",
                    133: "…",
                    134: "†",
                    135: "‡",
                    136: "ˆ",
                    137: "‰",
                    138: "Š",
                    139: "‹",
                    140: "Œ",
                    142: "Ž",
                    145: "‘",
                    146: "’",
                    147: "“",
                    148: "”",
                    149: "•",
                    150: "–",
                    151: "—",
                    152: "˜",
                    153: "™",
                    154: "š",
                    155: "›",
                    156: "œ",
                    158: "ž",
                    159: "Ÿ"
                },
                invalidReferenceCodePoints = [1, 2, 3, 4, 5, 6, 7, 8, 11, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 64976, 64977, 64978, 64979, 64980, 64981, 64982, 64983, 64984, 64985, 64986, 64987, 64988, 64989, 64990, 64991, 64992, 64993, 64994, 64995, 64996, 64997, 64998, 64999, 65e3, 65001, 65002, 65003, 65004, 65005, 65006, 65007, 65534, 65535, 131070, 131071, 196606, 196607, 262142, 262143, 327678, 327679, 393214, 393215, 458750, 458751, 524286, 524287, 589822, 589823, 655358, 655359, 720894, 720895, 786430, 786431, 851966, 851967, 917502, 917503, 983038, 983039, 1048574, 1048575, 1114110, 1114111],
                stringFromCharCode = String.fromCharCode,
                hasOwnProperty = {}.hasOwnProperty,
                has = function(object, propertyName) {
                    return hasOwnProperty.call(object, propertyName)
                },
                merge = function(options, defaults) {
                    if (!options) return defaults;
                    var key, result = {};
                    for (key in defaults) result[key] = has(options, key) ? options[key] : defaults[key];
                    return result
                },
                codePointToSymbol = function(codePoint, strict) {
                    var output = "";
                    return codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111 ? (strict && parseError("character reference outside the permissible Unicode range"), "�") : has(decodeMapNumeric, codePoint) ? (strict && parseError("disallowed character reference"), decodeMapNumeric[codePoint]) : (strict && function(array, value) {
                        for (var index = -1, length = array.length; ++index < length;)
                            if (array[index] == value) return !0;
                        return !1
                    }(invalidReferenceCodePoints, codePoint) && parseError("disallowed character reference"), codePoint > 65535 && (output += stringFromCharCode((codePoint -= 65536) >>> 10 & 1023 | 55296), codePoint = 56320 | 1023 & codePoint), output += stringFromCharCode(codePoint))
                },
                hexEscape = function(codePoint) {
                    return "&#x" + codePoint.toString(16).toUpperCase() + ";"
                },
                decEscape = function(codePoint) {
                    return "&#" + codePoint + ";"
                },
                parseError = function(message) {
                    throw Error("Parse error: " + message)
                },
                encode = function(string, options) {
                    (options = merge(options, encode.options)).strict && regexInvalidRawCodePoint.test(string) && parseError("forbidden code point");
                    var encodeEverything = options.encodeEverything,
                        useNamedReferences = options.useNamedReferences,
                        allowUnsafeSymbols = options.allowUnsafeSymbols,
                        escapeCodePoint = options.decimal ? decEscape : hexEscape,
                        escapeBmpSymbol = function(symbol) {
                            return escapeCodePoint(symbol.charCodeAt(0))
                        };
                    return encodeEverything ? (string = string.replace(regexAsciiWhitelist, (function(symbol) {
                        return useNamedReferences && has(encodeMap, symbol) ? "&" + encodeMap[symbol] + ";" : escapeBmpSymbol(symbol)
                    })), useNamedReferences && (string = string.replace(/&gt;\u20D2/g, "&nvgt;").replace(/&lt;\u20D2/g, "&nvlt;").replace(/&#x66;&#x6A;/g, "&fjlig;")), useNamedReferences && (string = string.replace(regexEncodeNonAscii, (function(string) {
                        return "&" + encodeMap[string] + ";"
                    })))) : useNamedReferences ? (allowUnsafeSymbols || (string = string.replace(regexEscape, (function(string) {
                        return "&" + encodeMap[string] + ";"
                    }))), string = (string = string.replace(/&gt;\u20D2/g, "&nvgt;").replace(/&lt;\u20D2/g, "&nvlt;")).replace(regexEncodeNonAscii, (function(string) {
                        return "&" + encodeMap[string] + ";"
                    }))) : allowUnsafeSymbols || (string = string.replace(regexEscape, escapeBmpSymbol)), string.replace(regexAstralSymbols, (function($0) {
                        var high = $0.charCodeAt(0),
                            low = $0.charCodeAt(1);
                        return escapeCodePoint(1024 * (high - 55296) + low - 56320 + 65536)
                    })).replace(regexBmpWhitelist, escapeBmpSymbol)
                };
            encode.options = {
                allowUnsafeSymbols: !1,
                encodeEverything: !1,
                strict: !1,
                useNamedReferences: !1,
                decimal: !1
            };
            var decode = function(html, options) {
                var strict = (options = merge(options, decode.options)).strict;
                return strict && regexInvalidEntity.test(html) && parseError("malformed character reference"), html.replace(regexDecode, (function($0, $1, $2, $3, $4, $5, $6, $7, $8) {
                    var codePoint, semicolon, decDigits, hexDigits, reference, next;
                    return $1 ? decodeMap[reference = $1] : $2 ? (reference = $2, (next = $3) && options.isAttributeValue ? (strict && "=" == next && parseError("`&` did not start a character reference"), $0) : (strict && parseError("named character reference was not terminated by a semicolon"), decodeMapLegacy[reference] + (next || ""))) : $4 ? (decDigits = $4, semicolon = $5, strict && !semicolon && parseError("character reference was not terminated by a semicolon"), codePoint = parseInt(decDigits, 10), codePointToSymbol(codePoint, strict)) : $6 ? (hexDigits = $6, semicolon = $7, strict && !semicolon && parseError("character reference was not terminated by a semicolon"), codePoint = parseInt(hexDigits, 16), codePointToSymbol(codePoint, strict)) : (strict && parseError("named character reference was not terminated by a semicolon"), $0)
                }))
            };
            decode.options = {
                isAttributeValue: !1,
                strict: !1
            };
            var he = {
                version: "1.2.0",
                encode: encode,
                decode: decode,
                escape: function(string) {
                    return string.replace(regexEscape, (function($0) {
                        return escapeMap[$0]
                    }))
                },
                unescape: decode
            };
            void 0 === (__WEBPACK_AMD_DEFINE_RESULT__ = function() {
                return he
            }.call(exports, __webpack_require__, exports, module)) || (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)
        }()
    }).call(this, __webpack_require__(104)(module), __webpack_require__(65))
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.r(__webpack_exports__)
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.r(__webpack_exports__)
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.r(__webpack_exports__)
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.r(__webpack_exports__), __webpack_require__.d(__webpack_exports__, "UIRouterUpgradeModule", (function() {
        return uirouter_angular_hybrid_UIRouterUpgradeModule
    })), __webpack_require__.d(__webpack_exports__, "UIViewNgUpgrade", (function() {
        return UIViewNgUpgrade
    })), __webpack_require__.d(__webpack_exports__, "getParentUIViewInject", (function() {
        return getParentUIViewInject
    })), __webpack_require__.d(__webpack_exports__, "getUIRouter", (function() {
        return getUIRouter
    })), __webpack_require__.d(__webpack_exports__, "objectFactory", (function() {
        return objectFactory
    })), __webpack_require__.d(__webpack_exports__, "uiRouterUpgradeFactory", (function() {
        return uiRouterUpgradeFactory
    })), __webpack_require__.d(__webpack_exports__, "upgradeModule", (function() {
        return uirouter_angular_hybrid_upgradeModule
    })), __webpack_require__.d(__webpack_exports__, "ɵ0", (function() {
        return uirouter_angular_hybrid_0
    }));
    var core = __webpack_require__(0),
        common = __webpack_require__(8);
    class platform_browser_GenericBrowserDomAdapter extends common.g {
        constructor() {
            super()
        }
        supportsDOMEvents() {
            return !0
        }
    }(() => {
        if (core.Ab.Node) core.Ab.Node.prototype.contains
    })();
    class platform_browser_BrowserDomAdapter extends platform_browser_GenericBrowserDomAdapter {
        static makeCurrent() {
            Object(common.k)(new platform_browser_BrowserDomAdapter)
        }
        getProperty(el, name) {
            return el[name]
        }
        log(error) {
            window.console && window.console.log && window.console.log(error)
        }
        logGroup(error) {
            window.console && window.console.group && window.console.group(error)
        }
        logGroupEnd() {
            window.console && window.console.groupEnd && window.console.groupEnd()
        }
        onAndCancel(el, evt, listener) {
            return el.addEventListener(evt, listener, !1), () => {
                el.removeEventListener(evt, listener, !1)
            }
        }
        dispatchEvent(el, evt) {
            el.dispatchEvent(evt)
        }
        remove(node) {
            return node.parentNode && node.parentNode.removeChild(node), node
        }
        getValue(el) {
            return el.value
        }
        createElement(tagName, doc) {
            return (doc = doc || this.getDefaultDocument()).createElement(tagName)
        }
        createHtmlDocument() {
            return document.implementation.createHTMLDocument("fakeTitle")
        }
        getDefaultDocument() {
            return document
        }
        isElementNode(node) {
            return node.nodeType === Node.ELEMENT_NODE
        }
        isShadowRoot(node) {
            return node instanceof DocumentFragment
        }
        getGlobalEventTarget(doc, target) {
            return "window" === target ? window : "document" === target ? doc : "body" === target ? doc.body : null
        }
        getHistory() {
            return window.history
        }
        getLocation() {
            return window.location
        }
        getBaseHref(doc) {
            const href = function() {
                if (!baseElement && (baseElement = document.querySelector("base"), !baseElement)) return null;
                return baseElement.getAttribute("href")
            }();
            return null == href ? null : function(url) {
                urlParsingNode || (urlParsingNode = document.createElement("a"));
                return urlParsingNode.setAttribute("href", url), "/" === urlParsingNode.pathname.charAt(0) ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
            }(href)
        }
        resetBaseElement() {
            baseElement = null
        }
        getUserAgent() {
            return window.navigator.userAgent
        }
        performanceNow() {
            return window.performance && window.performance.now ? window.performance.now() : (new Date).getTime()
        }
        supportsCookies() {
            return !0
        }
        getCookie(name) {
            return Object(common.j)(document.cookie, name)
        }
    }
    let urlParsingNode, baseElement = null;
    const TRANSITION_ID = new core.w("TRANSITION_ID");
    const SERVER_TRANSITION_PROVIDERS = [{
        provide: core.c,
        useFactory: function(transitionId, document, injector) {
            return () => {
                injector.get(core.d).donePromise.then((() => {
                    const dom = Object(common.i)();
                    Array.prototype.slice.apply(document.querySelectorAll("style[ng-transition]")).filter((el => el.getAttribute("ng-transition") === transitionId)).forEach((el => dom.remove(el)))
                }))
            }
        },
        deps: [TRANSITION_ID, common.b, core.x],
        multi: !0
    }];
    class platform_browser_BrowserGetTestability {
        static init() {
            Object(core.ib)(new platform_browser_BrowserGetTestability)
        }
        addToWindow(registry) {
            core.Ab.getAngularTestability = (elem, findInAncestors = !0) => {
                const testability = registry.findTestabilityInTree(elem, findInAncestors);
                if (null == testability) throw new Error("Could not find testability for element.");
                return testability
            }, core.Ab.getAllAngularTestabilities = () => registry.getAllTestabilities(), core.Ab.getAllAngularRootElements = () => registry.getAllRootElements();
            core.Ab.frameworkStabilizers || (core.Ab.frameworkStabilizers = []), core.Ab.frameworkStabilizers.push((callback => {
                const testabilities = core.Ab.getAllAngularTestabilities();
                let count = testabilities.length,
                    didWork = !1;
                const decrement = function(didWork_) {
                    didWork = didWork || didWork_, count--, 0 == count && callback(didWork)
                };
                testabilities.forEach((function(testability) {
                    testability.whenStable(decrement)
                }))
            }))
        }
        findTestabilityInTree(registry, elem, findInAncestors) {
            if (null == elem) return null;
            const t = registry.getTestability(elem);
            return null != t ? t : findInAncestors ? Object(common.i)().isShadowRoot(elem) ? this.findTestabilityInTree(registry, elem.host, !0) : this.findTestabilityInTree(registry, elem.parentElement, !0) : null
        }
    }

    function exportNgVar(name, value) {
        if ("undefined" == typeof COMPILED || !COMPILED) {
            (core.Ab.ng = core.Ab.ng || {})[name] = value
        }
    }
    const CORE_TOKENS = {
        ApplicationRef: core.f,
        NgZone: core.H
    };

    function inspectNativeElementR2(element) {
        return Object(core.wb)(element)
    }
    const ELEMENT_PROBE_PROVIDERS = [{
            provide: core.c,
            useFactory: function(coreTokens) {
                return exportNgVar("probe", inspectNativeElementR2), exportNgVar("coreTokens", Object.assign(Object.assign({}, CORE_TOKENS), (coreTokens || []).reduce(((prev, t) => (prev[t.name] = t.token, prev)), {}))), () => inspectNativeElementR2
            },
            deps: [
                [core.G, new core.I]
            ],
            multi: !0
        }],
        EVENT_MANAGER_PLUGINS = new core.w("EventManagerPlugins");
    class EventManager {
        constructor(plugins, _zone) {
            this._zone = _zone, this._eventNameToPlugin = new Map, plugins.forEach((p => p.manager = this)), this._plugins = plugins.slice().reverse()
        }
        addEventListener(element, eventName, handler) {
            return this._findPluginFor(eventName).addEventListener(element, eventName, handler)
        }
        addGlobalEventListener(target, eventName, handler) {
            return this._findPluginFor(eventName).addGlobalEventListener(target, eventName, handler)
        }
        getZone() {
            return this._zone
        }
        _findPluginFor(eventName) {
            const plugin = this._eventNameToPlugin.get(eventName);
            if (plugin) return plugin;
            const plugins = this._plugins;
            for (let i = 0; i < plugins.length; i++) {
                const plugin = plugins[i];
                if (plugin.supports(eventName)) return this._eventNameToPlugin.set(eventName, plugin), plugin
            }
            throw new Error(`No event manager plugin found for event ${eventName}`)
        }
    }
    EventManager.decorators = [{
        type: core.v
    }], EventManager.ctorParameters = () => [{
        type: Array,
        decorators: [{
            type: core.u,
            args: [EVENT_MANAGER_PLUGINS]
        }]
    }, {
        type: core.H
    }];
    class platform_browser_EventManagerPlugin {
        constructor(_doc) {
            this._doc = _doc
        }
        addGlobalEventListener(element, eventName, handler) {
            const target = Object(common.i)().getGlobalEventTarget(this._doc, element);
            if (!target) throw new Error(`Unsupported event target ${target} for event ${eventName}`);
            return this.addEventListener(target, eventName, handler)
        }
    }
    class SharedStylesHost {
        constructor() {
            this._stylesSet = new Set
        }
        addStyles(styles) {
            const additions = new Set;
            styles.forEach((style => {
                this._stylesSet.has(style) || (this._stylesSet.add(style), additions.add(style))
            })), this.onStylesAdded(additions)
        }
        onStylesAdded(additions) {}
        getAllStyles() {
            return Array.from(this._stylesSet)
        }
    }
    SharedStylesHost.decorators = [{
        type: core.v
    }];
    class platform_browser_DomSharedStylesHost extends SharedStylesHost {
        constructor(_doc) {
            super(), this._doc = _doc, this._hostNodes = new Set, this._styleNodes = new Set, this._hostNodes.add(_doc.head)
        }
        _addStylesToHost(styles, host) {
            styles.forEach((style => {
                const styleEl = this._doc.createElement("style");
                styleEl.textContent = style, this._styleNodes.add(host.appendChild(styleEl))
            }))
        }
        addHost(hostNode) {
            this._addStylesToHost(this._stylesSet, hostNode), this._hostNodes.add(hostNode)
        }
        removeHost(hostNode) {
            this._hostNodes.delete(hostNode)
        }
        onStylesAdded(additions) {
            this._hostNodes.forEach((hostNode => this._addStylesToHost(additions, hostNode)))
        }
        ngOnDestroy() {
            this._styleNodes.forEach((styleNode => Object(common.i)().remove(styleNode)))
        }
    }
    platform_browser_DomSharedStylesHost.decorators = [{
        type: core.v
    }], platform_browser_DomSharedStylesHost.ctorParameters = () => [{
        type: void 0,
        decorators: [{
            type: core.u,
            args: [common.b]
        }]
    }];
    const NAMESPACE_URIS = {
            svg: "http://www.w3.org/2000/svg",
            xhtml: "http://www.w3.org/1999/xhtml",
            xlink: "http://www.w3.org/1999/xlink",
            xml: "http://www.w3.org/XML/1998/namespace",
            xmlns: "http://www.w3.org/2000/xmlns/"
        },
        COMPONENT_REGEX = /%COMP%/g,
        NG_DEV_MODE = "undefined" == typeof ngDevMode || !!ngDevMode,
        HOST_ATTR = "_nghost-%COMP%",
        CONTENT_ATTR = "_ngcontent-%COMP%";

    function flattenStyles(compId, styles, target) {
        for (let i = 0; i < styles.length; i++) {
            let style = styles[i];
            Array.isArray(style) ? flattenStyles(compId, style, target) : (style = style.replace(COMPONENT_REGEX, compId), target.push(style))
        }
        return target
    }

    function decoratePreventDefault(eventHandler) {
        return event => {
            if ("__ngUnwrap__" === event) return eventHandler;
            !1 === eventHandler(event) && (event.preventDefault(), event.returnValue = !1)
        }
    }
    let hasLoggedNativeEncapsulationWarning = !1;
    class platform_browser_DomRendererFactory2 {
        constructor(eventManager, sharedStylesHost, appId) {
            this.eventManager = eventManager, this.sharedStylesHost = sharedStylesHost, this.appId = appId, this.rendererByCompId = new Map, this.defaultRenderer = new platform_browser_DefaultDomRenderer2(eventManager)
        }
        createRenderer(element, type) {
            if (!element || !type) return this.defaultRenderer;
            switch (type.encapsulation) {
                case core.db.Emulated:
                    {
                        let renderer = this.rendererByCompId.get(type.id);
                        return renderer || (renderer = new EmulatedEncapsulationDomRenderer2(this.eventManager, this.sharedStylesHost, type, this.appId), this.rendererByCompId.set(type.id, renderer)),
                        renderer.applyToHost(element),
                        renderer
                    }
                case 1:
                case core.db.ShadowDom:
                    return "undefined" != typeof ngDevMode && !ngDevMode || hasLoggedNativeEncapsulationWarning || 1 !== type.encapsulation || (hasLoggedNativeEncapsulationWarning = !0, console.warn("ViewEncapsulation.Native is no longer supported. Falling back to ViewEncapsulation.ShadowDom. The fallback will be removed in v12.")), new ShadowDomRenderer(this.eventManager, this.sharedStylesHost, element, type);
                default:
                    if (!this.rendererByCompId.has(type.id)) {
                        const styles = flattenStyles(type.id, type.styles, []);
                        this.sharedStylesHost.addStyles(styles), this.rendererByCompId.set(type.id, this.defaultRenderer)
                    }
                    return this.defaultRenderer
            }
        }
        begin() {}
        end() {}
    }
    platform_browser_DomRendererFactory2.decorators = [{
        type: core.v
    }], platform_browser_DomRendererFactory2.ctorParameters = () => [{
        type: EventManager
    }, {
        type: platform_browser_DomSharedStylesHost
    }, {
        type: String,
        decorators: [{
            type: core.u,
            args: [core.b]
        }]
    }];
    class platform_browser_DefaultDomRenderer2 {
        constructor(eventManager) {
            this.eventManager = eventManager, this.data = Object.create(null)
        }
        destroy() {}
        createElement(name, namespace) {
            return namespace ? document.createElementNS(NAMESPACE_URIS[namespace] || namespace, name) : document.createElement(name)
        }
        createComment(value) {
            return document.createComment(value)
        }
        createText(value) {
            return document.createTextNode(value)
        }
        appendChild(parent, newChild) {
            parent.appendChild(newChild)
        }
        insertBefore(parent, newChild, refChild) {
            parent && parent.insertBefore(newChild, refChild)
        }
        removeChild(parent, oldChild) {
            parent && parent.removeChild(oldChild)
        }
        selectRootElement(selectorOrNode, preserveContent) {
            let el = "string" == typeof selectorOrNode ? document.querySelector(selectorOrNode) : selectorOrNode;
            if (!el) throw new Error(`The selector "${selectorOrNode}" did not match any elements`);
            return preserveContent || (el.textContent = ""), el
        }
        parentNode(node) {
            return node.parentNode
        }
        nextSibling(node) {
            return node.nextSibling
        }
        setAttribute(el, name, value, namespace) {
            if (namespace) {
                name = namespace + ":" + name;
                const namespaceUri = NAMESPACE_URIS[namespace];
                namespaceUri ? el.setAttributeNS(namespaceUri, name, value) : el.setAttribute(name, value)
            } else el.setAttribute(name, value)
        }
        removeAttribute(el, name, namespace) {
            if (namespace) {
                const namespaceUri = NAMESPACE_URIS[namespace];
                namespaceUri ? el.removeAttributeNS(namespaceUri, name) : el.removeAttribute(`${namespace}:${name}`)
            } else el.removeAttribute(name)
        }
        addClass(el, name) {
            el.classList.add(name)
        }
        removeClass(el, name) {
            el.classList.remove(name)
        }
        setStyle(el, style, value, flags) {
            flags & (core.R.DashCase | core.R.Important) ? el.style.setProperty(style, value, flags & core.R.Important ? "important" : "") : el.style[style] = value
        }
        removeStyle(el, style, flags) {
            flags & core.R.DashCase ? el.style.removeProperty(style) : el.style[style] = ""
        }
        setProperty(el, name, value) {
            NG_DEV_MODE && checkNoSyntheticProp(name, "property"), el[name] = value
        }
        setValue(node, value) {
            node.nodeValue = value
        }
        listen(target, event, callback) {
            return NG_DEV_MODE && checkNoSyntheticProp(event, "listener"), "string" == typeof target ? this.eventManager.addGlobalEventListener(target, event, decoratePreventDefault(callback)) : this.eventManager.addEventListener(target, event, decoratePreventDefault(callback))
        }
    }
    const AT_CHARCODE = "@".charCodeAt(0);

    function checkNoSyntheticProp(name, nameKind) {
        if (name.charCodeAt(0) === AT_CHARCODE) throw new Error(`Found the synthetic ${nameKind} ${name}. Please include either "BrowserAnimationsModule" or "NoopAnimationsModule" in your application.`)
    }
    class EmulatedEncapsulationDomRenderer2 extends platform_browser_DefaultDomRenderer2 {
        constructor(eventManager, sharedStylesHost, component, appId) {
            super(eventManager), this.component = component;
            const styles = flattenStyles(appId + "-" + component.id, component.styles, []);
            var componentShortId;
            sharedStylesHost.addStyles(styles), this.contentAttr = (componentShortId = appId + "-" + component.id, CONTENT_ATTR.replace(COMPONENT_REGEX, componentShortId)), this.hostAttr = function(componentShortId) {
                return HOST_ATTR.replace(COMPONENT_REGEX, componentShortId)
            }(appId + "-" + component.id)
        }
        applyToHost(element) {
            super.setAttribute(element, this.hostAttr, "")
        }
        createElement(parent, name) {
            const el = super.createElement(parent, name);
            return super.setAttribute(el, this.contentAttr, ""), el
        }
    }
    class ShadowDomRenderer extends platform_browser_DefaultDomRenderer2 {
        constructor(eventManager, sharedStylesHost, hostEl, component) {
            super(eventManager), this.sharedStylesHost = sharedStylesHost, this.hostEl = hostEl, this.shadowRoot = hostEl.attachShadow({
                mode: "open"
            }), this.sharedStylesHost.addHost(this.shadowRoot);
            const styles = flattenStyles(component.id, component.styles, []);
            for (let i = 0; i < styles.length; i++) {
                const styleEl = document.createElement("style");
                styleEl.textContent = styles[i], this.shadowRoot.appendChild(styleEl)
            }
        }
        nodeOrShadowRoot(node) {
            return node === this.hostEl ? this.shadowRoot : node
        }
        destroy() {
            this.sharedStylesHost.removeHost(this.shadowRoot)
        }
        appendChild(parent, newChild) {
            return super.appendChild(this.nodeOrShadowRoot(parent), newChild)
        }
        insertBefore(parent, newChild, refChild) {
            return super.insertBefore(this.nodeOrShadowRoot(parent), newChild, refChild)
        }
        removeChild(parent, oldChild) {
            return super.removeChild(this.nodeOrShadowRoot(parent), oldChild)
        }
        parentNode(node) {
            return this.nodeOrShadowRoot(super.parentNode(this.nodeOrShadowRoot(node)))
        }
    }
    class DomEventsPlugin extends platform_browser_EventManagerPlugin {
        constructor(doc) {
            super(doc)
        }
        supports(eventName) {
            return !0
        }
        addEventListener(element, eventName, handler) {
            return element.addEventListener(eventName, handler, !1), () => this.removeEventListener(element, eventName, handler)
        }
        removeEventListener(target, eventName, callback) {
            return target.removeEventListener(eventName, callback)
        }
    }
    DomEventsPlugin.decorators = [{
        type: core.v
    }], DomEventsPlugin.ctorParameters = () => [{
        type: void 0,
        decorators: [{
            type: core.u,
            args: [common.b]
        }]
    }];
    const EVENT_NAMES = {
            pan: !0,
            panstart: !0,
            panmove: !0,
            panend: !0,
            pancancel: !0,
            panleft: !0,
            panright: !0,
            panup: !0,
            pandown: !0,
            pinch: !0,
            pinchstart: !0,
            pinchmove: !0,
            pinchend: !0,
            pinchcancel: !0,
            pinchin: !0,
            pinchout: !0,
            press: !0,
            pressup: !0,
            rotate: !0,
            rotatestart: !0,
            rotatemove: !0,
            rotateend: !0,
            rotatecancel: !0,
            swipe: !0,
            swipeleft: !0,
            swiperight: !0,
            swipeup: !0,
            swipedown: !0,
            tap: !0
        },
        HAMMER_GESTURE_CONFIG = new core.w("HammerGestureConfig"),
        HAMMER_LOADER = new core.w("HammerLoader");
    class HammerGestureConfig {
        constructor() {
            this.events = [], this.overrides = {}
        }
        buildHammer(element) {
            const mc = new Hammer(element, this.options);
            mc.get("pinch").set({
                enable: !0
            }), mc.get("rotate").set({
                enable: !0
            });
            for (const eventName in this.overrides) mc.get(eventName).set(this.overrides[eventName]);
            return mc
        }
    }
    HammerGestureConfig.decorators = [{
        type: core.v
    }];
    class HammerGesturesPlugin extends platform_browser_EventManagerPlugin {
        constructor(doc, _config, console, loader) {
            super(doc), this._config = _config, this.console = console, this.loader = loader
        }
        supports(eventName) {
            return !(!EVENT_NAMES.hasOwnProperty(eventName.toLowerCase()) && !this.isCustomEvent(eventName)) && (!(!window.Hammer && !this.loader) || (this.console.warn(`The "${eventName}" event cannot be bound because Hammer.JS is not loaded and no custom loader has been specified.`), !1))
        }
        addEventListener(element, eventName, handler) {
            const zone = this.manager.getZone();
            if (eventName = eventName.toLowerCase(), !window.Hammer && this.loader) {
                let cancelRegistration = !1,
                    deregister = () => {
                        cancelRegistration = !0
                    };
                return this.loader().then((() => {
                    if (!window.Hammer) return this.console.warn("The custom HAMMER_LOADER completed, but Hammer.JS is not present."), void(deregister = () => {});
                    cancelRegistration || (deregister = this.addEventListener(element, eventName, handler))
                })).catch((() => {
                    this.console.warn(`The "${eventName}" event cannot be bound because the custom Hammer.JS loader failed.`), deregister = () => {}
                })), () => {
                    deregister()
                }
            }
            return zone.runOutsideAngular((() => {
                const mc = this._config.buildHammer(element),
                    callback = function(eventObj) {
                        zone.runGuarded((function() {
                            handler(eventObj)
                        }))
                    };
                return mc.on(eventName, callback), () => {
                    mc.off(eventName, callback), "function" == typeof mc.destroy && mc.destroy()
                }
            }))
        }
        isCustomEvent(eventName) {
            return this._config.events.indexOf(eventName) > -1
        }
    }
    HammerGesturesPlugin.decorators = [{
        type: core.v
    }], HammerGesturesPlugin.ctorParameters = () => [{
        type: void 0,
        decorators: [{
            type: core.u,
            args: [common.b]
        }]
    }, {
        type: HammerGestureConfig,
        decorators: [{
            type: core.u,
            args: [HAMMER_GESTURE_CONFIG]
        }]
    }, {
        type: core.jb
    }, {
        type: void 0,
        decorators: [{
            type: core.I
        }, {
            type: core.u,
            args: [HAMMER_LOADER]
        }]
    }];
    const HAMMER_PROVIDERS__PRE_R3__ = [{
            provide: EVENT_MANAGER_PLUGINS,
            useClass: HammerGesturesPlugin,
            multi: !0,
            deps: [common.b, HAMMER_GESTURE_CONFIG, core.jb, [new core.I, HAMMER_LOADER]]
        }, {
            provide: HAMMER_GESTURE_CONFIG,
            useClass: HammerGestureConfig,
            deps: []
        }],
        HAMMER_PROVIDERS = HAMMER_PROVIDERS__PRE_R3__;
    core.C;
    const MODIFIER_KEYS = ["alt", "control", "meta", "shift"],
        _keyMap = {
            "\b": "Backspace",
            "\t": "Tab",
            "": "Delete",
            "": "Escape",
            Del: "Delete",
            Esc: "Escape",
            Left: "ArrowLeft",
            Right: "ArrowRight",
            Up: "ArrowUp",
            Down: "ArrowDown",
            Menu: "ContextMenu",
            Scroll: "ScrollLock",
            Win: "OS"
        },
        _chromeNumKeyPadMap = {
            A: "1",
            B: "2",
            C: "3",
            D: "4",
            E: "5",
            F: "6",
            G: "7",
            H: "8",
            I: "9",
            J: "*",
            K: "+",
            M: "-",
            N: ".",
            O: "/",
            "`": "0",
            "": "NumLock"
        },
        MODIFIER_KEY_GETTERS = {
            alt: event => event.altKey,
            control: event => event.ctrlKey,
            meta: event => event.metaKey,
            shift: event => event.shiftKey
        };
    class platform_browser_KeyEventsPlugin extends platform_browser_EventManagerPlugin {
        constructor(doc) {
            super(doc)
        }
        supports(eventName) {
            return null != platform_browser_KeyEventsPlugin.parseEventName(eventName)
        }
        addEventListener(element, eventName, handler) {
            const parsedEvent = platform_browser_KeyEventsPlugin.parseEventName(eventName),
                outsideHandler = platform_browser_KeyEventsPlugin.eventCallback(parsedEvent.fullKey, handler, this.manager.getZone());
            return this.manager.getZone().runOutsideAngular((() => Object(common.i)().onAndCancel(element, parsedEvent.domEventName, outsideHandler)))
        }
        static parseEventName(eventName) {
            const parts = eventName.toLowerCase().split("."),
                domEventName = parts.shift();
            if (0 === parts.length || "keydown" !== domEventName && "keyup" !== domEventName) return null;
            const key = platform_browser_KeyEventsPlugin._normalizeKey(parts.pop());
            let fullKey = "";
            if (MODIFIER_KEYS.forEach((modifierName => {
                    const index = parts.indexOf(modifierName);
                    index > -1 && (parts.splice(index, 1), fullKey += modifierName + ".")
                })), fullKey += key, 0 != parts.length || 0 === key.length) return null;
            const result = {};
            return result.domEventName = domEventName, result.fullKey = fullKey, result
        }
        static getEventFullKey(event) {
            let fullKey = "",
                key = function(event) {
                    let key = event.key;
                    if (null == key) {
                        if (key = event.keyIdentifier, null == key) return "Unidentified";
                        key.startsWith("U+") && (key = String.fromCharCode(parseInt(key.substring(2), 16)), 3 === event.location && _chromeNumKeyPadMap.hasOwnProperty(key) && (key = _chromeNumKeyPadMap[key]))
                    }
                    return _keyMap[key] || key
                }(event);
            return key = key.toLowerCase(), " " === key ? key = "space" : "." === key && (key = "dot"), MODIFIER_KEYS.forEach((modifierName => {
                if (modifierName != key) {
                    (0, MODIFIER_KEY_GETTERS[modifierName])(event) && (fullKey += modifierName + ".")
                }
            })), fullKey += key, fullKey
        }
        static eventCallback(fullKey, handler, zone) {
            return event => {
                platform_browser_KeyEventsPlugin.getEventFullKey(event) === fullKey && zone.runGuarded((() => handler(event)))
            }
        }
        static _normalizeKey(keyName) {
            switch (keyName) {
                case "esc":
                    return "escape";
                default:
                    return keyName
            }
        }
    }
    platform_browser_KeyEventsPlugin.decorators = [{
        type: core.v
    }], platform_browser_KeyEventsPlugin.ctorParameters = () => [{
        type: void 0,
        decorators: [{
            type: core.u,
            args: [common.b]
        }]
    }];
    class DomSanitizer {}

    function domSanitizerImplFactory(injector) {
        return new platform_browser_DomSanitizerImpl(injector.get(common.b))
    }
    DomSanitizer.ɵprov = Object(core.Ib)({
        factory: function() {
            return Object(core.Jb)(platform_browser_DomSanitizerImpl)
        },
        token: DomSanitizer,
        providedIn: "root"
    }), DomSanitizer.decorators = [{
        type: core.v,
        args: [{
            providedIn: "root",
            useExisting: Object(core.fb)((() => platform_browser_DomSanitizerImpl))
        }]
    }];
    class platform_browser_DomSanitizerImpl extends DomSanitizer {
        constructor(_doc) {
            super(), this._doc = _doc
        }
        sanitize(ctx, value) {
            if (null == value) return null;
            switch (ctx) {
                case core.T.NONE:
                    return value;
                case core.T.HTML:
                    return Object(core.pb)(value, "HTML") ? Object(core.Hb)(value) : Object(core.nb)(this._doc, String(value));
                case core.T.STYLE:
                    return Object(core.pb)(value, "Style") ? Object(core.Hb)(value) : value;
                case core.T.SCRIPT:
                    if (Object(core.pb)(value, "Script")) return Object(core.Hb)(value);
                    throw new Error("unsafe value used in a script context");
                case core.T.URL:
                    Object(core.zb)(value);
                    return Object(core.pb)(value, "URL") ? Object(core.Hb)(value) : Object(core.ob)(String(value));
                case core.T.RESOURCE_URL:
                    if (Object(core.pb)(value, "ResourceURL")) return Object(core.Hb)(value);
                    throw new Error("unsafe value used in a resource URL context (see https://g.co/ng/security#xss)");
                default:
                    throw new Error(`Unexpected SecurityContext ${ctx} (see https://g.co/ng/security#xss)`)
            }
        }
        bypassSecurityTrustHtml(value) {
            return Object(core.qb)(value)
        }
        bypassSecurityTrustStyle(value) {
            return Object(core.tb)(value)
        }
        bypassSecurityTrustScript(value) {
            return Object(core.sb)(value)
        }
        bypassSecurityTrustUrl(value) {
            return Object(core.ub)(value)
        }
        bypassSecurityTrustResourceUrl(value) {
            return Object(core.rb)(value)
        }
    }
    platform_browser_DomSanitizerImpl.ɵprov = Object(core.Ib)({
        factory: function() {
            return domSanitizerImplFactory(Object(core.Jb)(core.t))
        },
        token: platform_browser_DomSanitizerImpl,
        providedIn: "root"
    }), platform_browser_DomSanitizerImpl.decorators = [{
        type: core.v,
        args: [{
            providedIn: "root",
            useFactory: domSanitizerImplFactory,
            deps: [core.x]
        }]
    }], platform_browser_DomSanitizerImpl.ctorParameters = () => [{
        type: void 0,
        decorators: [{
            type: core.u,
            args: [common.b]
        }]
    }];
    const ɵ0$4 = common.h,
        INTERNAL_BROWSER_PLATFORM_PROVIDERS = [{
            provide: core.K,
            useValue: ɵ0$4
        }, {
            provide: core.L,
            useValue: function() {
                platform_browser_BrowserDomAdapter.makeCurrent(), platform_browser_BrowserGetTestability.init()
            },
            multi: !0
        }, {
            provide: common.b,
            useFactory: function() {
                return Object(core.Fb)(document), document
            },
            deps: []
        }],
        BROWSER_SANITIZATION_PROVIDERS = [{
            provide: core.S,
            useExisting: DomSanitizer
        }, {
            provide: DomSanitizer,
            useClass: platform_browser_DomSanitizerImpl,
            deps: [common.b]
        }],
        BROWSER_MODULE_PROVIDERS = (Object(core.eb)(core.hb, "browser", INTERNAL_BROWSER_PLATFORM_PROVIDERS), [BROWSER_SANITIZATION_PROVIDERS, {
            provide: core.kb,
            useValue: "root"
        }, {
            provide: core.p,
            useFactory: function() {
                return new core.p
            },
            deps: []
        }, {
            provide: EVENT_MANAGER_PLUGINS,
            useClass: DomEventsPlugin,
            multi: !0,
            deps: [common.b, core.H, core.K]
        }, {
            provide: EVENT_MANAGER_PLUGINS,
            useClass: platform_browser_KeyEventsPlugin,
            multi: !0,
            deps: [common.b]
        }, HAMMER_PROVIDERS, {
            provide: platform_browser_DomRendererFactory2,
            useClass: platform_browser_DomRendererFactory2,
            deps: [EventManager, platform_browser_DomSharedStylesHost, core.b]
        }, {
            provide: core.Q,
            useExisting: platform_browser_DomRendererFactory2
        }, {
            provide: SharedStylesHost,
            useExisting: platform_browser_DomSharedStylesHost
        }, {
            provide: platform_browser_DomSharedStylesHost,
            useClass: platform_browser_DomSharedStylesHost,
            deps: [common.b]
        }, {
            provide: core.Y,
            useClass: core.Y,
            deps: [core.H]
        }, {
            provide: EventManager,
            useClass: EventManager,
            deps: [EVENT_MANAGER_PLUGINS, core.H]
        }, ELEMENT_PROBE_PROVIDERS]);
    class platform_browser_BrowserModule {
        constructor(parentModule) {
            if (parentModule) throw new Error("BrowserModule has already been loaded. If you need access to common directives such as NgIf and NgFor from a lazy loaded module, import CommonModule instead.")
        }
        static withServerTransition(params) {
            return {
                ngModule: platform_browser_BrowserModule,
                providers: [{
                    provide: core.b,
                    useValue: params.appId
                }, {
                    provide: TRANSITION_ID,
                    useExisting: core.b
                }, SERVER_TRANSITION_PROVIDERS]
            }
        }
    }

    function createMeta() {
        return new platform_browser_Meta(Object(core.Jb)(common.b))
    }
    platform_browser_BrowserModule.decorators = [{
        type: core.C,
        args: [{
            providers: BROWSER_MODULE_PROVIDERS,
            exports: [common.a, core.e]
        }]
    }], platform_browser_BrowserModule.ctorParameters = () => [{
        type: platform_browser_BrowserModule,
        decorators: [{
            type: core.I
        }, {
            type: core.W
        }, {
            type: core.u,
            args: [platform_browser_BrowserModule]
        }]
    }];
    class platform_browser_Meta {
        constructor(_doc) {
            this._doc = _doc, this._dom = Object(common.i)()
        }
        addTag(tag, forceCreation = !1) {
            return tag ? this._getOrCreateElement(tag, forceCreation) : null
        }
        addTags(tags, forceCreation = !1) {
            return tags ? tags.reduce(((result, tag) => (tag && result.push(this._getOrCreateElement(tag, forceCreation)), result)), []) : []
        }
        getTag(attrSelector) {
            return attrSelector && this._doc.querySelector(`meta[${attrSelector}]`) || null
        }
        getTags(attrSelector) {
            if (!attrSelector) return [];
            const list = this._doc.querySelectorAll(`meta[${attrSelector}]`);
            return list ? [].slice.call(list) : []
        }
        updateTag(tag, selector) {
            if (!tag) return null;
            selector = selector || this._parseSelector(tag);
            const meta = this.getTag(selector);
            return meta ? this._setMetaElementAttributes(tag, meta) : this._getOrCreateElement(tag, !0)
        }
        removeTag(attrSelector) {
            this.removeTagElement(this.getTag(attrSelector))
        }
        removeTagElement(meta) {
            meta && this._dom.remove(meta)
        }
        _getOrCreateElement(meta, forceCreation = !1) {
            if (!forceCreation) {
                const selector = this._parseSelector(meta),
                    elem = this.getTag(selector);
                if (elem && this._containsAttributes(meta, elem)) return elem
            }
            const element = this._dom.createElement("meta");
            this._setMetaElementAttributes(meta, element);
            return this._doc.getElementsByTagName("head")[0].appendChild(element), element
        }
        _setMetaElementAttributes(tag, el) {
            return Object.keys(tag).forEach((prop => el.setAttribute(this._getMetaKeyMap(prop), tag[prop]))), el
        }
        _parseSelector(tag) {
            const attr = tag.name ? "name" : "property";
            return `${attr}="${tag[attr]}"`
        }
        _containsAttributes(tag, elem) {
            return Object.keys(tag).every((key => elem.getAttribute(this._getMetaKeyMap(key)) === tag[key]))
        }
        _getMetaKeyMap(prop) {
            return META_KEYS_MAP[prop] || prop
        }
    }
    platform_browser_Meta.ɵprov = Object(core.Ib)({
        factory: createMeta,
        token: platform_browser_Meta,
        providedIn: "root"
    }), platform_browser_Meta.decorators = [{
        type: core.v,
        args: [{
            providedIn: "root",
            useFactory: createMeta,
            deps: []
        }]
    }], platform_browser_Meta.ctorParameters = () => [{
        type: void 0,
        decorators: [{
            type: core.u,
            args: [common.b]
        }]
    }];
    const META_KEYS_MAP = {
        httpEquiv: "http-equiv"
    };

    function createTitle() {
        return new Title(Object(core.Jb)(common.b))
    }
    class Title {
        constructor(_doc) {
            this._doc = _doc
        }
        getTitle() {
            return this._doc.title
        }
        setTitle(newTitle) {
            this._doc.title = newTitle || ""
        }
    }
    Title.ɵprov = Object(core.Ib)({
        factory: createTitle,
        token: Title,
        providedIn: "root"
    }), Title.decorators = [{
        type: core.v,
        args: [{
            providedIn: "root",
            useFactory: createTitle,
            deps: []
        }]
    }], Title.ctorParameters = () => [{
        type: void 0,
        decorators: [{
            type: core.u,
            args: [common.b]
        }]
    }];
    "undefined" != typeof window && window;
    class TransferState {
        constructor() {
            this.store = {}, this.onSerializeCallbacks = {}
        }
        static init(initState) {
            const transferState = new TransferState;
            return transferState.store = initState, transferState
        }
        get(key, defaultValue) {
            return void 0 !== this.store[key] ? this.store[key] : defaultValue
        }
        set(key, value) {
            this.store[key] = value
        }
        remove(key) {
            delete this.store[key]
        }
        hasKey(key) {
            return this.store.hasOwnProperty(key)
        }
        onSerialize(key, callback) {
            this.onSerializeCallbacks[key] = callback
        }
        toJson() {
            for (const key in this.onSerializeCallbacks)
                if (this.onSerializeCallbacks.hasOwnProperty(key)) try {
                    this.store[key] = this.onSerializeCallbacks[key]()
                } catch (e) {
                    console.warn("Exception in onSerialize callback: ", e)
                }
            return JSON.stringify(this.store)
        }
    }
    TransferState.decorators = [{
        type: core.v
    }];
    core.C, common.b, core.b;
    new core.ab("11.0.5");

    function noNg() {
        throw new Error("AngularJS v1.x is not loaded!")
    }
    const noNgElement = () => noNg();
    noNgElement.cleanData = noNg;
    let angular = {
        bootstrap: noNg,
        module: noNg,
        element: noNgElement,
        injector: noNg,
        version: void 0,
        resumeBootstrap: noNg,
        getTestability: noNg
    };
    try {
        window.hasOwnProperty("angular") && (angular = window.angular)
    } catch (_a) {}

    function getAngularJSGlobal() {
        return angular
    }
    const module_ = (prefix, dependencies) => angular.module(prefix, dependencies),
        static_element = e => angular.element(e);
    static_element.cleanData = nodes => angular.element.cleanData(nodes);
    const INJECTOR_KEY = "$$angularInjector";
    class PropertyBinding {
        constructor(prop, attr) {
            this.prop = prop, this.attr = attr, this.parseBinding()
        }
        parseBinding() {
            this.bracketAttr = `[${this.attr}]`, this.parenAttr = `(${this.attr})`, this.bracketParenAttr = `[(${this.attr})]`;
            const capitalAttr = this.attr.charAt(0).toUpperCase() + this.attr.substr(1);
            this.onAttr = `on${capitalAttr}`, this.bindAttr = `bind${capitalAttr}`, this.bindonAttr = `bindon${capitalAttr}`
        }
    }
    const DIRECTIVE_PREFIX_REGEXP = /^(?:x|data)[:\-_]/i,
        DIRECTIVE_SPECIAL_CHARS_REGEXP = /[:\-_]+(.)/g;

    function cleanData(node) {
        static_element.cleanData([node]),
            function(node) {
                return isFunction(node.querySelectorAll)
            }(node) && static_element.cleanData(node.querySelectorAll("*"))
    }

    function controllerKey(name) {
        return "$" + name + "Controller"
    }

    function destroyApp($injector) {
        const $rootElement = $injector.get("$rootElement");
        $injector.get("$rootScope").$destroy(), cleanData($rootElement[0])
    }

    function getTypeName(type) {
        return type.overriddenName || type.name || type.toString().split("\n")[0]
    }

    function getDowngradedModuleCount($injector) {
        return $injector.has("$$angularDowngradedModuleCount") ? $injector.get("$$angularDowngradedModuleCount") : 0
    }

    function getUpgradeAppType($injector) {
        return $injector.has("$$angularUpgradeAppType") ? $injector.get("$$angularUpgradeAppType") : 0
    }

    function isFunction(value) {
        return "function" == typeof value
    }

    function validateInjectionKey($injector, downgradedModule, injectionKey, attemptedAction) {
        const upgradeAppType = getUpgradeAppType($injector),
            downgradedModuleCount = getDowngradedModuleCount($injector);
        switch (upgradeAppType) {
            case 1:
            case 2:
                if (downgradedModule) throw new Error(`Error while ${attemptedAction}: 'downgradedModule' unexpectedly specified.\nYou should not specify a value for 'downgradedModule', unless you are downgrading more than one Angular module (via 'downgradeModule()').`);
                break;
            case 3:
                if (!downgradedModule && downgradedModuleCount >= 2) throw new Error(`Error while ${attemptedAction}: 'downgradedModule' not specified.\nThis application contains more than one downgraded Angular module, thus you need to always specify 'downgradedModule' when downgrading components and injectables.`);
                if (!$injector.has(injectionKey)) throw new Error(`Error while ${attemptedAction}: Unable to find the specified downgraded module.\nDid you forget to downgrade an Angular module or include it in the AngularJS application?`);
                break;
            default:
                throw new Error(`Error while ${attemptedAction}: Not a valid '@angular/upgrade' application.\nDid you forget to downgrade an Angular module or include it in the AngularJS application?`)
        }
    }
    const INITIAL_VALUE = {
        __UNINITIALIZED__: !0
    };
    class static_DowngradeComponentAdapter {
        constructor(element, attrs, scope, ngModel, parentInjector, $compile, $parse, componentFactory, wrapCallback) {
            this.element = element, this.attrs = attrs, this.scope = scope, this.ngModel = ngModel, this.parentInjector = parentInjector, this.$compile = $compile, this.$parse = $parse, this.componentFactory = componentFactory, this.wrapCallback = wrapCallback, this.implementsOnChanges = !1, this.inputChangeCount = 0, this.inputChanges = {}, this.componentScope = scope.$new()
        }
        compileContents() {
            const compiledProjectableNodes = [],
                linkFns = this.groupProjectableNodes().map((nodes => this.$compile(nodes)));
            return this.element.empty(), linkFns.forEach((linkFn => {
                linkFn(this.scope, (clone => {
                    compiledProjectableNodes.push(clone), this.element.append(clone)
                }))
            })), compiledProjectableNodes
        }
        createComponent(projectableNodes) {
            const providers = [{
                    provide: "$scope",
                    useValue: this.componentScope
                }],
                childInjector = core.x.create({
                    providers: providers,
                    parent: this.parentInjector,
                    name: "DowngradeComponentAdapter"
                });
            this.componentRef = this.componentFactory.create(childInjector, projectableNodes, this.element[0]), this.viewChangeDetector = this.componentRef.injector.get(core.h), this.changeDetector = this.componentRef.changeDetectorRef, this.component = this.componentRef.instance;
            const testability = this.componentRef.injector.get(core.Y, null);
            var ngModel, component;
            testability && this.componentRef.injector.get(core.Z).registerApplication(this.componentRef.location.nativeElement, testability), ngModel = this.ngModel, component = this.component, ngModel && function(component) {
                return "function" == typeof component.writeValue && "function" == typeof component.registerOnChange
            }(component) && (ngModel.$render = () => {
                component.writeValue(ngModel.$viewValue)
            }, component.registerOnChange(ngModel.$setViewValue.bind(ngModel)), "function" == typeof component.registerOnTouched && component.registerOnTouched(ngModel.$setTouched.bind(ngModel)))
        }
        setupInputs(manuallyAttachView, propagateDigest = !0) {
            const attrs = this.attrs,
                inputs = this.componentFactory.inputs || [];
            for (let i = 0; i < inputs.length; i++) {
                const input = new PropertyBinding(inputs[i].propName, inputs[i].templateName);
                let expr = null;
                if (attrs.hasOwnProperty(input.attr)) {
                    const observeFn = (prop => {
                        let prevValue = INITIAL_VALUE;
                        return currValue => {
                            var val1, val2;
                            (val1 = prevValue) === (val2 = currValue) || val1 != val1 && val2 != val2 || (prevValue === INITIAL_VALUE && (prevValue = currValue), this.updateInput(prop, prevValue, currValue), prevValue = currValue)
                        }
                    })(input.prop);
                    attrs.$observe(input.attr, observeFn);
                    let unwatch = this.componentScope.$watch((() => {
                        unwatch(), unwatch = null, observeFn(attrs[input.attr])
                    }))
                } else attrs.hasOwnProperty(input.bindAttr) ? expr = attrs[input.bindAttr] : attrs.hasOwnProperty(input.bracketAttr) ? expr = attrs[input.bracketAttr] : attrs.hasOwnProperty(input.bindonAttr) ? expr = attrs[input.bindonAttr] : attrs.hasOwnProperty(input.bracketParenAttr) && (expr = attrs[input.bracketParenAttr]);
                if (null != expr) {
                    const watchFn = (prop => (currValue, prevValue) => this.updateInput(prop, prevValue, currValue))(input.prop);
                    this.componentScope.$watch(expr, watchFn)
                }
            }
            const detectChanges = () => this.changeDetector.detectChanges(),
                prototype = this.componentFactory.componentType.prototype;
            if (this.implementsOnChanges = !(!prototype || !prototype.ngOnChanges), this.componentScope.$watch((() => this.inputChangeCount), this.wrapCallback((() => {
                    if (this.implementsOnChanges) {
                        const inputChanges = this.inputChanges;
                        this.inputChanges = {}, this.component.ngOnChanges(inputChanges)
                    }
                    this.viewChangeDetector.markForCheck(), propagateDigest || detectChanges()
                }))), propagateDigest && this.componentScope.$watch(this.wrapCallback(detectChanges)), manuallyAttachView || !propagateDigest) {
                let unwatch = this.componentScope.$watch((() => {
                    unwatch(), unwatch = null;
                    this.parentInjector.get(core.f).attachView(this.componentRef.hostView)
                }))
            }
        }
        setupOutputs() {
            const attrs = this.attrs,
                outputs = this.componentFactory.outputs || [];
            for (let j = 0; j < outputs.length; j++) {
                const output = new PropertyBinding(outputs[j].propName, outputs[j].templateName),
                    bindonAttr = output.bindonAttr.substring(0, output.bindonAttr.length - 6),
                    bracketParenAttr = `[(${output.bracketParenAttr.substring(2,output.bracketParenAttr.length-8)})]`;
                attrs.hasOwnProperty(bindonAttr) && this.subscribeToOutput(output, attrs[bindonAttr], !0), attrs.hasOwnProperty(bracketParenAttr) && this.subscribeToOutput(output, attrs[bracketParenAttr], !0), attrs.hasOwnProperty(output.onAttr) && this.subscribeToOutput(output, attrs[output.onAttr]), attrs.hasOwnProperty(output.parenAttr) && this.subscribeToOutput(output, attrs[output.parenAttr])
            }
        }
        subscribeToOutput(output, expr, isAssignment = !1) {
            const getter = this.$parse(expr),
                setter = getter.assign;
            if (isAssignment && !setter) throw new Error(`Expression '${expr}' is not assignable!`);
            const emitter = this.component[output.prop];
            if (!emitter) throw new Error(`Missing emitter '${output.prop}' on component '${getTypeName(this.componentFactory.componentType)}'!`);
            emitter.subscribe({
                next: isAssignment ? v => setter(this.scope, v) : v => getter(this.scope, {
                    $event: v
                })
            })
        }
        registerCleanup() {
            const testabilityRegistry = this.componentRef.injector.get(core.Z),
                destroyComponentRef = this.wrapCallback((() => this.componentRef.destroy()));
            let destroyed = !1;
            this.element.on("$destroy", (() => {
                destroyed || this.componentScope.$destroy()
            })), this.componentScope.$on("$destroy", (() => {
                destroyed || (destroyed = !0, testabilityRegistry.unregisterApplication(this.componentRef.location.nativeElement), cleanData(this.element[0]), destroyComponentRef())
            }))
        }
        getInjector() {
            return this.componentRef.injector
        }
        updateInput(prop, prevValue, currValue) {
            this.implementsOnChanges && (this.inputChanges[prop] = new core.V(prevValue, currValue, prevValue === currValue)), this.inputChangeCount++, this.component[prop] = currValue
        }
        groupProjectableNodes() {
            return function(ngContentSelectors, nodes) {
                const projectableNodes = [];
                for (let i = 0, ii = ngContentSelectors.length; i < ii; ++i) projectableNodes[i] = [];
                for (let j = 0, jj = nodes.length; j < jj; ++j) {
                    const node = nodes[j],
                        ngContentIndex = findMatchingNgContentIndex(node, ngContentSelectors);
                    null != ngContentIndex && projectableNodes[ngContentIndex].push(node)
                }
                return projectableNodes
            }(this.componentFactory.ngContentSelectors, this.element.contents())
        }
    }

    function findMatchingNgContentIndex(element, ngContentSelectors) {
        const ngContentIndices = [];
        let wildcardNgContentIndex = -1;
        for (let i = 0; i < ngContentSelectors.length; i++) {
            const selector = ngContentSelectors[i];
            "*" === selector ? wildcardNgContentIndex = i : matchesSelector(element, selector) && ngContentIndices.push(i)
        }
        return ngContentIndices.sort(), -1 !== wildcardNgContentIndex && ngContentIndices.push(wildcardNgContentIndex), ngContentIndices.length ? ngContentIndices[0] : null
    }
    let _matches;

    function matchesSelector(el, selector) {
        if (!_matches) {
            const elProto = Element.prototype;
            _matches = elProto.matches || elProto.matchesSelector || elProto.mozMatchesSelector || elProto.msMatchesSelector || elProto.oMatchesSelector || elProto.webkitMatchesSelector
        }
        return el.nodeType === Node.ELEMENT_NODE && _matches.call(el, selector)
    }
    class SyncPromise {
        constructor() {
            this.resolved = !1, this.callbacks = []
        }
        static all(valuesOrPromises) {
            const aggrPromise = new SyncPromise;
            let resolvedCount = 0;
            const results = [],
                resolve = (idx, value) => {
                    results[idx] = value, ++resolvedCount === valuesOrPromises.length && aggrPromise.resolve(results)
                };
            return valuesOrPromises.forEach(((p, idx) => {
                var obj;
                (obj = p) && isFunction(obj.then) ? p.then((v => resolve(idx, v))) : resolve(idx, p)
            })), aggrPromise
        }
        resolve(value) {
            this.resolved || (this.value = value, this.resolved = !0, this.callbacks.forEach((callback => callback(value))), this.callbacks.length = 0)
        }
        then(callback) {
            this.resolved ? callback(this.value) : this.callbacks.push(callback)
        }
    }
    class ParentInjectorPromise extends SyncPromise {
        constructor(element) {
            super(), this.element = element, this.injectorKey = controllerKey(INJECTOR_KEY), element.data(this.injectorKey, this)
        }
        resolve(injector) {
            this.element.data(this.injectorKey, injector), this.element = null, super.resolve(injector)
        }
    }
    new core.ab("11.0.5");
    let tempInjectorRef = null;

    function setTempInjectorRef(injector) {
        tempInjectorRef = injector
    }
    const angular1Providers = [{
        provide: "$injector",
        useFactory: function() {
            if (!tempInjectorRef) throw new Error("Trying to get the AngularJS injector before it being set.");
            const injector = tempInjectorRef;
            return tempInjectorRef = null, injector
        },
        deps: []
    }, {
        provide: "$rootScope",
        useFactory: function(i) {
            return i.get("$rootScope")
        },
        deps: ["$injector"]
    }, {
        provide: "$compile",
        useFactory: function(i) {
            return i.get("$compile")
        },
        deps: ["$injector"]
    }, {
        provide: "$parse",
        useFactory: function(i) {
            return i.get("$parse")
        },
        deps: ["$injector"]
    }];
    class static_NgAdapterInjector {
        constructor(modInjector) {
            this.modInjector = modInjector
        }
        get(token, notFoundValue) {
            return notFoundValue === core.mb ? notFoundValue : this.modInjector.get(token, notFoundValue)
        }
    }
    const REQUIRE_PREFIX_RE = /^(\^\^?)?(\?)?(\^\^?)?/;
    class UpgradeHelper {
        constructor(injector, name, elementRef, directive) {
            this.name = name, this.$injector = injector.get("$injector"), this.$compile = this.$injector.get("$compile"), this.$controller = this.$injector.get("$controller"), this.element = elementRef.nativeElement, this.$element = static_element(this.element), this.directive = directive || UpgradeHelper.getDirective(this.$injector, name)
        }
        static getDirective($injector, name) {
            const directives = $injector.get(name + "Directive");
            if (directives.length > 1) throw new Error(`Only support single directive definition for: ${name}`);
            const directive = directives[0];
            return directive.compile && !directive.link && notSupported(name, "compile"), directive.replace && notSupported(name, "replace"), directive.terminal && notSupported(name, "terminal"), directive
        }
        static getTemplate($injector, directive, fetchRemoteTemplate = !1, $element) {
            if (void 0 !== directive.template) return getOrCall(directive.template, $element);
            if (directive.templateUrl) {
                const $templateCache = $injector.get("$templateCache"),
                    url = getOrCall(directive.templateUrl, $element),
                    template = $templateCache.get(url);
                if (void 0 !== template) return template;
                if (!fetchRemoteTemplate) throw new Error("loading directive templates asynchronously is not supported");
                return new Promise(((resolve, reject) => {
                    $injector.get("$httpBackend")("GET", url, null, ((status, response) => {
                        200 === status ? resolve($templateCache.put(url, response)) : reject(`GET component template from '${url}' returned '${status}: ${response}'`)
                    }))
                }))
            }
            throw new Error(`Directive '${directive.name}' is not a component, it is missing template.`)
        }
        buildController(controllerType, $scope) {
            const locals = {
                    $scope: $scope,
                    $element: this.$element
                },
                controller = this.$controller(controllerType, locals, null, this.directive.controllerAs);
            return this.$element.data(controllerKey(this.directive.name), controller), controller
        }
        compileTemplate(template) {
            return void 0 === template && (template = UpgradeHelper.getTemplate(this.$injector, this.directive, !1, this.$element)), this.compileHtml(template)
        }
        onDestroy($scope, controllerInstance) {
            controllerInstance && isFunction(controllerInstance.$onDestroy) && controllerInstance.$onDestroy(), $scope.$destroy(), cleanData(this.element)
        }
        prepareTransclusion() {
            const transclude = this.directive.transclude,
                contentChildNodes = this.extractChildNodes(),
                attachChildrenFn = (scope, cloneAttachFn) => cloneAttachFn($template, scope = scope || {
                    $destroy: () => {}
                });
            let $template = contentChildNodes;
            if (transclude) {
                const slots = Object.create(null);
                if ("object" == typeof transclude) {
                    $template = [];
                    const slotMap = Object.create(null),
                        filledSlots = Object.create(null);
                    Object.keys(transclude).forEach((slotName => {
                        let selector = transclude[slotName];
                        const optional = "?" === selector.charAt(0);
                        selector = optional ? selector.substring(1) : selector, slotMap[selector] = slotName, slots[slotName] = null, filledSlots[slotName] = optional
                    })), contentChildNodes.forEach((node => {
                        const slotName = slotMap[(name = node.nodeName.toLowerCase(), name.replace(DIRECTIVE_PREFIX_REGEXP, "").replace(DIRECTIVE_SPECIAL_CHARS_REGEXP, ((_, letter) => letter.toUpperCase())))];
                        var name;
                        slotName ? (filledSlots[slotName] = !0, slots[slotName] = slots[slotName] || [], slots[slotName].push(node)) : $template.push(node)
                    })), Object.keys(filledSlots).forEach((slotName => {
                        if (!filledSlots[slotName]) throw new Error(`Required transclusion slot '${slotName}' on directive: ${this.name}`)
                    })), Object.keys(slots).filter((slotName => slots[slotName])).forEach((slotName => {
                        const nodes = slots[slotName];
                        slots[slotName] = (scope, cloneAttach) => cloneAttach(nodes, scope)
                    }))
                }
                attachChildrenFn.$$slots = slots, $template.forEach((node => {
                    node.nodeType !== Node.TEXT_NODE || node.nodeValue || (node.nodeValue = "‌")
                }))
            }
            return attachChildrenFn
        }
        resolveAndBindRequiredControllers(controllerInstance) {
            const directiveRequire = this.getDirectiveRequire(),
                requiredControllers = this.resolveRequire(directiveRequire);
            if (controllerInstance && this.directive.bindToController && isMap(directiveRequire)) {
                const requiredControllersMap = requiredControllers;
                Object.keys(requiredControllersMap).forEach((key => {
                    controllerInstance[key] = requiredControllersMap[key]
                }))
            }
            return requiredControllers
        }
        compileHtml(html) {
            return this.element.innerHTML = html, this.$compile(this.element.childNodes)
        }
        extractChildNodes() {
            const childNodes = [];
            let childNode;
            for (; childNode = this.element.firstChild;) this.element.removeChild(childNode), childNodes.push(childNode);
            return childNodes
        }
        getDirectiveRequire() {
            const require = this.directive.require || this.directive.controller && this.directive.name;
            return isMap(require) && Object.keys(require).forEach((key => {
                const value = require[key],
                    match = value.match(REQUIRE_PREFIX_RE);
                value.substring(match[0].length) || (require[key] = match[0] + key)
            })), require
        }
        resolveRequire(require, controllerInstance) {
            if (require) {
                if (Array.isArray(require)) return require.map((req => this.resolveRequire(req)));
                if ("object" == typeof require) {
                    const value = {};
                    return Object.keys(require).forEach((key => value[key] = this.resolveRequire(require[key]))), value
                }
                if ("string" == typeof require) {
                    const match = require.match(REQUIRE_PREFIX_RE),
                        inheritType = match[1] || match[3],
                        name = require.substring(match[0].length),
                        isOptional = !!match[2],
                        searchParents = !!inheritType,
                        startOnParent = "^^" === inheritType,
                        ctrlKey = controllerKey(name),
                        elem = startOnParent ? this.$element.parent() : this.$element,
                        value = searchParents ? elem.inheritedData(ctrlKey) : elem.data(ctrlKey);
                    if (!value && !isOptional) throw new Error(`Unable to find required '${require}' in upgraded directive '${this.name}'.`);
                    return value
                }
                throw new Error(`Unrecognized 'require' syntax on upgraded directive '${this.name}': ${require}`)
            }
            return null
        }
    }

    function getOrCall(property, ...args) {
        return isFunction(property) ? property(...args) : property
    }

    function isMap(value) {
        return value && !Array.isArray(value) && "object" == typeof value
    }

    function notSupported(name, feature) {
        throw new Error(`Upgraded directive '${name}' contains unsupported feature: '${feature}'.`)
    }
    const INITIAL_VALUE$1 = {
        __UNINITIALIZED__: !0
    };
    class Bindings {
        constructor() {
            this.twoWayBoundProperties = [], this.twoWayBoundLastValues = [], this.expressionBoundProperties = [], this.propertyToOutputMap = {}
        }
    }
    class static_UpgradeComponent {
        constructor(name, elementRef, injector) {
            this.name = name, this.elementRef = elementRef, this.injector = injector, this.helper = new UpgradeHelper(injector, name, elementRef), this.$injector = this.helper.$injector, this.element = this.helper.element, this.$element = this.helper.$element, this.directive = this.helper.directive, this.bindings = this.initializeBindings(this.directive);
            const $parentScope = injector.get("$scope");
            this.$componentScope = $parentScope.$new(!!this.directive.scope), this.initializeOutputs()
        }
        ngOnInit() {
            const attachChildNodes = this.helper.prepareTransclusion(),
                linkFn = this.helper.compileTemplate(),
                controllerType = this.directive.controller,
                bindToController = this.directive.bindToController;
            if (controllerType) this.controllerInstance = this.helper.buildController(controllerType, this.$componentScope);
            else if (bindToController) throw new Error(`Upgraded directive '${this.directive.name}' specifies 'bindToController' but no controller.`);
            this.bindingDestination = bindToController ? this.controllerInstance : this.$componentScope, this.bindOutputs();
            const requiredControllers = this.helper.resolveAndBindRequiredControllers(this.controllerInstance);
            if (this.pendingChanges && (this.forwardChanges(this.pendingChanges), this.pendingChanges = null), this.controllerInstance && isFunction(this.controllerInstance.$onInit) && this.controllerInstance.$onInit(), this.controllerInstance && isFunction(this.controllerInstance.$doCheck)) {
                const callDoCheck = () => this.controllerInstance.$doCheck();
                this.unregisterDoCheckWatcher = this.$componentScope.$parent.$watch(callDoCheck), callDoCheck()
            }
            const link = this.directive.link,
                preLink = "object" == typeof link && link.pre,
                postLink = "object" == typeof link ? link.post : link;
            preLink && preLink(this.$componentScope, this.$element, "NOT_SUPPORTED", requiredControllers, "NOT_SUPPORTED"), linkFn(this.$componentScope, null, {
                parentBoundTranscludeFn: attachChildNodes
            }), postLink && postLink(this.$componentScope, this.$element, "NOT_SUPPORTED", requiredControllers, "NOT_SUPPORTED"), this.controllerInstance && isFunction(this.controllerInstance.$postLink) && this.controllerInstance.$postLink()
        }
        ngOnChanges(changes) {
            this.bindingDestination ? this.forwardChanges(changes) : this.pendingChanges = changes
        }
        ngDoCheck() {
            const twoWayBoundProperties = this.bindings.twoWayBoundProperties,
                twoWayBoundLastValues = this.bindings.twoWayBoundLastValues,
                propertyToOutputMap = this.bindings.propertyToOutputMap;
            twoWayBoundProperties.forEach(((propName, idx) => {
                const newValue = this.bindingDestination[propName],
                    oldValue = twoWayBoundLastValues[idx];
                if (!Object.is(newValue, oldValue)) {
                    this[propertyToOutputMap[propName]].emit(newValue), twoWayBoundLastValues[idx] = newValue
                }
            }))
        }
        ngOnDestroy() {
            isFunction(this.unregisterDoCheckWatcher) && this.unregisterDoCheckWatcher(), this.helper.onDestroy(this.$componentScope, this.controllerInstance)
        }
        initializeBindings(directive) {
            const btcIsObject = "object" == typeof directive.bindToController;
            if (btcIsObject && Object.keys(directive.scope).length) throw new Error("Binding definitions on scope and controller at the same time is not supported.");
            const context = btcIsObject ? directive.bindToController : directive.scope,
                bindings = new Bindings;
            return "object" == typeof context && Object.keys(context).forEach((propName => {
                const bindingType = context[propName].charAt(0);
                switch (bindingType) {
                    case "@":
                    case "<":
                        break;
                    case "=":
                        bindings.twoWayBoundProperties.push(propName), bindings.twoWayBoundLastValues.push(INITIAL_VALUE$1), bindings.propertyToOutputMap[propName] = propName + "Change";
                        break;
                    case "&":
                        bindings.expressionBoundProperties.push(propName), bindings.propertyToOutputMap[propName] = propName;
                        break;
                    default:
                        let json = JSON.stringify(context);
                        throw new Error(`Unexpected mapping '${bindingType}' in '${json}' in '${this.name}' directive.`)
                }
            })), bindings
        }
        initializeOutputs() {
            this.bindings.twoWayBoundProperties.concat(this.bindings.expressionBoundProperties).forEach((propName => {
                this[this.bindings.propertyToOutputMap[propName]] = new core.q
            }))
        }
        bindOutputs() {
            this.bindings.expressionBoundProperties.forEach((propName => {
                const emitter = this[this.bindings.propertyToOutputMap[propName]];
                this.bindingDestination[propName] = value => emitter.emit(value)
            }))
        }
        forwardChanges(changes) {
            Object.keys(changes).forEach((propName => this.bindingDestination[propName] = changes[propName].currentValue)), isFunction(this.bindingDestination.$onChanges) && this.bindingDestination.$onChanges(changes)
        }
    }
    static_UpgradeComponent.decorators = [{
        type: core.n
    }], static_UpgradeComponent.ctorParameters = () => [{
        type: String
    }, {
        type: core.o
    }, {
        type: core.x
    }];
    class static_UpgradeModule {
        constructor(injector, ngZone, platformRef) {
            this.ngZone = ngZone, this.platformRef = platformRef, this.injector = new static_NgAdapterInjector(injector)
        }
        bootstrap(element$1, modules = [], config) {
            const INIT_MODULE_NAME = "$$UpgradeModule.init";
            module_(INIT_MODULE_NAME, []).constant("$$angularUpgradeAppType", 2).value(INJECTOR_KEY, this.injector).factory("$$angularLazyModuleRef", [INJECTOR_KEY, injector => ({
                injector: injector
            })]).config(["$provide", "$injector", ($provide, $injector) => {
                $injector.has("$$testability") && $provide.decorator("$$testability", ["$delegate", testabilityDelegate => {
                    const originalWhenStable = testabilityDelegate.whenStable,
                        injector = this.injector,
                        newWhenStable = function(callback) {
                            originalWhenStable.call(testabilityDelegate, (function() {
                                const ng2Testability = injector.get(core.Y);
                                ng2Testability.isStable() ? callback() : ng2Testability.whenStable(newWhenStable.bind(testabilityDelegate, callback))
                            }))
                        };
                    return testabilityDelegate.whenStable = newWhenStable, testabilityDelegate
                }]), $injector.has("$interval") && $provide.decorator("$interval", ["$delegate", intervalDelegate => {
                    let wrappedInterval = (fn, delay, count, invokeApply, ...pass) => this.ngZone.runOutsideAngular((() => intervalDelegate(((...args) => {
                        setTimeout((() => {
                            this.ngZone.run((() => fn(...args)))
                        }))
                    }), delay, count, invokeApply, ...pass)));
                    return wrappedInterval.cancel = intervalDelegate.cancel, wrappedInterval
                }])
            }]).run(["$injector", $injector => {
                this.$injector = $injector;
                const $rootScope = $injector.get("$rootScope");
                setTempInjectorRef($injector), this.injector.get("$injector"), static_element(element$1).data(controllerKey(INJECTOR_KEY), this.injector), this.platformRef.onDestroy((() => destroyApp($injector))), setTimeout((() => {
                    const subscription = this.ngZone.onMicrotaskEmpty.subscribe((() => $rootScope.$$phase ? (Object(core.gb)() && console.warn("A digest was triggered while one was already in progress. This may mean that something is triggering digests outside the Angular zone."), $rootScope.$evalAsync()) : $rootScope.$digest()));
                    $rootScope.$on("$destroy", (() => {
                        subscription.unsubscribe()
                    }))
                }), 0)
            }]);
            const upgradeModule = module_("$$UpgradeModule", [INIT_MODULE_NAME].concat(modules)),
                windowAngular = window.angular;
            if (windowAngular.resumeBootstrap = void 0, this.ngZone.run((() => {
                    ((e, modules, config) => {
                        angular.bootstrap(e, modules, config)
                    })(element$1, [upgradeModule.name], config)
                })), windowAngular.resumeBootstrap) {
                const originalResumeBootstrap = windowAngular.resumeBootstrap,
                    ngZone = this.ngZone;
                windowAngular.resumeBootstrap = function() {
                    let args = arguments;
                    return windowAngular.resumeBootstrap = originalResumeBootstrap, ngZone.run((() => windowAngular.resumeBootstrap.apply(this, args)))
                }
            }
        }
    }
    static_UpgradeModule.decorators = [{
        type: core.C,
        args: [{
            providers: [angular1Providers]
        }]
    }], static_UpgradeModule.ctorParameters = () => [{
        type: core.x
    }, {
        type: core.H
    }, {
        type: core.N
    }];
    var lib_esm = __webpack_require__(1),
        uirouter_angular = __webpack_require__(22),
        angularjs_lib_esm = __webpack_require__(257),
        rx_lib_esm = __webpack_require__(98);
    const uirouter_angular_hybrid_angular = (getAngularJSGlobal || function() {
        return getAngularJSGlobal()
    })();
    if (!uirouter_angular_hybrid_angular) throw new Error("AngularJS not found on window.  https://github.com/ui-router/angular-hybrid/wiki/AngularJS-not-found-on-window");
    const uirouter_angular_hybrid_upgradeModule = uirouter_angular_hybrid_angular.module("ui.router.upgrade", ["ui.router"]);

    function objectFactory() {
        return {}
    }
    class UIViewNgUpgrade {
        constructor(ref, parent, registry) {
            const ng1elem = uirouter_angular_hybrid_angular.element(ref.nativeElement).parent().parent();
            Object.defineProperty(parent, "context", {
                get: function() {
                    const data = ng1elem.inheritedData("$uiView");
                    return data && data.$cfg ? data.$cfg.viewDecl.$context : registry.root()
                },
                enumerable: !0
            }), Object.defineProperty(parent, "fqn", {
                get: function() {
                    const data = ng1elem.inheritedData("$uiView");
                    return data && data.$uiView ? data.$uiView.fqn : null
                },
                enumerable: !0
            })
        }
    }

    function uiRouterUpgradeFactory(router, injector) {
        return injector.get(uirouter_angular.UIROUTER_MODULE_TOKEN, []).forEach((module => Object(uirouter_angular.applyModuleConfig)(router, injector, module))), router
    }

    function getUIRouter($injector) {
        return $injector.get("$uiRouter")
    }

    function getParentUIViewInject(r) {
        return {
            fqn: null,
            context: r.root()
        }
    }
    UIViewNgUpgrade.decorators = [{
        type: core.j,
        args: [{
            selector: "ui-view-ng-upgrade",
            template: ' <ui-view [name]="name"></ui-view> ',
            viewProviders: [{
                provide: uirouter_angular.UIView.PARENT_INJECT,
                useFactory: objectFactory
            }]
        }]
    }], UIViewNgUpgrade.ctorParameters = () => [{
        type: core.o
    }, {
        type: void 0,
        decorators: [{
            type: core.u,
            args: [uirouter_angular.UIView.PARENT_INJECT]
        }]
    }, {
        type: lib_esm.StateRegistry
    }], UIViewNgUpgrade.propDecorators = {
        name: [{
            type: core.y
        }]
    };
    const uirouter_angular_hybrid_0 = {};
    class uirouter_angular_hybrid_UIRouterUpgradeModule {
        static forRoot(module = {}) {
            return {
                ngModule: uirouter_angular_hybrid_UIRouterUpgradeModule,
                providers: Object(uirouter_angular.makeChildProviders)(module)
            }
        }
        static forChild(module = {}) {
            return {
                ngModule: uirouter_angular.UIRouterModule,
                providers: Object(uirouter_angular.makeChildProviders)(module)
            }
        }
    }
    uirouter_angular_hybrid_UIRouterUpgradeModule.decorators = [{
        type: core.C,
        args: [{
            imports: [uirouter_angular.UIRouterModule, static_UpgradeModule],
            declarations: [UIViewNgUpgrade],
            providers: [{
                provide: "$uiRouter",
                useFactory: getUIRouter,
                deps: ["$injector"]
            }, {
                provide: lib_esm.UIRouter,
                useFactory: uiRouterUpgradeFactory,
                deps: ["$uiRouter", core.x]
            }, {
                provide: uirouter_angular.UIROUTER_ROOT_MODULE,
                useValue: uirouter_angular_hybrid_0,
                multi: !0
            }, {
                provide: uirouter_angular.UIView.PARENT_INJECT,
                useFactory: getParentUIViewInject,
                deps: [lib_esm.StateRegistry]
            }, ...uirouter_angular._UIROUTER_SERVICE_PROVIDERS],
            entryComponents: [UIViewNgUpgrade],
            exports: [UIViewNgUpgrade, uirouter_angular.UIRouterModule]
        }]
    }], uirouter_angular_hybrid_upgradeModule.directive("uiViewNgUpgrade", function(info) {
        const directiveFactory = function($compile, $injector, $parse) {
            const isNgUpgradeLite = 3 === getUpgradeAppType($injector),
                wrapCallback = isNgUpgradeLite ? cb => () => core.H.isInAngularZone() ? cb() : ngZone.run(cb) : cb => cb;
            let ngZone;
            const hasMultipleDowngradedModules = isNgUpgradeLite && getDowngradedModuleCount($injector) > 1;
            return {
                restrict: "E",
                terminal: !0,
                require: ["?^^$$angularInjector", "?ngModel"],
                link: (scope, element, attrs, required) => {
                    const ngModel = required[1],
                        parentInjector = required[0];
                    let moduleInjector, ranAsync = !1;
                    if (!parentInjector || hasMultipleDowngradedModules) {
                        const downgradedModule = info.downgradedModule || "",
                            lazyModuleRefKey = `$$angularLazyModuleRef${downgradedModule}`,
                            attemptedAction = `instantiating component '${getTypeName(info.component)}'`;
                        validateInjectionKey($injector, downgradedModule, lazyModuleRefKey, attemptedAction);
                        const lazyModuleRef = $injector.get(lazyModuleRefKey);
                        moduleInjector = lazyModuleRef.injector || lazyModuleRef.promise
                    }
                    const finalParentInjector = parentInjector || moduleInjector,
                        finalModuleInjector = moduleInjector || parentInjector,
                        doDowngrade = (injector, moduleInjector) => {
                            const componentFactory = moduleInjector.get(core.k).resolveComponentFactory(info.component);
                            if (!componentFactory) throw new Error(`Expecting ComponentFactory for: ${getTypeName(info.component)}`);
                            const injectorPromise = new ParentInjectorPromise(element),
                                facade = new static_DowngradeComponentAdapter(element, attrs, scope, ngModel, injector, $compile, $parse, componentFactory, wrapCallback),
                                projectableNodes = facade.compileContents();
                            facade.createComponent(projectableNodes), facade.setupInputs(isNgUpgradeLite, info.propagateDigest), facade.setupOutputs(), facade.registerCleanup(), injectorPromise.resolve(facade.getInjector()), ranAsync && scope.$evalAsync((() => {}))
                        },
                        downgradeFn = isNgUpgradeLite ? (pInjector, mInjector) => {
                            ngZone || (ngZone = pInjector.get(core.H)), wrapCallback((() => doDowngrade(pInjector, mInjector)))()
                        } : doDowngrade;
                    SyncPromise.all([finalParentInjector, finalModuleInjector]).then((([pInjector, mInjector]) => downgradeFn(pInjector, mInjector))), ranAsync = !0
                }
            }
        };
        return directiveFactory.$inject = ["$compile", "$injector", "$parse"], directiveFactory
    }({
        component: UIViewNgUpgrade,
        inputs: ["name"]
    })), uirouter_angular_hybrid_upgradeModule.run(["$injector", ng1Injector => {
        const $uiRouter = ng1Injector.get("$uiRouter");
        $uiRouter.plugin(rx_lib_esm.a);
        const mergedInjector = {
                get: function(token, ng2NotFoundValue) {
                    if (ng1Injector.has(token)) return ng1Injector.get(token);
                    return ng1Injector.get("$$angularInjector").get(token, ng2NotFoundValue)
                }
            },
            ng2InjectorResolvable = lib_esm.Resolvable.fromData(lib_esm.NATIVE_INJECTOR_TOKEN, mergedInjector);
        $uiRouter.stateRegistry.root().resolvables.push(ng2InjectorResolvable)
    }]), uirouter_angular_hybrid_upgradeModule.config(["$stateRegistryProvider", $stateRegistry => {
        $stateRegistry.decorator("lazyLoad", uirouter_angular.ng2LazyLoadBuilder)
    }]), uirouter_angular_hybrid_upgradeModule.config(["$stateRegistryProvider", $stateRegistry => {
        $stateRegistry.decorator("views", (function(state, parentFn) {
            const views = parentFn(state);
            return Object(lib_esm.forEach)(views, ((viewDecl, viewName) => {
                "ng1-to-ng2" !== viewDecl.$type && "function" != typeof viewDecl.component || (viewDecl.$type = "ng1-to-ng2", viewDecl.templateProvider = null, viewDecl.template = `<ui-view-ng-upgrade name='${viewDecl.$uiViewName}'></ui-view-ng-upgrade>`)
            })), views
        }))
    }]), uirouter_angular_hybrid_upgradeModule.run(["$view", "$templateFactory", ($view, $templateFactory) => {
        $view._pluginapi._viewConfigFactory("ng2", ((path, config) => new uirouter_angular.Ng2ViewConfig(path, config))), $view._pluginapi._viewConfigFactory("ng1-to-ng2", ((path, config) => {
            const ng1ViewConfig = new angularjs_lib_esm.Ng1ViewConfig(path, Object.assign({}, config, {
                $type: "ng1"
            }), $templateFactory);
            return [new uirouter_angular.Ng2ViewConfig(path, Object.assign({}, config, {
                $type: "ng2"
            })), ng1ViewConfig]
        }))
    }])
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return merge
    }));
    var _Observable__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(12),
        _util_isScheduler__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(51),
        _operators_mergeAll__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(97),
        _fromArray__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(54);

    function merge() {
        for (var observables = [], _i = 0; _i < arguments.length; _i++) observables[_i] = arguments[_i];
        var concurrent = Number.POSITIVE_INFINITY,
            scheduler = null,
            last = observables[observables.length - 1];
        return Object(_util_isScheduler__WEBPACK_IMPORTED_MODULE_1__.a)(last) ? (scheduler = observables.pop(), observables.length > 1 && "number" == typeof observables[observables.length - 1] && (concurrent = observables.pop())) : "number" == typeof last && (concurrent = observables.pop()), null === scheduler && 1 === observables.length && observables[0] instanceof _Observable__WEBPACK_IMPORTED_MODULE_0__.a ? observables[0] : Object(_operators_mergeAll__WEBPACK_IMPORTED_MODULE_2__.a)(concurrent)(Object(_fromArray__WEBPACK_IMPORTED_MODULE_3__.a)(observables, scheduler))
    }
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return BehaviorSubject
    }));
    var tslib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(7),
        _Subject__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(32),
        _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(31),
        BehaviorSubject = function(_super) {
            function BehaviorSubject(_value) {
                var _this = _super.call(this) || this;
                return _this._value = _value, _this
            }
            return tslib__WEBPACK_IMPORTED_MODULE_0__.a(BehaviorSubject, _super), Object.defineProperty(BehaviorSubject.prototype, "value", {
                get: function() {
                    return this.getValue()
                },
                enumerable: !0,
                configurable: !0
            }), BehaviorSubject.prototype._subscribe = function(subscriber) {
                var subscription = _super.prototype._subscribe.call(this, subscriber);
                return subscription && !subscription.closed && subscriber.next(this._value), subscription
            }, BehaviorSubject.prototype.getValue = function() {
                if (this.hasError) throw this.thrownError;
                if (this.closed) throw new _util_ObjectUnsubscribedError__WEBPACK_IMPORTED_MODULE_2__.a;
                return this._value
            }, BehaviorSubject.prototype.next = function(value) {
                _super.prototype.next.call(this, this._value = value)
            }, BehaviorSubject
        }(_Subject__WEBPACK_IMPORTED_MODULE_1__.a)
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return share
    }));
    var tslib_es6 = __webpack_require__(7),
        Subject = __webpack_require__(32),
        Observable = __webpack_require__(12),
        Subscriber = __webpack_require__(11),
        Subscription = __webpack_require__(15);

    function refCount() {
        return function(source) {
            return source.lift(new RefCountOperator(source))
        }
    }
    var RefCountOperator = function() {
            function RefCountOperator(connectable) {
                this.connectable = connectable
            }
            return RefCountOperator.prototype.call = function(subscriber, source) {
                var connectable = this.connectable;
                connectable._refCount++;
                var refCounter = new refCount_RefCountSubscriber(subscriber, connectable),
                    subscription = source.subscribe(refCounter);
                return refCounter.closed || (refCounter.connection = connectable.connect()), subscription
            }, RefCountOperator
        }(),
        refCount_RefCountSubscriber = function(_super) {
            function RefCountSubscriber(destination, connectable) {
                var _this = _super.call(this, destination) || this;
                return _this.connectable = connectable, _this
            }
            return tslib_es6.a(RefCountSubscriber, _super), RefCountSubscriber.prototype._unsubscribe = function() {
                var connectable = this.connectable;
                if (connectable) {
                    this.connectable = null;
                    var refCount = connectable._refCount;
                    if (refCount <= 0) this.connection = null;
                    else if (connectable._refCount = refCount - 1, refCount > 1) this.connection = null;
                    else {
                        var connection = this.connection,
                            sharedConnection = connectable._connection;
                        this.connection = null, !sharedConnection || connection && sharedConnection !== connection || sharedConnection.unsubscribe()
                    }
                } else this.connection = null
            }, RefCountSubscriber
        }(Subscriber.a),
        ConnectableObservable_ConnectableObservable = function(_super) {
            function ConnectableObservable(source, subjectFactory) {
                var _this = _super.call(this) || this;
                return _this.source = source, _this.subjectFactory = subjectFactory, _this._refCount = 0, _this._isComplete = !1, _this
            }
            return tslib_es6.a(ConnectableObservable, _super), ConnectableObservable.prototype._subscribe = function(subscriber) {
                return this.getSubject().subscribe(subscriber)
            }, ConnectableObservable.prototype.getSubject = function() {
                var subject = this._subject;
                return subject && !subject.isStopped || (this._subject = this.subjectFactory()), this._subject
            }, ConnectableObservable.prototype.connect = function() {
                var connection = this._connection;
                return connection || (this._isComplete = !1, (connection = this._connection = new Subscription.a).add(this.source.subscribe(new ConnectableObservable_ConnectableSubscriber(this.getSubject(), this))), connection.closed && (this._connection = null, connection = Subscription.a.EMPTY)), connection
            }, ConnectableObservable.prototype.refCount = function() {
                return refCount()(this)
            }, ConnectableObservable
        }(Observable.a),
        connectableObservableDescriptor = function() {
            var connectableProto = ConnectableObservable_ConnectableObservable.prototype;
            return {
                operator: {
                    value: null
                },
                _refCount: {
                    value: 0,
                    writable: !0
                },
                _subject: {
                    value: null,
                    writable: !0
                },
                _connection: {
                    value: null,
                    writable: !0
                },
                _subscribe: {
                    value: connectableProto._subscribe
                },
                _isComplete: {
                    value: connectableProto._isComplete,
                    writable: !0
                },
                getSubject: {
                    value: connectableProto.getSubject
                },
                connect: {
                    value: connectableProto.connect
                },
                refCount: {
                    value: connectableProto.refCount
                }
            }
        }(),
        ConnectableObservable_ConnectableSubscriber = function(_super) {
            function ConnectableSubscriber(destination, connectable) {
                var _this = _super.call(this, destination) || this;
                return _this.connectable = connectable, _this
            }
            return tslib_es6.a(ConnectableSubscriber, _super), ConnectableSubscriber.prototype._error = function(err) {
                this._unsubscribe(), _super.prototype._error.call(this, err)
            }, ConnectableSubscriber.prototype._complete = function() {
                this.connectable._isComplete = !0, this._unsubscribe(), _super.prototype._complete.call(this)
            }, ConnectableSubscriber.prototype._unsubscribe = function() {
                var connectable = this.connectable;
                if (connectable) {
                    this.connectable = null;
                    var connection = connectable._connection;
                    connectable._refCount = 0, connectable._subject = null, connectable._connection = null, connection && connection.unsubscribe()
                }
            }, ConnectableSubscriber
        }(Subject.b);
    Subscriber.a;
    var MulticastOperator = function() {
        function MulticastOperator(subjectFactory, selector) {
            this.subjectFactory = subjectFactory, this.selector = selector
        }
        return MulticastOperator.prototype.call = function(subscriber, source) {
            var selector = this.selector,
                subject = this.subjectFactory(),
                subscription = selector(subject).subscribe(subscriber);
            return subscription.add(source.subscribe(subject)), subscription
        }, MulticastOperator
    }();

    function shareSubjectFactory() {
        return new Subject.a
    }

    function share() {
        return function(source) {
            return refCount()((subjectOrSubjectFactory = shareSubjectFactory, function(source) {
                var subjectFactory;
                if (subjectFactory = "function" == typeof subjectOrSubjectFactory ? subjectOrSubjectFactory : function() {
                        return subjectOrSubjectFactory
                    }, "function" == typeof selector) return source.lift(new MulticastOperator(subjectFactory, selector));
                var connectable = Object.create(source, connectableObservableDescriptor);
                return connectable.source = source, connectable.subjectFactory = subjectFactory, connectable
            })(source));
            var subjectOrSubjectFactory, selector
        }
    }
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return combineLatest
    }));
    var tslib_es6 = __webpack_require__(7),
        isScheduler = __webpack_require__(51),
        isArray = __webpack_require__(90),
        Subscriber = __webpack_require__(11),
        OuterSubscriber_OuterSubscriber = function(_super) {
            function OuterSubscriber() {
                return null !== _super && _super.apply(this, arguments) || this
            }
            return tslib_es6.a(OuterSubscriber, _super), OuterSubscriber.prototype.notifyNext = function(outerValue, innerValue, outerIndex, innerIndex, innerSub) {
                this.destination.next(innerValue)
            }, OuterSubscriber.prototype.notifyError = function(error, innerSub) {
                this.destination.error(error)
            }, OuterSubscriber.prototype.notifyComplete = function(innerSub) {
                this.destination.complete()
            }, OuterSubscriber
        }(Subscriber.a),
        InnerSubscriber_InnerSubscriber = function(_super) {
            function InnerSubscriber(parent, outerValue, outerIndex) {
                var _this = _super.call(this) || this;
                return _this.parent = parent, _this.outerValue = outerValue, _this.outerIndex = outerIndex, _this.index = 0, _this
            }
            return tslib_es6.a(InnerSubscriber, _super), InnerSubscriber.prototype._next = function(value) {
                this.parent.notifyNext(this.outerValue, value, this.outerIndex, this.index++, this)
            }, InnerSubscriber.prototype._error = function(error) {
                this.parent.notifyError(error, this), this.unsubscribe()
            }, InnerSubscriber.prototype._complete = function() {
                this.parent.notifyComplete(this), this.unsubscribe()
            }, InnerSubscriber
        }(Subscriber.a),
        subscribeTo = __webpack_require__(55),
        Observable = __webpack_require__(12);

    function subscribeToResult(outerSubscriber, result, outerValue, outerIndex, innerSubscriber) {
        if (void 0 === innerSubscriber && (innerSubscriber = new InnerSubscriber_InnerSubscriber(outerSubscriber, outerValue, outerIndex)), !innerSubscriber.closed) return result instanceof Observable.a ? result.subscribe(innerSubscriber) : Object(subscribeTo.a)(result)(innerSubscriber)
    }
    var fromArray = __webpack_require__(54),
        NONE = {};

    function combineLatest() {
        for (var observables = [], _i = 0; _i < arguments.length; _i++) observables[_i] = arguments[_i];
        var resultSelector = void 0,
            scheduler = void 0;
        return Object(isScheduler.a)(observables[observables.length - 1]) && (scheduler = observables.pop()), "function" == typeof observables[observables.length - 1] && (resultSelector = observables.pop()), 1 === observables.length && Object(isArray.a)(observables[0]) && (observables = observables[0]), Object(fromArray.a)(observables, scheduler).lift(new CombineLatestOperator(resultSelector))
    }
    var CombineLatestOperator = function() {
            function CombineLatestOperator(resultSelector) {
                this.resultSelector = resultSelector
            }
            return CombineLatestOperator.prototype.call = function(subscriber, source) {
                return source.subscribe(new combineLatest_CombineLatestSubscriber(subscriber, this.resultSelector))
            }, CombineLatestOperator
        }(),
        combineLatest_CombineLatestSubscriber = function(_super) {
            function CombineLatestSubscriber(destination, resultSelector) {
                var _this = _super.call(this, destination) || this;
                return _this.resultSelector = resultSelector, _this.active = 0, _this.values = [], _this.observables = [], _this
            }
            return tslib_es6.a(CombineLatestSubscriber, _super), CombineLatestSubscriber.prototype._next = function(observable) {
                this.values.push(NONE), this.observables.push(observable)
            }, CombineLatestSubscriber.prototype._complete = function() {
                var observables = this.observables,
                    len = observables.length;
                if (0 === len) this.destination.complete();
                else {
                    this.active = len, this.toRespond = len;
                    for (var i = 0; i < len; i++) {
                        var observable = observables[i];
                        this.add(subscribeToResult(this, observable, void 0, i))
                    }
                }
            }, CombineLatestSubscriber.prototype.notifyComplete = function(unused) {
                0 == (this.active -= 1) && this.destination.complete()
            }, CombineLatestSubscriber.prototype.notifyNext = function(_outerValue, innerValue, outerIndex) {
                var values = this.values,
                    oldVal = values[outerIndex],
                    toRespond = this.toRespond ? oldVal === NONE ? --this.toRespond : this.toRespond : 0;
                values[outerIndex] = innerValue, 0 === toRespond && (this.resultSelector ? this._tryResultSelector(values) : this.destination.next(values.slice()))
            }, CombineLatestSubscriber.prototype._tryResultSelector = function(values) {
                var result;
                try {
                    result = this.resultSelector.apply(this, values)
                } catch (err) {
                    return void this.destination.error(err)
                }
                this.destination.next(result)
            }, CombineLatestSubscriber
        }(OuterSubscriber_OuterSubscriber)
}, function(module, __webpack_exports__, __webpack_require__) {
    "use strict";
    __webpack_require__.d(__webpack_exports__, "a", (function() {
        return concat
    }));
    var of = __webpack_require__(62), mergeAll = __webpack_require__(97);

    function concatAll() {
        return Object(mergeAll.a)(1)
    }

    function concat() {
        for (var observables = [], _i = 0; _i < arguments.length; _i++) observables[_i] = arguments[_i];
        return concatAll()( of .a.apply(void 0, observables))
    }
}]);